; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf
PUBLIC	__snprintf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign
PUBLIC	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	?_Throw_tree_length_error@std@@YAXXZ		; std::_Throw_tree_length_error
PUBLIC	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??1?$CSingleton@VCPythonMiniMap@@@@UAE@XZ	; CSingleton<CPythonMiniMap>::~CSingleton<CPythonMiniMap>
PUBLIC	??_G?$CSingleton@VCPythonMiniMap@@@@UAEPAXI@Z	; CSingleton<CPythonMiniMap>::`scalar deleting destructor'
PUBLIC	??0CPythonMiniMap@@QAE@XZ			; CPythonMiniMap::CPythonMiniMap
PUBLIC	??1CPythonMiniMap@@UAE@XZ			; CPythonMiniMap::~CPythonMiniMap
PUBLIC	?Destroy@CPythonMiniMap@@QAEXXZ			; CPythonMiniMap::Destroy
PUBLIC	?Create@CPythonMiniMap@@QAE_NXZ			; CPythonMiniMap::Create
PUBLIC	?IsAtlas@CPythonMiniMap@@QAE_NXZ		; CPythonMiniMap::IsAtlas
PUBLIC	?CanShow@CPythonMiniMap@@QAE_NXZ		; CPythonMiniMap::CanShow
PUBLIC	?CanShowAtlas@CPythonMiniMap@@QAE_NXZ		; CPythonMiniMap::CanShowAtlas
PUBLIC	?SetMiniMapSize@CPythonMiniMap@@QAEXMM@Z	; CPythonMiniMap::SetMiniMapSize
PUBLIC	?SetScale@CPythonMiniMap@@QAEXM@Z		; CPythonMiniMap::SetScale
PUBLIC	?ScaleUp@CPythonMiniMap@@QAEXXZ			; CPythonMiniMap::ScaleUp
PUBLIC	?ScaleDown@CPythonMiniMap@@QAEXXZ		; CPythonMiniMap::ScaleDown
PUBLIC	?SetCenterPosition@CPythonMiniMap@@QAEXMM@Z	; CPythonMiniMap::SetCenterPosition
PUBLIC	?Update@CPythonMiniMap@@QAEXMM@Z		; CPythonMiniMap::Update
PUBLIC	?Render@CPythonMiniMap@@QAEXMM@Z		; CPythonMiniMap::Render
PUBLIC	?Show@CPythonMiniMap@@QAEXXZ			; CPythonMiniMap::Show
PUBLIC	?Hide@CPythonMiniMap@@QAEXXZ			; CPythonMiniMap::Hide
PUBLIC	?GetPickedInstanceInfo@CPythonMiniMap@@QAE_NMMAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM1PAK@Z ; CPythonMiniMap::GetPickedInstanceInfo
PUBLIC	?LoadAtlas@CPythonMiniMap@@QAE_NXZ		; CPythonMiniMap::LoadAtlas
PUBLIC	?UpdateAtlas@CPythonMiniMap@@QAEXXZ		; CPythonMiniMap::UpdateAtlas
PUBLIC	?RenderAtlas@CPythonMiniMap@@QAEXMM@Z		; CPythonMiniMap::RenderAtlas
PUBLIC	?ShowAtlas@CPythonMiniMap@@QAEXXZ		; CPythonMiniMap::ShowAtlas
PUBLIC	?HideAtlas@CPythonMiniMap@@QAEXXZ		; CPythonMiniMap::HideAtlas
PUBLIC	?GetAtlasInfo@CPythonMiniMap@@QAE_NMMAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM1PAK2@Z ; CPythonMiniMap::GetAtlasInfo
PUBLIC	?GetAtlasSize@CPythonMiniMap@@QAE_NPAM0@Z	; CPythonMiniMap::GetAtlasSize
PUBLIC	?AddObserver@CPythonMiniMap@@QAEXKMM@Z		; CPythonMiniMap::AddObserver
PUBLIC	?MoveObserver@CPythonMiniMap@@QAEXKMM@Z		; CPythonMiniMap::MoveObserver
PUBLIC	?RemoveObserver@CPythonMiniMap@@QAEXK@Z		; CPythonMiniMap::RemoveObserver
PUBLIC	?AddWayPoint@CPythonMiniMap@@QAEXEKMMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CPythonMiniMap::AddWayPoint
PUBLIC	?RemoveWayPoint@CPythonMiniMap@@QAEXK@Z		; CPythonMiniMap::RemoveWayPoint
PUBLIC	?AddSignalPoint@CPythonMiniMap@@QAEXMM@Z	; CPythonMiniMap::AddSignalPoint
PUBLIC	?ClearAllSignalPoint@CPythonMiniMap@@QAEXXZ	; CPythonMiniMap::ClearAllSignalPoint
PUBLIC	?RegisterAtlasWindow@CPythonMiniMap@@QAEXPAU_object@@@Z ; CPythonMiniMap::RegisterAtlasWindow
PUBLIC	?UnregisterAtlasWindow@CPythonMiniMap@@QAEXXZ	; CPythonMiniMap::UnregisterAtlasWindow
PUBLIC	?OpenAtlasWindow@CPythonMiniMap@@QAEXXZ		; CPythonMiniMap::OpenAtlasWindow
PUBLIC	?SetAtlasCenterPosition@CPythonMiniMap@@QAEXHH@Z ; CPythonMiniMap::SetAtlasCenterPosition
PUBLIC	?ClearAtlasMarkInfo@CPythonMiniMap@@QAEXXZ	; CPythonMiniMap::ClearAtlasMarkInfo
PUBLIC	?RegisterAtlasMark@CPythonMiniMap@@QAEXEPBDJJ@Z	; CPythonMiniMap::RegisterAtlasMark
PUBLIC	?ClearGuildArea@CPythonMiniMap@@QAEXXZ		; CPythonMiniMap::ClearGuildArea
PUBLIC	?RegisterGuildArea@CPythonMiniMap@@QAEXKKJJJJ@Z	; CPythonMiniMap::RegisterGuildArea
PUBLIC	?GetGuildAreaID@CPythonMiniMap@@QAEKKK@Z	; CPythonMiniMap::GetGuildAreaID
PUBLIC	?CreateTarget@CPythonMiniMap@@QAEXHPBD@Z	; CPythonMiniMap::CreateTarget
PUBLIC	?CreateTarget@CPythonMiniMap@@QAEXHPBDK@Z	; CPythonMiniMap::CreateTarget
PUBLIC	?UpdateTarget@CPythonMiniMap@@QAEXHHH@Z		; CPythonMiniMap::UpdateTarget
PUBLIC	?DeleteTarget@CPythonMiniMap@@QAEXH@Z		; CPythonMiniMap::DeleteTarget
PUBLIC	?__Initialize@CPythonMiniMap@@IAEXXZ		; CPythonMiniMap::__Initialize
PUBLIC	?__SetPosition@CPythonMiniMap@@IAEXXZ		; CPythonMiniMap::__SetPosition
PUBLIC	?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ	; CPythonMiniMap::__LoadAtlasMarkInfo
PUBLIC	?__RenderWayPointMark@CPythonMiniMap@@IAEXHH@Z	; CPythonMiniMap::__RenderWayPointMark
PUBLIC	?__RenderMiniWayPointMark@CPythonMiniMap@@IAEXHH@Z ; CPythonMiniMap::__RenderMiniWayPointMark
PUBLIC	?__RenderTargetMark@CPythonMiniMap@@IAEXHH@Z	; CPythonMiniMap::__RenderTargetMark
PUBLIC	?__GlobalPositionToAtlasPosition@CPythonMiniMap@@IAEXJJPAM0@Z ; CPythonMiniMap::__GlobalPositionToAtlasPosition
PUBLIC	??0TAtlasMarkInfo@CPythonMiniMap@@QAE@XZ	; CPythonMiniMap::TAtlasMarkInfo::TAtlasMarkInfo
PUBLIC	??1TAtlasMarkInfo@CPythonMiniMap@@QAE@XZ	; CPythonMiniMap::TAtlasMarkInfo::~TAtlasMarkInfo
PUBLIC	??0TAtlasMarkInfo@CPythonMiniMap@@QAE@ABU01@@Z	; CPythonMiniMap::TAtlasMarkInfo::TAtlasMarkInfo
PUBLIC	??0TAtlasMarkInfo@CPythonMiniMap@@QAE@$$QAU01@@Z ; CPythonMiniMap::TAtlasMarkInfo::TAtlasMarkInfo
PUBLIC	??4TAtlasMarkInfo@CPythonMiniMap@@QAEAAU01@$$QAU01@@Z ; CPythonMiniMap::TAtlasMarkInfo::operator=
PUBLIC	?deallocate@?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@QAEXQAUTMarkPosition@CPythonMiniMap@@I@Z ; std::allocator<CPythonMiniMap::TMarkPosition>::deallocate
PUBLIC	??1?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::~vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >
PUBLIC	?clear@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEXXZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::clear
PUBLIC	?_Destroy@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@AAEXPAUTMarkPosition@CPythonMiniMap@@0@Z ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@ABEII@Z ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@AAEXQAUTMarkPosition@CPythonMiniMap@@II@Z ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Change_array
PUBLIC	?_Tidy@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@AAEXXZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Tidy
PUBLIC	?_Xlength@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@CAXXZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CPythonMiniMap::TMarkPosition> >::_Vector_val<std::_Simple_types<CPythonMiniMap::TMarkPosition> >
PUBLIC	?__GetWayPoint@CPythonMiniMap@@IAE_NKPAPAUTAtlasMarkInfo@1@@Z ; CPythonMiniMap::__GetWayPoint
PUBLIC	?__UpdateWayPoint@CPythonMiniMap@@IAEXPAUTAtlasMarkInfo@1@HH@Z ; CPythonMiniMap::__UpdateWayPoint
PUBLIC	??0?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::max_size
PUBLIC	?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Erase_unchecked
PUBLIC	?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Erase_unchecked
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAEIABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::clear
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::find
PUBLIC	?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Check_grow_by_1
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Rrotate
PUBLIC	?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Extract
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Insert_node
PUBLIC	??1?$map@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@@std@@QAE@XZ ; std::map<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::~map<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >
PUBLIC	?deallocate@?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@QAEXQAUTAtlasMarkInfo@CPythonMiniMap@@I@Z ; std::allocator<CPythonMiniMap::TAtlasMarkInfo>::deallocate
PUBLIC	??1?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::~vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
PUBLIC	?erase@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@@2@@Z ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::erase
PUBLIC	?clear@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEXXZ ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::clear
PUBLIC	?_Destroy@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXPAUTAtlasMarkInfo@CPythonMiniMap@@0@Z ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@ABEII@Z ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXQAUTAtlasMarkInfo@CPythonMiniMap@@II@Z ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Change_array
PUBLIC	?_Tidy@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXXZ ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Tidy
PUBLIC	?_Xlength@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@CAXXZ ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Xlength
PUBLIC	?deallocate@?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@QAEXQAUTGuildAreaInfo@CPythonMiniMap@@I@Z ; std::allocator<CPythonMiniMap::TGuildAreaInfo>::deallocate
PUBLIC	??1?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::~vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >
PUBLIC	?clear@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEXXZ ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::clear
PUBLIC	?_Destroy@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@AAEXPAUTGuildAreaInfo@CPythonMiniMap@@0@Z ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@ABEII@Z ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@AAEXQAUTGuildAreaInfo@CPythonMiniMap@@II@Z ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Change_array
PUBLIC	?_Tidy@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@AAEXXZ ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Tidy
PUBLIC	?_Xlength@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@CAXXZ ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Xlength
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@@std@@QAE@PAUTAtlasMarkInfo@CPythonMiniMap@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPythonMiniMap::TAtlasMarkInfo> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPythonMiniMap::TAtlasMarkInfo> > >
PUBLIC	?deallocate@?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@QAEXQAUTSignalPoint@CPythonMiniMap@@I@Z ; std::allocator<CPythonMiniMap::TSignalPoint>::deallocate
PUBLIC	??1?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::~vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >
PUBLIC	?clear@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEXXZ ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::clear
PUBLIC	?_Destroy@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@AAEXPAUTSignalPoint@CPythonMiniMap@@0@Z ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@ABEII@Z ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@AAEXQAUTSignalPoint@CPythonMiniMap@@II@Z ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Change_array
PUBLIC	?_Tidy@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@AAEXXZ ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Tidy
PUBLIC	?_Xlength@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@CAXXZ ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Xlength
PUBLIC	??_GCPythonMiniMap@@UAEPAXI@Z			; CPythonMiniMap::`scalar deleting destructor'
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KPAVCInstanceBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCInstanceBase@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCInstanceBase@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CInstanceBase *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CInstanceBase *> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KPAVCInstanceBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCInstanceBase@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCInstanceBase@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CInstanceBase *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CInstanceBase *> >,0> >::end
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCInstanceBase@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CInstanceBase *> > >,std::_Iterator_base0>::operator++
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >,std::_Iterator_base0>::operator++
PUBLIC	??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::insert<0,0>
PUBLIC	??$_Eqrange@K@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IBE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@PAU12@@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Eqrange<unsigned long>
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::end
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::max_size
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
PUBLIC	?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Check_grow_by_1
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Rrotate
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Insert_node
PUBLIC	??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
PUBLIC	??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
PUBLIC	??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEPAXI@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::`scalar deleting destructor'
PUBLIC	??$_Const_cast@$$CBUTSignalPoint@CPythonMiniMap@@@std@@YAPAUTSignalPoint@CPythonMiniMap@@PBU12@@Z ; std::_Const_cast<CPythonMiniMap::TSignalPoint const >
PUBLIC	??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor'
PUBLIC	??$emplace_back@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEXABUTSignalPoint@CPythonMiniMap@@@Z ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::emplace_back<CPythonMiniMap::TSignalPoint const &>
PUBLIC	??$_Emplace_reallocate@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEPAUTSignalPoint@CPythonMiniMap@@QAU23@ABU23@@Z ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Emplace_reallocate<CPythonMiniMap::TSignalPoint const &>
PUBLIC	??$emplace_back@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEXABUTGuildAreaInfo@CPythonMiniMap@@@Z ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::emplace_back<CPythonMiniMap::TGuildAreaInfo const &>
PUBLIC	??$_Emplace_reallocate@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTGuildAreaInfo@CPythonMiniMap@@QAU23@ABU23@@Z ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Emplace_reallocate<CPythonMiniMap::TGuildAreaInfo const &>
PUBLIC	??$emplace_back@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEXABUTAtlasMarkInfo@CPythonMiniMap@@@Z ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::emplace_back<CPythonMiniMap::TAtlasMarkInfo const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXABUTAtlasMarkInfo@CPythonMiniMap@@@Z ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Emplace_back_with_unused_capacity<CPythonMiniMap::TAtlasMarkInfo const &>
PUBLIC	??$_Emplace_reallocate@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTAtlasMarkInfo@CPythonMiniMap@@QAU23@ABU23@@Z ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Emplace_reallocate<CPythonMiniMap::TAtlasMarkInfo const &>
PUBLIC	??$_Find@K@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Find<unsigned long>
PUBLIC	??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::distance<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >,std::_Iterator_base0> >
PUBLIC	??$emplace_back@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEXABUTMarkPosition@CPythonMiniMap@@@Z ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::emplace_back<CPythonMiniMap::TMarkPosition const &>
PUBLIC	??$_Emplace_reallocate@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEPAUTMarkPosition@CPythonMiniMap@@QAU23@ABU23@@Z ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Emplace_reallocate<CPythonMiniMap::TMarkPosition const &>
PUBLIC	??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z ; std::_Traits_find<std::char_traits<char> >
PUBLIC	??$_Destroy_range@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@YAXPAUTSignalPoint@CPythonMiniMap@@QAU12@AAV?$allocator@UTSignalPoint@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TSignalPoint> >
PUBLIC	??$_Destroy_range@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@YAXPAUTGuildAreaInfo@CPythonMiniMap@@QAU12@AAV?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TGuildAreaInfo> >
PUBLIC	??$_Destroy_range@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAXPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
PUBLIC	??$_Destroy_range@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@YAXPAUTMarkPosition@CPythonMiniMap@@QAU12@AAV?$allocator@UTMarkPosition@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TMarkPosition> >
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >
PUBLIC	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
PUBLIC	??$_Emplace@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Emplace<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >
PUBLIC	??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Lower_bound_duplicate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Lower_bound_duplicate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
PUBLIC	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
PUBLIC	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
PUBLIC	??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
PUBLIC	??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Find_lower_bound<unsigned long>
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * const &>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> * const &>
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *>
PUBLIC	??$_Uninitialized_move@PAUTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@YAPAUTSignalPoint@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTSignalPoint@CPythonMiniMap@@@0@@Z ; std::_Uninitialized_move<CPythonMiniMap::TSignalPoint *,std::allocator<CPythonMiniMap::TSignalPoint> >
PUBLIC	??$_Uninitialized_move@PAUTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@YAPAUTGuildAreaInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@0@@Z ; std::_Uninitialized_move<CPythonMiniMap::TGuildAreaInfo *,std::allocator<CPythonMiniMap::TGuildAreaInfo> >
PUBLIC	??$_Uninitialized_move@PAUTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z ; std::_Uninitialized_move<CPythonMiniMap::TAtlasMarkInfo *,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
PUBLIC	??$_Uninitialized_move@PAUTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@YAPAUTMarkPosition@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTMarkPosition@CPythonMiniMap@@@0@@Z ; std::_Uninitialized_move<CPythonMiniMap::TMarkPosition *,std::allocator<CPythonMiniMap::TMarkPosition> >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >
PUBLIC	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >
PUBLIC	??$?0U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > ><std::pair<unsigned long const ,CPythonMiniMap::SObserver> >
PUBLIC	??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * &>
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *>
PUBLIC	??$_Copy_memmove@PAUTGuildAreaInfo@CPythonMiniMap@@PAU12@@std@@YAPAUTGuildAreaInfo@CPythonMiniMap@@PAU12@00@Z ; std::_Copy_memmove<CPythonMiniMap::TGuildAreaInfo *,CPythonMiniMap::TGuildAreaInfo *>
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::~_Uninitialized_backout_al<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
PUBLIC	??$_Emplace_back@UTAtlasMarkInfo@CPythonMiniMap@@@?$_Uninitialized_backout_al@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEX$$QAUTAtlasMarkInfo@CPythonMiniMap@@@Z ; std::_Uninitialized_backout_al<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Emplace_back<CPythonMiniMap::TAtlasMarkInfo>
PUBLIC	??$_Copy_memmove@PAUTMarkPosition@CPythonMiniMap@@PAU12@@std@@YAPAUTMarkPosition@CPythonMiniMap@@PAU12@00@Z ; std::_Copy_memmove<CPythonMiniMap::TMarkPosition *,CPythonMiniMap::TMarkPosition *>
PUBLIC	??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> * &>
PUBLIC	??$?0$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>
PUBLIC	??_ECPythonMiniMap@@W3AEPAXI@Z			; [thunk]:CPythonMiniMap::`vector deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0BB@GCADKGJO@map?1set?5too?5long@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
PUBLIC	??_7?$CSingleton@VCPythonMiniMap@@@@6B@		; CSingleton<CPythonMiniMap>::`vftable'
PUBLIC	??_7CPythonMiniMap@@6BCScreen@@@		; CPythonMiniMap::`vftable'
PUBLIC	??_7CPythonMiniMap@@6B?$CSingleton@VCPythonMiniMap@@@@@ ; CPythonMiniMap::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
PUBLIC	?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
PUBLIC	??_C@_0BB@FOBBAEMC@D?3?1ymir?5work?1ui?1@	; `string'
PUBLIC	??_C@_0BJ@NLDABMC@minimap_image_filter?4dds@	; `string'
PUBLIC	??_C@_0BD@BAIINCPI@minimap_camera?4dds@		; `string'
PUBLIC	??_C@_0BH@IALDDMEN@minimap?1playermark?4sub@	; `string'
PUBLIC	??_C@_0BG@ODEIMIMD@minimap?1whitemark?4sub@	; `string'
PUBLIC	??_C@_0CA@MEBBNPAF@?$CFsminimap?1mini_waypoint?$CF02d?4sub@ ; `string'
PUBLIC	??_C@_0BL@CILDCNBH@?$CFsminimap?1waypoint?$CF02d?4sub@ ; `string'
PUBLIC	??_C@_0BN@MHOOKNLA@?$CFsminimap?1targetmark?$CF02d?4sub@ ; `string'
PUBLIC	??_C@_0CI@EODFAHAD@d?3?1ymir?5work?1ui?1minimap?1GuildAr@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_0BE@LGPAIIIP@?$CFs?1map?1?$CFs_point?4txt@ ; `string'
PUBLIC	??_C@_0DJ@IGENJIBL@?5CPythonMiniMap?3?3__LoadAtlasMar@ ; `string'
PUBLIC	??_C@_03KKCEFKPO@OPC@				; `string'
PUBLIC	??_C@_06NKIKAPIL@OPCPVP@			; `string'
PUBLIC	??_C@_0L@JKLELMDP@OPCPVPSELF@			; `string'
PUBLIC	??_C@_03BCJIDNJL@NPC@				; `string'
PUBLIC	??_C@_07GKFEMEDF@MONSTER@			; `string'
PUBLIC	??_C@_04EFMFIDOL@WARP@				; `string'
PUBLIC	??_C@_08MIFNEBLL@WAYPOINT@			; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_0CH@JMBNEHDO@d?3?1ymir?5work?1ui?1minimap?1playerm@ ; `string'
PUBLIC	??_C@_0N@KOLJCEFK@?$CFs?1atlas?4sub@		; `string'
PUBLIC	??_C@_0CD@LPCJKMM@d?3?1ymir?5work?1ui?1atlas?1?$CFs?1atlas?4@ ; `string'
PUBLIC	??_C@_0BB@MMPFNHIC@empty_guild_area@		; `string'
PUBLIC	??_C@_02HCKGKOFO@?$CI?$CJ@			; `string'
PUBLIC	??_C@_04JLAJABDJ@Show@				; `string'
PUBLIC	??_C@_04INACLLOK@?$CIii?$CJ@			; `string'
PUBLIC	??_C@_0BI@DPOECPOI@SetCenterPositionAdjust@	; `string'
PUBLIC	??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vftable'
PUBLIC	??_R1A@?0A@EA@CScreen@@8			; CScreen::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCScreen@@@8				; CScreen `RTTI Type Descriptor'
PUBLIC	??_R3CScreen@@8					; CScreen::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CScreen@@8					; CScreen::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicCollisionObject@@8	; CGraphicCollisionObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCGraphicCollisionObject@@@8		; CGraphicCollisionObject `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicCollisionObject@@8			; CGraphicCollisionObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicCollisionObject@@8			; CGraphicCollisionObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicBase@@8			; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCGraphicBase@@@8			; CGraphicBase `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicBase@@8				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicBase@@8				; CGraphicBase::`RTTI Base Class Array'
PUBLIC	??_R4CPythonMiniMap@@6BCScreen@@@		; CPythonMiniMap::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCPythonMiniMap@@@8			; CPythonMiniMap `RTTI Type Descriptor'
PUBLIC	??_R3CPythonMiniMap@@8				; CPythonMiniMap::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CPythonMiniMap@@8				; CPythonMiniMap::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CPythonMiniMap@@8			; CPythonMiniMap::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@?$CSingleton@VCPythonMiniMap@@@@8	; CSingleton<CPythonMiniMap>::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AV?$CSingleton@VCPythonMiniMap@@@@@8	; CSingleton<CPythonMiniMap> `RTTI Type Descriptor'
PUBLIC	??_R3?$CSingleton@VCPythonMiniMap@@@@8		; CSingleton<CPythonMiniMap>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CSingleton@VCPythonMiniMap@@@@8		; CSingleton<CPythonMiniMap>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CSingleton@VCPythonMiniMap@@@@8	; CSingleton<CPythonMiniMap>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CPythonMiniMap@@6B?$CSingleton@VCPythonMiniMap@@@@@ ; CPythonMiniMap::`RTTI Complete Object Locator'
PUBLIC	??_R4?$CSingleton@VCPythonMiniMap@@@@6B@	; CSingleton<CPythonMiniMap>::`RTTI Complete Object Locator'
PUBLIC	??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3ba3d70a
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fe3333333333333
PUBLIC	__real@40000000
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@40c00000
PUBLIC	__real@42000000
PUBLIC	__real@425c0000
PUBLIC	__real@42800000
PUBLIC	__real@43000000
PUBLIC	__real@43480000
PUBLIC	__real@437f0000
PUBLIC	__real@43b40000
PUBLIC	__real@44070000
PUBLIC	__real@44160000
PUBLIC	__real@44960000
PUBLIC	__real@46c80000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_atof:PROC
EXTRN	_memchr:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	_acos:PROC
EXTRN	_asin:PROC
EXTRN	_cos:PROC
EXTRN	_fabs:PROC
EXTRN	_sin:PROC
EXTRN	_sqrt:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?Tracef@@YAXPBDZZ:PROC				; Tracef
EXTRN	?fMIN@@YAMMM@Z:PROC				; fMIN
EXTRN	__imp__Py_BuildValue:PROC
EXTRN	?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z:PROC ; PyCallClassMemberFunc
EXTRN	?GetCurrentSecond@CTimer@@QAEMXZ:PROC		; CTimer::GetCurrentSecond
EXTRN	?ELTimer_GetMSec@@YAKXZ:PROC			; ELTimer_GetMSec
EXTRN	?LoadMultipleTextData@@YA_NPBDAAV?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@@Z:PROC ; LoadMultipleTextData
EXTRN	?IsEmpty@CResource@@QBE_NXZ:PROC		; CResource::IsEmpty
EXTRN	?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z:PROC ; CResourceManager::GetResourcePointer
EXTRN	?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ:PROC ; CGraphicTexture::GetD3DTexture
EXTRN	??0CGraphicIndexBuffer@@QAE@XZ:PROC		; CGraphicIndexBuffer::CGraphicIndexBuffer
EXTRN	??1CGraphicIndexBuffer@@UAE@XZ:PROC		; CGraphicIndexBuffer::~CGraphicIndexBuffer
EXTRN	?Destroy@CGraphicIndexBuffer@@QAEXXZ:PROC	; CGraphicIndexBuffer::Destroy
EXTRN	?Create@CGraphicIndexBuffer@@QAE_NHW4_D3DFORMAT@@@Z:PROC ; CGraphicIndexBuffer::Create
EXTRN	?Lock@CGraphicIndexBuffer@@QAE_NPAPAX@Z:PROC	; CGraphicIndexBuffer::Lock
EXTRN	?Unlock@CGraphicIndexBuffer@@QAEXXZ:PROC	; CGraphicIndexBuffer::Unlock
EXTRN	?GetD3DIndexBuffer@CGraphicIndexBuffer@@QBEPAUIDirect3DIndexBuffer8@@XZ:PROC ; CGraphicIndexBuffer::GetD3DIndexBuffer
EXTRN	??0CGraphicVertexBuffer@@QAE@XZ:PROC		; CGraphicVertexBuffer::CGraphicVertexBuffer
EXTRN	??1CGraphicVertexBuffer@@UAE@XZ:PROC		; CGraphicVertexBuffer::~CGraphicVertexBuffer
EXTRN	?Destroy@CGraphicVertexBuffer@@QAEXXZ:PROC	; CGraphicVertexBuffer::Destroy
EXTRN	?Unlock@CGraphicVertexBuffer@@QAE_NXZ:PROC	; CGraphicVertexBuffer::Unlock
EXTRN	??0CGraphicImageInstance@@QAE@XZ:PROC		; CGraphicImageInstance::CGraphicImageInstance
EXTRN	??1CGraphicImageInstance@@UAE@XZ:PROC		; CGraphicImageInstance::~CGraphicImageInstance
EXTRN	?Destroy@CGraphicImageInstance@@QAEXXZ:PROC	; CGraphicImageInstance::Destroy
EXTRN	?Render@CGraphicImageInstance@@QAEXXZ:PROC	; CGraphicImageInstance::Render
EXTRN	?SetPosition@CGraphicImageInstance@@QAEXMM@Z:PROC ; CGraphicImageInstance::SetPosition
EXTRN	?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z:PROC ; CGraphicImageInstance::SetImagePointer
EXTRN	?IsEmpty@CGraphicImageInstance@@QBE_NXZ:PROC	; CGraphicImageInstance::IsEmpty
EXTRN	?GetWidth@CGraphicImageInstance@@QAEHXZ:PROC	; CGraphicImageInstance::GetWidth
EXTRN	?GetHeight@CGraphicImageInstance@@QAEHXZ:PROC	; CGraphicImageInstance::GetHeight
EXTRN	?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ:PROC ; CGraphicImageInstance::GetTexturePointer
EXTRN	??0CGraphicExpandedImageInstance@@QAE@XZ:PROC	; CGraphicExpandedImageInstance::CGraphicExpandedImageInstance
EXTRN	??1CGraphicExpandedImageInstance@@UAE@XZ:PROC	; CGraphicExpandedImageInstance::~CGraphicExpandedImageInstance
EXTRN	?Destroy@CGraphicExpandedImageInstance@@QAEXXZ:PROC ; CGraphicExpandedImageInstance::Destroy
EXTRN	?SetRotation@CGraphicExpandedImageInstance@@QAEXM@Z:PROC ; CGraphicExpandedImageInstance::SetRotation
EXTRN	?SetRenderingMode@CGraphicExpandedImageInstance@@QAEXH@Z:PROC ; CGraphicExpandedImageInstance::SetRenderingMode
EXTRN	??0CScreen@@QAE@XZ:PROC				; CScreen::CScreen
EXTRN	??1CScreen@@UAE@XZ:PROC				; CScreen::~CScreen
EXTRN	?SetDiffuseOperation@CScreen@@QAEXXZ:PROC	; CScreen::SetDiffuseOperation
EXTRN	?LocaleService_GetLocalePath@@YAPBDXZ:PROC	; LocaleService_GetLocalePath
EXTRN	?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SaveRenderState
EXTRN	?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::RestoreRenderState
EXTRN	?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SetRenderState
EXTRN	?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z:PROC ; CStateManager::SetTexture
EXTRN	?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SaveTextureStageState
EXTRN	?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z:PROC ; CStateManager::RestoreTextureStageState
EXTRN	?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SetTextureStageState
EXTRN	?SetVertexShader@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetVertexShader
EXTRN	?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SetTransform
EXTRN	?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z:PROC ; CStateManager::SetStreamSource
EXTRN	?SetIndices@CStateManager@@QAEXPAUIDirect3DIndexBuffer8@@I@Z:PROC ; CStateManager::SetIndices
EXTRN	?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z:PROC ; CStateManager::DrawIndexedPrimitive
EXTRN	?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ:PROC ; CCameraManager::GetCurrentCamera
EXTRN	?isExist@CEterPackManager@@QAE_NPBD@Z:PROC	; CEterPackManager::isExist
EXTRN	?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z:PROC ; CMapOutdoor::GetTerrainPointer
EXTRN	?GetBaseXY@CMapOutdoor@@QAEXPAK0@Z:PROC		; CMapOutdoor::GetBaseXY
EXTRN	?IsMapOutdoor@CMapManager@@QAE_NXZ:PROC		; CMapManager::IsMapOutdoor
EXTRN	?GetMapOutdoorRef@CMapManager@@QAEAAVCMapOutdoor@@XZ:PROC ; CMapManager::GetMapOutdoorRef
EXTRN	?IsMapReady@CMapManager@@QAE_NXZ:PROC		; CMapManager::IsMapReady
EXTRN	??_E?$CSingleton@VCPythonMiniMap@@@@UAEPAXI@Z:PROC ; CSingleton<CPythonMiniMap>::`vector deleting destructor'
EXTRN	??_ECPythonMiniMap@@UAEPAXI@Z:PROC		; CPythonMiniMap::`vector deleting destructor'
EXTRN	?GetIndexedNameColor@CInstanceBase@@SAABUD3DXCOLOR@@I@Z:PROC ; CInstanceBase::GetIndexedNameColor
EXTRN	?GetNameString@CInstanceBase@@QAEPBDXZ:PROC	; CInstanceBase::GetNameString
EXTRN	?IsInvisibility@CInstanceBase@@QAEHXZ:PROC	; CInstanceBase::IsInvisibility
EXTRN	?IsEnemy@CInstanceBase@@QAEHXZ:PROC		; CInstanceBase::IsEnemy
EXTRN	?IsNPC@CInstanceBase@@QAEHXZ:PROC		; CInstanceBase::IsNPC
EXTRN	?IsPC@CInstanceBase@@QAEHXZ:PROC		; CInstanceBase::IsPC
EXTRN	?IsWarp@CInstanceBase@@QAEHXZ:PROC		; CInstanceBase::IsWarp
EXTRN	?NEW_GetPixelPosition@CInstanceBase@@QAEXPAUD3DXVECTOR3@@@Z:PROC ; CInstanceBase::NEW_GetPixelPosition
EXTRN	?GetRotation@CInstanceBase@@QAEMXZ:PROC		; CInstanceBase::GetRotation
EXTRN	?GetNameColorIndex@CInstanceBase@@QAEIXZ:PROC	; CInstanceBase::GetNameColorIndex
EXTRN	?GetNameColor@CInstanceBase@@QAEABUD3DXCOLOR@@XZ:PROC ; CInstanceBase::GetNameColor
EXTRN	?GetMainInstancePtr@CPythonCharacterManager@@QAEPAVCInstanceBase@@XZ:PROC ; CPythonCharacterManager::GetMainInstancePtr
EXTRN	?GetGuildName@CPythonGuild@@QAE_NKPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CPythonGuild::GetGuildName
EXTRN	??_E?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftoui3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A DD 01H DUP (?) ; CSingleton<CTimer>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A DD 01H DUP (?) ; CSingleton<CResourceManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A DD 01H DUP (?) ; CSingleton<CCameraManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A DD 01H DUP (?) ; CSingleton<CEterPackManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A DD 01H DUP (?) ; CSingleton<CPythonBackground>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A DD 01H DUP (?) ; CSingleton<CPythonMiniMap>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A DD 01H DUP (?) ; CSingleton<CPythonCharacterManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A DD 01H DUP (?) ; CSingleton<CPythonGuild>::ms_singleton
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@46c80000
CONST	SEGMENT
__real@46c80000 DD 046c80000r			; 25600
CONST	ENDS
;	COMDAT __real@44960000
CONST	SEGMENT
__real@44960000 DD 044960000r			; 1200
CONST	ENDS
;	COMDAT __real@44160000
CONST	SEGMENT
__real@44160000 DD 044160000r			; 600
CONST	ENDS
;	COMDAT __real@44070000
CONST	SEGMENT
__real@44070000 DD 044070000r			; 540
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@43000000
CONST	SEGMENT
__real@43000000 DD 043000000r			; 128
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@425c0000
CONST	SEGMENT
__real@425c0000 DD 0425c0000r			; 55
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fe3333333333333
CONST	SEGMENT
__real@3fe3333333333333 DQ 03fe3333333333333r	; 0.6
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ba3d70a
CONST	SEGMENT
__real@3ba3d70a DD 03ba3d70ar			; 0.005
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDe'
	DB	'corator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDec'
	DB	'orator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpd'
	DB	'ateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@N'
	DB	'EffectUpdateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEff'
	DB	'ectUpdateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffe'
	DB	'ctUpdateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecora'
	DB	'tor@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDeco'
	DB	'rator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R4?$CSingleton@VCPythonMiniMap@@@@6B@
rdata$r	SEGMENT
??_R4?$CSingleton@VCPythonMiniMap@@@@6B@ DD 00H		; CSingleton<CPythonMiniMap>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CSingleton@VCPythonMiniMap@@@@@8
	DD	FLAT:??_R3?$CSingleton@VCPythonMiniMap@@@@8
rdata$r	ENDS
;	COMDAT ??_R4CPythonMiniMap@@6B?$CSingleton@VCPythonMiniMap@@@@@
rdata$r	SEGMENT
??_R4CPythonMiniMap@@6B?$CSingleton@VCPythonMiniMap@@@@@ DD 00H ; CPythonMiniMap::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AVCPythonMiniMap@@@8
	DD	FLAT:??_R3CPythonMiniMap@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CSingleton@VCPythonMiniMap@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CSingleton@VCPythonMiniMap@@@@8 DD FLAT:??_R0?AV?$CSingleton@VCPythonMiniMap@@@@@8 ; CSingleton<CPythonMiniMap>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CSingleton@VCPythonMiniMap@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CSingleton@VCPythonMiniMap@@@@8
rdata$r	SEGMENT
??_R2?$CSingleton@VCPythonMiniMap@@@@8 DD FLAT:??_R1A@?0A@EA@?$CSingleton@VCPythonMiniMap@@@@8 ; CSingleton<CPythonMiniMap>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CSingleton@VCPythonMiniMap@@@@8
rdata$r	SEGMENT
??_R3?$CSingleton@VCPythonMiniMap@@@@8 DD 00H		; CSingleton<CPythonMiniMap>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CSingleton@VCPythonMiniMap@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CSingleton@VCPythonMiniMap@@@@@8
data$rs	SEGMENT
??_R0?AV?$CSingleton@VCPythonMiniMap@@@@@8 DD FLAT:??_7type_info@@6B@ ; CSingleton<CPythonMiniMap> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CSingleton@VCPythonMiniMap@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R13?0A@EA@?$CSingleton@VCPythonMiniMap@@@@8
rdata$r	SEGMENT
??_R13?0A@EA@?$CSingleton@VCPythonMiniMap@@@@8 DD FLAT:??_R0?AV?$CSingleton@VCPythonMiniMap@@@@@8 ; CSingleton<CPythonMiniMap>::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CSingleton@VCPythonMiniMap@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CPythonMiniMap@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CPythonMiniMap@@8 DD FLAT:??_R0?AVCPythonMiniMap@@@8 ; CPythonMiniMap::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CPythonMiniMap@@8
rdata$r	ENDS
;	COMDAT ??_R2CPythonMiniMap@@8
rdata$r	SEGMENT
??_R2CPythonMiniMap@@8 DD FLAT:??_R1A@?0A@EA@CPythonMiniMap@@8 ; CPythonMiniMap::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CScreen@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
	DD	FLAT:??_R13?0A@EA@?$CSingleton@VCPythonMiniMap@@@@8
rdata$r	ENDS
;	COMDAT ??_R3CPythonMiniMap@@8
rdata$r	SEGMENT
??_R3CPythonMiniMap@@8 DD 00H				; CPythonMiniMap::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2CPythonMiniMap@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPythonMiniMap@@@8
data$rs	SEGMENT
??_R0?AVCPythonMiniMap@@@8 DD FLAT:??_7type_info@@6B@	; CPythonMiniMap `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPythonMiniMap@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CPythonMiniMap@@6BCScreen@@@
rdata$r	SEGMENT
??_R4CPythonMiniMap@@6BCScreen@@@ DD 00H		; CPythonMiniMap::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPythonMiniMap@@@8
	DD	FLAT:??_R3CPythonMiniMap@@8
rdata$r	ENDS
;	COMDAT ??_R2CGraphicBase@@8
rdata$r	SEGMENT
??_R2CGraphicBase@@8 DD FLAT:??_R1A@?0A@EA@CGraphicBase@@8 ; CGraphicBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CGraphicBase@@8
rdata$r	SEGMENT
??_R3CGraphicBase@@8 DD 00H				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicBase@@@8
data$rs	SEGMENT
??_R0?AVCGraphicBase@@@8 DD FLAT:??_7type_info@@6B@	; CGraphicBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicBase@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicBase@@8 DD FLAT:??_R0?AVCGraphicBase@@@8 ; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R2CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R2CGraphicCollisionObject@@8 DD FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8 ; CGraphicCollisionObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R3CGraphicCollisionObject@@8 DD 00H			; CGraphicCollisionObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CGraphicCollisionObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicCollisionObject@@@8
data$rs	SEGMENT
??_R0?AVCGraphicCollisionObject@@@8 DD FLAT:??_7type_info@@6B@ ; CGraphicCollisionObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicCollisionObject@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicCollisionObject@@8 DD FLAT:??_R0?AVCGraphicCollisionObject@@@8 ; CGraphicCollisionObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicCollisionObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CScreen@@8
rdata$r	SEGMENT
??_R2CScreen@@8 DD FLAT:??_R1A@?0A@EA@CScreen@@8	; CScreen::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CScreen@@8
rdata$r	SEGMENT
??_R3CScreen@@8 DD 00H					; CScreen::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CScreen@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCScreen@@@8
data$rs	SEGMENT
??_R0?AVCScreen@@@8 DD FLAT:??_7type_info@@6B@		; CScreen `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCScreen@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CScreen@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CScreen@@8 DD FLAT:??_R0?AVCScreen@@@8	; CScreen::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CScreen@@8
rdata$r	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_0BI@DPOECPOI@SetCenterPositionAdjust@
CONST	SEGMENT
??_C@_0BI@DPOECPOI@SetCenterPositionAdjust@ DB 'SetCenterPositionAdjust', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04INACLLOK@?$CIii?$CJ@
CONST	SEGMENT
??_C@_04INACLLOK@?$CIii?$CJ@ DB '(ii)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JLAJABDJ@Show@
CONST	SEGMENT
??_C@_04JLAJABDJ@Show@ DB 'Show', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HCKGKOFO@?$CI?$CJ@
CONST	SEGMENT
??_C@_02HCKGKOFO@?$CI?$CJ@ DB '()', 00H			; `string'
CONST	ENDS
;	COMDAT ?g_id@?1??AddSignalPoint@CPythonMiniMap@@QAEXMM@Z@4IA
_DATA	SEGMENT
?g_id@?1??AddSignalPoint@CPythonMiniMap@@QAEXMM@Z@4IA DD 0ffH ; `CPythonMiniMap::AddSignalPoint'::`2'::g_id
_DATA	ENDS
;	COMDAT ??_C@_0BB@MMPFNHIC@empty_guild_area@
CONST	SEGMENT
??_C@_0BB@MMPFNHIC@empty_guild_area@ DB 'empty_guild_area', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LPCJKMM@d?3?1ymir?5work?1ui?1atlas?1?$CFs?1atlas?4@
CONST	SEGMENT
??_C@_0CD@LPCJKMM@d?3?1ymir?5work?1ui?1atlas?1?$CFs?1atlas?4@ DB 'd:/ymir'
	DB	' work/ui/atlas/%s/atlas.sub', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KOLJCEFK@?$CFs?1atlas?4sub@
CONST	SEGMENT
??_C@_0N@KOLJCEFK@?$CFs?1atlas?4sub@ DB '%s/atlas.sub', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JMBNEHDO@d?3?1ymir?5work?1ui?1minimap?1playerm@
CONST	SEGMENT
??_C@_0CH@JMBNEHDO@d?3?1ymir?5work?1ui?1minimap?1playerm@ DB 'd:/ymir wor'
	DB	'k/ui/minimap/playermark.sub', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08MIFNEBLL@WAYPOINT@
CONST	SEGMENT
??_C@_08MIFNEBLL@WAYPOINT@ DB 'WAYPOINT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EFMFIDOL@WARP@
CONST	SEGMENT
??_C@_04EFMFIDOL@WARP@ DB 'WARP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07GKFEMEDF@MONSTER@
CONST	SEGMENT
??_C@_07GKFEMEDF@MONSTER@ DB 'MONSTER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BCJIDNJL@NPC@
CONST	SEGMENT
??_C@_03BCJIDNJL@NPC@ DB 'NPC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JKLELMDP@OPCPVPSELF@
CONST	SEGMENT
??_C@_0L@JKLELMDP@OPCPVPSELF@ DB 'OPCPVPSELF', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06NKIKAPIL@OPCPVP@
CONST	SEGMENT
??_C@_06NKIKAPIL@OPCPVP@ DB 'OPCPVP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KKCEFKPO@OPC@
CONST	SEGMENT
??_C@_03KKCEFKPO@OPC@ DB 'OPC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@IGENJIBL@?5CPythonMiniMap?3?3__LoadAtlasMar@
CONST	SEGMENT
??_C@_0DJ@IGENJIBL@?5CPythonMiniMap?3?3__LoadAtlasMar@ DB ' CPythonMiniMa'
	DB	'p::__LoadAtlasMarkInfo File Load %s ERROR', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LGPAIIIP@?$CFs?1map?1?$CFs_point?4txt@
CONST	SEGMENT
??_C@_0BE@LGPAIIIP@?$CFs?1map?1?$CFs_point?4txt@ DB '%s/map/%s_point.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EODFAHAD@d?3?1ymir?5work?1ui?1minimap?1GuildAr@
CONST	SEGMENT
??_C@_0CI@EODFAHAD@d?3?1ymir?5work?1ui?1minimap?1GuildAr@ DB 'd:/ymir wor'
	DB	'k/ui/minimap/GuildArea01.sub', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MHOOKNLA@?$CFsminimap?1targetmark?$CF02d?4sub@
CONST	SEGMENT
??_C@_0BN@MHOOKNLA@?$CFsminimap?1targetmark?$CF02d?4sub@ DB '%sminimap/ta'
	DB	'rgetmark%02d.sub', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CILDCNBH@?$CFsminimap?1waypoint?$CF02d?4sub@
CONST	SEGMENT
??_C@_0BL@CILDCNBH@?$CFsminimap?1waypoint?$CF02d?4sub@ DB '%sminimap/wayp'
	DB	'oint%02d.sub', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MEBBNPAF@?$CFsminimap?1mini_waypoint?$CF02d?4sub@
CONST	SEGMENT
??_C@_0CA@MEBBNPAF@?$CFsminimap?1mini_waypoint?$CF02d?4sub@ DB '%sminimap'
	DB	'/mini_waypoint%02d.sub', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ODEIMIMD@minimap?1whitemark?4sub@
CONST	SEGMENT
??_C@_0BG@ODEIMIMD@minimap?1whitemark?4sub@ DB 'minimap/whitemark.sub', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IALDDMEN@minimap?1playermark?4sub@
CONST	SEGMENT
??_C@_0BH@IALDDMEN@minimap?1playermark?4sub@ DB 'minimap/playermark.sub', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BAIINCPI@minimap_camera?4dds@
CONST	SEGMENT
??_C@_0BD@BAIINCPI@minimap_camera?4dds@ DB 'minimap_camera.dds', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NLDABMC@minimap_image_filter?4dds@
CONST	SEGMENT
??_C@_0BJ@NLDABMC@minimap_image_filter?4dds@ DB 'minimap_image_filter.dds'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FOBBAEMC@D?3?1ymir?5work?1ui?1@
CONST	SEGMENT
??_C@_0BB@FOBBAEMC@D?3?1ymir?5work?1ui?1@ DB 'D:/ymir work/ui/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CPythonMiniMap@@6B?$CSingleton@VCPythonMiniMap@@@@@
CONST	SEGMENT
??_7CPythonMiniMap@@6B?$CSingleton@VCPythonMiniMap@@@@@ DD FLAT:??_R4CPythonMiniMap@@6B?$CSingleton@VCPythonMiniMap@@@@@ ; CPythonMiniMap::`vftable'
	DD	FLAT:??_ECPythonMiniMap@@W3AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CPythonMiniMap@@6BCScreen@@@
CONST	SEGMENT
??_7CPythonMiniMap@@6BCScreen@@@ DD FLAT:??_R4CPythonMiniMap@@6BCScreen@@@ ; CPythonMiniMap::`vftable'
	DD	FLAT:??_ECPythonMiniMap@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CSingleton@VCPythonMiniMap@@@@6B@
CONST	SEGMENT
??_7?$CSingleton@VCPythonMiniMap@@@@6B@ DD FLAT:??_R4?$CSingleton@VCPythonMiniMap@@@@6B@ ; CSingleton<CPythonMiniMap>::`vftable'
	DD	FLAT:??_E?$CSingleton@VCPythonMiniMap@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
CONST	SEGMENT
??_C@_0BB@GCADKGJO@map?1set?5too?5long@ DB 'map/set too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z$1
__ehfuncinfo$??$?0U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_move@PAUTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_move@PAUTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_move@PAUTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_move@PAUTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z$0
__ehfuncinfo$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEPAUTMarkPosition@CPythonMiniMap@@QAU23@ABU23@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEPAUTMarkPosition@CPythonMiniMap@@QAU23@ABU23@@Z$0
__unwindtable$??$_Emplace_reallocate@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEPAUTMarkPosition@CPythonMiniMap@@QAU23@ABU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEPAUTMarkPosition@CPythonMiniMap@@QAU23@ABU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEPAUTMarkPosition@CPythonMiniMap@@QAU23@ABU23@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEPAUTMarkPosition@CPythonMiniMap@@QAU23@ABU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEPAUTMarkPosition@CPythonMiniMap@@QAU23@ABU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEPAUTMarkPosition@CPythonMiniMap@@QAU23@ABU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTAtlasMarkInfo@CPythonMiniMap@@QAU23@ABU23@@Z$33 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTAtlasMarkInfo@CPythonMiniMap@@QAU23@ABU23@@Z$0
__unwindtable$??$_Emplace_reallocate@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTAtlasMarkInfo@CPythonMiniMap@@QAU23@ABU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTAtlasMarkInfo@CPythonMiniMap@@QAU23@ABU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTAtlasMarkInfo@CPythonMiniMap@@QAU23@ABU23@@Z$33
__ehfuncinfo$??$_Emplace_reallocate@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTAtlasMarkInfo@CPythonMiniMap@@QAU23@ABU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTAtlasMarkInfo@CPythonMiniMap@@QAU23@ABU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTAtlasMarkInfo@CPythonMiniMap@@QAU23@ABU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTGuildAreaInfo@CPythonMiniMap@@QAU23@ABU23@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTGuildAreaInfo@CPythonMiniMap@@QAU23@ABU23@@Z$0
__unwindtable$??$_Emplace_reallocate@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTGuildAreaInfo@CPythonMiniMap@@QAU23@ABU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTGuildAreaInfo@CPythonMiniMap@@QAU23@ABU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTGuildAreaInfo@CPythonMiniMap@@QAU23@ABU23@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTGuildAreaInfo@CPythonMiniMap@@QAU23@ABU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTGuildAreaInfo@CPythonMiniMap@@QAU23@ABU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTGuildAreaInfo@CPythonMiniMap@@QAU23@ABU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEPAUTSignalPoint@CPythonMiniMap@@QAU23@ABU23@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEPAUTSignalPoint@CPythonMiniMap@@QAU23@ABU23@@Z$0
__unwindtable$??$_Emplace_reallocate@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEPAUTSignalPoint@CPythonMiniMap@@QAU23@ABU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEPAUTSignalPoint@CPythonMiniMap@@QAU23@ABU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEPAUTSignalPoint@CPythonMiniMap@@QAU23@ABU23@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEPAUTSignalPoint@CPythonMiniMap@@QAU23@ABU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEPAUTSignalPoint@CPythonMiniMap@@QAU23@ABU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEPAUTSignalPoint@CPythonMiniMap@@QAU23@ABU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$7
	DD	00H
	DD	FLAT:__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$9
	DD	08H
	DD	FLAT:__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$10
	DD	08H
	DD	FLAT:__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$11
	DD	08H
	DD	FLAT:__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$12
	DD	0bH
	DD	FLAT:__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$13
	DD	0cH
	DD	FLAT:__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$14
	DD	0dH
	DD	FLAT:__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$15
	DD	0eH
	DD	FLAT:__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$16
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?RegisterAtlasMark@CPythonMiniMap@@QAEXEPBDJJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RegisterAtlasMark@CPythonMiniMap@@QAEXEPBDJJ@Z$0
__ehfuncinfo$?RegisterAtlasMark@CPythonMiniMap@@QAEXEPBDJJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RegisterAtlasMark@CPythonMiniMap@@QAEXEPBDJJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddWayPoint@CPythonMiniMap@@QAEXEKMMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddWayPoint@CPythonMiniMap@@QAEXEKMMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AddWayPoint@CPythonMiniMap@@QAEXEKMMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z$1
__ehfuncinfo$?AddWayPoint@CPythonMiniMap@@QAEXEKMMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AddWayPoint@CPythonMiniMap@@QAEXEKMMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create@CPythonMiniMap@@QAE_NXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?Create@CPythonMiniMap@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Create@CPythonMiniMap@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create@CPythonMiniMap@@QAE_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create@CPythonMiniMap@@QAE_NXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Create@CPythonMiniMap@@QAE_NXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Create@CPythonMiniMap@@QAE_NXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?Create@CPythonMiniMap@@QAE_NXZ$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CPythonMiniMap@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CPythonMiniMap@@QAE@XZ DD 019930522H
	DD	019H
	DD	FLAT:__unwindtable$??0CPythonMiniMap@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CPythonMiniMap@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$12
	DD	0cH
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$13
	DD	0dH
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$14
	DD	0eH
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$15
	DD	0fH
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$16
	DD	010H
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$17
	DD	011H
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$18
	DD	012H
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$19
	DD	013H
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$20
	DD	014H
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$21
	DD	015H
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$22
	DD	016H
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$23
	DD	017H
	DD	FLAT:__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$24
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_ECPythonMiniMap@@W3AEPAXI@Z
_TEXT	SEGMENT
??_ECPythonMiniMap@@W3AEPAXI@Z PROC			; [thunk]:CPythonMiniMap::`vector deleting destructor', COMDAT
  00000	83 e9 04	 sub	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ??_ECPythonMiniMap@@UAEPAXI@Z
??_ECPythonMiniMap@@W3AEPAXI@Z ENDP			; [thunk]:CPythonMiniMap::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
;	COMDAT ??$?0$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
_this$1 = -36						; size = 4
_this$ = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
_this$4 = -16						; size = 4
___formal$ = -12					; size = 1
___formal$ = -8						; size = 1
$T5 = -2						; size = 1
$T6 = -1						; size = 1
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 1
??$?0$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>, COMDAT
; _this$ = ecx

; 986  :     : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	33 c0		 xor	 eax, eax
  0000b	88 45 ff	 mov	 BYTE PTR $T6[ebp], al
  0000e	33 c0		 xor	 eax, eax
  00010	88 45 fe	 mov	 BYTE PTR $T5[ebp], al
  00013	8a 45 ff	 mov	 al, BYTE PTR $T6[ebp]
  00016	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al
  00019	8a 45 fe	 mov	 al, BYTE PTR $T5[ebp]
  0001c	88 45 f4	 mov	 BYTE PTR ___formal$[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0001f	8d 45 0c	 lea	 eax, DWORD PTR __Val1$[ebp]
  00022	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 790  :     return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);

  00025	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax

; 980  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...), second(_STD get<_Indexes2>(_STD move(_Val2))...) {}

  0002d	ff 75 e4	 push	 DWORD PTR $T2[ebp]
  00030	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00038	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	83 c0 18	 add	 eax, 24			; 00000018H
  0003e	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00041	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00044	89 45 dc	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00047	8b 45 dc	 mov	 eax, DWORD PTR _this$1[ebp]
  0004a	89 45 f0	 mov	 DWORD PTR _this$4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0004d	8b 45 f0	 mov	 eax, DWORD PTR _this$4[ebp]
  00050	83 20 00	 and	 DWORD PTR [eax], 0
  00053	8b 45 f0	 mov	 eax, DWORD PTR _this$4[ebp]
  00056	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005a	8b 45 f0	 mov	 eax, DWORD PTR _this$4[ebp]
  0005d	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 986  :     : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

  00061	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00064	c9		 leave
  00065	c2 0c 00	 ret	 12			; 0000000cH
??$?0$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::operator<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4586 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 4587 :     return _Left.compare(_Right) < 0;

  00004	ff 75 0c	 push	 DWORD PTR __Right$[ebp]
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000a	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  0000f	85 c0		 test	 eax, eax
  00011	7d 09		 jge	 SHORT $LN3@operator
  00013	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  0001a	eb 04		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0001c	83 65 fc 00	 and	 DWORD PTR tv68[ebp], 0
$LN4@operator:
  00020	8a 45 fc	 mov	 al, BYTE PTR tv68[ebp]

; 4588 : }

  00023	c9		 leave
  00024	c3		 ret	 0
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAUTMarkPosition@CPythonMiniMap@@PAU12@@std@@YAPAUTMarkPosition@CPythonMiniMap@@PAU12@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUTMarkPosition@CPythonMiniMap@@PAU12@@std@@YAPAUTMarkPosition@CPythonMiniMap@@PAU12@00@Z PROC ; std::_Copy_memmove<CPythonMiniMap::TMarkPosition *,CPythonMiniMap::TMarkPosition *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAUTMarkPosition@CPythonMiniMap@@PAU12@@std@@YAPAUTMarkPosition@CPythonMiniMap@@PAU12@00@Z ENDP ; std::_Copy_memmove<CPythonMiniMap::TMarkPosition *,CPythonMiniMap::TMarkPosition *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Emplace_back@UTAtlasMarkInfo@CPythonMiniMap@@@?$_Uninitialized_backout_al@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEX$$QAUTAtlasMarkInfo@CPythonMiniMap@@@Z
_TEXT	SEGMENT
___formal$ = -28					; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
$T4 = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@UTAtlasMarkInfo@CPythonMiniMap@@@?$_Uninitialized_backout_al@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEX$$QAUTAtlasMarkInfo@CPythonMiniMap@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Emplace_back<CPythonMiniMap::TAtlasMarkInfo>, COMDAT
; _this$ = ecx

; 1545 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00018	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001b	89 45 f4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00024	89 45 e4	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00027	8b 45 f4	 mov	 eax, DWORD PTR $T4[ebp]
  0002a	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0002d	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00030	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00033	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00036	8b 4d e8	 mov	 ecx, DWORD PTR $T1[ebp]
  00039	e8 00 00 00 00	 call	 ??0TAtlasMarkInfo@CPythonMiniMap@@QAE@$$QAU01@@Z

; 1547 :         ++_Last;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	83 c0 3c	 add	 eax, 60			; 0000003cH
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1548 :     }

  0004d	c9		 leave
  0004e	c2 04 00	 ret	 4
??$_Emplace_back@UTAtlasMarkInfo@CPythonMiniMap@@@?$_Uninitialized_backout_al@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEX$$QAUTAtlasMarkInfo@CPythonMiniMap@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Emplace_back<CPythonMiniMap::TAtlasMarkInfo>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Uninitialized_backout_al@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::~_Uninitialized_backout_al<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >, COMDAT
; _this$ = ecx

; 1540 :     ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1541 :         _Destroy_range(_First, _Last, _Al);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	ff 70 08	 push	 DWORD PTR [eax+8]
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	ff 70 04	 push	 DWORD PTR [eax+4]
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	ff 30		 push	 DWORD PTR [eax]
  00018	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAXPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1542 :     }

  00020	c9		 leave
  00021	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::~_Uninitialized_backout_al<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAUTGuildAreaInfo@CPythonMiniMap@@PAU12@@std@@YAPAUTGuildAreaInfo@CPythonMiniMap@@PAU12@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUTGuildAreaInfo@CPythonMiniMap@@PAU12@@std@@YAPAUTGuildAreaInfo@CPythonMiniMap@@PAU12@00@Z PROC ; std::_Copy_memmove<CPythonMiniMap::TGuildAreaInfo *,CPythonMiniMap::TGuildAreaInfo *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAUTGuildAreaInfo@CPythonMiniMap@@PAU12@@std@@YAPAUTGuildAreaInfo@CPythonMiniMap@@PAU12@00@Z ENDP ; std::_Copy_memmove<CPythonMiniMap::TGuildAreaInfo *,CPythonMiniMap::TGuildAreaInfo *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
_<_Args_2>$ = 24					; size = 4
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >, COMDAT

; 700  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0000c	8b 45 18	 mov	 eax, DWORD PTR _<_Args_2>$[ebp]
  0000f	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00012	51		 push	 ecx
  00013	89 65 e8	 mov	 DWORD PTR _this$[ebp], esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00016	8b 45 14	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  00019	89 45 fc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0001c	51		 push	 ecx
  0001d	89 65 f8	 mov	 DWORD PTR _this$[ebp], esp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

  00020	8b 45 fc	 mov	 eax, DWORD PTR $T4[ebp]
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
  00025	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0002a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0002d	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00030	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00033	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00036	50		 push	 eax
  00037	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0003a	e8 00 00 00 00	 call	 ??$?0$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>

; 702  :     }

  0003f	c9		 leave
  00040	c3		 ret	 0
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$?0U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z
_TEXT	SEGMENT
___formal$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
__Val$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
__Myhead$ = 12						; size = 4
_<_Vals_0>$ = 16					; size = 4
??$?0U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > ><std::pair<unsigned long const ,CPythonMiniMap::SObserver> >, COMDAT
; _this$ = ecx

; 805  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  0002a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  00030	89 08		 mov	 DWORD PTR [eax], ecx
  00032	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00035	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 784  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00039	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 785  :         _Alloc_construct_ptr<_Alnode>::_Allocate();

  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >::_Allocate

; 786  :     }

  00045	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00049	8b 45 10	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0004c	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0004f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00052	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00055	83 c0 10	 add	 eax, 16			; 00000010H
  00058	89 45 ec	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0005b	8b 45 ec	 mov	 eax, DWORD PTR __Val$[ebp]
  0005e	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  00061	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00064	8b 00		 mov	 eax, DWORD PTR [eax]
  00066	89 45 d8	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00069	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0006c	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0006f	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00072	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00075	6a 09		 push	 9
  00077	59		 pop	 ecx
  00078	8b 75 e0	 mov	 esi, DWORD PTR $T3[ebp]
  0007b	8b 7d dc	 mov	 edi, DWORD PTR $T2[ebp]
  0007e	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 807  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  00080	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  00083	50		 push	 eax
  00084	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00087	ff 70 04	 push	 DWORD PTR [eax+4]
  0008a	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> * &>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx

; 808  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  00091	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  00094	50		 push	 eax
  00095	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00098	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0009b	83 c0 04	 add	 eax, 4
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> * &>
  000a4	59		 pop	 ecx
  000a5	59		 pop	 ecx

; 809  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  000a6	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  000a9	50		 push	 eax
  000aa	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b0	83 c0 08	 add	 eax, 8
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> * &>
  000b9	59		 pop	 ecx
  000ba	59		 pop	 ecx

; 810  :         this->_Ptr->_Color = _Red;

  000bb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000be	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c1	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 811  :         this->_Ptr->_Isnil = false;

  000c5	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cb	c6 40 0d 00	 mov	 BYTE PTR [eax+13], 0

; 812  :     }

  000cf	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000dc	59		 pop	 ecx
  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	c9		 leave
  000e0	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > ><std::pair<unsigned long const ,CPythonMiniMap::SObserver> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >, COMDAT
; _this$ = ecx

; 817  :     ~_Tree_temp_node() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 818  :         if (this->_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 3e		 je	 SHORT $LN9@Tree_temp_

; 819  :             _Destroy_in_place(this->_Ptr->_Left);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	ff 70 04	 push	 DWORD PTR [eax+4]
  00018	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *>
  0001d	59		 pop	 ecx

; 820  :             _Destroy_in_place(this->_Ptr->_Parent);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	83 c0 04	 add	 eax, 4
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *>
  0002d	59		 pop	 ecx

; 821  :             _Destroy_in_place(this->_Ptr->_Right);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00034	83 c0 08	 add	 eax, 8
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *>
  0003d	59		 pop	 ecx

; 822  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	83 c0 10	 add	 eax, 16			; 00000010H
  00047	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
$LN9@Tree_temp_:
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 824  :     }

  00058	c9		 leave
  00059	c3		 ret	 0
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >, COMDAT
; _this$ = ecx

; 1056 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 22		 je	 SHORT $LN3@Alloc_cons

; 1058 :             _Al.deallocate(_Ptr, 1);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	6b c0 34	 imul	 eax, eax, 52
  00029	50		 push	 eax
  0002a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN3@Alloc_cons:

; 1059 :         }
; 1060 :     }

  00034	c9		 leave
  00035	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1051 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1053 :         _Ptr = _Al.allocate(1);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00018	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001c	c7 45 e8 c4 4e
	ec 04		 mov	 DWORD PTR __Max_possible$1[ebp], 82595524 ; 04ec4ec4H

; 60   :         if (_Count > _Max_possible) {

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	3d c4 4e ec 04	 cmp	 eax, 82595524		; 04ec4ec4H
  0002b	76 05		 jbe	 SHORT $LN6@Allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Allocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 34	 imul	 eax, eax, 52
  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00043	59		 pop	 ecx
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1053 :         _Ptr = _Al.allocate(1);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Allocate:

; 1054 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@YAPAUTMarkPosition@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTMarkPosition@CPythonMiniMap@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@YAPAUTMarkPosition@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTMarkPosition@CPythonMiniMap@@@0@@Z PROC ; std::_Uninitialized_move<CPythonMiniMap::TMarkPosition *,std::allocator<CPythonMiniMap::TMarkPosition> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUTMarkPosition@CPythonMiniMap@@PAU12@@std@@YAPAUTMarkPosition@CPythonMiniMap@@PAU12@00@Z ; std::_Copy_memmove<CPythonMiniMap::TMarkPosition *,CPythonMiniMap::TMarkPosition *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	99		 cdq
  00030	6a 0c		 push	 12			; 0000000cH
  00032	59		 pop	 ecx
  00033	f7 f9		 idiv	 ecx
  00035	6b c0 0c	 imul	 eax, eax, 12
  00038	03 45 10	 add	 eax, DWORD PTR __Dest$[ebp]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  0003b	c9		 leave
  0003c	c3		 ret	 0
??$_Uninitialized_move@PAUTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@YAPAUTMarkPosition@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTMarkPosition@CPythonMiniMap@@@0@@Z ENDP ; std::_Uninitialized_move<CPythonMiniMap::TMarkPosition *,std::allocator<CPythonMiniMap::TMarkPosition> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z
_TEXT	SEGMENT
__Backout$2 = -40					; size = 12
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__ULast$ = -20						; size = 4
__UFirst$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z PROC ; std::_Uninitialized_move<CPythonMiniMap::TAtlasMarkInfo *,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_move@PAUTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __ULast$[ebp], eax

; 1535 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00031	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00034	89 45 d8	 mov	 DWORD PTR __Backout$2[ebp], eax
  00037	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003a	89 45 dc	 mov	 DWORD PTR __Backout$2[ebp+4], eax
  0003d	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00040	89 45 e0	 mov	 DWORD PTR __Backout$2[ebp+8], eax

; 1691 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1692 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1694 :         return _Dest + (_ULast - _UFirst);
; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00043	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {

  00047	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00049	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	83 c0 3c	 add	 eax, 60			; 0000003cH
  0004f	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  00052	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00055	3b 45 ec	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00058	74 13		 je	 SHORT $LN3@Uninitiali
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0005a	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0005d	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));

  00060	ff 75 e8	 push	 DWORD PTR $T4[ebp]
  00063	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00066	e8 00 00 00 00	 call	 ??$_Emplace_back@UTAtlasMarkInfo@CPythonMiniMap@@@?$_Uninitialized_backout_al@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEX$$QAUTAtlasMarkInfo@CPythonMiniMap@@@Z ; std::_Uninitialized_backout_al<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Emplace_back<CPythonMiniMap::TAtlasMarkInfo>

; 1699 :         }

  0006b	eb dc		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1551 :         _First = _Last;

  0006d	8b 45 dc	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00070	89 45 d8	 mov	 DWORD PTR __Backout$2[ebp], eax

; 1552 :         return _Last;

  00073	8b 45 dc	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00076	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1700 : 
; 1701 :         return _Backout._Release();

  00079	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1541 :         _Destroy_range(_First, _Last, _Al);

  0007d	ff 75 e0	 push	 DWORD PTR __Backout$2[ebp+8]
  00080	ff 75 dc	 push	 DWORD PTR __Backout$2[ebp+4]
  00083	ff 75 d8	 push	 DWORD PTR __Backout$2[ebp]
  00086	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAXPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1700 : 
; 1701 :         return _Backout._Release();

  0008e	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]

; 1702 :     }
; 1703 : }

  00091	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00094	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009b	59		 pop	 ecx
  0009c	c9		 leave
  0009d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_move@PAUTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::~_Uninitialized_backout_al<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_move@PAUTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_move@PAUTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move@PAUTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z ENDP ; std::_Uninitialized_move<CPythonMiniMap::TAtlasMarkInfo *,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@YAPAUTGuildAreaInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@YAPAUTGuildAreaInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@0@@Z PROC ; std::_Uninitialized_move<CPythonMiniMap::TGuildAreaInfo *,std::allocator<CPythonMiniMap::TGuildAreaInfo> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUTGuildAreaInfo@CPythonMiniMap@@PAU12@@std@@YAPAUTGuildAreaInfo@CPythonMiniMap@@PAU12@00@Z ; std::_Copy_memmove<CPythonMiniMap::TGuildAreaInfo *,CPythonMiniMap::TGuildAreaInfo *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	99		 cdq
  00030	6a 24		 push	 36			; 00000024H
  00032	59		 pop	 ecx
  00033	f7 f9		 idiv	 ecx
  00035	6b c0 24	 imul	 eax, eax, 36
  00038	03 45 10	 add	 eax, DWORD PTR __Dest$[ebp]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  0003b	c9		 leave
  0003c	c3		 ret	 0
??$_Uninitialized_move@PAUTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@YAPAUTGuildAreaInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@0@@Z ENDP ; std::_Uninitialized_move<CPythonMiniMap::TGuildAreaInfo *,std::allocator<CPythonMiniMap::TGuildAreaInfo> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@YAPAUTSignalPoint@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTSignalPoint@CPythonMiniMap@@@0@@Z
_TEXT	SEGMENT
__Backout$1 = -52					; size = 12
___formal$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
$T7 = -12						; size = 4
__ULast$ = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@YAPAUTSignalPoint@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTSignalPoint@CPythonMiniMap@@@0@@Z PROC ; std::_Uninitialized_move<CPythonMiniMap::TSignalPoint *,std::allocator<CPythonMiniMap::TSignalPoint> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00008	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR __ULast$[ebp], eax

; 1535 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00014	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00017	89 45 cc	 mov	 DWORD PTR __Backout$1[ebp], eax
  0001a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001d	89 45 d0	 mov	 DWORD PTR __Backout$1[ebp+4], eax
  00020	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00023	89 45 d4	 mov	 DWORD PTR __Backout$1[ebp+8], eax

; 1691 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1692 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1694 :         return _Dest + (_ULast - _UFirst);
; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {

  00026	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00028	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0002b	83 c0 0c	 add	 eax, 12			; 0000000cH
  0002e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  00031	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00034	3b 45 f8	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00037	74 3e		 je	 SHORT $LN3@Uninitiali
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00039	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003c	89 45 f4	 mov	 DWORD PTR $T7[ebp], eax

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003f	8b 45 f4	 mov	 eax, DWORD PTR $T7[ebp]
  00042	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00045	8b 45 d0	 mov	 eax, DWORD PTR __Backout$1[ebp+4]
  00048	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0004b	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0004e	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00051	8b 45 d4	 mov	 eax, DWORD PTR __Backout$1[ebp+8]
  00054	89 45 d8	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00057	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  0005a	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0005d	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00060	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00063	8b 75 e4	 mov	 esi, DWORD PTR $T4[ebp]
  00066	8b 7d e0	 mov	 edi, DWORD PTR $T3[ebp]
  00069	a5		 movsd
  0006a	a5		 movsd
  0006b	a5		 movsd

; 1547 :         ++_Last;

  0006c	8b 45 d0	 mov	 eax, DWORD PTR __Backout$1[ebp+4]
  0006f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00072	89 45 d0	 mov	 DWORD PTR __Backout$1[ebp+4], eax

; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }

  00075	eb b1		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1551 :         _First = _Last;

  00077	8b 45 d0	 mov	 eax, DWORD PTR __Backout$1[ebp+4]
  0007a	89 45 cc	 mov	 DWORD PTR __Backout$1[ebp], eax

; 1552 :         return _Last;

  0007d	8b 45 d0	 mov	 eax, DWORD PTR __Backout$1[ebp+4]
  00080	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax

; 1541 :         _Destroy_range(_First, _Last, _Al);

  00083	ff 75 d4	 push	 DWORD PTR __Backout$1[ebp+8]
  00086	ff 75 d0	 push	 DWORD PTR __Backout$1[ebp+4]
  00089	ff 75 cc	 push	 DWORD PTR __Backout$1[ebp]
  0008c	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@YAXPAUTSignalPoint@CPythonMiniMap@@QAU12@AAV?$allocator@UTSignalPoint@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TSignalPoint> >
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1700 : 
; 1701 :         return _Backout._Release();

  00094	8b 45 dc	 mov	 eax, DWORD PTR $T2[ebp]

; 1702 :     }
; 1703 : }

  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	c9		 leave
  0009a	c3		 ret	 0
??$_Uninitialized_move@PAUTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@YAPAUTSignalPoint@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTSignalPoint@CPythonMiniMap@@@0@@Z ENDP ; std::_Uninitialized_move<CPythonMiniMap::TSignalPoint *,std::allocator<CPythonMiniMap::TSignalPoint> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >, COMDAT

; 368  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 369  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 370  :         _Destroy_in_place(_Ptr->_Left);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *>
  0000b	59		 pop	 ecx

; 371  :         _Destroy_in_place(_Ptr->_Parent);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *>
  00018	59		 pop	 ecx

; 372  :         _Destroy_in_place(_Ptr->_Right);

  00019	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001c	83 c0 08	 add	 eax, 8
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *>
  00025	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	6b c0 34	 imul	 eax, eax, 52
  0002c	50		 push	 eax
  0002d	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00030	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00035	59		 pop	 ecx
  00036	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 374  :     }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@ABK@Z
_TEXT	SEGMENT
__Result$ = -40						; size = 12
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
tv64 = -16						; size = 4
_this$ = -12						; size = 4
__Scary$ = -8						; size = 4
__Trynode$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Find_lower_bound<unsigned long>, COMDAT
; _this$ = ecx

; 1699 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000e	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00011	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00014	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1700 :         const auto _Scary = _Get_scary();
; 1701 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00017	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001f	89 45 d8	 mov	 DWORD PTR __Result$[ebp], eax
  00022	83 65 dc 00	 and	 DWORD PTR __Result$[ebp+4], 0
  00026	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1702 :         _Nodeptr _Trynode = _Result._Location._Parent;

  0002e	8b 45 d8	 mov	 eax, DWORD PTR __Result$[ebp]
  00031	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN2@Find_lower:

; 1703 :         while (!_Trynode->_Isnil) {

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00037	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  0003b	85 c0		 test	 eax, eax
  0003d	75 5a		 jne	 SHORT $LN3@Find_lower

; 1704 :             _Result._Location._Parent = _Trynode;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00042	89 45 d8	 mov	 DWORD PTR __Result$[ebp], eax

; 2035 :         return _Mypair._Get_first();

  00045	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00048	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0004b	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00051	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00057	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0005a	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0005c	73 09		 jae	 SHORT $LN23@Find_lower
  0005e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv64[ebp], 1
  00065	eb 04		 jmp	 SHORT $LN21@Find_lower
$LN23@Find_lower:
  00067	83 65 f0 00	 and	 DWORD PTR tv64[ebp], 0
$LN21@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1705 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  0006b	0f b6 45 f0	 movzx	 eax, BYTE PTR tv64[ebp]
  0006f	85 c0		 test	 eax, eax
  00071	74 0f		 je	 SHORT $LN4@Find_lower

; 1706 :                 _Result._Location._Child = _Tree_child::_Right;

  00073	83 65 dc 00	 and	 DWORD PTR __Result$[ebp+4], 0

; 1707 :                 _Trynode                 = _Trynode->_Right;

  00077	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0007a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0007d	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax

; 1708 :             } else {

  00080	eb 15		 jmp	 SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1709 :                 _Result._Location._Child = _Tree_child::_Left;

  00082	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR __Result$[ebp+4], 1

; 1710 :                 _Result._Bound           = _Trynode;

  00089	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0008c	89 45 e0	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1711 :                 _Trynode                 = _Trynode->_Left;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00092	8b 00		 mov	 eax, DWORD PTR [eax]
  00094	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN5@Find_lower:

; 1712 :             }
; 1713 :         }

  00097	eb 9b		 jmp	 SHORT $LN2@Find_lower
$LN3@Find_lower:

; 1714 : 
; 1715 :         return _Result;

  00099	8d 75 d8	 lea	 esi, DWORD PTR __Result$[ebp]
  0009c	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0009f	a5		 movsd
  000a0	a5		 movsd
  000a1	a5		 movsd
  000a2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1716 :     }

  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	c9		 leave
  000a8	c2 08 00	 ret	 8
??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Find_lower_bound<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >, COMDAT

; 368  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 369  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 370  :         _Destroy_in_place(_Ptr->_Left);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *>
  0000b	59		 pop	 ecx

; 371  :         _Destroy_in_place(_Ptr->_Parent);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *>
  00018	59		 pop	 ecx

; 372  :         _Destroy_in_place(_Ptr->_Right);

  00019	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001c	83 c0 08	 add	 eax, 8
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *>
  00025	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	6b c0 34	 imul	 eax, eax, 52
  0002c	50		 push	 eax
  0002d	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00030	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00035	59		 pop	 ecx
  00036	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 374  :     }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__Old_val$2 = -16					; size = 4
__New_val$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@Erase_tree:

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000c	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00010	85 c0		 test	 eax, eax
  00012	75 4d		 jne	 SHORT $LN4@Erase_tree

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00017	ff 70 08	 push	 DWORD PTR [eax+8]
  0001a	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >

; 745  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00028	89 45 f4	 mov	 DWORD PTR __New_val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0002e	89 45 f0	 mov	 DWORD PTR __Old_val$2[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  00031	8b 45 f4	 mov	 eax, DWORD PTR __New_val$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	89 45 0c	 mov	 DWORD PTR __Rootnode$[ebp], eax

; 600  :     return _Old_val;

  00039	8b 45 f0	 mov	 eax, DWORD PTR __Old_val$2[ebp]
  0003c	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 379  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0003f	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  00042	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00045	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 706  :         _Ptr->~_Uty();

  00048	6a 00		 push	 0
  0004a	8b 4d ec	 mov	 ecx, DWORD PTR $T1[ebp]
  0004d	e8 00 00 00 00	 call	 ??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEPAXI@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 380  :         _Freenode0(_Al, _Ptr);

  00052	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  00055	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  00058	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
  0005d	59		 pop	 ecx
  0005e	59		 pop	 ecx

; 746  :         }

  0005f	eb a8		 jmp	 SHORT $LN2@Erase_tree
$LN4@Erase_tree:

; 747  :     }

  00061	c9		 leave
  00062	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
__Val$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
__Myhead$ = 12						; size = 4
_<_Vals_0>$ = 16					; size = 4
_<_Vals_1>$ = 20					; size = 4
_<_Vals_2>$ = 24					; size = 4
??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >, COMDAT
; _this$ = ecx

; 805  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx
  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 784  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00037	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 785  :         _Alloc_construct_ptr<_Alnode>::_Allocate();

  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::_Allocate

; 805  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00043	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0004a	8b 45 18	 mov	 eax, DWORD PTR _<_Vals_2>$[ebp]
  0004d	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
  00050	8b 45 14	 mov	 eax, DWORD PTR _<_Vals_1>$[ebp]
  00053	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
  00056	8b 45 10	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00059	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0005c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00062	83 c0 10	 add	 eax, 16			; 00000010H
  00065	89 45 ec	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Val$[ebp]
  0006b	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0006e	ff 75 e8	 push	 DWORD PTR $T5[ebp]
  00071	ff 75 e4	 push	 DWORD PTR $T4[ebp]
  00074	ff 75 e0	 push	 DWORD PTR $T3[ebp]
  00077	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  0007a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	ff 30		 push	 DWORD PTR [eax]
  0007f	e8 00 00 00 00	 call	 ??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
  00084	83 c4 14	 add	 esp, 20			; 00000014H

; 807  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  00087	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  0008a	50		 push	 eax
  0008b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	ff 70 04	 push	 DWORD PTR [eax+4]
  00091	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * &>
  00096	59		 pop	 ecx
  00097	59		 pop	 ecx

; 808  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  00098	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  0009b	50		 push	 eax
  0009c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a2	83 c0 04	 add	 eax, 4
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * &>
  000ab	59		 pop	 ecx
  000ac	59		 pop	 ecx

; 809  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  000ad	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  000b0	50		 push	 eax
  000b1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b7	83 c0 08	 add	 eax, 8
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * &>
  000c0	59		 pop	 ecx
  000c1	59		 pop	 ecx

; 810  :         this->_Ptr->_Color = _Red;

  000c2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c8	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 811  :         this->_Ptr->_Isnil = false;

  000cc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000cf	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d2	c6 40 0d 00	 mov	 BYTE PTR [eax+13], 0

; 812  :     }

  000d6	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000da	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e7	59		 pop	 ecx
  000e8	c9		 leave
  000e9	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
__unwindfunclet$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z$0:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
___formal$ = -16					; size = 4
$T1 = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >, COMDAT
; _this$ = ecx

; 817  :     ~_Tree_temp_node() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 818  :         if (this->_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 50		 je	 SHORT $LN54@Tree_temp_

; 819  :             _Destroy_in_place(this->_Ptr->_Left);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	ff 70 04	 push	 DWORD PTR [eax+4]
  00018	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *>
  0001d	59		 pop	 ecx

; 820  :             _Destroy_in_place(this->_Ptr->_Parent);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	83 c0 04	 add	 eax, 4
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *>
  0002d	59		 pop	 ecx

; 821  :             _Destroy_in_place(this->_Ptr->_Right);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00034	83 c0 08	 add	 eax, 8
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *>
  0003d	59		 pop	 ecx

; 822  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	83 c0 10	 add	 eax, 16			; 00000010H
  00047	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 822  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 00		 mov	 eax, DWORD PTR [eax]
  00055	89 45 f0	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 706  :         _Ptr->~_Uty();

  00058	6a 00		 push	 0
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0005d	e8 00 00 00 00	 call	 ??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEPAXI@Z
$LN54@Tree_temp_:
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 824  :     }

  0006a	c9		 leave
  0006b	c3		 ret	 0
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >, COMDAT
; _this$ = ecx

; 1056 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 22		 je	 SHORT $LN3@Alloc_cons

; 1058 :             _Al.deallocate(_Ptr, 1);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	6b c0 34	 imul	 eax, eax, 52
  00029	50		 push	 eax
  0002a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN3@Alloc_cons:

; 1059 :         }
; 1060 :     }

  00034	c9		 leave
  00035	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1051 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1053 :         _Ptr = _Al.allocate(1);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00018	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001c	c7 45 e8 c4 4e
	ec 04		 mov	 DWORD PTR __Max_possible$1[ebp], 82595524 ; 04ec4ec4H

; 60   :         if (_Count > _Max_possible) {

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	3d c4 4e ec 04	 cmp	 eax, 82595524		; 04ec4ec4H
  0002b	76 05		 jbe	 SHORT $LN6@Allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Allocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 34	 imul	 eax, eax, 52
  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00043	59		 pop	 ecx
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1053 :         _Ptr = _Al.allocate(1);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Allocate:

; 1054 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Lower_bound_duplicate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_this$ = -8						; size = 4
tv78 = -4						; size = 4
__Bound$ = 8						; size = 4
__Keyval$ = 12						; size = 4
??$_Lower_bound_duplicate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Lower_bound_duplicate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1694 :     bool _Lower_bound_duplicate(const _Nodeptr _Bound, const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Bound$[ebp]
  0000c	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00010	85 c0		 test	 eax, eax
  00012	75 2d		 jne	 SHORT $LN3@Lower_boun

; 2035 :         return _Mypair._Get_first();

  00014	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00017	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0001a	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  0001d	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 69   :         return _Val.first;

  00020	8b 45 08	 mov	 eax, DWORD PTR __Bound$[ebp]
  00023	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00026	50		 push	 eax
  00027	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  0002a	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00031	0f b6 c0	 movzx	 eax, al
  00034	85 c0		 test	 eax, eax
  00036	75 09		 jne	 SHORT $LN3@Lower_boun
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  0003f	eb 04		 jmp	 SHORT $LN4@Lower_boun
$LN3@Lower_boun:
  00041	83 65 fc 00	 and	 DWORD PTR tv78[ebp], 0
$LN4@Lower_boun:
  00045	8a 45 fc	 mov	 al, BYTE PTR tv78[ebp]

; 1696 :     }

  00048	c9		 leave
  00049	c2 08 00	 ret	 8
??$_Lower_bound_duplicate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Lower_bound_duplicate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Result$ = -36						; size = 12
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
_this$ = -12						; size = 4
__Scary$ = -8						; size = 4
__Trynode$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1699 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000e	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00011	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00014	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1700 :         const auto _Scary = _Get_scary();
; 1701 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00017	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001f	89 45 dc	 mov	 DWORD PTR __Result$[ebp], eax
  00022	83 65 e0 00	 and	 DWORD PTR __Result$[ebp+4], 0
  00026	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e4	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1702 :         _Nodeptr _Trynode = _Result._Location._Parent;

  0002e	8b 45 dc	 mov	 eax, DWORD PTR __Result$[ebp]
  00031	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN2@Find_lower:

; 1703 :         while (!_Trynode->_Isnil) {

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00037	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  0003b	85 c0		 test	 eax, eax
  0003d	75 50		 jne	 SHORT $LN3@Find_lower

; 1704 :             _Result._Location._Parent = _Trynode;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00042	89 45 dc	 mov	 DWORD PTR __Result$[ebp], eax

; 2035 :         return _Mypair._Get_first();

  00045	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00048	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0004b	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00051	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 69   :         return _Val.first;

  00054	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00057	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  00060	59		 pop	 ecx
  00061	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1705 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  00062	0f b6 c0	 movzx	 eax, al
  00065	85 c0		 test	 eax, eax
  00067	74 0f		 je	 SHORT $LN4@Find_lower

; 1706 :                 _Result._Location._Child = _Tree_child::_Right;

  00069	83 65 e0 00	 and	 DWORD PTR __Result$[ebp+4], 0

; 1707 :                 _Trynode                 = _Trynode->_Right;

  0006d	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00070	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00073	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax

; 1708 :             } else {

  00076	eb 15		 jmp	 SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1709 :                 _Result._Location._Child = _Tree_child::_Left;

  00078	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR __Result$[ebp+4], 1

; 1710 :                 _Result._Bound           = _Trynode;

  0007f	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00082	89 45 e4	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1711 :                 _Trynode                 = _Trynode->_Left;

  00085	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00088	8b 00		 mov	 eax, DWORD PTR [eax]
  0008a	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN5@Find_lower:

; 1712 :             }
; 1713 :         }

  0008d	eb a5		 jmp	 SHORT $LN2@Find_lower
$LN3@Find_lower:

; 1714 : 
; 1715 :         return _Result;

  0008f	8d 75 dc	 lea	 esi, DWORD PTR __Result$[ebp]
  00092	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00095	a5		 movsd
  00096	a5		 movsd
  00097	a5		 movsd
  00098	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1716 :     }

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	c9		 leave
  0009e	c2 08 00	 ret	 8
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Emplace@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z
_TEXT	SEGMENT
$T1 = -128						; size = 12
$T2 = -116						; size = 8
$T3 = -108						; size = 4
__Loc$ = -104						; size = 12
$T4 = -92						; size = 4
$T5 = -88						; size = 4
$T6 = -84						; size = 4
__Inserted$ = -80					; size = 4
$T7 = -76						; size = 4
__Old_val$8 = -72					; size = 4
$T9 = -68						; size = 4
$T10 = -64						; size = 4
$T11 = -60						; size = 4
$T12 = -56						; size = 4
$T13 = -52						; size = 4
$T14 = -48						; size = 4
$T15 = -44						; size = 4
$T16 = -40						; size = 4
$T17 = -36						; size = 4
__Scary$ = -32						; size = 4
__Val$ = -28						; size = 4
tv147 = -24						; size = 4
tv167 = -20						; size = 4
__Bound$ = -16						; size = 4
__Keyval$18 = -12					; size = 4
_this$ = -8						; size = 4
$T19 = -2						; size = 1
$T20 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
_<_Vals_0>$ = 12					; size = 4
??$_Emplace@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Emplace<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >, COMDAT
; _this$ = ecx

; 1002 :     pair<_Nodeptr, bool> _Emplace(_Valtys&&... _Vals) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00011	89 45 dc	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00014	8b 45 dc	 mov	 eax, DWORD PTR $T17[ebp]
  00017	89 45 e0	 mov	 DWORD PTR __Scary$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 2000 :         return _Val.first;

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1008 :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);

  0001d	89 45 f4	 mov	 DWORD PTR __Keyval$18[ebp], eax

; 1009 :             _Loc                = _Find_lower_bound(_Keyval);

  00020	ff 75 f4	 push	 DWORD PTR __Keyval$18[ebp]
  00023	8d 45 80	 lea	 eax, DWORD PTR $T1[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Find_lower_bound<unsigned long>
  0002f	8b f0		 mov	 esi, eax
  00031	8d 7d 98	 lea	 edi, DWORD PTR __Loc$[ebp]
  00034	a5		 movsd
  00035	a5		 movsd
  00036	a5		 movsd

; 1010 :             if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00037	8b 45 a0	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0003a	89 45 f0	 mov	 DWORD PTR __Bound$[ebp], eax

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0003d	8b 45 f0	 mov	 eax, DWORD PTR __Bound$[ebp]
  00040	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00044	85 c0		 test	 eax, eax
  00046	75 37		 jne	 SHORT $LN39@Emplace

; 2035 :         return _Mypair._Get_first();

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0004b	89 45 d8	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0004e	8b 45 d8	 mov	 eax, DWORD PTR $T16[ebp]
  00051	89 45 94	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00054	8b 45 f4	 mov	 eax, DWORD PTR __Keyval$18[ebp]
  00057	8b 4d f0	 mov	 ecx, DWORD PTR __Bound$[ebp]
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]
  0005c	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  0005f	73 09		 jae	 SHORT $LN51@Emplace
  00061	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv167[ebp], 1
  00068	eb 04		 jmp	 SHORT $LN49@Emplace
$LN51@Emplace:
  0006a	83 65 ec 00	 and	 DWORD PTR tv167[ebp], 0
$LN49@Emplace:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0006e	0f b6 45 ec	 movzx	 eax, BYTE PTR tv167[ebp]
  00072	85 c0		 test	 eax, eax
  00074	75 09		 jne	 SHORT $LN39@Emplace
  00076	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv147[ebp], 1
  0007d	eb 04		 jmp	 SHORT $LN37@Emplace
$LN39@Emplace:
  0007f	83 65 e8 00	 and	 DWORD PTR tv147[ebp], 0
$LN37@Emplace:

; 1010 :             if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00083	0f b6 45 e8	 movzx	 eax, BYTE PTR tv147[ebp]
  00087	85 c0		 test	 eax, eax
  00089	74 2d		 je	 SHORT $LN2@Emplace

; 1011 :                 return {_Loc._Bound, false};

  0008b	c6 45 ff 00	 mov	 BYTE PTR $T20[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0008f	8d 45 a0	 lea	 eax, DWORD PTR __Loc$[ebp+8]
  00092	89 45 d4	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00095	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00098	8b 4d d4	 mov	 ecx, DWORD PTR $T15[ebp]
  0009b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0009d	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0009f	8d 45 ff	 lea	 eax, DWORD PTR $T20[ebp]
  000a2	89 45 d0	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000a5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a8	8b 4d d0	 mov	 ecx, DWORD PTR $T14[ebp]
  000ab	8a 09		 mov	 cl, BYTE PTR [ecx]
  000ad	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1011 :                 return {_Loc._Bound, false};

  000b0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b3	e9 9d 00 00 00	 jmp	 $LN1@Emplace
$LN2@Emplace:

; 1012 :             }
; 1013 : 
; 1014 :             _Check_grow_by_1();

  000b8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	e8 00 00 00 00	 call	 ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Check_grow_by_1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000c0	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  000c3	89 45 c8	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  000c6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000c9	89 45 cc	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  000cc	8b 45 cc	 mov	 eax, DWORD PTR $T13[ebp]
  000cf	89 45 c4	 mov	 DWORD PTR $T11[ebp], eax

; 1015 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  000d2	ff 75 c8	 push	 DWORD PTR $T12[ebp]
  000d5	8b 45 e0	 mov	 eax, DWORD PTR __Scary$[ebp]
  000d8	ff 30		 push	 DWORD PTR [eax]
  000da	ff 75 c4	 push	 DWORD PTR $T11[ebp]
  000dd	8d 4d 8c	 lea	 ecx, DWORD PTR $T2[ebp]
  000e0	e8 00 00 00 00	 call	 ??$?0U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > ><std::pair<unsigned long const ,CPythonMiniMap::SObserver> >
  000e5	89 45 c0	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1048 :         return _STD exchange(_Ptr, nullptr);

  000e8	83 65 bc 00	 and	 DWORD PTR $T9[ebp], 0
  000ec	8b 45 c0	 mov	 eax, DWORD PTR $T10[ebp]
  000ef	83 c0 04	 add	 eax, 4
  000f2	89 45 e4	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  000f5	8b 45 e4	 mov	 eax, DWORD PTR __Val$[ebp]
  000f8	8b 00		 mov	 eax, DWORD PTR [eax]
  000fa	89 45 b8	 mov	 DWORD PTR __Old_val$8[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  000fd	8b 45 e4	 mov	 eax, DWORD PTR __Val$[ebp]
  00100	8b 4d bc	 mov	 ecx, DWORD PTR $T9[ebp]
  00103	89 08		 mov	 DWORD PTR [eax], ecx

; 600  :     return _Old_val;

  00105	8b 45 b8	 mov	 eax, DWORD PTR __Old_val$8[ebp]
  00108	89 45 b4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1048 :         return _STD exchange(_Ptr, nullptr);

  0010b	8b 45 b4	 mov	 eax, DWORD PTR $T7[ebp]
  0010e	89 45 b0	 mov	 DWORD PTR __Inserted$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1015 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  00111	8d 4d 8c	 lea	 ecx, DWORD PTR $T2[ebp]
  00114	e8 00 00 00 00	 call	 ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >

; 1034 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00119	ff 75 b0	 push	 DWORD PTR __Inserted$[ebp]
  0011c	ff 75 9c	 push	 DWORD PTR __Loc$[ebp+4]
  0011f	ff 75 98	 push	 DWORD PTR __Loc$[ebp]
  00122	8b 4d e0	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00125	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Insert_node
  0012a	89 45 ac	 mov	 DWORD PTR $T6[ebp], eax
  0012d	c6 45 fe 01	 mov	 BYTE PTR $T19[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00131	8d 45 ac	 lea	 eax, DWORD PTR $T6[ebp]
  00134	89 45 a8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00137	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0013a	8b 4d a8	 mov	 ecx, DWORD PTR $T5[ebp]
  0013d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0013f	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00141	8d 45 fe	 lea	 eax, DWORD PTR $T19[ebp]
  00144	89 45 a4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00147	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0014a	8b 4d a4	 mov	 ecx, DWORD PTR $T4[ebp]
  0014d	8a 09		 mov	 cl, BYTE PTR [ecx]
  0014f	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1034 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00152	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Emplace:

; 1035 :     }

  00155	5f		 pop	 edi
  00156	5e		 pop	 esi
  00157	c9		 leave
  00158	c2 08 00	 ret	 8
??$_Emplace@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Emplace<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {

  00004	eb 09		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	83 c0 18	 add	 eax, 24			; 00000018H
  0000c	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
  0000f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00012	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00015	74 23		 je	 SHORT $LN5@Destroy_ra
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001a	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00020	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00025	33 c0		 xor	 eax, eax
  00027	83 e0 01	 and	 eax, 1
  0002a	74 0c		 je	 SHORT $LN9@Destroy_ra
  0002c	6a 18		 push	 24			; 00000018H
  0002e	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00031	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00036	59		 pop	 ecx
  00037	59		 pop	 ecx
$LN9@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 968  :         }

  00038	eb cc		 jmp	 SHORT $LN2@Destroy_ra
$LN5@Destroy_ra:

; 969  :     }
; 970  : }

  0003a	c9		 leave
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__Old_val$2 = -16					; size = 4
__New_val$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@Erase_tree:

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000c	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00010	85 c0		 test	 eax, eax
  00012	75 43		 jne	 SHORT $LN4@Erase_tree

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00017	ff 70 08	 push	 DWORD PTR [eax+8]
  0001a	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >

; 745  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00028	89 45 f4	 mov	 DWORD PTR __New_val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0002e	89 45 f0	 mov	 DWORD PTR __Old_val$2[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  00031	8b 45 f4	 mov	 eax, DWORD PTR __New_val$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	89 45 0c	 mov	 DWORD PTR __Rootnode$[ebp], eax

; 600  :     return _Old_val;

  00039	8b 45 f0	 mov	 eax, DWORD PTR __Old_val$2[ebp]
  0003c	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 379  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0003f	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  00042	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00045	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 380  :         _Freenode0(_Al, _Ptr);

  00048	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  0004b	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0004e	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >
  00053	59		 pop	 ecx
  00054	59		 pop	 ecx

; 746  :         }

  00055	eb b2		 jmp	 SHORT $LN2@Erase_tree
$LN4@Erase_tree:

; 747  :     }

  00057	c9		 leave
  00058	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__Pnode$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
__Al$ = 8						; size = 4
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >, COMDAT

; 341  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00006	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000a	c7 45 ec c4 4e
	ec 04		 mov	 DWORD PTR __Max_possible$1[ebp], 82595524 ; 04ec4ec4H

; 60   :         if (_Count > _Max_possible) {

  00011	33 c0		 xor	 eax, eax
  00013	40		 inc	 eax
  00014	3d c4 4e ec 04	 cmp	 eax, 82595524		; 04ec4ec4H
  00019	76 05		 jbe	 SHORT $LN6@Buyheadnod

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001b	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Buyheadnod:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00020	33 c0		 xor	 eax, eax
  00022	40		 inc	 eax
  00023	6b c0 34	 imul	 eax, eax, 52
  00026	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00031	59		 pop	 ecx
  00032	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 343  :         const auto _Pnode = _Al.allocate(1);

  00035	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00038	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0003b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	ff 75 f8	 push	 DWORD PTR __Pnode$[ebp]
  00042	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> * const &>
  00047	59		 pop	 ecx
  00048	59		 pop	 ecx

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00049	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0004c	50		 push	 eax
  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00050	83 c0 04	 add	 eax, 4
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> * const &>
  00059	59		 pop	 ecx
  0005a	59		 pop	 ecx

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0005b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0005e	50		 push	 eax
  0005f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00062	83 c0 08	 add	 eax, 8
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> * const &>
  0006b	59		 pop	 ecx
  0006c	59		 pop	 ecx

; 347  :         _Pnode->_Color = _Black;

  0006d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00070	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 348  :         _Pnode->_Isnil = true;

  00074	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00077	c6 40 0d 01	 mov	 BYTE PTR [eax+13], 1

; 349  :         return _Pnode;

  0007b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
$LN9@Buyheadnod:

; 350  :     }

  0007e	c9		 leave
  0007f	c3		 ret	 0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__Pnode$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
__Al$ = 8						; size = 4
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >, COMDAT

; 341  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00006	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000a	c7 45 ec c4 4e
	ec 04		 mov	 DWORD PTR __Max_possible$1[ebp], 82595524 ; 04ec4ec4H

; 60   :         if (_Count > _Max_possible) {

  00011	33 c0		 xor	 eax, eax
  00013	40		 inc	 eax
  00014	3d c4 4e ec 04	 cmp	 eax, 82595524		; 04ec4ec4H
  00019	76 05		 jbe	 SHORT $LN6@Buyheadnod

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001b	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Buyheadnod:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00020	33 c0		 xor	 eax, eax
  00022	40		 inc	 eax
  00023	6b c0 34	 imul	 eax, eax, 52
  00026	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00031	59		 pop	 ecx
  00032	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 343  :         const auto _Pnode = _Al.allocate(1);

  00035	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00038	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0003b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	ff 75 f8	 push	 DWORD PTR __Pnode$[ebp]
  00042	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * const &>
  00047	59		 pop	 ecx
  00048	59		 pop	 ecx

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00049	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0004c	50		 push	 eax
  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00050	83 c0 04	 add	 eax, 4
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * const &>
  00059	59		 pop	 ecx
  0005a	59		 pop	 ecx

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0005b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0005e	50		 push	 eax
  0005f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00062	83 c0 08	 add	 eax, 8
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * const &>
  0006b	59		 pop	 ecx
  0006c	59		 pop	 ecx

; 347  :         _Pnode->_Color = _Black;

  0006d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00070	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 348  :         _Pnode->_Isnil = true;

  00074	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00077	c6 40 0d 01	 mov	 BYTE PTR [eax+13], 1

; 349  :         return _Pnode;

  0007b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
$LN9@Buyheadnod:

; 350  :     }

  0007e	c9		 leave
  0007f	c3		 ret	 0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 885  : void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 886  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 887  :         _Left = _Right;
; 888  :     }
; 889  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@YAXPAUTMarkPosition@CPythonMiniMap@@QAU12@AAV?$allocator@UTMarkPosition@CPythonMiniMap@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@YAXPAUTMarkPosition@CPythonMiniMap@@QAU12@AAV?$allocator@UTMarkPosition@CPythonMiniMap@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CPythonMiniMap::TMarkPosition> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@YAXPAUTMarkPosition@CPythonMiniMap@@QAU12@AAV?$allocator@UTMarkPosition@CPythonMiniMap@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CPythonMiniMap::TMarkPosition> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAXPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAXPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {

  00004	eb 09		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	83 c0 3c	 add	 eax, 60			; 0000003cH
  0000c	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
  0000f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00012	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00015	74 26		 je	 SHORT $LN5@Destroy_ra
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001a	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00020	83 c1 24	 add	 ecx, 36			; 00000024H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00023	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00028	33 c0		 xor	 eax, eax
  0002a	83 e0 01	 and	 eax, 1
  0002d	74 0c		 je	 SHORT $LN9@Destroy_ra
  0002f	6a 3c		 push	 60			; 0000003cH
  00031	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00039	59		 pop	 ecx
  0003a	59		 pop	 ecx
$LN9@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 968  :         }

  0003b	eb c9		 jmp	 SHORT $LN2@Destroy_ra
$LN5@Destroy_ra:

; 969  :     }
; 970  : }

  0003d	c9		 leave
  0003e	c3		 ret	 0
??$_Destroy_range@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAXPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@YAXPAUTGuildAreaInfo@CPythonMiniMap@@QAU12@AAV?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@YAXPAUTGuildAreaInfo@CPythonMiniMap@@QAU12@AAV?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CPythonMiniMap::TGuildAreaInfo> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@YAXPAUTGuildAreaInfo@CPythonMiniMap@@QAU12@AAV?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CPythonMiniMap::TGuildAreaInfo> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@YAXPAUTSignalPoint@CPythonMiniMap@@QAU12@AAV?$allocator@UTSignalPoint@CPythonMiniMap@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@YAXPAUTSignalPoint@CPythonMiniMap@@QAU12@AAV?$allocator@UTSignalPoint@CPythonMiniMap@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CPythonMiniMap::TSignalPoint> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@YAXPAUTSignalPoint@CPythonMiniMap@@QAU12@AAV?$allocator@UTSignalPoint@CPythonMiniMap@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CPythonMiniMap::TSignalPoint> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Possible_matches_end$ = -8				; size = 4
__Match_try$2 = -4					; size = 4
__Haystack$ = 8						; size = 4
__Hay_size$ = 12					; size = 4
__Start_at$ = 16					; size = 4
__Needle$ = 20						; size = 4
__Needle_size$ = 24					; size = 4
??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z PROC ; std::_Traits_find<std::char_traits<char> >, COMDAT

; 588  :     const size_t _Needle_size) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 589  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at
; 590  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

  00006	8b 45 18	 mov	 eax, DWORD PTR __Needle_size$[ebp]
  00009	3b 45 0c	 cmp	 eax, DWORD PTR __Hay_size$[ebp]
  0000c	77 0b		 ja	 SHORT $LN6@Traits_fin
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Hay_size$[ebp]
  00011	2b 45 18	 sub	 eax, DWORD PTR __Needle_size$[ebp]
  00014	39 45 10	 cmp	 DWORD PTR __Start_at$[ebp], eax
  00017	76 05		 jbe	 SHORT $LN5@Traits_fin
$LN6@Traits_fin:

; 591  :         // xpos cannot exist, report failure
; 592  :         // N4659 24.3.2.7.2 [string.find]/1 says:
; 593  :         // 1. _Start_at <= xpos
; 594  :         // 2. xpos + _Needle_size <= _Hay_size;
; 595  :         // therefore:
; 596  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 597  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 598  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 599  :         return static_cast<size_t>(-1);

  00019	83 c8 ff	 or	 eax, -1
  0001c	eb 78		 jmp	 SHORT $LN10@Traits_fin
$LN5@Traits_fin:

; 600  :     }
; 601  : 
; 602  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

  0001e	83 7d 18 00	 cmp	 DWORD PTR __Needle_size$[ebp], 0
  00022	75 05		 jne	 SHORT $LN7@Traits_fin

; 603  :         return _Start_at;

  00024	8b 45 10	 mov	 eax, DWORD PTR __Start_at$[ebp]
  00027	eb 6d		 jmp	 SHORT $LN10@Traits_fin
$LN7@Traits_fin:

; 604  :     }
; 605  : 
; 606  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00029	8b 45 0c	 mov	 eax, DWORD PTR __Hay_size$[ebp]
  0002c	2b 45 18	 sub	 eax, DWORD PTR __Needle_size$[ebp]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Haystack$[ebp]
  00032	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  00036	89 45 f8	 mov	 DWORD PTR __Possible_matches_end$[ebp], eax

; 607  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

  00039	8b 45 08	 mov	 eax, DWORD PTR __Haystack$[ebp]
  0003c	03 45 10	 add	 eax, DWORD PTR __Start_at$[ebp]
  0003f	89 45 fc	 mov	 DWORD PTR __Match_try$2[ebp], eax
  00042	eb 07		 jmp	 SHORT $LN4@Traits_fin
$LN2@Traits_fin:
  00044	8b 45 fc	 mov	 eax, DWORD PTR __Match_try$2[ebp]
  00047	40		 inc	 eax
  00048	89 45 fc	 mov	 DWORD PTR __Match_try$2[ebp], eax
$LN4@Traits_fin:

; 608  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

  0004b	8b 45 f8	 mov	 eax, DWORD PTR __Possible_matches_end$[ebp]
  0004e	2b 45 fc	 sub	 eax, DWORD PTR __Match_try$2[ebp]

; 410  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));

  00051	50		 push	 eax
  00052	8b 45 14	 mov	 eax, DWORD PTR __Needle$[ebp]
  00055	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00058	50		 push	 eax
  00059	ff 75 fc	 push	 DWORD PTR __Match_try$2[ebp]
  0005c	e8 00 00 00 00	 call	 _memchr
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	89 45 fc	 mov	 DWORD PTR __Match_try$2[ebp], eax

; 609  :         if (!_Match_try) { // didn't find first character; report failure

  00067	83 7d fc 00	 cmp	 DWORD PTR __Match_try$2[ebp], 0
  0006b	75 05		 jne	 SHORT $LN8@Traits_fin

; 610  :             return static_cast<size_t>(-1);

  0006d	83 c8 ff	 or	 eax, -1
  00070	eb 24		 jmp	 SHORT $LN10@Traits_fin
$LN8@Traits_fin:

; 369  :         return _CSTD memcmp(_First1, _First2, _Count);

  00072	ff 75 18	 push	 DWORD PTR __Needle_size$[ebp]
  00075	ff 75 14	 push	 DWORD PTR __Needle$[ebp]
  00078	ff 75 fc	 push	 DWORD PTR __Match_try$2[ebp]
  0007b	e8 00 00 00 00	 call	 _memcmp
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
  00083	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 611  :         }
; 612  : 
; 613  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

  00086	83 7d f4 00	 cmp	 DWORD PTR $T1[ebp], 0
  0008a	75 08		 jne	 SHORT $LN9@Traits_fin

; 614  :             return static_cast<size_t>(_Match_try - _Haystack);

  0008c	8b 45 fc	 mov	 eax, DWORD PTR __Match_try$2[ebp]
  0008f	2b 45 08	 sub	 eax, DWORD PTR __Haystack$[ebp]
  00092	eb 02		 jmp	 SHORT $LN10@Traits_fin
$LN9@Traits_fin:

; 615  :         }
; 616  :     }

  00094	eb ae		 jmp	 SHORT $LN2@Traits_fin
$LN10@Traits_fin:

; 617  : }

  00096	c9		 leave
  00097	c3		 ret	 0
??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z ENDP ; std::_Traits_find<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEPAUTMarkPosition@CPythonMiniMap@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEPAUTMarkPosition@CPythonMiniMap@@QAU23@ABU23@@Z PROC ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Emplace_reallocate<CPythonMiniMap::TMarkPosition const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEPAUTMarkPosition@CPythonMiniMap@@QAU23@ABU23@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	8b c1		 mov	 eax, ecx
  0005f	99		 cdq
  00060	6a 0c		 push	 12			; 0000000cH
  00062	59		 pop	 ecx
  00063	f7 f9		 idiv	 ecx
  00065	89 45 60	 mov	 DWORD PTR __Whereoff$[ebp], eax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00068	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006b	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 0c		 push	 12			; 0000000cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  0007b	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0007e	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00081	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  00084	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00087	c7 45 40 55 55
	55 15		 mov	 DWORD PTR $T22[ebp], 357913941 ; 15555555H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0008e	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00095	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00098	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0009b	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  0009e	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  000a1	73 08		 jae	 SHORT $LN34@Emplace_re
  000a3	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a9	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000ab	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000ae	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000b1	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000b4	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000b7	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000ba	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000bd	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000c0	8b 00		 mov	 eax, DWORD PTR [eax]
  000c2	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000c5	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c8	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000cb	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000cd	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@CAXXZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000d2	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000d5	40		 inc	 eax
  000d6	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d9	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000dc	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@ABEII@Z ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Calculate_growth
  000e4	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000e7	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000eb	c7 45 bc 55 55
	55 15		 mov	 DWORD PTR __Max_possible$2[ebp], 357913941 ; 15555555H

; 60   :         if (_Count > _Max_possible) {

  000f2	81 7d 54 55 55
	55 15		 cmp	 DWORD PTR __Newcapacity$[ebp], 357913941 ; 15555555H
  000f9	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000fb	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00100	6b 45 54 0c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 12
  00104	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00107	ff 75 10	 push	 DWORD PTR $T14[ebp]
  0010a	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0010f	59		 pop	 ecx
  00110	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  00113	6b 45 60 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  00117	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0011a	8d 44 01 0c	 lea	 eax, DWORD PTR [ecx+eax+12]
  0011e	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  00121	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  00124	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00127	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0012b	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0012e	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00131	6b 45 60 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  00135	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00138	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0013b	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  0013e	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00141	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  00144	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00147	8b 75 04	 mov	 esi, DWORD PTR $T11[ebp]
  0014a	8b 7d 00	 mov	 edi, DWORD PTR $T10[ebp]
  0014d	a5		 movsd
  0014e	a5		 movsd
  0014f	a5		 movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  00150	6b 45 60 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  00154	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
  00157	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0015a	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015d	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00160	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00162	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00164	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00167	8b 00		 mov	 eax, DWORD PTR [eax]
  00169	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016c	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016f	8b 00		 mov	 eax, DWORD PTR [eax]
  00171	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00174	33 c0		 xor	 eax, eax
  00176	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00179	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017c	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017f	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00182	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00185	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00188	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0018b	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018e	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00191	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00194	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00197	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@YAPAUTMarkPosition@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTMarkPosition@CPythonMiniMap@@@0@@Z ; std::_Uninitialized_move<CPythonMiniMap::TMarkPosition *,std::allocator<CPythonMiniMap::TMarkPosition> >
  0019c	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019f	eb 5f		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  001a1	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a4	8b 00		 mov	 eax, DWORD PTR [eax]
  001a6	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a9	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001ac	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001af	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b2	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b5	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b8	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001bb	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001be	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001c1	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@YAPAUTMarkPosition@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTMarkPosition@CPythonMiniMap@@@0@@Z ; std::_Uninitialized_move<CPythonMiniMap::TMarkPosition *,std::allocator<CPythonMiniMap::TMarkPosition> >
  001c6	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c9	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001cc	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cf	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d2	8b 00		 mov	 eax, DWORD PTR [eax]
  001d4	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001da	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001dd	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001e0	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e3	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e6	6b 45 60 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  001ea	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ed	8d 44 01 0c	 lea	 eax, DWORD PTR [ecx+eax+12]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001f1	50		 push	 eax
  001f2	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f5	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f8	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@YAPAUTMarkPosition@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTMarkPosition@CPythonMiniMap@@@0@@Z ; std::_Uninitialized_move<CPythonMiniMap::TMarkPosition *,std::allocator<CPythonMiniMap::TMarkPosition> >
  001fd	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00200	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEPAUTMarkPosition@CPythonMiniMap@@QAU23@ABU23@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  00202	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00205	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00208	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  0020b	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@AAEXPAUTMarkPosition@CPythonMiniMap@@0@Z ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00210	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00213	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00216	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00219	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@QAEXQAUTMarkPosition@CPythonMiniMap@@I@Z ; std::allocator<CPythonMiniMap::TMarkPosition>::deallocate

; 762  :         _RERAISE;

  0021e	6a 00		 push	 0
  00220	6a 00		 push	 0
  00222	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00227	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  0022c	c3		 ret	 0
$LN7@Emplace_re:
  0022d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  00231	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEPAUTMarkPosition@CPythonMiniMap@@QAU23@ABU23@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00233	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEPAUTMarkPosition@CPythonMiniMap@@QAU23@ABU23@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00237	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  0023a	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023d	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00240	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00243	e8 00 00 00 00	 call	 ?_Change_array@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@AAEXQAUTMarkPosition@CPythonMiniMap@@II@Z ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00248	6b 45 60 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  0024c	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
$LN70@Emplace_re:

; 767  :     }

  0024f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00252	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00259	59		 pop	 ecx
  0025a	5f		 pop	 edi
  0025b	5e		 pop	 esi
  0025c	5b		 pop	 ebx
  0025d	83 c5 70	 add	 ebp, 112		; 00000070H
  00260	c9		 leave
  00261	c2 08 00	 ret	 8
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
  00268	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEPAUTMarkPosition@CPythonMiniMap@@QAU23@ABU23@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEPAUTMarkPosition@CPythonMiniMap@@QAU23@ABU23@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEPAUTMarkPosition@CPythonMiniMap@@QAU23@ABU23@@Z ENDP ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Emplace_reallocate<CPythonMiniMap::TMarkPosition const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEXABUTMarkPosition@CPythonMiniMap@@@Z
_TEXT	SEGMENT
__Result$ = -64						; size = 4
__Result$1 = -60					; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
$T8 = -32						; size = 4
__Ptr$ = -28						; size = 4
$T9 = -24						; size = 4
__My_data$10 = -20					; size = 4
__Mylast$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$11 = -4					; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEXABUTMarkPosition@CPythonMiniMap@@@Z PROC ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::emplace_back<CPythonMiniMap::TMarkPosition const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  0000b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  00011	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00014	83 c0 04	 add	 eax, 4
  00017	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  0001a	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001d	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00025	74 61		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00027	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0002a	89 45 e8	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 684  :         auto& _My_data   = _Mypair._Myval2;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	89 45 ec	 mov	 DWORD PTR __My_data$10[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  00033	8b 45 ec	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00036	83 c0 04	 add	 eax, 4
  00039	89 45 fc	 mov	 DWORD PTR __Mylast$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003c	8b 45 e8	 mov	 eax, DWORD PTR $T9[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00042	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 e4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0004a	8b 45 e4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00053	89 45 e0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00056	8b 45 e0	 mov	 eax, DWORD PTR $T8[ebp]
  00059	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0005c	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T6[ebp]
  00065	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00068	8b 75 d4	 mov	 esi, DWORD PTR $T5[ebp]
  0006b	8b 7d d0	 mov	 edi, DWORD PTR $T4[ebp]
  0006e	a5		 movsd
  0006f	a5		 movsd
  00070	a5		 movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  00071	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00074	8b 00		 mov	 eax, DWORD PTR [eax]
  00076	89 45 c4	 mov	 DWORD PTR __Result$1[ebp], eax

; 690  :         ++_Mylast;

  00079	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  0007c	8b 00		 mov	 eax, DWORD PTR [eax]
  0007e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00081	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$11[ebp]
  00084	89 01		 mov	 DWORD PTR [ecx], eax

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00086	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00088	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0008b	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0008e	ff 75 cc	 push	 DWORD PTR $T3[ebp]
  00091	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00094	ff 30		 push	 DWORD PTR [eax]
  00096	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEPAUTMarkPosition@CPythonMiniMap@@QAU23@ABU23@@Z ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Emplace_reallocate<CPythonMiniMap::TMarkPosition const &>
  0009e	89 45 c0	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	c9		 leave
  000a4	c2 04 00	 ret	 4
??$emplace_back@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEXABUTMarkPosition@CPythonMiniMap@@@Z ENDP ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::emplace_back<CPythonMiniMap::TMarkPosition const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z
_TEXT	SEGMENT
__ULast$1 = -24						; size = 4
tv95 = -20						; size = 4
tv87 = -16						; size = 4
__UFirst$2 = -12					; size = 4
__Off$3 = -8						; size = 4
$T4 = -2						; size = 1
$T5 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z PROC ; std::distance<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >,std::_Iterator_base0> >, COMDAT

; 1792 : _NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 1793 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1794 :         return _Last - _First; // assume the iterator will do debug checking
; 1795 :     } else {
; 1796 :         _Adl_verify_range(_First, _Last);
; 1797 :         auto _UFirst             = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR __UFirst$2[ebp], eax

; 1798 :         const auto _ULast        = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 e8	 mov	 DWORD PTR __ULast$1[ebp], eax

; 1799 :         _Iter_diff_t<_InIt> _Off = 0;

  00012	83 65 f8 00	 and	 DWORD PTR __Off$3[ebp], 0
  00016	eb 08		 jmp	 SHORT $LN4@distance
$LN2@distance:

; 1800 :         for (; _UFirst != _ULast; ++_UFirst) {

  00018	8d 4d f4	 lea	 ecx, DWORD PTR __UFirst$2[ebp]
  0001b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >,std::_Iterator_base0>::operator++
$LN4@distance:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 98   :         return _Ptr == _Right._Ptr;

  00020	8b 45 f4	 mov	 eax, DWORD PTR __UFirst$2[ebp]
  00023	3b 45 e8	 cmp	 eax, DWORD PTR __ULast$1[ebp]
  00026	75 09		 jne	 SHORT $LN31@distance
  00028	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv87[ebp], 1
  0002f	eb 04		 jmp	 SHORT $LN32@distance
$LN31@distance:
  00031	83 65 f0 00	 and	 DWORD PTR tv87[ebp], 0
$LN32@distance:
  00035	8a 45 f0	 mov	 al, BYTE PTR tv87[ebp]
  00038	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 102  :         return !(*this == _Right);

  0003b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  0003f	85 c0		 test	 eax, eax
  00041	75 09		 jne	 SHORT $LN26@distance
  00043	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv95[ebp], 1
  0004a	eb 04		 jmp	 SHORT $LN27@distance
$LN26@distance:
  0004c	83 65 ec 00	 and	 DWORD PTR tv95[ebp], 0
$LN27@distance:
  00050	8a 45 ec	 mov	 al, BYTE PTR tv95[ebp]
  00053	88 45 fe	 mov	 BYTE PTR $T4[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1800 :         for (; _UFirst != _ULast; ++_UFirst) {

  00056	0f b6 45 fe	 movzx	 eax, BYTE PTR $T4[ebp]
  0005a	85 c0		 test	 eax, eax
  0005c	74 09		 je	 SHORT $LN3@distance

; 1801 :             ++_Off;

  0005e	8b 45 f8	 mov	 eax, DWORD PTR __Off$3[ebp]
  00061	40		 inc	 eax
  00062	89 45 f8	 mov	 DWORD PTR __Off$3[ebp], eax

; 1802 :         }

  00065	eb b1		 jmp	 SHORT $LN2@distance
$LN3@distance:

; 1803 : 
; 1804 :         return _Off;

  00067	8b 45 f8	 mov	 eax, DWORD PTR __Off$3[ebp]

; 1805 :     }
; 1806 : }

  0006a	c9		 leave
  0006b	c3		 ret	 0
??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ENDP ; std::distance<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Find@K@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@ABK@Z
_TEXT	SEGMENT
__Loc$ = -44						; size = 12
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
tv79 = -16						; size = 4
tv131 = -12						; size = 4
__Bound$ = -8						; size = 4
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
??$_Find@K@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Find<unsigned long>, COMDAT
; _this$ = ecx

; 1457 :     _NODISCARD _Nodeptr _Find(const _Other& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1458 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00009	ff 75 08	 push	 DWORD PTR __Keyval$[ebp]
  0000c	8d 45 d4	 lea	 eax, DWORD PTR __Loc$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Find_lower_bound<unsigned long>

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00018	8b 45 dc	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0001b	89 45 f8	 mov	 DWORD PTR __Bound$[ebp], eax

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Bound$[ebp]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 37		 jne	 SHORT $LN30@Find

; 2035 :         return _Mypair._Get_first();

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002c	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0002f	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00032	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00035	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00038	8b 4d f8	 mov	 ecx, DWORD PTR __Bound$[ebp]
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  00040	73 09		 jae	 SHORT $LN42@Find
  00042	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv131[ebp], 1
  00049	eb 04		 jmp	 SHORT $LN40@Find
$LN42@Find:
  0004b	83 65 f4 00	 and	 DWORD PTR tv131[ebp], 0
$LN40@Find:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0004f	0f b6 45 f4	 movzx	 eax, BYTE PTR tv131[ebp]
  00053	85 c0		 test	 eax, eax
  00055	75 09		 jne	 SHORT $LN30@Find
  00057	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  0005e	eb 04		 jmp	 SHORT $LN28@Find
$LN30@Find:
  00060	83 65 f0 00	 and	 DWORD PTR tv79[ebp], 0
$LN28@Find:

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00064	0f b6 45 f0	 movzx	 eax, BYTE PTR tv79[ebp]
  00068	85 c0		 test	 eax, eax
  0006a	74 05		 je	 SHORT $LN2@Find

; 1460 :             return _Loc._Bound;

  0006c	8b 45 dc	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0006f	eb 11		 jmp	 SHORT $LN1@Find
$LN2@Find:

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00074	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00077	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  0007a	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax

; 1461 :         }
; 1462 : 
; 1463 :         return _Get_scary()->_Myhead;

  0007d	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  00080	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Find:

; 1464 :     }

  00082	c9		 leave
  00083	c2 04 00	 ret	 4
??$_Find@K@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Find<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTAtlasMarkInfo@CPythonMiniMap@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTAtlasMarkInfo@CPythonMiniMap@@QAU23@ABU23@@Z PROC ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Emplace_reallocate<CPythonMiniMap::TAtlasMarkInfo const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTAtlasMarkInfo@CPythonMiniMap@@QAU23@ABU23@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	8b c1		 mov	 eax, ecx
  0005f	99		 cdq
  00060	6a 3c		 push	 60			; 0000003cH
  00062	59		 pop	 ecx
  00063	f7 f9		 idiv	 ecx
  00065	89 45 60	 mov	 DWORD PTR __Whereoff$[ebp], eax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00068	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006b	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 3c		 push	 60			; 0000003cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  0007b	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0007e	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00081	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  00084	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00087	c7 45 40 44 44
	44 04		 mov	 DWORD PTR $T22[ebp], 71582788 ; 04444444H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0008e	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00095	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00098	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0009b	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  0009e	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  000a1	73 08		 jae	 SHORT $LN34@Emplace_re
  000a3	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a9	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000ab	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000ae	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000b1	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000b4	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000b7	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000ba	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000bd	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000c0	8b 00		 mov	 eax, DWORD PTR [eax]
  000c2	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000c5	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c8	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000cb	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000cd	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@CAXXZ ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000d2	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000d5	40		 inc	 eax
  000d6	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d9	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000dc	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@ABEII@Z ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Calculate_growth
  000e4	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000e7	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000eb	c7 45 bc 44 44
	44 04		 mov	 DWORD PTR __Max_possible$2[ebp], 71582788 ; 04444444H

; 60   :         if (_Count > _Max_possible) {

  000f2	81 7d 54 44 44
	44 04		 cmp	 DWORD PTR __Newcapacity$[ebp], 71582788 ; 04444444H
  000f9	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000fb	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00100	6b 45 54 3c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 60
  00104	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00107	ff 75 10	 push	 DWORD PTR $T14[ebp]
  0010a	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0010f	59		 pop	 ecx
  00110	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  00113	6b 45 60 3c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 60
  00117	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0011a	8d 44 01 3c	 lea	 eax, DWORD PTR [ecx+eax+60]
  0011e	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  00121	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  00124	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00127	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0012b	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0012e	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00131	6b 45 60 3c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 60
  00135	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00138	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0013b	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  0013e	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00141	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  00144	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00147	ff 75 04	 push	 DWORD PTR $T11[ebp]
  0014a	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  0014d	e8 00 00 00 00	 call	 ??0TAtlasMarkInfo@CPythonMiniMap@@QAE@ABU01@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  00152	6b 45 60 3c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 60
  00156	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
  00159	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0015c	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015f	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00162	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00164	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00166	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00169	8b 00		 mov	 eax, DWORD PTR [eax]
  0016b	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016e	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00171	8b 00		 mov	 eax, DWORD PTR [eax]
  00173	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00176	33 c0		 xor	 eax, eax
  00178	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  0017b	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017e	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  00181	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00184	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00187	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  0018a	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0018d	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  00190	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00193	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00196	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00199	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z ; std::_Uninitialized_move<CPythonMiniMap::TAtlasMarkInfo *,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
  0019e	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  001a1	eb 5f		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  001a3	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a6	8b 00		 mov	 eax, DWORD PTR [eax]
  001a8	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001ab	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001ae	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001b1	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b4	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b7	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001ba	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001bd	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001c0	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001c3	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z ; std::_Uninitialized_move<CPythonMiniMap::TAtlasMarkInfo *,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
  001c8	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001cb	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ce	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001d1	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d4	8b 00		 mov	 eax, DWORD PTR [eax]
  001d6	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d9	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001dc	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001df	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001e2	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e5	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e8	6b 45 60 3c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 60
  001ec	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ef	8d 44 01 3c	 lea	 eax, DWORD PTR [ecx+eax+60]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001f3	50		 push	 eax
  001f4	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f7	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001fa	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z ; std::_Uninitialized_move<CPythonMiniMap::TAtlasMarkInfo *,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
  001ff	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00202	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTAtlasMarkInfo@CPythonMiniMap@@QAU23@ABU23@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  00204	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00207	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  0020a	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  0020d	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXPAUTAtlasMarkInfo@CPythonMiniMap@@0@Z ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00212	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00215	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00218	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  0021b	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@QAEXQAUTAtlasMarkInfo@CPythonMiniMap@@I@Z ; std::allocator<CPythonMiniMap::TAtlasMarkInfo>::deallocate

; 762  :         _RERAISE;

  00220	6a 00		 push	 0
  00222	6a 00		 push	 0
  00224	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00229	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  0022e	c3		 ret	 0
$LN7@Emplace_re:
  0022f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  00233	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTAtlasMarkInfo@CPythonMiniMap@@QAU23@ABU23@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00235	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTAtlasMarkInfo@CPythonMiniMap@@QAU23@ABU23@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00239	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  0023c	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023f	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00242	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00245	e8 00 00 00 00	 call	 ?_Change_array@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXQAUTAtlasMarkInfo@CPythonMiniMap@@II@Z ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  0024a	6b 45 60 3c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 60
  0024e	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
$LN70@Emplace_re:

; 767  :     }

  00251	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00254	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0025b	59		 pop	 ecx
  0025c	5f		 pop	 edi
  0025d	5e		 pop	 esi
  0025e	5b		 pop	 ebx
  0025f	83 c5 70	 add	 ebp, 112		; 00000070H
  00262	c9		 leave
  00263	c2 08 00	 ret	 8
  00266	cc		 int	 3
  00267	cc		 int	 3
  00268	cc		 int	 3
  00269	cc		 int	 3
  0026a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTAtlasMarkInfo@CPythonMiniMap@@QAU23@ABU23@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTAtlasMarkInfo@CPythonMiniMap@@QAU23@ABU23@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTAtlasMarkInfo@CPythonMiniMap@@QAU23@ABU23@@Z ENDP ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Emplace_reallocate<CPythonMiniMap::TAtlasMarkInfo const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXABUTAtlasMarkInfo@CPythonMiniMap@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXABUTAtlasMarkInfo@CPythonMiniMap@@@Z PROC ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Emplace_back_with_unused_capacity<CPythonMiniMap::TAtlasMarkInfo const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	ff 75 e0	 push	 DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	e8 00 00 00 00	 call	 ??0TAtlasMarkInfo@CPythonMiniMap@@QAE@ABU01@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00052	8b 00		 mov	 eax, DWORD PTR [eax]
  00054	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00057	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]
  0005c	83 c0 3c	 add	 eax, 60			; 0000003cH
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00062	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00064	c9		 leave
  00065	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXABUTAtlasMarkInfo@CPythonMiniMap@@@Z ENDP ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Emplace_back_with_unused_capacity<CPythonMiniMap::TAtlasMarkInfo const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEXABUTAtlasMarkInfo@CPythonMiniMap@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEXABUTAtlasMarkInfo@CPythonMiniMap@@@Z PROC ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::emplace_back<CPythonMiniMap::TAtlasMarkInfo const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXABUTAtlasMarkInfo@CPythonMiniMap@@@Z ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Emplace_back_with_unused_capacity<CPythonMiniMap::TAtlasMarkInfo const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTAtlasMarkInfo@CPythonMiniMap@@QAU23@ABU23@@Z ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Emplace_reallocate<CPythonMiniMap::TAtlasMarkInfo const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEXABUTAtlasMarkInfo@CPythonMiniMap@@@Z ENDP ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::emplace_back<CPythonMiniMap::TAtlasMarkInfo const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTGuildAreaInfo@CPythonMiniMap@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTGuildAreaInfo@CPythonMiniMap@@QAU23@ABU23@@Z PROC ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Emplace_reallocate<CPythonMiniMap::TGuildAreaInfo const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTGuildAreaInfo@CPythonMiniMap@@QAU23@ABU23@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	8b c1		 mov	 eax, ecx
  0005f	99		 cdq
  00060	6a 24		 push	 36			; 00000024H
  00062	59		 pop	 ecx
  00063	f7 f9		 idiv	 ecx
  00065	89 45 60	 mov	 DWORD PTR __Whereoff$[ebp], eax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00068	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006b	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 24		 push	 36			; 00000024H
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  0007b	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0007e	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00081	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  00084	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00087	c7 45 40 c7 71
	1c 07		 mov	 DWORD PTR $T22[ebp], 119304647 ; 071c71c7H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0008e	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00095	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00098	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0009b	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  0009e	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  000a1	73 08		 jae	 SHORT $LN34@Emplace_re
  000a3	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a9	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000ab	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000ae	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000b1	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000b4	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000b7	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000ba	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000bd	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000c0	8b 00		 mov	 eax, DWORD PTR [eax]
  000c2	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000c5	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c8	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000cb	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000cd	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@CAXXZ ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000d2	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000d5	40		 inc	 eax
  000d6	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d9	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000dc	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@ABEII@Z ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Calculate_growth
  000e4	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000e7	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000eb	c7 45 bc c7 71
	1c 07		 mov	 DWORD PTR __Max_possible$2[ebp], 119304647 ; 071c71c7H

; 60   :         if (_Count > _Max_possible) {

  000f2	81 7d 54 c7 71
	1c 07		 cmp	 DWORD PTR __Newcapacity$[ebp], 119304647 ; 071c71c7H
  000f9	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000fb	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00100	6b 45 54 24	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 36
  00104	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00107	ff 75 10	 push	 DWORD PTR $T14[ebp]
  0010a	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0010f	59		 pop	 ecx
  00110	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  00113	6b 45 60 24	 imul	 eax, DWORD PTR __Whereoff$[ebp], 36
  00117	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0011a	8d 44 01 24	 lea	 eax, DWORD PTR [ecx+eax+36]
  0011e	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  00121	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  00124	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00127	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0012b	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0012e	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00131	6b 45 60 24	 imul	 eax, DWORD PTR __Whereoff$[ebp], 36
  00135	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00138	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0013b	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  0013e	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00141	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  00144	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00147	6a 09		 push	 9
  00149	59		 pop	 ecx
  0014a	8b 75 04	 mov	 esi, DWORD PTR $T11[ebp]
  0014d	8b 7d 00	 mov	 edi, DWORD PTR $T10[ebp]
  00150	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  00152	6b 45 60 24	 imul	 eax, DWORD PTR __Whereoff$[ebp], 36
  00156	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
  00159	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0015c	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015f	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00162	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00164	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00166	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00169	8b 00		 mov	 eax, DWORD PTR [eax]
  0016b	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016e	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00171	8b 00		 mov	 eax, DWORD PTR [eax]
  00173	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00176	33 c0		 xor	 eax, eax
  00178	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  0017b	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017e	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  00181	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00184	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00187	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  0018a	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0018d	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  00190	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00193	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00196	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00199	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@YAPAUTGuildAreaInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@0@@Z ; std::_Uninitialized_move<CPythonMiniMap::TGuildAreaInfo *,std::allocator<CPythonMiniMap::TGuildAreaInfo> >
  0019e	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  001a1	eb 5f		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  001a3	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a6	8b 00		 mov	 eax, DWORD PTR [eax]
  001a8	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001ab	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001ae	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001b1	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b4	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b7	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001ba	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001bd	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001c0	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001c3	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@YAPAUTGuildAreaInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@0@@Z ; std::_Uninitialized_move<CPythonMiniMap::TGuildAreaInfo *,std::allocator<CPythonMiniMap::TGuildAreaInfo> >
  001c8	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001cb	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ce	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001d1	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d4	8b 00		 mov	 eax, DWORD PTR [eax]
  001d6	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d9	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001dc	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001df	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001e2	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e5	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e8	6b 45 60 24	 imul	 eax, DWORD PTR __Whereoff$[ebp], 36
  001ec	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ef	8d 44 01 24	 lea	 eax, DWORD PTR [ecx+eax+36]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001f3	50		 push	 eax
  001f4	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f7	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001fa	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@YAPAUTGuildAreaInfo@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@0@@Z ; std::_Uninitialized_move<CPythonMiniMap::TGuildAreaInfo *,std::allocator<CPythonMiniMap::TGuildAreaInfo> >
  001ff	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00202	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTGuildAreaInfo@CPythonMiniMap@@QAU23@ABU23@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  00204	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00207	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  0020a	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  0020d	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@AAEXPAUTGuildAreaInfo@CPythonMiniMap@@0@Z ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00212	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00215	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00218	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  0021b	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@QAEXQAUTGuildAreaInfo@CPythonMiniMap@@I@Z ; std::allocator<CPythonMiniMap::TGuildAreaInfo>::deallocate

; 762  :         _RERAISE;

  00220	6a 00		 push	 0
  00222	6a 00		 push	 0
  00224	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00229	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  0022e	c3		 ret	 0
$LN7@Emplace_re:
  0022f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  00233	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTGuildAreaInfo@CPythonMiniMap@@QAU23@ABU23@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00235	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTGuildAreaInfo@CPythonMiniMap@@QAU23@ABU23@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00239	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  0023c	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023f	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00242	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00245	e8 00 00 00 00	 call	 ?_Change_array@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@AAEXQAUTGuildAreaInfo@CPythonMiniMap@@II@Z ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  0024a	6b 45 60 24	 imul	 eax, DWORD PTR __Whereoff$[ebp], 36
  0024e	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
$LN70@Emplace_re:

; 767  :     }

  00251	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00254	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0025b	59		 pop	 ecx
  0025c	5f		 pop	 edi
  0025d	5e		 pop	 esi
  0025e	5b		 pop	 ebx
  0025f	83 c5 70	 add	 ebp, 112		; 00000070H
  00262	c9		 leave
  00263	c2 08 00	 ret	 8
  00266	cc		 int	 3
  00267	cc		 int	 3
  00268	cc		 int	 3
  00269	cc		 int	 3
  0026a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTGuildAreaInfo@CPythonMiniMap@@QAU23@ABU23@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTGuildAreaInfo@CPythonMiniMap@@QAU23@ABU23@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTGuildAreaInfo@CPythonMiniMap@@QAU23@ABU23@@Z ENDP ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Emplace_reallocate<CPythonMiniMap::TGuildAreaInfo const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEXABUTGuildAreaInfo@CPythonMiniMap@@@Z
_TEXT	SEGMENT
__Result$ = -64						; size = 4
__Result$1 = -60					; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
$T8 = -32						; size = 4
__Ptr$ = -28						; size = 4
$T9 = -24						; size = 4
__My_data$10 = -20					; size = 4
__Mylast$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$11 = -4					; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEXABUTGuildAreaInfo@CPythonMiniMap@@@Z PROC ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::emplace_back<CPythonMiniMap::TGuildAreaInfo const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  0000b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  00011	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00014	83 c0 04	 add	 eax, 4
  00017	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  0001a	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001d	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00025	74 63		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00027	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0002a	89 45 e8	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 684  :         auto& _My_data   = _Mypair._Myval2;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	89 45 ec	 mov	 DWORD PTR __My_data$10[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  00033	8b 45 ec	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00036	83 c0 04	 add	 eax, 4
  00039	89 45 fc	 mov	 DWORD PTR __Mylast$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003c	8b 45 e8	 mov	 eax, DWORD PTR $T9[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00042	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 e4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0004a	8b 45 e4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00053	89 45 e0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00056	8b 45 e0	 mov	 eax, DWORD PTR $T8[ebp]
  00059	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0005c	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T6[ebp]
  00065	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00068	6a 09		 push	 9
  0006a	59		 pop	 ecx
  0006b	8b 75 d4	 mov	 esi, DWORD PTR $T5[ebp]
  0006e	8b 7d d0	 mov	 edi, DWORD PTR $T4[ebp]
  00071	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  00073	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00076	8b 00		 mov	 eax, DWORD PTR [eax]
  00078	89 45 c4	 mov	 DWORD PTR __Result$1[ebp], eax

; 690  :         ++_Mylast;

  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	83 c0 24	 add	 eax, 36			; 00000024H
  00083	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$11[ebp]
  00086	89 01		 mov	 DWORD PTR [ecx], eax

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00088	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0008a	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0008d	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00090	ff 75 cc	 push	 DWORD PTR $T3[ebp]
  00093	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00096	ff 30		 push	 DWORD PTR [eax]
  00098	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEPAUTGuildAreaInfo@CPythonMiniMap@@QAU23@ABU23@@Z ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Emplace_reallocate<CPythonMiniMap::TGuildAreaInfo const &>
  000a0	89 45 c0	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	c9		 leave
  000a6	c2 04 00	 ret	 4
??$emplace_back@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEXABUTGuildAreaInfo@CPythonMiniMap@@@Z ENDP ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::emplace_back<CPythonMiniMap::TGuildAreaInfo const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEPAUTSignalPoint@CPythonMiniMap@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEPAUTSignalPoint@CPythonMiniMap@@QAU23@ABU23@@Z PROC ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Emplace_reallocate<CPythonMiniMap::TSignalPoint const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEPAUTSignalPoint@CPythonMiniMap@@QAU23@ABU23@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	8b c1		 mov	 eax, ecx
  0005f	99		 cdq
  00060	6a 0c		 push	 12			; 0000000cH
  00062	59		 pop	 ecx
  00063	f7 f9		 idiv	 ecx
  00065	89 45 60	 mov	 DWORD PTR __Whereoff$[ebp], eax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00068	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006b	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 0c		 push	 12			; 0000000cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  0007b	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0007e	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00081	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  00084	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00087	c7 45 40 55 55
	55 15		 mov	 DWORD PTR $T22[ebp], 357913941 ; 15555555H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0008e	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00095	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00098	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0009b	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  0009e	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  000a1	73 08		 jae	 SHORT $LN34@Emplace_re
  000a3	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a9	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000ab	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000ae	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000b1	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000b4	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000b7	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000ba	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000bd	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000c0	8b 00		 mov	 eax, DWORD PTR [eax]
  000c2	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000c5	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c8	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000cb	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000cd	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@CAXXZ ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000d2	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000d5	40		 inc	 eax
  000d6	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d9	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000dc	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@ABEII@Z ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Calculate_growth
  000e4	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000e7	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000eb	c7 45 bc 55 55
	55 15		 mov	 DWORD PTR __Max_possible$2[ebp], 357913941 ; 15555555H

; 60   :         if (_Count > _Max_possible) {

  000f2	81 7d 54 55 55
	55 15		 cmp	 DWORD PTR __Newcapacity$[ebp], 357913941 ; 15555555H
  000f9	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000fb	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00100	6b 45 54 0c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 12
  00104	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00107	ff 75 10	 push	 DWORD PTR $T14[ebp]
  0010a	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0010f	59		 pop	 ecx
  00110	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  00113	6b 45 60 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  00117	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0011a	8d 44 01 0c	 lea	 eax, DWORD PTR [ecx+eax+12]
  0011e	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  00121	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  00124	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00127	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0012b	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0012e	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00131	6b 45 60 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  00135	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00138	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0013b	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  0013e	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00141	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  00144	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00147	8b 75 04	 mov	 esi, DWORD PTR $T11[ebp]
  0014a	8b 7d 00	 mov	 edi, DWORD PTR $T10[ebp]
  0014d	a5		 movsd
  0014e	a5		 movsd
  0014f	a5		 movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  00150	6b 45 60 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  00154	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
  00157	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0015a	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015d	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00160	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00162	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00164	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00167	8b 00		 mov	 eax, DWORD PTR [eax]
  00169	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016c	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016f	8b 00		 mov	 eax, DWORD PTR [eax]
  00171	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00174	33 c0		 xor	 eax, eax
  00176	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00179	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017c	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017f	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00182	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00185	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00188	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0018b	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018e	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00191	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00194	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00197	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@YAPAUTSignalPoint@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTSignalPoint@CPythonMiniMap@@@0@@Z ; std::_Uninitialized_move<CPythonMiniMap::TSignalPoint *,std::allocator<CPythonMiniMap::TSignalPoint> >
  0019c	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019f	eb 5f		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  001a1	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a4	8b 00		 mov	 eax, DWORD PTR [eax]
  001a6	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a9	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001ac	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001af	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b2	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b5	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b8	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001bb	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001be	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001c1	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@YAPAUTSignalPoint@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTSignalPoint@CPythonMiniMap@@@0@@Z ; std::_Uninitialized_move<CPythonMiniMap::TSignalPoint *,std::allocator<CPythonMiniMap::TSignalPoint> >
  001c6	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c9	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001cc	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cf	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d2	8b 00		 mov	 eax, DWORD PTR [eax]
  001d4	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001da	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001dd	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001e0	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e3	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e6	6b 45 60 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  001ea	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ed	8d 44 01 0c	 lea	 eax, DWORD PTR [ecx+eax+12]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001f1	50		 push	 eax
  001f2	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f5	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f8	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@YAPAUTSignalPoint@CPythonMiniMap@@QAU12@0PAU12@AAV?$allocator@UTSignalPoint@CPythonMiniMap@@@0@@Z ; std::_Uninitialized_move<CPythonMiniMap::TSignalPoint *,std::allocator<CPythonMiniMap::TSignalPoint> >
  001fd	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00200	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEPAUTSignalPoint@CPythonMiniMap@@QAU23@ABU23@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  00202	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00205	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00208	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  0020b	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@AAEXPAUTSignalPoint@CPythonMiniMap@@0@Z ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00210	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00213	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00216	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00219	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@QAEXQAUTSignalPoint@CPythonMiniMap@@I@Z ; std::allocator<CPythonMiniMap::TSignalPoint>::deallocate

; 762  :         _RERAISE;

  0021e	6a 00		 push	 0
  00220	6a 00		 push	 0
  00222	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00227	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  0022c	c3		 ret	 0
$LN7@Emplace_re:
  0022d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  00231	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEPAUTSignalPoint@CPythonMiniMap@@QAU23@ABU23@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00233	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEPAUTSignalPoint@CPythonMiniMap@@QAU23@ABU23@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00237	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  0023a	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023d	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00240	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00243	e8 00 00 00 00	 call	 ?_Change_array@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@AAEXQAUTSignalPoint@CPythonMiniMap@@II@Z ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00248	6b 45 60 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  0024c	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
$LN70@Emplace_re:

; 767  :     }

  0024f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00252	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00259	59		 pop	 ecx
  0025a	5f		 pop	 edi
  0025b	5e		 pop	 esi
  0025c	5b		 pop	 ebx
  0025d	83 c5 70	 add	 ebp, 112		; 00000070H
  00260	c9		 leave
  00261	c2 08 00	 ret	 8
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
  00268	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEPAUTSignalPoint@CPythonMiniMap@@QAU23@ABU23@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEPAUTSignalPoint@CPythonMiniMap@@QAU23@ABU23@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEPAUTSignalPoint@CPythonMiniMap@@QAU23@ABU23@@Z ENDP ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Emplace_reallocate<CPythonMiniMap::TSignalPoint const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEXABUTSignalPoint@CPythonMiniMap@@@Z
_TEXT	SEGMENT
__Result$ = -64						; size = 4
__Result$1 = -60					; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
$T8 = -32						; size = 4
__Ptr$ = -28						; size = 4
$T9 = -24						; size = 4
__My_data$10 = -20					; size = 4
__Mylast$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$11 = -4					; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEXABUTSignalPoint@CPythonMiniMap@@@Z PROC ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::emplace_back<CPythonMiniMap::TSignalPoint const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  0000b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  00011	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00014	83 c0 04	 add	 eax, 4
  00017	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  0001a	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001d	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00025	74 61		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00027	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0002a	89 45 e8	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 684  :         auto& _My_data   = _Mypair._Myval2;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	89 45 ec	 mov	 DWORD PTR __My_data$10[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  00033	8b 45 ec	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00036	83 c0 04	 add	 eax, 4
  00039	89 45 fc	 mov	 DWORD PTR __Mylast$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003c	8b 45 e8	 mov	 eax, DWORD PTR $T9[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00042	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 e4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0004a	8b 45 e4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00053	89 45 e0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00056	8b 45 e0	 mov	 eax, DWORD PTR $T8[ebp]
  00059	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0005c	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T6[ebp]
  00065	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00068	8b 75 d4	 mov	 esi, DWORD PTR $T5[ebp]
  0006b	8b 7d d0	 mov	 edi, DWORD PTR $T4[ebp]
  0006e	a5		 movsd
  0006f	a5		 movsd
  00070	a5		 movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  00071	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00074	8b 00		 mov	 eax, DWORD PTR [eax]
  00076	89 45 c4	 mov	 DWORD PTR __Result$1[ebp], eax

; 690  :         ++_Mylast;

  00079	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  0007c	8b 00		 mov	 eax, DWORD PTR [eax]
  0007e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00081	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$11[ebp]
  00084	89 01		 mov	 DWORD PTR [ecx], eax

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00086	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00088	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0008b	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0008e	ff 75 cc	 push	 DWORD PTR $T3[ebp]
  00091	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00094	ff 30		 push	 DWORD PTR [eax]
  00096	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEPAUTSignalPoint@CPythonMiniMap@@QAU23@ABU23@@Z ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Emplace_reallocate<CPythonMiniMap::TSignalPoint const &>
  0009e	89 45 c0	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	c9		 leave
  000a4	c2 04 00	 ret	 4
??$emplace_back@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEXABUTSignalPoint@CPythonMiniMap@@@Z ENDP ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::emplace_back<CPythonMiniMap::TSignalPoint const &>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Loc$ = -24						; size = 12
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1457 :     _NODISCARD _Nodeptr _Find(const _Other& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1458 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00009	ff 75 08	 push	 DWORD PTR __Keyval$[ebp]
  0000c	8d 45 e8	 lea	 eax, DWORD PTR __Loc$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00018	ff 75 08	 push	 DWORD PTR __Keyval$[ebp]
  0001b	ff 75 f0	 push	 DWORD PTR __Loc$[ebp+8]
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Lower_bound_duplicate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Lower_bound_duplicate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00026	0f b6 c0	 movzx	 eax, al
  00029	85 c0		 test	 eax, eax
  0002b	74 05		 je	 SHORT $LN2@Find

; 1460 :             return _Loc._Bound;

  0002d	8b 45 f0	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  00030	eb 11		 jmp	 SHORT $LN1@Find
$LN2@Find:

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00035	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00038	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0003b	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1461 :         }
; 1462 : 
; 1463 :         return _Get_scary()->_Myhead;

  0003e	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  00041	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Find:

; 1464 :     }

  00043	c9		 leave
  00044	c2 04 00	 ret	 4
??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
;	COMDAT ??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = -128						; size = 8
__Loc$ = -120						; size = 12
$T2 = -108						; size = 4
$T3 = -104						; size = 4
$T4 = -100						; size = 4
__Inserted$ = -96					; size = 4
$T5 = -92						; size = 4
__Old_val$6 = -88					; size = 4
$T7 = -84						; size = 4
$T8 = -80						; size = 4
$T9 = -76						; size = 4
$T10 = -72						; size = 4
$T11 = -68						; size = 4
$T12 = -64						; size = 4
$T13 = -60						; size = 4
$T14 = -56						; size = 4
_this$15 = -52						; size = 4
$T16 = -48						; size = 4
$T17 = -44						; size = 4
$T18 = -40						; size = 4
$T19 = -36						; size = 4
$T20 = -32						; size = 4
$T21 = -28						; size = 4
$T22 = -24						; size = 4
__Scary$ = -20						; size = 4
__Val$ = -16						; size = 4
$T23 = -9						; size = 1
_this$ = -8						; size = 4
$T24 = -2						; size = 1
$T25 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 175  :     pair<_Nodeptr, bool> _Try_emplace(_Keyty&& _Keyval, _Mappedty&&... _Mapval) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 176  :         const auto _Loc = _Mybase::_Find_lower_bound(_Keyval);

  0000c	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  0000f	8d 45 88	 lea	 eax, DWORD PTR __Loc$[ebp]
  00012	50		 push	 eax
  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 177  :         if (_Mybase::_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  0001b	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  0001e	ff 75 90	 push	 DWORD PTR __Loc$[ebp+8]
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ??$_Lower_bound_duplicate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Lower_bound_duplicate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	74 2d		 je	 SHORT $LN2@Try_emplac

; 178  :             return {_Loc._Bound, false};

  00030	c6 45 ff 00	 mov	 BYTE PTR $T25[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00034	8d 45 90	 lea	 eax, DWORD PTR __Loc$[ebp+8]
  00037	89 45 e8	 mov	 DWORD PTR $T22[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0003a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003d	8b 4d e8	 mov	 ecx, DWORD PTR $T22[ebp]
  00040	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00042	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00044	8d 45 ff	 lea	 eax, DWORD PTR $T25[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0004a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0004d	8b 4d e4	 mov	 ecx, DWORD PTR $T21[ebp]
  00050	8a 09		 mov	 cl, BYTE PTR [ecx]
  00052	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 178  :             return {_Loc._Bound, false};

  00055	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00058	e9 e3 00 00 00	 jmp	 $LN1@Try_emplac
$LN2@Try_emplac:

; 179  :         }
; 180  : 
; 181  :         _Mybase::_Check_grow_by_1();

  0005d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	e8 00 00 00 00	 call	 ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Check_grow_by_1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00065	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00068	89 45 e0	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0006b	8b 45 e0	 mov	 eax, DWORD PTR $T20[ebp]
  0006e	89 45 ec	 mov	 DWORD PTR __Scary$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 854  :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

  00071	8d 45 f7	 lea	 eax, DWORD PTR $T23[ebp]
  00074	89 45 bc	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00077	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0007a	89 45 dc	 mov	 DWORD PTR $T19[ebp], eax
  0007d	8b 45 dc	 mov	 eax, DWORD PTR $T19[ebp]
  00080	89 45 d8	 mov	 DWORD PTR $T18[ebp], eax
  00083	8b 45 d8	 mov	 eax, DWORD PTR $T18[ebp]
  00086	89 45 d4	 mov	 DWORD PTR $T17[ebp], eax
  00089	8b 45 d4	 mov	 eax, DWORD PTR $T17[ebp]
  0008c	89 45 d0	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 245  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

  0008f	8d 45 c4	 lea	 eax, DWORD PTR $T13[ebp]
  00092	89 45 cc	 mov	 DWORD PTR _this$15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00095	8b 45 d0	 mov	 eax, DWORD PTR $T16[ebp]
  00098	89 45 c8	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 163  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

  0009b	8b 45 cc	 mov	 eax, DWORD PTR _this$15[ebp]
  0009e	8b 4d c8	 mov	 ecx, DWORD PTR $T14[ebp]
  000a1	89 08		 mov	 DWORD PTR [eax], ecx

; 854  :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

  000a3	8d 45 c4	 lea	 eax, DWORD PTR $T13[ebp]
  000a6	89 45 b8	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000ac	89 45 c0	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  000af	8b 45 c0	 mov	 eax, DWORD PTR $T12[ebp]
  000b2	89 45 b4	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 184  :         const auto _Inserted = _Tree_temp_node<_Alnode>(_Mybase::_Getal(), _Scary->_Myhead, piecewise_construct,

  000b5	ff 75 bc	 push	 DWORD PTR $T11[ebp]
  000b8	ff 75 b8	 push	 DWORD PTR $T10[ebp]
  000bb	68 00 00 00 00	 push	 OFFSET ?piecewise_construct@std@@3Upiecewise_construct_t@1@B
  000c0	8b 45 ec	 mov	 eax, DWORD PTR __Scary$[ebp]
  000c3	ff 30		 push	 DWORD PTR [eax]
  000c5	ff 75 b4	 push	 DWORD PTR $T9[ebp]
  000c8	8d 4d 80	 lea	 ecx, DWORD PTR $T1[ebp]
  000cb	e8 00 00 00 00	 call	 ??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
  000d0	89 45 b0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1048 :         return _STD exchange(_Ptr, nullptr);

  000d3	83 65 ac 00	 and	 DWORD PTR $T7[ebp], 0
  000d7	8b 45 b0	 mov	 eax, DWORD PTR $T8[ebp]
  000da	83 c0 04	 add	 eax, 4
  000dd	89 45 f0	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  000e0	8b 45 f0	 mov	 eax, DWORD PTR __Val$[ebp]
  000e3	8b 00		 mov	 eax, DWORD PTR [eax]
  000e5	89 45 a8	 mov	 DWORD PTR __Old_val$6[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  000e8	8b 45 f0	 mov	 eax, DWORD PTR __Val$[ebp]
  000eb	8b 4d ac	 mov	 ecx, DWORD PTR $T7[ebp]
  000ee	89 08		 mov	 DWORD PTR [eax], ecx

; 600  :     return _Old_val;

  000f0	8b 45 a8	 mov	 eax, DWORD PTR __Old_val$6[ebp]
  000f3	89 45 a4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1048 :         return _STD exchange(_Ptr, nullptr);

  000f6	8b 45 a4	 mov	 eax, DWORD PTR $T5[ebp]
  000f9	89 45 a0	 mov	 DWORD PTR __Inserted$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 184  :         const auto _Inserted = _Tree_temp_node<_Alnode>(_Mybase::_Getal(), _Scary->_Myhead, piecewise_construct,

  000fc	8d 4d 80	 lea	 ecx, DWORD PTR $T1[ebp]
  000ff	e8 00 00 00 00	 call	 ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >

; 190  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00104	ff 75 a0	 push	 DWORD PTR __Inserted$[ebp]
  00107	ff 75 8c	 push	 DWORD PTR __Loc$[ebp+4]
  0010a	ff 75 88	 push	 DWORD PTR __Loc$[ebp]
  0010d	8b 4d ec	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00110	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Insert_node
  00115	89 45 9c	 mov	 DWORD PTR $T4[ebp], eax
  00118	c6 45 fe 01	 mov	 BYTE PTR $T24[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0011c	8d 45 9c	 lea	 eax, DWORD PTR $T4[ebp]
  0011f	89 45 98	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00122	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00125	8b 4d 98	 mov	 ecx, DWORD PTR $T3[ebp]
  00128	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0012a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0012c	8d 45 fe	 lea	 eax, DWORD PTR $T24[ebp]
  0012f	89 45 94	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00132	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00135	8b 4d 94	 mov	 ecx, DWORD PTR $T2[ebp]
  00138	8a 09		 mov	 cl, BYTE PTR [ecx]
  0013a	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 190  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0013d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Try_emplac:

; 191  :     }

  00140	c9		 leave
  00141	c2 08 00	 ret	 8
??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Const_cast@$$CBUTSignalPoint@CPythonMiniMap@@@std@@YAPAUTSignalPoint@CPythonMiniMap@@PBU12@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Const_cast@$$CBUTSignalPoint@CPythonMiniMap@@@std@@YAPAUTSignalPoint@CPythonMiniMap@@PBU12@@Z PROC ; std::_Const_cast<CPythonMiniMap::TSignalPoint const >, COMDAT

; 292  : auto _Const_cast(_Ty* _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 293  :     return const_cast<remove_const_t<_Ty>*>(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 294  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Const_cast@$$CBUTSignalPoint@CPythonMiniMap@@@std@@YAPAUTSignalPoint@CPythonMiniMap@@PBU12@@Z ENDP ; std::_Const_cast<CPythonMiniMap::TSignalPoint const >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEPAXI@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 18	 add	 ecx, 24			; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0000d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001d	83 e0 01	 and	 eax, 1
  00020	74 0c		 je	 SHORT $LN2@scalar
  00022	6a 24		 push	 36			; 00000024H
  00024	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002c	59		 pop	 ecx
  0002d	59		 pop	 ecx
$LN2@scalar:
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c9		 leave
  00032	c2 04 00	 ret	 4
??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEPAXI@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
;	COMDAT ??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, COMDAT
; _this$ = ecx

; 107  :     map() : _Mybase(key_compare()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00008	8d 45 ff	 lea	 eax, DWORD PTR $T1[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
  00014	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c9		 leave
  00018	c3		 ret	 0
??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Parent_sibling$1 = -20				; size = 4
__Parent_sibling$2 = -16				; size = 4
_this$ = -12						; size = 4
__Head$ = -8						; size = 4
__Pnode$3 = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Insert_node, COMDAT
; _this$ = ecx

; 644  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 645  :         ++_Mysize;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	40		 inc	 eax
  00010	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 646  :         const auto _Head  = _Myhead;

  00016	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 00		 mov	 eax, DWORD PTR [eax]
  0001b	89 45 f8	 mov	 DWORD PTR __Head$[ebp], eax

; 647  :         _Newnode->_Parent = _Loc._Parent;

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00024	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 648  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  00027	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  0002a	3b 45 f8	 cmp	 eax, DWORD PTR __Head$[ebp]
  0002d	75 29		 jne	 SHORT $LN5@Insert_nod

; 649  :             _Head->_Left     = _Newnode;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00035	89 08		 mov	 DWORD PTR [eax], ecx

; 650  :             _Head->_Parent   = _Newnode;

  00037	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0003a	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 651  :             _Head->_Right    = _Newnode;

  00040	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00043	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00046	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 652  :             _Newnode->_Color = _Black; // the root is black

  00049	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0004c	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 653  :             return _Newnode;

  00050	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00053	e9 a3 01 00 00	 jmp	 $LN18@Insert_nod
$LN5@Insert_nod:

; 654  :         }
; 655  : 
; 656  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 657  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00058	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  0005c	75 1f		 jne	 SHORT $LN6@Insert_nod

; 658  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 659  :             _Loc._Parent->_Right = _Newnode;

  0005e	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00061	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00064	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 660  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  00067	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0006d	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00070	75 09		 jne	 SHORT $LN8@Insert_nod

; 661  :                 _Head->_Right = _Newnode;

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00075	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00078	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN8@Insert_nod:

; 662  :             }
; 663  :         } else { // add to left of _Loc._Parent

  0007b	eb 1a		 jmp	 SHORT $LN7@Insert_nod
$LN6@Insert_nod:

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 665  :             _Loc._Parent->_Left = _Newnode;

  0007d	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00080	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00083	89 08		 mov	 DWORD PTR [eax], ecx

; 666  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00085	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0008b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0008d	75 08		 jne	 SHORT $LN7@Insert_nod

; 667  :                 _Head->_Left = _Newnode;

  0008f	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00092	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00097	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0009a	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax
$LN4@Insert_nod:
  0009d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000a0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a3	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  000a7	85 c0		 test	 eax, eax
  000a9	0f 85 3f 01 00
	00		 jne	 $LN3@Insert_nod

; 672  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  000af	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000b2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  000bb	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000be	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000c0	0f 85 95 00 00
	00		 jne	 $LN10@Insert_nod

; 673  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  000c6	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000c9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cf	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000d2	89 45 f0	 mov	 DWORD PTR __Parent_sibling$2[ebp], eax

; 674  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  000d5	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000d8	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  000dc	85 c0		 test	 eax, eax
  000de	75 2c		 jne	 SHORT $LN12@Insert_nod

; 675  :                     _Pnode->_Parent->_Color          = _Black;

  000e0	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000e3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000e6	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 676  :                     _Parent_sibling->_Color          = _Black;

  000ea	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000ed	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 677  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000f1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000f4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000fa	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 678  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  000fe	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00101	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00104	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00107	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 679  :                 } else { // parent's sibling has red and black children

  0010a	eb 4a		 jmp	 SHORT $LN13@Insert_nod
$LN12@Insert_nod:

; 680  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  0010c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0010f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00112	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  00115	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00118	75 14		 jne	 SHORT $LN14@Insert_nod

; 681  :                         _Pnode = _Pnode->_Parent;

  0011a	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0011d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00120	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 682  :                         _Lrotate(_Pnode);

  00123	ff 75 fc	 push	 DWORD PTR __Pnode$3[ebp]
  00126	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Lrotate
$LN14@Insert_nod:

; 683  :                     }
; 684  : 
; 685  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  0012e	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00131	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00134	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 686  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00138	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0013b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 687  :                     _Rrotate(_Pnode->_Parent->_Parent);

  00145	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00148	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0014b	ff 70 04	 push	 DWORD PTR [eax+4]
  0014e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00151	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Rrotate
$LN13@Insert_nod:

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  00156	e9 8e 00 00 00	 jmp	 $LN11@Insert_nod
$LN10@Insert_nod:

; 690  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;

  0015b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0015e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00161	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00164	8b 00		 mov	 eax, DWORD PTR [eax]
  00166	89 45 ec	 mov	 DWORD PTR __Parent_sibling$1[ebp], eax

; 691  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00169	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  0016c	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  00170	85 c0		 test	 eax, eax
  00172	75 2c		 jne	 SHORT $LN15@Insert_nod

; 692  :                     _Pnode->_Parent->_Color          = _Black;

  00174	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00177	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0017a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 693  :                     _Parent_sibling->_Color          = _Black;

  0017e	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  00181	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 694  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00185	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00188	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 695  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  00192	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00195	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00198	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019b	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 696  :                 } else { // parent's sibling has red and black children

  0019e	eb 49		 jmp	 SHORT $LN11@Insert_nod
$LN15@Insert_nod:

; 697  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  001a0	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001a3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a6	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  001a9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001ab	75 14		 jne	 SHORT $LN17@Insert_nod

; 698  :                         _Pnode = _Pnode->_Parent;

  001ad	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001b0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001b3	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 699  :                         _Rrotate(_Pnode);

  001b6	ff 75 fc	 push	 DWORD PTR __Pnode$3[ebp]
  001b9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001bc	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Rrotate
$LN17@Insert_nod:

; 700  :                     }
; 701  : 
; 702  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  001c1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001c4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001c7	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 703  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  001cb	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001ce	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d4	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 704  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001d8	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001db	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001de	ff 70 04	 push	 DWORD PTR [eax+4]
  001e1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001e4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Lrotate
$LN11@Insert_nod:

; 705  :                 }
; 706  :             }
; 707  :         }

  001e9	e9 af fe ff ff	 jmp	 $LN4@Insert_nod
$LN3@Insert_nod:

; 708  : 
; 709  :         _Head->_Parent->_Color = _Black; // root is always black

  001ee	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  001f1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001f4	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 710  :         return _Newnode;

  001f8	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
$LN18@Insert_nod:

; 711  :     }

  001fb	c9		 leave
  001fc	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Rrotate, COMDAT
; _this$ = ecx

; 480  :     void _Rrotate(_Nodeptr _Wherenode) noexcept { // promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00013	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00016	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00019	89 08		 mov	 DWORD PTR [eax], ecx

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 0c		 jne	 SHORT $LN2@Rrotate

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00032	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Rrotate:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  00035	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00049	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004c	75 0d		 jne	 SHORT $LN3@Rrotate

; 491  :             _Myhead->_Parent = _Pnode;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00056	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00059	eb 27		 jmp	 SHORT $LN4@Rrotate
$LN3@Rrotate:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  0005b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00061	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00064	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00067	75 0e		 jne	 SHORT $LN5@Rrotate

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  00069	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00072	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 494  :         } else {

  00075	eb 0b		 jmp	 SHORT $LN4@Rrotate
$LN5@Rrotate:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  00077	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0007a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00080	89 08		 mov	 DWORD PTR [eax], ecx
$LN4@Rrotate:

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  00082	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00085	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00088	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 499  :         _Wherenode->_Parent = _Pnode;

  0008b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00091	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 500  :     }

  00094	c9		 leave
  00095	c2 04 00	 ret	 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Lrotate, COMDAT
; _this$ = ecx

; 458  :     void _Lrotate(_Nodeptr _Wherenode) noexcept { // promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 459  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000e	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  00011	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00014	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00017	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 0b		 jne	 SHORT $LN2@Lrotate

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00031	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Lrotate:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00037	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 00		 mov	 eax, DWORD PTR [eax]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00048	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004b	75 0d		 jne	 SHORT $LN3@Lrotate

; 469  :             _Myhead->_Parent = _Pnode;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 00		 mov	 eax, DWORD PTR [eax]
  00052	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00055	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00058	eb 26		 jmp	 SHORT $LN4@Lrotate
$LN3@Lrotate:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00063	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00065	75 0d		 jne	 SHORT $LN5@Lrotate

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  00067	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00070	89 08		 mov	 DWORD PTR [eax], ecx

; 472  :         } else {

  00072	eb 0c		 jmp	 SHORT $LN4@Lrotate
$LN5@Lrotate:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  00074	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00077	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0007d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN4@Lrotate:

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;

  00080	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00083	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00086	89 08		 mov	 DWORD PTR [eax], ecx

; 477  :         _Wherenode->_Parent = _Pnode;

  00088	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0008e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 478  :     }

  00091	c9		 leave
  00092	c2 04 00	 ret	 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -28					; size = 4
__Scary$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
_$S17$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 2017 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 e8	 mov	 DWORD PTR __Scary$[ebp], eax

; 2018 :         const auto _Scary = _Get_scary();
; 2019 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00015	8d 45 ff	 lea	 eax, DWORD PTR _$S17$[ebp]
  00018	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0001e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00021	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax

; 2020 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 2021 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00027	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0002a	e8 00 00 00 00	 call	 ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
  0002f	59		 pop	 ecx
  00030	8b 4d e8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00033	89 01		 mov	 DWORD PTR [ecx], eax

; 2022 :         _Proxy._Release();
; 2023 :     }

  00035	c9		 leave
  00036	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Check_grow_by_1, COMDAT
; _this$ = ecx

; 1718 :     void _Check_grow_by_1() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1719 :         if (max_size() == _Get_scary()->_Mysize) {

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::max_size
  0001d	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00020	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00023	75 05		 jne	 SHORT $LN3@Check_grow

; 1720 :             _Throw_tree_length_error();

  00025	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN3@Check_grow:

; 1721 :         }
; 1722 :     }

  0002a	c9		 leave
  0002b	c3		 ret	 0
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Check_grow_by_1
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
___param0$ = -12					; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find, COMDAT
; _this$ = ecx

; 1467 :     _NODISCARD iterator find(const key_type& _Keyval) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 1468 :         return iterator(_Find(_Keyval), _Get_scary());

  00015	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00020	89 45 f4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00026	8b 4d f4	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00029	89 08		 mov	 DWORD PTR [eax], ecx

; 1468 :         return iterator(_Find(_Keyval), _Get_scary());

  0002b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1469 :     }

  0002e	c9		 leave
  0002f	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
tv68 = -12						; size = 4
$T6 = -8						; size = 4
$T7 = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::max_size, COMDAT
; _this$ = ecx

; 1310 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2043 :         return _Mypair._Myval2._Get_first();

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2043 :         return _Mypair._Myval2._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	c7 45 fc c4 4e
	ec 04		 mov	 DWORD PTR $T7[ebp], 82595524 ; 04ec4ec4H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0001c	c7 45 e8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1311 :         return (_STD min)(

  00023	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00026	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00029	8b 45 fc	 mov	 eax, DWORD PTR $T7[ebp]
  0002c	3b 45 f8	 cmp	 eax, DWORD PTR $T6[ebp]
  0002f	73 08		 jae	 SHORT $LN17@max_size
  00031	8d 45 fc	 lea	 eax, DWORD PTR $T7[ebp]
  00034	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
  00037	eb 06		 jmp	 SHORT $LN18@max_size
$LN17@max_size:
  00039	8d 45 f8	 lea	 eax, DWORD PTR $T6[ebp]
  0003c	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
$LN18@max_size:
  0003f	8b 45 f4	 mov	 eax, DWORD PTR tv68[ebp]
  00042	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  00045	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00048	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1311 :         return (_STD min)(

  0004b	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1312 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1313 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___param0$ = -16					; size = 4
__Scary$ = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::end, COMDAT
; _this$ = ecx

; 1248 :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Scary$[ebp], eax

; 1249 :         const auto _Scary = _Get_scary();
; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00015	8b 45 f4	 mov	 eax, DWORD PTR __Scary$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00020	8b 4d f0	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx

; 1249 :         const auto _Scary = _Get_scary();
; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00025	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1251 :     }

  00028	c9		 leave
  00029	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Scary$ = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >, COMDAT
; _this$ = ecx

; 1189 :     ~_Tree() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Scary$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00021	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	ff 70 04	 push	 DWORD PTR [eax+4]
  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >

; 753  :         _Alnode::value_type::_Freenode0(_Al, _Myhead);

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00037	ff 30		 push	 DWORD PTR [eax]
  00039	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 1190 :         const auto _Scary = _Get_scary();
; 1191 :         _Scary->_Erase_head(_Getal());
; 1192 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1193 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1194 :         _Delete_plain_internal(_Alproxy, _Scary->_Myproxy);
; 1195 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1196 :     }

  00043	c9		 leave
  00044	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
$T1 = -20						; size = 4
_this$2 = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T3 = -1						; size = 1
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >, COMDAT
; _this$ = ecx

; 885  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0000f	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  00012	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00015	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00018	8a 00		 mov	 al, BYTE PTR [eax]
  0001a	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al
  0001d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00020	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00023	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00029	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  0002c	83 20 00	 and	 DWORD PTR [eax], 0
  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  00032	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 886  :         _Alloc_sentinel_and_proxy();

  00036	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Alloc_sentinel_and_proxy

; 887  :     }

  0003e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	c9		 leave
  00042	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z
_TEXT	SEGMENT
$T1 = -28						; size = 1
tv86 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
__Left_size$ = -12					; size = 4
__Right_size$ = -8					; size = 4
$T4 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4480 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	83 65 f0 00	 and	 DWORD PTR $T3[ebp], 0

; 3770 :         return _Mypair._Myval2._Mysize;

  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  0000d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00010	89 45 f4	 mov	 DWORD PTR __Left_size$[ebp], eax

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00013	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  00016	e8 00 00 00 00	 call	 _strlen
  0001b	59		 pop	 ecx
  0001c	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  0001f	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00022	89 45 f8	 mov	 DWORD PTR __Right_size$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4484 :     if (_Left.max_size() - _Left_size < _Right_size) {

  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00028	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0002d	2b 45 f4	 sub	 eax, DWORD PTR __Left_size$[ebp]
  00030	3b 45 f8	 cmp	 eax, DWORD PTR __Right_size$[ebp]
  00033	73 05		 jae	 SHORT $LN2@operator

; 4485 :         _Xlen_string();

  00035	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@operator:

; 4486 :     }
; 4487 : 
; 4488 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

  0003a	8a 45 ff	 mov	 al, BYTE PTR $T4[ebp]
  0003d	88 45 e4	 mov	 BYTE PTR $T1[ebp], al
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00043	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00048	89 45 e8	 mov	 DWORD PTR tv86[ebp], eax
  0004b	ff 75 f8	 push	 DWORD PTR __Right_size$[ebp]
  0004e	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  00051	ff 75 f4	 push	 DWORD PTR __Left_size$[ebp]
  00054	ff 75 e8	 push	 DWORD PTR tv86[ebp]
  00057	ff 75 0c	 push	 DWORD PTR __Left$[ebp]
  0005a	ff 75 e4	 push	 DWORD PTR $T1[ebp]
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00060	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00065	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00068	83 c8 01	 or	 eax, 1
  0006b	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  0006e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@operator:

; 4489 : }

  00071	c9		 leave
  00072	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Eqrange@K@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IBE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@PAU12@@1@ABK@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
__Comp$ = -64						; size = 4
$T2 = -60						; size = 4
$T3 = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
$T6 = -44						; size = 4
__Lonode$ = -40						; size = 4
tv91 = -36						; size = 4
tv133 = -32						; size = 4
tv81 = -28						; size = 4
__Nodekey$7 = -24					; size = 4
tv66 = -20						; size = 4
_this$ = -16						; size = 4
__Scary$ = -12						; size = 4
__Hinode$ = -8						; size = 4
__Pnode$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Eqrange@K@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IBE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@PAU12@@1@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Eqrange<unsigned long>, COMDAT
; _this$ = ecx

; 1783 :         noexcept(_Nothrow_compare<key_compare, key_type, _Other>&& _Nothrow_compare<key_compare, _Other, key_type>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 d4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 d4	 mov	 eax, DWORD PTR $T6[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Scary$[ebp], eax

; 2035 :         return _Mypair._Get_first();

  00015	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00018	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0001b	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  0001e	89 45 c0	 mov	 DWORD PTR __Comp$[ebp], eax

; 1784 :         // find range of nodes equivalent to _Keyval
; 1785 :         const auto _Scary = _Get_scary();
; 1786 :         const auto& _Comp = _Getcomp();
; 1787 :         _Nodeptr _Pnode   = _Scary->_Myhead->_Parent;

  00021	8b 45 f4	 mov	 eax, DWORD PTR __Scary$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1788 :         _Nodeptr _Lonode  = _Scary->_Myhead; // end() if search fails

  0002c	8b 45 f4	 mov	 eax, DWORD PTR __Scary$[ebp]
  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	89 45 d8	 mov	 DWORD PTR __Lonode$[ebp], eax

; 1789 :         _Nodeptr _Hinode  = _Scary->_Myhead; // end() if search fails

  00034	8b 45 f4	 mov	 eax, DWORD PTR __Scary$[ebp]
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	89 45 f8	 mov	 DWORD PTR __Hinode$[ebp], eax
$LN2@Eqrange:

; 1790 : 
; 1791 :         while (!_Pnode->_Isnil) {

  0003c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0003f	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00043	85 c0		 test	 eax, eax
  00045	75 7a		 jne	 SHORT $LN3@Eqrange
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 69   :         return _Val.first;

  00047	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0004a	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1792 :             const auto& _Nodekey = _Traits::_Kfn(_Pnode->_Myval);

  0004d	89 45 e8	 mov	 DWORD PTR __Nodekey$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00050	8b 45 e8	 mov	 eax, DWORD PTR __Nodekey$7[ebp]
  00053	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00056	8b 00		 mov	 eax, DWORD PTR [eax]
  00058	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0005a	73 09		 jae	 SHORT $LN30@Eqrange
  0005c	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00063	eb 04		 jmp	 SHORT $LN28@Eqrange
$LN30@Eqrange:
  00065	83 65 ec 00	 and	 DWORD PTR tv66[ebp], 0
$LN28@Eqrange:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1793 :             if (_DEBUG_LT_PRED(_Comp, _Nodekey, _Keyval)) {

  00069	0f b6 45 ec	 movzx	 eax, BYTE PTR tv66[ebp]
  0006d	85 c0		 test	 eax, eax
  0006f	74 0b		 je	 SHORT $LN6@Eqrange

; 1794 :                 _Pnode = _Pnode->_Right; // descend right subtree

  00071	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00074	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00077	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1795 :             } else { // _Pnode not less than _Keyval, remember it

  0007a	eb 40		 jmp	 SHORT $LN7@Eqrange
$LN6@Eqrange:

; 1796 :                 if (_Hinode->_Isnil && _DEBUG_LT_PRED(_Comp, _Keyval, _Nodekey)) {

  0007c	8b 45 f8	 mov	 eax, DWORD PTR __Hinode$[ebp]
  0007f	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00083	85 c0		 test	 eax, eax
  00085	74 27		 je	 SHORT $LN8@Eqrange
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00087	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0008a	8b 4d e8	 mov	 ecx, DWORD PTR __Nodekey$7[ebp]
  0008d	8b 00		 mov	 eax, DWORD PTR [eax]
  0008f	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00091	73 09		 jae	 SHORT $LN34@Eqrange
  00093	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv81[ebp], 1
  0009a	eb 04		 jmp	 SHORT $LN32@Eqrange
$LN34@Eqrange:
  0009c	83 65 e4 00	 and	 DWORD PTR tv81[ebp], 0
$LN32@Eqrange:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1796 :                 if (_Hinode->_Isnil && _DEBUG_LT_PRED(_Comp, _Keyval, _Nodekey)) {

  000a0	0f b6 45 e4	 movzx	 eax, BYTE PTR tv81[ebp]
  000a4	85 c0		 test	 eax, eax
  000a6	74 06		 je	 SHORT $LN8@Eqrange

; 1797 :                     _Hinode = _Pnode; // _Pnode greater, remember it

  000a8	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000ab	89 45 f8	 mov	 DWORD PTR __Hinode$[ebp], eax
$LN8@Eqrange:

; 1798 :                 }
; 1799 : 
; 1800 :                 _Lonode = _Pnode;

  000ae	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000b1	89 45 d8	 mov	 DWORD PTR __Lonode$[ebp], eax

; 1801 :                 _Pnode  = _Pnode->_Left; // descend left subtree

  000b4	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000b7	8b 00		 mov	 eax, DWORD PTR [eax]
  000b9	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN7@Eqrange:

; 1802 :             }
; 1803 :         }

  000bc	e9 7b ff ff ff	 jmp	 $LN2@Eqrange
$LN3@Eqrange:

; 1804 : 
; 1805 :         _Pnode = _Hinode->_Isnil ? _Scary->_Myhead->_Parent : _Hinode->_Left; // continue scan for upper bound

  000c1	8b 45 f8	 mov	 eax, DWORD PTR __Hinode$[ebp]
  000c4	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  000c8	85 c0		 test	 eax, eax
  000ca	74 0d		 je	 SHORT $LN12@Eqrange
  000cc	8b 45 f4	 mov	 eax, DWORD PTR __Scary$[ebp]
  000cf	8b 00		 mov	 eax, DWORD PTR [eax]
  000d1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d4	89 45 e0	 mov	 DWORD PTR tv133[ebp], eax
  000d7	eb 08		 jmp	 SHORT $LN13@Eqrange
$LN12@Eqrange:
  000d9	8b 45 f8	 mov	 eax, DWORD PTR __Hinode$[ebp]
  000dc	8b 00		 mov	 eax, DWORD PTR [eax]
  000de	89 45 e0	 mov	 DWORD PTR tv133[ebp], eax
$LN13@Eqrange:
  000e1	8b 45 e0	 mov	 eax, DWORD PTR tv133[ebp]
  000e4	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN4@Eqrange:

; 1806 :         while (!_Pnode->_Isnil) {

  000e7	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000ea	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  000ee	85 c0		 test	 eax, eax
  000f0	75 49		 jne	 SHORT $LN5@Eqrange

; 2035 :         return _Mypair._Get_first();

  000f2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  000f5	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  000f8	8b 45 cc	 mov	 eax, DWORD PTR $T4[ebp]
  000fb	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  000fe	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00101	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00104	8b 00		 mov	 eax, DWORD PTR [eax]
  00106	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  00109	73 09		 jae	 SHORT $LN46@Eqrange
  0010b	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv91[ebp], 1
  00112	eb 04		 jmp	 SHORT $LN44@Eqrange
$LN46@Eqrange:
  00114	83 65 dc 00	 and	 DWORD PTR tv91[ebp], 0
$LN44@Eqrange:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1807 :             if (_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Pnode->_Myval))) {

  00118	0f b6 45 dc	 movzx	 eax, BYTE PTR tv91[ebp]
  0011c	85 c0		 test	 eax, eax
  0011e	74 10		 je	 SHORT $LN9@Eqrange

; 1808 :                 // _Pnode greater than _Keyval, remember it
; 1809 :                 _Hinode = _Pnode;

  00120	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00123	89 45 f8	 mov	 DWORD PTR __Hinode$[ebp], eax

; 1810 :                 _Pnode  = _Pnode->_Left; // descend left subtree

  00126	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00129	8b 00		 mov	 eax, DWORD PTR [eax]
  0012b	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1811 :             } else {

  0012e	eb 09		 jmp	 SHORT $LN10@Eqrange
$LN9@Eqrange:

; 1812 :                 _Pnode = _Pnode->_Right; // descend right subtree

  00130	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00133	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00136	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN10@Eqrange:

; 1813 :             }
; 1814 :         }

  00139	eb ac		 jmp	 SHORT $LN4@Eqrange
$LN5@Eqrange:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013b	8d 45 d8	 lea	 eax, DWORD PTR __Lonode$[ebp]
  0013e	89 45 c8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00141	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00144	8b 4d c8	 mov	 ecx, DWORD PTR $T3[ebp]
  00147	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00149	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0014b	8d 45 f8	 lea	 eax, DWORD PTR __Hinode$[ebp]
  0014e	89 45 c4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00151	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00154	8b 4d c4	 mov	 ecx, DWORD PTR $T2[ebp]
  00157	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00159	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1816 :         return {_Lonode, _Hinode};

  0015c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1817 :     }

  0015f	c9		 leave
  00160	c2 08 00	 ret	 8
??$_Eqrange@K@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IBE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@PAU12@@1@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Eqrange<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z
_TEXT	SEGMENT
__Result$ = -40						; size = 8
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
___param0$ = -16					; size = 4
$T5 = -12						; size = 4
$T6 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::insert<0,0>, COMDAT
; _this$ = ecx

; 1343 :     pair<iterator, bool> insert(value_type&& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1344 :         const auto _Result = _Emplace(_STD move(_Val));

  0000f	ff 75 f8	 push	 DWORD PTR $T6[ebp]
  00012	8d 45 d8	 lea	 eax, DWORD PTR __Result$[ebp]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??$_Emplace@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Emplace<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00021	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00024	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00027	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax

; 1345 :         return {iterator(_Result.first, _Get_scary()), _Result.second};

  0002a	8b 45 d8	 mov	 eax, DWORD PTR __Result$[ebp]
  0002d	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00030	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00033	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00036	8d 45 ec	 lea	 eax, DWORD PTR $T4[ebp]
  00039	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0003c	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00044	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00046	8d 45 dc	 lea	 eax, DWORD PTR __Result$[ebp+4]
  00049	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0004c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0004f	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  00052	8a 09		 mov	 cl, BYTE PTR [ecx]
  00054	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1345 :         return {iterator(_Result.first, _Get_scary()), _Result.second};

  00057	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1346 :     }

  0005a	c9		 leave
  0005b	c2 08 00	 ret	 8
??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::insert<0,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Pnode$ = -12						; size = 4
__Pnode$2 = -8						; size = 4
_this$ = -4						; size = 4
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 51   :     _Tree_unchecked_const_iterator& operator++() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 52   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00011	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00015	85 c0		 test	 eax, eax
  00017	74 37		 je	 SHORT $LN4@operator
$LN2@operator:

; 53   :             _Nodeptr _Pnode;
; 54   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00021	89 45 f8	 mov	 DWORD PTR __Pnode$2[ebp], eax
  00024	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$2[ebp]
  00027	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  0002b	85 c0		 test	 eax, eax
  0002d	75 17		 jne	 SHORT $LN3@operator
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$2[ebp]
  00035	8b 00		 mov	 eax, DWORD PTR [eax]
  00037	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0003a	75 0a		 jne	 SHORT $LN3@operator

; 55   :                 _Ptr = _Pnode; // ==> parent while right subtree

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$2[ebp]
  00042	89 08		 mov	 DWORD PTR [eax], ecx

; 56   :             }

  00044	eb d3		 jmp	 SHORT $LN2@operator
$LN3@operator:

; 57   : 
; 58   :             _Ptr = _Pnode; // ==> parent (head if end())

  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$2[ebp]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx

; 59   :         } else {

  0004e	eb 30		 jmp	 SHORT $LN5@operator
$LN4@operator:

; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 00		 mov	 eax, DWORD PTR [eax]
  00055	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00058	89 45 f4	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN8@operator:

; 451  :         while (!_Pnode->_Left->_Isnil) {

  0005b	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005e	8b 00		 mov	 eax, DWORD PTR [eax]
  00060	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00064	85 c0		 test	 eax, eax
  00066	75 0a		 jne	 SHORT $LN9@operator

; 452  :             _Pnode = _Pnode->_Left;

  00068	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0006b	8b 00		 mov	 eax, DWORD PTR [eax]
  0006d	89 45 f4	 mov	 DWORD PTR __Pnode$[ebp], eax

; 453  :         }

  00070	eb e9		 jmp	 SHORT $LN8@operator
$LN9@operator:

; 454  : 
; 455  :         return _Pnode;

  00072	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00075	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  00078	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0007e	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@operator:

; 61   :         }
; 62   : 
; 63   :         return *this;

  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 64   :     }

  00083	c9		 leave
  00084	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCInstanceBase@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Pnode$ = -12						; size = 4
__Pnode$2 = -8						; size = 4
_this$ = -4						; size = 4
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCInstanceBase@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CInstanceBase *> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 51   :     _Tree_unchecked_const_iterator& operator++() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 52   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00011	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00015	85 c0		 test	 eax, eax
  00017	74 37		 je	 SHORT $LN4@operator
$LN2@operator:

; 53   :             _Nodeptr _Pnode;
; 54   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00021	89 45 f8	 mov	 DWORD PTR __Pnode$2[ebp], eax
  00024	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$2[ebp]
  00027	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  0002b	85 c0		 test	 eax, eax
  0002d	75 17		 jne	 SHORT $LN3@operator
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$2[ebp]
  00035	8b 00		 mov	 eax, DWORD PTR [eax]
  00037	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0003a	75 0a		 jne	 SHORT $LN3@operator

; 55   :                 _Ptr = _Pnode; // ==> parent while right subtree

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$2[ebp]
  00042	89 08		 mov	 DWORD PTR [eax], ecx

; 56   :             }

  00044	eb d3		 jmp	 SHORT $LN2@operator
$LN3@operator:

; 57   : 
; 58   :             _Ptr = _Pnode; // ==> parent (head if end())

  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$2[ebp]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx

; 59   :         } else {

  0004e	eb 30		 jmp	 SHORT $LN5@operator
$LN4@operator:

; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 00		 mov	 eax, DWORD PTR [eax]
  00055	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00058	89 45 f4	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN8@operator:

; 451  :         while (!_Pnode->_Left->_Isnil) {

  0005b	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005e	8b 00		 mov	 eax, DWORD PTR [eax]
  00060	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00064	85 c0		 test	 eax, eax
  00066	75 0a		 jne	 SHORT $LN9@operator

; 452  :             _Pnode = _Pnode->_Left;

  00068	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0006b	8b 00		 mov	 eax, DWORD PTR [eax]
  0006d	89 45 f4	 mov	 DWORD PTR __Pnode$[ebp], eax

; 453  :         }

  00070	eb e9		 jmp	 SHORT $LN8@operator
$LN9@operator:

; 454  : 
; 455  :         return _Pnode;

  00072	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00075	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  00078	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0007e	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@operator:

; 61   :         }
; 62   : 
; 63   :         return *this;

  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 64   :     }

  00083	c9		 leave
  00084	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCInstanceBase@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CInstanceBase *> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCInstanceBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCInstanceBase@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCInstanceBase@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___param0$ = -16					; size = 4
__Scary$ = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCInstanceBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCInstanceBase@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCInstanceBase@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CInstanceBase *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CInstanceBase *> >,0> >::end, COMDAT
; _this$ = ecx

; 1248 :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Scary$[ebp], eax

; 1249 :         const auto _Scary = _Get_scary();
; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00015	8b 45 f4	 mov	 eax, DWORD PTR __Scary$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00020	8b 4d f0	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx

; 1249 :         const auto _Scary = _Get_scary();
; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00025	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1251 :     }

  00028	c9		 leave
  00029	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCInstanceBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCInstanceBase@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCInstanceBase@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CInstanceBase *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CInstanceBase *> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCInstanceBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCInstanceBase@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCInstanceBase@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___param0$ = -16					; size = 4
__Scary$ = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVCInstanceBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCInstanceBase@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCInstanceBase@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CInstanceBase *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CInstanceBase *> >,0> >::begin, COMDAT
; _this$ = ecx

; 1238 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Scary$[ebp], eax

; 1239 :         const auto _Scary = _Get_scary();
; 1240 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00015	8b 45 f4	 mov	 eax, DWORD PTR __Scary$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00022	8b 4d f0	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00025	89 08		 mov	 DWORD PTR [eax], ecx

; 1239 :         const auto _Scary = _Get_scary();
; 1240 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00027	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1241 :     }

  0002a	c9		 leave
  0002b	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVCInstanceBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCInstanceBase@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCInstanceBase@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CInstanceBase *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CInstanceBase *> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCPythonMiniMap@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCPythonMiniMap@@UAEPAXI@Z PROC			; CPythonMiniMap::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CPythonMiniMap@@UAE@XZ ; CPythonMiniMap::~CPythonMiniMap
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0f		 je	 SHORT $LN2@scalar
  00017	68 38 0c 00 00	 push	 3128			; 00000c38H
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_GCPythonMiniMap@@UAEPAXI@Z ENDP			; CPythonMiniMap::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@CAXXZ PROC ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@CAXXZ ENDP ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@AAEXXZ PROC ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 75		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@YAXPAUTSignalPoint@CPythonMiniMap@@QAU12@AAV?$allocator@UTSignalPoint@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TSignalPoint> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 0c		 push	 12			; 0000000cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00098	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009b	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009e	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a1	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a4	c9		 leave
  000a5	c3		 ret	 0
?_Tidy@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@AAEXXZ ENDP ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@AAEXQAUTSignalPoint@CPythonMiniMap@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@AAEXQAUTSignalPoint@CPythonMiniMap@@II@Z PROC ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 63		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@YAXPAUTSignalPoint@CPythonMiniMap@@QAU12@AAV?$allocator@UTSignalPoint@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TSignalPoint> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 0c		 push	 12			; 0000000cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00098	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  0009a	6b 45 0c 0c	 imul	 eax, DWORD PTR __Newsize$[ebp], 12
  0009e	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000a1	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a4	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a6	6b 45 10 0c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 12
  000aa	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b0	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b2	c9		 leave
  000b3	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@AAEXQAUTSignalPoint@CPythonMiniMap@@II@Z ENDP ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@ABEII@Z PROC ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	99		 cdq
  0001b	6a 0c		 push	 12			; 0000000cH
  0001d	59		 pop	 ecx
  0001e	f7 f9		 idiv	 ecx
  00020	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00023	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00026	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00029	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  0002c	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002f	c7 45 f0 55 55
	55 15		 mov	 DWORD PTR $T7[ebp], 357913941 ; 15555555H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00036	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003d	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  00040	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00043	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00046	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00049	73 08		 jae	 SHORT $LN25@Calculate_
  0004b	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  00051	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00053	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00056	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  0005c	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00062	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00065	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006d	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00070	d1 e8		 shr	 eax, 1
  00072	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00075	2b c8		 sub	 ecx, eax
  00077	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  0007a	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  0007c	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007f	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00081	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00084	d1 e8		 shr	 eax, 1
  00086	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00089	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  0008c	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008f	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00092	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00094	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00097	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00099	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  0009c	c9		 leave
  0009d	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@ABEII@Z ENDP ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@AAEXPAUTSignalPoint@CPythonMiniMap@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@AAEXPAUTSignalPoint@CPythonMiniMap@@0@Z PROC ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@YAXPAUTSignalPoint@CPythonMiniMap@@QAU12@AAV?$allocator@UTSignalPoint@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TSignalPoint> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@AAEXPAUTSignalPoint@CPythonMiniMap@@0@Z ENDP ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEXXZ PROC ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@YAXPAUTSignalPoint@CPythonMiniMap@@QAU12@AAV?$allocator@UTSignalPoint@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TSignalPoint> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEXXZ ENDP ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAE@XZ PROC ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::~vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@AAEXXZ ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAE@XZ ENDP ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::~vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@QAEXQAUTSignalPoint@CPythonMiniMap@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@QAEXQAUTSignalPoint@CPythonMiniMap@@I@Z PROC ; std::allocator<CPythonMiniMap::TSignalPoint>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	6b 45 0c 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx

; 811  :     }

  00016	c9		 leave
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@QAEXQAUTSignalPoint@CPythonMiniMap@@I@Z ENDP ; std::allocator<CPythonMiniMap::TSignalPoint>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@@std@@QAE@PAUTAtlasMarkInfo@CPythonMiniMap@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@@std@@QAE@PAUTAtlasMarkInfo@CPythonMiniMap@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPythonMiniMap::TAtlasMarkInfo> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPythonMiniMap::TAtlasMarkInfo> > >, COMDAT
; _this$ = ecx

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 43   :         this->_Adopt(_Pvector);
; 44   :     }

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c9		 leave
  00013	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@@std@@QAE@PAUTAtlasMarkInfo@CPythonMiniMap@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPythonMiniMap::TAtlasMarkInfo> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPythonMiniMap::TAtlasMarkInfo> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@CAXXZ PROC ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@CAXXZ ENDP ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@AAEXXZ PROC ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 75		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@YAXPAUTGuildAreaInfo@CPythonMiniMap@@QAU12@AAV?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TGuildAreaInfo> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 24		 push	 36			; 00000024H
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 24	 imul	 eax, DWORD PTR __Count$[ebp], 36
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00098	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009b	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009e	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a1	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a4	c9		 leave
  000a5	c3		 ret	 0
?_Tidy@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@AAEXXZ ENDP ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@AAEXQAUTGuildAreaInfo@CPythonMiniMap@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@AAEXQAUTGuildAreaInfo@CPythonMiniMap@@II@Z PROC ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 63		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@YAXPAUTGuildAreaInfo@CPythonMiniMap@@QAU12@AAV?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TGuildAreaInfo> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 24		 push	 36			; 00000024H
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 24	 imul	 eax, DWORD PTR __Count$[ebp], 36
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00098	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  0009a	6b 45 0c 24	 imul	 eax, DWORD PTR __Newsize$[ebp], 36
  0009e	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000a1	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a4	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a6	6b 45 10 24	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 36
  000aa	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b0	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b2	c9		 leave
  000b3	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@AAEXQAUTGuildAreaInfo@CPythonMiniMap@@II@Z ENDP ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@ABEII@Z PROC ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	99		 cdq
  0001b	6a 24		 push	 36			; 00000024H
  0001d	59		 pop	 ecx
  0001e	f7 f9		 idiv	 ecx
  00020	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00023	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00026	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00029	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  0002c	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002f	c7 45 f0 c7 71
	1c 07		 mov	 DWORD PTR $T7[ebp], 119304647 ; 071c71c7H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00036	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003d	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  00040	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00043	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00046	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00049	73 08		 jae	 SHORT $LN25@Calculate_
  0004b	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  00051	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00053	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00056	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  0005c	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00062	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00065	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006d	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00070	d1 e8		 shr	 eax, 1
  00072	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00075	2b c8		 sub	 ecx, eax
  00077	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  0007a	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  0007c	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007f	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00081	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00084	d1 e8		 shr	 eax, 1
  00086	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00089	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  0008c	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008f	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00092	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00094	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00097	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00099	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  0009c	c9		 leave
  0009d	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@ABEII@Z ENDP ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@AAEXPAUTGuildAreaInfo@CPythonMiniMap@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@AAEXPAUTGuildAreaInfo@CPythonMiniMap@@0@Z PROC ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@YAXPAUTGuildAreaInfo@CPythonMiniMap@@QAU12@AAV?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TGuildAreaInfo> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@AAEXPAUTGuildAreaInfo@CPythonMiniMap@@0@Z ENDP ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEXXZ PROC ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@YAXPAUTGuildAreaInfo@CPythonMiniMap@@QAU12@AAV?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TGuildAreaInfo> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEXXZ ENDP ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAE@XZ PROC ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::~vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@AAEXXZ ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAE@XZ ENDP ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::~vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@QAEXQAUTGuildAreaInfo@CPythonMiniMap@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@QAEXQAUTGuildAreaInfo@CPythonMiniMap@@I@Z PROC ; std::allocator<CPythonMiniMap::TGuildAreaInfo>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	6b 45 0c 24	 imul	 eax, DWORD PTR __Count$[ebp], 36
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx

; 811  :     }

  00016	c9		 leave
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@QAEXQAUTGuildAreaInfo@CPythonMiniMap@@I@Z ENDP ; std::allocator<CPythonMiniMap::TGuildAreaInfo>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@CAXXZ PROC ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@CAXXZ ENDP ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXXZ PROC ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 75		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAXPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 3c		 push	 60			; 0000003cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 3c	 imul	 eax, DWORD PTR __Count$[ebp], 60
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00098	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009b	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009e	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a1	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a4	c9		 leave
  000a5	c3		 ret	 0
?_Tidy@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXXZ ENDP ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXQAUTAtlasMarkInfo@CPythonMiniMap@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXQAUTAtlasMarkInfo@CPythonMiniMap@@II@Z PROC ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 63		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAXPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 3c		 push	 60			; 0000003cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 3c	 imul	 eax, DWORD PTR __Count$[ebp], 60
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00098	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  0009a	6b 45 0c 3c	 imul	 eax, DWORD PTR __Newsize$[ebp], 60
  0009e	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000a1	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a4	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a6	6b 45 10 3c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 60
  000aa	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b0	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b2	c9		 leave
  000b3	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXQAUTAtlasMarkInfo@CPythonMiniMap@@II@Z ENDP ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@ABEII@Z PROC ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	99		 cdq
  0001b	6a 3c		 push	 60			; 0000003cH
  0001d	59		 pop	 ecx
  0001e	f7 f9		 idiv	 ecx
  00020	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00023	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00026	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00029	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  0002c	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002f	c7 45 f0 44 44
	44 04		 mov	 DWORD PTR $T7[ebp], 71582788 ; 04444444H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00036	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003d	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  00040	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00043	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00046	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00049	73 08		 jae	 SHORT $LN25@Calculate_
  0004b	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  00051	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00053	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00056	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  0005c	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00062	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00065	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006d	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00070	d1 e8		 shr	 eax, 1
  00072	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00075	2b c8		 sub	 ecx, eax
  00077	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  0007a	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  0007c	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007f	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00081	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00084	d1 e8		 shr	 eax, 1
  00086	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00089	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  0008c	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008f	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00092	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00094	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00097	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00099	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  0009c	c9		 leave
  0009d	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@ABEII@Z ENDP ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXPAUTAtlasMarkInfo@CPythonMiniMap@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXPAUTAtlasMarkInfo@CPythonMiniMap@@0@Z PROC ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAXPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXPAUTAtlasMarkInfo@CPythonMiniMap@@0@Z ENDP ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEXXZ PROC ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@YAXPAUTAtlasMarkInfo@CPythonMiniMap@@QAU12@AAV?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEXXZ ENDP ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?erase@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
__Ptr$ = -40						; size = 4
$T4 = -36						; size = 4
__Last$ = -32						; size = 4
__My_data$ = -28					; size = 4
$T5 = -24						; size = 4
_this$ = -20						; size = 4
__Whereptr$ = -16					; size = 4
__Dest$ = -12						; size = 4
__Mylast$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@@2@@Z PROC ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::erase, COMDAT
; _this$ = ecx

; 1341 :     iterator erase(const_iterator _Where) noexcept(is_nothrow_move_assignable_v<value_type>) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1342 :         const pointer _Whereptr = _Where._Ptr;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Whereptr$[ebp], eax

; 1343 :         auto& _My_data          = _Mypair._Myval2;

  0000f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1344 :         pointer& _Mylast        = _My_data._Mylast;

  00015	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1345 : 
; 1346 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1347 :         _STL_VERIFY(
; 1348 :             _Where._Getcont() == _STD addressof(_My_data) && _Whereptr >= _My_data._Myfirst && _Mylast > _Whereptr,
; 1349 :             "vector erase iterator outside range");
; 1350 :         _Orphan_range(_Whereptr, _Mylast);
; 1351 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1352 : 
; 1353 :         _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);

  0001e	8b 45 f0	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00021	89 45 f4	 mov	 DWORD PTR __Dest$[ebp], eax
  00024	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  0002c	8b 45 f0	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  0002f	83 c0 3c	 add	 eax, 60			; 0000003cH
  00032	89 45 fc	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4632 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

  00035	eb 12		 jmp	 SHORT $LN6@erase
$LN4@erase:
  00037	8b 45 f4	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003a	83 c0 3c	 add	 eax, 60			; 0000003cH
  0003d	89 45 f4	 mov	 DWORD PTR __Dest$[ebp], eax
  00040	8b 45 fc	 mov	 eax, DWORD PTR __First$[ebp]
  00043	83 c0 3c	 add	 eax, 60			; 0000003cH
  00046	89 45 fc	 mov	 DWORD PTR __First$[ebp], eax
$LN6@erase:
  00049	8b 45 fc	 mov	 eax, DWORD PTR __First$[ebp]
  0004c	3b 45 e0	 cmp	 eax, DWORD PTR __Last$[ebp]
  0004f	74 13		 je	 SHORT $LN3@erase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00051	8b 45 fc	 mov	 eax, DWORD PTR __First$[ebp]
  00054	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4633 :         *_Dest = _STD move(*_First);

  00057	ff 75 dc	 push	 DWORD PTR $T4[ebp]
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005d	e8 00 00 00 00	 call	 ??4TAtlasMarkInfo@CPythonMiniMap@@QAEAAU01@$$QAU01@@Z

; 4634 :     }

  00062	eb d3		 jmp	 SHORT $LN4@erase
$LN3@erase:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1354 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  00064	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00067	8b 00		 mov	 eax, DWORD PTR [eax]
  00069	83 e8 3c	 sub	 eax, 60			; 0000003cH
  0006c	89 45 d8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0006f	8b 45 d8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00072	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00075	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00078	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0007b	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0007e	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
  00081	8b 4d e8	 mov	 ecx, DWORD PTR $T5[ebp]
  00084	83 c1 24	 add	 ecx, 36			; 00000024H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00087	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0008c	33 c0		 xor	 eax, eax
  0008e	83 e0 01	 and	 eax, 1
  00091	74 0c		 je	 SHORT $LN30@erase
  00093	6a 3c		 push	 60			; 0000003cH
  00095	ff 75 e8	 push	 DWORD PTR $T5[ebp]
  00098	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0009d	59		 pop	 ecx
  0009e	59		 pop	 ecx
$LN30@erase:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1355 :         --_Mylast;

  0009f	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000a2	8b 00		 mov	 eax, DWORD PTR [eax]
  000a4	83 e8 3c	 sub	 eax, 60			; 0000003cH
  000a7	8b 4d f8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000aa	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000ac	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000af	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  000b2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b5	8b 4d f0	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  000b8	89 08		 mov	 DWORD PTR [eax], ecx

; 1356 :         return iterator(_Whereptr, _STD addressof(_My_data));

  000ba	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1357 :     }

  000bd	c9		 leave
  000be	c2 08 00	 ret	 8
?erase@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@@2@@Z ENDP ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::erase
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAE@XZ PROC ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::~vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXXZ ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAE@XZ ENDP ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::~vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@QAEXQAUTAtlasMarkInfo@CPythonMiniMap@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@QAEXQAUTAtlasMarkInfo@CPythonMiniMap@@I@Z PROC ; std::allocator<CPythonMiniMap::TAtlasMarkInfo>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	6b 45 0c 3c	 imul	 eax, DWORD PTR __Count$[ebp], 60
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx

; 811  :     }

  00016	c9		 leave
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@QAEXQAUTAtlasMarkInfo@CPythonMiniMap@@I@Z ENDP ; std::allocator<CPythonMiniMap::TAtlasMarkInfo>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$map@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@@std@@QAE@XZ PROC ; std::map<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::~map<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >
  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$map@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@@std@@QAE@XZ ENDP ; std::map<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::~map<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Parent_sibling$1 = -20				; size = 4
__Parent_sibling$2 = -16				; size = 4
_this$ = -12						; size = 4
__Head$ = -8						; size = 4
__Pnode$3 = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Insert_node, COMDAT
; _this$ = ecx

; 644  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 645  :         ++_Mysize;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	40		 inc	 eax
  00010	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 646  :         const auto _Head  = _Myhead;

  00016	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 00		 mov	 eax, DWORD PTR [eax]
  0001b	89 45 f8	 mov	 DWORD PTR __Head$[ebp], eax

; 647  :         _Newnode->_Parent = _Loc._Parent;

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00024	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 648  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  00027	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  0002a	3b 45 f8	 cmp	 eax, DWORD PTR __Head$[ebp]
  0002d	75 29		 jne	 SHORT $LN5@Insert_nod

; 649  :             _Head->_Left     = _Newnode;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00035	89 08		 mov	 DWORD PTR [eax], ecx

; 650  :             _Head->_Parent   = _Newnode;

  00037	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0003a	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 651  :             _Head->_Right    = _Newnode;

  00040	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00043	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00046	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 652  :             _Newnode->_Color = _Black; // the root is black

  00049	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0004c	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 653  :             return _Newnode;

  00050	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00053	e9 a3 01 00 00	 jmp	 $LN18@Insert_nod
$LN5@Insert_nod:

; 654  :         }
; 655  : 
; 656  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 657  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00058	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  0005c	75 1f		 jne	 SHORT $LN6@Insert_nod

; 658  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 659  :             _Loc._Parent->_Right = _Newnode;

  0005e	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00061	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00064	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 660  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  00067	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0006d	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00070	75 09		 jne	 SHORT $LN8@Insert_nod

; 661  :                 _Head->_Right = _Newnode;

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00075	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00078	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN8@Insert_nod:

; 662  :             }
; 663  :         } else { // add to left of _Loc._Parent

  0007b	eb 1a		 jmp	 SHORT $LN7@Insert_nod
$LN6@Insert_nod:

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 665  :             _Loc._Parent->_Left = _Newnode;

  0007d	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00080	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00083	89 08		 mov	 DWORD PTR [eax], ecx

; 666  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00085	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0008b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0008d	75 08		 jne	 SHORT $LN7@Insert_nod

; 667  :                 _Head->_Left = _Newnode;

  0008f	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00092	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00097	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0009a	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax
$LN4@Insert_nod:
  0009d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000a0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a3	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  000a7	85 c0		 test	 eax, eax
  000a9	0f 85 3f 01 00
	00		 jne	 $LN3@Insert_nod

; 672  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  000af	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000b2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  000bb	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000be	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000c0	0f 85 95 00 00
	00		 jne	 $LN10@Insert_nod

; 673  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  000c6	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000c9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cf	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000d2	89 45 f0	 mov	 DWORD PTR __Parent_sibling$2[ebp], eax

; 674  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  000d5	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000d8	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  000dc	85 c0		 test	 eax, eax
  000de	75 2c		 jne	 SHORT $LN12@Insert_nod

; 675  :                     _Pnode->_Parent->_Color          = _Black;

  000e0	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000e3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000e6	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 676  :                     _Parent_sibling->_Color          = _Black;

  000ea	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000ed	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 677  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000f1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000f4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000fa	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 678  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  000fe	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00101	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00104	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00107	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 679  :                 } else { // parent's sibling has red and black children

  0010a	eb 4a		 jmp	 SHORT $LN13@Insert_nod
$LN12@Insert_nod:

; 680  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  0010c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0010f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00112	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  00115	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00118	75 14		 jne	 SHORT $LN14@Insert_nod

; 681  :                         _Pnode = _Pnode->_Parent;

  0011a	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0011d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00120	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 682  :                         _Lrotate(_Pnode);

  00123	ff 75 fc	 push	 DWORD PTR __Pnode$3[ebp]
  00126	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Lrotate
$LN14@Insert_nod:

; 683  :                     }
; 684  : 
; 685  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  0012e	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00131	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00134	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 686  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00138	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0013b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 687  :                     _Rrotate(_Pnode->_Parent->_Parent);

  00145	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00148	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0014b	ff 70 04	 push	 DWORD PTR [eax+4]
  0014e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00151	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Rrotate
$LN13@Insert_nod:

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  00156	e9 8e 00 00 00	 jmp	 $LN11@Insert_nod
$LN10@Insert_nod:

; 690  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;

  0015b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0015e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00161	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00164	8b 00		 mov	 eax, DWORD PTR [eax]
  00166	89 45 ec	 mov	 DWORD PTR __Parent_sibling$1[ebp], eax

; 691  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00169	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  0016c	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  00170	85 c0		 test	 eax, eax
  00172	75 2c		 jne	 SHORT $LN15@Insert_nod

; 692  :                     _Pnode->_Parent->_Color          = _Black;

  00174	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00177	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0017a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 693  :                     _Parent_sibling->_Color          = _Black;

  0017e	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  00181	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 694  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00185	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00188	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 695  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  00192	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00195	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00198	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019b	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 696  :                 } else { // parent's sibling has red and black children

  0019e	eb 49		 jmp	 SHORT $LN11@Insert_nod
$LN15@Insert_nod:

; 697  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  001a0	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001a3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a6	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  001a9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001ab	75 14		 jne	 SHORT $LN17@Insert_nod

; 698  :                         _Pnode = _Pnode->_Parent;

  001ad	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001b0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001b3	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 699  :                         _Rrotate(_Pnode);

  001b6	ff 75 fc	 push	 DWORD PTR __Pnode$3[ebp]
  001b9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001bc	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Rrotate
$LN17@Insert_nod:

; 700  :                     }
; 701  : 
; 702  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  001c1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001c4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001c7	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 703  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  001cb	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001ce	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d4	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 704  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001d8	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001db	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001de	ff 70 04	 push	 DWORD PTR [eax+4]
  001e1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001e4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Lrotate
$LN11@Insert_nod:

; 705  :                 }
; 706  :             }
; 707  :         }

  001e9	e9 af fe ff ff	 jmp	 $LN4@Insert_nod
$LN3@Insert_nod:

; 708  : 
; 709  :         _Head->_Parent->_Color = _Black; // root is always black

  001ee	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  001f1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001f4	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 710  :         return _Newnode;

  001f8	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
$LN18@Insert_nod:

; 711  :     }

  001fb	c9		 leave
  001fc	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
__Right$ = -48						; size = 4
__Left$ = -44						; size = 4
tv144 = -40						; size = 4
tv133 = -36						; size = 4
__Pnode$ = -32						; size = 4
__Pnode$ = -28						; size = 4
_this$ = -24						; size = 4
__Erasednode$ = -20					; size = 4
__Fixnode$ = -16					; size = 4
__Fixnodeparent$ = -12					; size = 4
__Pnode$ = -8						; size = 4
__Tmp$6 = -1						; size = 1
__Where$ = 8						; size = 4
?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Extract, COMDAT
; _this$ = ecx

; 502  :     _Nodeptr _Extract(_Unchecked_const_iterator _Where) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 503  :         _Nodeptr _Erasednode = _Where._Ptr; // node to erase

  00009	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR __Erasednode$[ebp], eax

; 504  :         ++_Where; // save successor iterator for return

  0000f	8d 4d 08	 lea	 ecx, DWORD PTR __Where$[ebp]
  00012	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >,std::_Iterator_base0>::operator++

; 505  : 
; 506  :         _Nodeptr _Fixnode; // the node to recolor as needed
; 507  :         _Nodeptr _Fixnodeparent; // parent of _Fixnode (which may be nil)
; 508  :         _Nodeptr _Pnode = _Erasednode;

  00017	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0001a	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 509  : 
; 510  :         if (_Pnode->_Left->_Isnil) {

  0001d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00026	85 c0		 test	 eax, eax
  00028	74 0b		 je	 SHORT $LN5@Extract

; 511  :             _Fixnode = _Pnode->_Right; // stitch up right subtree

  0002a	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00030	89 45 f0	 mov	 DWORD PTR __Fixnode$[ebp], eax
  00033	eb 27		 jmp	 SHORT $LN6@Extract
$LN5@Extract:

; 512  :         } else if (_Pnode->_Right->_Isnil) {

  00035	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00038	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0003b	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  0003f	85 c0		 test	 eax, eax
  00041	74 0a		 je	 SHORT $LN7@Extract

; 513  :             _Fixnode = _Pnode->_Left; // stitch up left subtree

  00043	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 45 f0	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 514  :         } else { // two subtrees, must lift successor node to replace erased

  0004b	eb 0f		 jmp	 SHORT $LN6@Extract
$LN7@Extract:

; 515  :             _Pnode   = _Where._Ptr; // _Pnode is successor node

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 516  :             _Fixnode = _Pnode->_Right; // _Fixnode is only subtree

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00056	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00059	89 45 f0	 mov	 DWORD PTR __Fixnode$[ebp], eax
$LN6@Extract:

; 517  :         }
; 518  : 
; 519  :         if (_Pnode == _Erasednode) { // at most one subtree, relink it

  0005c	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005f	3b 45 ec	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00062	0f 85 01 01 00
	00		 jne	 $LN9@Extract

; 520  :             _Fixnodeparent = _Erasednode->_Parent;

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0006b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006e	89 45 f4	 mov	 DWORD PTR __Fixnodeparent$[ebp], eax

; 521  :             if (!_Fixnode->_Isnil) {

  00071	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00074	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00078	85 c0		 test	 eax, eax
  0007a	75 09		 jne	 SHORT $LN11@Extract

; 522  :                 _Fixnode->_Parent = _Fixnodeparent; // link up

  0007c	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0007f	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00082	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN11@Extract:

; 523  :             }
; 524  : 
; 525  :             if (_Myhead->_Parent == _Erasednode) {

  00085	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 00		 mov	 eax, DWORD PTR [eax]
  0008a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008d	3b 45 ec	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00090	75 0d		 jne	 SHORT $LN12@Extract

; 526  :                 _Myhead->_Parent = _Fixnode; // link down from root

  00092	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00095	8b 00		 mov	 eax, DWORD PTR [eax]
  00097	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  0009a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0009d	eb 1d		 jmp	 SHORT $LN13@Extract
$LN12@Extract:

; 527  :             } else if (_Fixnodeparent->_Left == _Erasednode) {

  0009f	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  000a2	8b 00		 mov	 eax, DWORD PTR [eax]
  000a4	3b 45 ec	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  000a7	75 0a		 jne	 SHORT $LN14@Extract

; 528  :                 _Fixnodeparent->_Left = _Fixnode; // link down to left

  000a9	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  000ac	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  000af	89 08		 mov	 DWORD PTR [eax], ecx

; 529  :             } else {

  000b1	eb 09		 jmp	 SHORT $LN13@Extract
$LN14@Extract:

; 530  :                 _Fixnodeparent->_Right = _Fixnode; // link down to right

  000b3	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  000b6	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  000b9	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN13@Extract:

; 531  :             }
; 532  : 
; 533  :             if (_Myhead->_Left == _Erasednode) {

  000bc	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	8b 00		 mov	 eax, DWORD PTR [eax]
  000c1	8b 00		 mov	 eax, DWORD PTR [eax]
  000c3	3b 45 ec	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  000c6	75 46		 jne	 SHORT $LN16@Extract

; 534  :                 _Myhead->_Left = _Fixnode->_Isnil ? _Fixnodeparent // smallest is parent of erased node

  000c8	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  000cb	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  000cf	85 c0		 test	 eax, eax
  000d1	74 08		 je	 SHORT $LN42@Extract
  000d3	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  000d6	89 45 dc	 mov	 DWORD PTR tv133[ebp], eax
  000d9	eb 29		 jmp	 SHORT $LN43@Extract
$LN42@Extract:
  000db	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  000de	89 45 e4	 mov	 DWORD PTR __Pnode$[ebp], eax
  000e1	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]
  000e4	89 45 dc	 mov	 DWORD PTR tv133[ebp], eax
$LN59@Extract:

; 451  :         while (!_Pnode->_Left->_Isnil) {

  000e7	8b 45 e4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000ea	8b 00		 mov	 eax, DWORD PTR [eax]
  000ec	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  000f0	85 c0		 test	 eax, eax
  000f2	75 0a		 jne	 SHORT $LN60@Extract

; 452  :             _Pnode = _Pnode->_Left;

  000f4	8b 45 e4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000f7	8b 00		 mov	 eax, DWORD PTR [eax]
  000f9	89 45 e4	 mov	 DWORD PTR __Pnode$[ebp], eax

; 453  :         }

  000fc	eb e9		 jmp	 SHORT $LN59@Extract
$LN60@Extract:

; 454  : 
; 455  :         return _Pnode;

  000fe	8b 45 e4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00101	89 45 dc	 mov	 DWORD PTR tv133[ebp], eax
$LN43@Extract:

; 534  :                 _Myhead->_Left = _Fixnode->_Isnil ? _Fixnodeparent // smallest is parent of erased node

  00104	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00107	8b 00		 mov	 eax, DWORD PTR [eax]
  00109	8b 4d dc	 mov	 ecx, DWORD PTR tv133[ebp]
  0010c	89 08		 mov	 DWORD PTR [eax], ecx
$LN16@Extract:

; 535  :                                                   : _Min(_Fixnode); // smallest in relinked subtree
; 536  :             }
; 537  : 
; 538  :             if (_Myhead->_Right == _Erasednode) {

  0010e	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00111	8b 00		 mov	 eax, DWORD PTR [eax]
  00113	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00116	3b 45 ec	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00119	75 49		 jne	 SHORT $LN17@Extract

; 539  :                 _Myhead->_Right = _Fixnode->_Isnil ? _Fixnodeparent // largest is parent of erased node

  0011b	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0011e	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00122	85 c0		 test	 eax, eax
  00124	74 08		 je	 SHORT $LN44@Extract
  00126	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00129	89 45 d8	 mov	 DWORD PTR tv144[ebp], eax
  0012c	eb 2b		 jmp	 SHORT $LN45@Extract
$LN44@Extract:
  0012e	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00131	89 45 e0	 mov	 DWORD PTR __Pnode$[ebp], eax
  00134	8b 45 bc	 mov	 eax, DWORD PTR $T1[ebp]
  00137	89 45 d8	 mov	 DWORD PTR tv144[ebp], eax
$LN64@Extract:

; 443  :         while (!_Pnode->_Right->_Isnil) {

  0013a	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0013d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00140	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00144	85 c0		 test	 eax, eax
  00146	75 0b		 jne	 SHORT $LN65@Extract

; 444  :             _Pnode = _Pnode->_Right;

  00148	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0014b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0014e	89 45 e0	 mov	 DWORD PTR __Pnode$[ebp], eax

; 445  :         }

  00151	eb e7		 jmp	 SHORT $LN64@Extract
$LN65@Extract:

; 446  : 
; 447  :         return _Pnode;

  00153	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00156	89 45 d8	 mov	 DWORD PTR tv144[ebp], eax
$LN45@Extract:

; 539  :                 _Myhead->_Right = _Fixnode->_Isnil ? _Fixnodeparent // largest is parent of erased node

  00159	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0015c	8b 00		 mov	 eax, DWORD PTR [eax]
  0015e	8b 4d d8	 mov	 ecx, DWORD PTR tv144[ebp]
  00161	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN17@Extract:

; 540  :                                                    : _Max(_Fixnode); // largest in relinked subtree
; 541  :             }
; 542  :         } else { // erased has two subtrees, _Pnode is successor to erased

  00164	e9 f1 00 00 00	 jmp	 $LN10@Extract
$LN9@Extract:

; 543  :             _Erasednode->_Left->_Parent = _Pnode; // link left up

  00169	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0016c	8b 00		 mov	 eax, DWORD PTR [eax]
  0016e	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00171	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 544  :             _Pnode->_Left               = _Erasednode->_Left; // link successor down

  00174	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00177	8b 4d ec	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  0017a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0017c	89 08		 mov	 DWORD PTR [eax], ecx

; 545  : 
; 546  :             if (_Pnode == _Erasednode->_Right) {

  0017e	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00181	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00184	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00187	75 08		 jne	 SHORT $LN18@Extract

; 547  :                 _Fixnodeparent = _Pnode; // successor is next to erased

  00189	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0018c	89 45 f4	 mov	 DWORD PTR __Fixnodeparent$[ebp], eax

; 548  :             } else { // successor further down, link in place of erased

  0018f	eb 3d		 jmp	 SHORT $LN19@Extract
$LN18@Extract:

; 549  :                 _Fixnodeparent = _Pnode->_Parent; // parent is successor's

  00191	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00194	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00197	89 45 f4	 mov	 DWORD PTR __Fixnodeparent$[ebp], eax

; 550  :                 if (!_Fixnode->_Isnil) {

  0019a	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0019d	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  001a1	85 c0		 test	 eax, eax
  001a3	75 09		 jne	 SHORT $LN20@Extract

; 551  :                     _Fixnode->_Parent = _Fixnodeparent; // link fix up

  001a5	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001a8	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  001ab	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN20@Extract:

; 552  :                 }
; 553  : 
; 554  :                 _Fixnodeparent->_Left        = _Fixnode; // link fix down

  001ae	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  001b1	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  001b4	89 08		 mov	 DWORD PTR [eax], ecx

; 555  :                 _Pnode->_Right               = _Erasednode->_Right; // link next down

  001b6	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  001b9	8b 4d ec	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  001bc	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  001bf	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 556  :                 _Erasednode->_Right->_Parent = _Pnode; // right up

  001c2	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  001c5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  001c8	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  001cb	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN19@Extract:

; 557  :             }
; 558  : 
; 559  :             if (_Myhead->_Parent == _Erasednode) {

  001ce	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001d1	8b 00		 mov	 eax, DWORD PTR [eax]
  001d3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d6	3b 45 ec	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  001d9	75 0d		 jne	 SHORT $LN21@Extract

; 560  :                 _Myhead->_Parent = _Pnode; // link down from root

  001db	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001de	8b 00		 mov	 eax, DWORD PTR [eax]
  001e0	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  001e3	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  001e6	eb 26		 jmp	 SHORT $LN22@Extract
$LN21@Extract:

; 561  :             } else if (_Erasednode->_Parent->_Left == _Erasednode) {

  001e8	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  001eb	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001ee	8b 00		 mov	 eax, DWORD PTR [eax]
  001f0	3b 45 ec	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  001f3	75 0d		 jne	 SHORT $LN23@Extract

; 562  :                 _Erasednode->_Parent->_Left = _Pnode; // link down to left

  001f5	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  001f8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001fb	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  001fe	89 08		 mov	 DWORD PTR [eax], ecx

; 563  :             } else {

  00200	eb 0c		 jmp	 SHORT $LN22@Extract
$LN23@Extract:

; 564  :                 _Erasednode->_Parent->_Right = _Pnode; // link down to right

  00202	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00205	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00208	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0020b	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN22@Extract:

; 565  :             }
; 566  : 
; 567  :             _Pnode->_Parent = _Erasednode->_Parent; // link successor up

  0020e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00211	8b 4d ec	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  00214	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00217	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 568  :             _STD swap(_Pnode->_Color, _Erasednode->_Color); // recolor it

  0021a	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0021d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00220	89 45 d0	 mov	 DWORD PTR __Right$[ebp], eax
  00223	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00226	83 c0 0c	 add	 eax, 12			; 0000000cH
  00229	89 45 d4	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0022c	8b 45 d4	 mov	 eax, DWORD PTR __Left$[ebp]
  0022f	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  00232	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  00235	8a 00		 mov	 al, BYTE PTR [eax]
  00237	88 45 ff	 mov	 BYTE PTR __Tmp$6[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0023a	8b 45 d0	 mov	 eax, DWORD PTR __Right$[ebp]
  0023d	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00240	8b 45 d4	 mov	 eax, DWORD PTR __Left$[ebp]
  00243	8b 4d c8	 mov	 ecx, DWORD PTR $T4[ebp]
  00246	8a 09		 mov	 cl, BYTE PTR [ecx]
  00248	88 08		 mov	 BYTE PTR [eax], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0024a	8d 45 ff	 lea	 eax, DWORD PTR __Tmp$6[ebp]
  0024d	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00250	8b 45 d0	 mov	 eax, DWORD PTR __Right$[ebp]
  00253	8b 4d c4	 mov	 ecx, DWORD PTR $T3[ebp]
  00256	8a 09		 mov	 cl, BYTE PTR [ecx]
  00258	88 08		 mov	 BYTE PTR [eax], cl
$LN10@Extract:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 571  :         if (_Erasednode->_Color == _Black) { // erasing black link, must recolor/rebalance tree

  0025a	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0025d	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  00261	83 f8 01	 cmp	 eax, 1
  00264	0f 85 f4 01 00
	00		 jne	 $LN25@Extract

; 572  :             for (; _Fixnode != _Myhead->_Parent && _Fixnode->_Color == _Black; _Fixnodeparent = _Fixnode->_Parent) {

  0026a	eb 09		 jmp	 SHORT $LN4@Extract
$LN2@Extract:
  0026c	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0026f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00272	89 45 f4	 mov	 DWORD PTR __Fixnodeparent$[ebp], eax
$LN4@Extract:
  00275	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00278	8b 00		 mov	 eax, DWORD PTR [eax]
  0027a	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  0027d	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00280	0f 84 d1 01 00
	00		 je	 $LN3@Extract
  00286	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00289	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  0028d	83 f8 01	 cmp	 eax, 1
  00290	0f 85 c1 01 00
	00		 jne	 $LN3@Extract

; 573  :                 if (_Fixnode == _Fixnodeparent->_Left) { // fixup left subtree

  00296	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00299	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  0029c	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0029e	0f 85 dd 00 00
	00		 jne	 $LN26@Extract

; 574  :                     _Pnode = _Fixnodeparent->_Right;

  002a4	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  002a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  002aa	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 575  :                     if (_Pnode->_Color == _Red) { // rotate red up from right subtree

  002ad	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  002b0	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  002b4	85 c0		 test	 eax, eax
  002b6	75 22		 jne	 SHORT $LN28@Extract

; 576  :                         _Pnode->_Color         = _Black;

  002b8	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  002bb	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 577  :                         _Fixnodeparent->_Color = _Red;

  002bf	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  002c2	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 578  :                         _Lrotate(_Fixnodeparent);

  002c6	ff 75 f4	 push	 DWORD PTR __Fixnodeparent$[ebp]
  002c9	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  002cc	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Lrotate

; 579  :                         _Pnode = _Fixnodeparent->_Right;

  002d1	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  002d4	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  002d7	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN28@Extract:

; 580  :                     }
; 581  : 
; 582  :                     if (_Pnode->_Isnil) {

  002da	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  002dd	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  002e1	85 c0		 test	 eax, eax
  002e3	74 0b		 je	 SHORT $LN29@Extract

; 583  :                         _Fixnode = _Fixnodeparent; // shouldn't happen

  002e5	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  002e8	89 45 f0	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 584  :                     } else if (_Pnode->_Left->_Color == _Black

  002eb	e9 8c 00 00 00	 jmp	 $LN30@Extract
$LN29@Extract:

; 585  :                                && _Pnode->_Right->_Color == _Black) { // redden right subtree with black children

  002f0	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  002f3	8b 00		 mov	 eax, DWORD PTR [eax]
  002f5	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  002f9	83 f8 01	 cmp	 eax, 1
  002fc	75 1e		 jne	 SHORT $LN31@Extract
  002fe	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00301	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00304	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  00308	83 f8 01	 cmp	 eax, 1
  0030b	75 0f		 jne	 SHORT $LN31@Extract

; 586  :                         _Pnode->_Color = _Red;

  0030d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00310	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 587  :                         _Fixnode       = _Fixnodeparent;

  00314	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00317	89 45 f0	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 588  :                     } else { // must rearrange right subtree

  0031a	eb 60		 jmp	 SHORT $LN30@Extract
$LN31@Extract:

; 589  :                         if (_Pnode->_Right->_Color == _Black) { // rotate red up from left sub-subtree

  0031c	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0031f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00322	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  00326	83 f8 01	 cmp	 eax, 1
  00329	75 24		 jne	 SHORT $LN33@Extract

; 590  :                             _Pnode->_Left->_Color = _Black;

  0032b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0032e	8b 00		 mov	 eax, DWORD PTR [eax]
  00330	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 591  :                             _Pnode->_Color        = _Red;

  00334	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00337	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 592  :                             _Rrotate(_Pnode);

  0033b	ff 75 f8	 push	 DWORD PTR __Pnode$[ebp]
  0033e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00341	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Rrotate

; 593  :                             _Pnode = _Fixnodeparent->_Right;

  00346	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00349	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0034c	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN33@Extract:

; 594  :                         }
; 595  : 
; 596  :                         _Pnode->_Color         = _Fixnodeparent->_Color;

  0034f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00352	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00355	8a 49 0c	 mov	 cl, BYTE PTR [ecx+12]
  00358	88 48 0c	 mov	 BYTE PTR [eax+12], cl

; 597  :                         _Fixnodeparent->_Color = _Black;

  0035b	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0035e	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 598  :                         _Pnode->_Right->_Color = _Black;

  00362	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00365	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00368	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 599  :                         _Lrotate(_Fixnodeparent);

  0036c	ff 75 f4	 push	 DWORD PTR __Fixnodeparent$[ebp]
  0036f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00372	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Lrotate

; 600  :                         break; // tree now recolored/rebalanced

  00377	e9 db 00 00 00	 jmp	 $LN3@Extract
$LN30@Extract:

; 601  :                     }
; 602  :                 } else { // fixup right subtree

  0037c	e9 d1 00 00 00	 jmp	 $LN27@Extract
$LN26@Extract:

; 603  :                     _Pnode = _Fixnodeparent->_Left;

  00381	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00384	8b 00		 mov	 eax, DWORD PTR [eax]
  00386	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 604  :                     if (_Pnode->_Color == _Red) { // rotate red up from left subtree

  00389	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0038c	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  00390	85 c0		 test	 eax, eax
  00392	75 21		 jne	 SHORT $LN34@Extract

; 605  :                         _Pnode->_Color         = _Black;

  00394	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00397	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 606  :                         _Fixnodeparent->_Color = _Red;

  0039b	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0039e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 607  :                         _Rrotate(_Fixnodeparent);

  003a2	ff 75 f4	 push	 DWORD PTR __Fixnodeparent$[ebp]
  003a5	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  003a8	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Rrotate

; 608  :                         _Pnode = _Fixnodeparent->_Left;

  003ad	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003b0	8b 00		 mov	 eax, DWORD PTR [eax]
  003b2	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN34@Extract:

; 609  :                     }
; 610  : 
; 611  :                     if (_Pnode->_Isnil) {

  003b5	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003b8	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  003bc	85 c0		 test	 eax, eax
  003be	74 0b		 je	 SHORT $LN35@Extract

; 612  :                         _Fixnode = _Fixnodeparent; // shouldn't happen

  003c0	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003c3	89 45 f0	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 613  :                     } else if (_Pnode->_Right->_Color == _Black

  003c6	e9 87 00 00 00	 jmp	 $LN27@Extract
$LN35@Extract:

; 614  :                                && _Pnode->_Left->_Color == _Black) { // redden left subtree with black children

  003cb	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003ce	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  003d1	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  003d5	83 f8 01	 cmp	 eax, 1
  003d8	75 1d		 jne	 SHORT $LN37@Extract
  003da	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003dd	8b 00		 mov	 eax, DWORD PTR [eax]
  003df	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  003e3	83 f8 01	 cmp	 eax, 1
  003e6	75 0f		 jne	 SHORT $LN37@Extract

; 615  :                         _Pnode->_Color = _Red;

  003e8	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003eb	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 616  :                         _Fixnode       = _Fixnodeparent;

  003ef	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003f2	89 45 f0	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 617  :                     } else { // must rearrange left subtree

  003f5	eb 5b		 jmp	 SHORT $LN27@Extract
$LN37@Extract:

; 618  :                         if (_Pnode->_Left->_Color == _Black) { // rotate red up from right sub-subtree

  003f7	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003fa	8b 00		 mov	 eax, DWORD PTR [eax]
  003fc	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  00400	83 f8 01	 cmp	 eax, 1
  00403	75 24		 jne	 SHORT $LN39@Extract

; 619  :                             _Pnode->_Right->_Color = _Black;

  00405	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00408	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0040b	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 620  :                             _Pnode->_Color         = _Red;

  0040f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00412	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 621  :                             _Lrotate(_Pnode);

  00416	ff 75 f8	 push	 DWORD PTR __Pnode$[ebp]
  00419	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0041c	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Lrotate

; 622  :                             _Pnode = _Fixnodeparent->_Left;

  00421	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00424	8b 00		 mov	 eax, DWORD PTR [eax]
  00426	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN39@Extract:

; 623  :                         }
; 624  : 
; 625  :                         _Pnode->_Color         = _Fixnodeparent->_Color;

  00429	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0042c	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  0042f	8a 49 0c	 mov	 cl, BYTE PTR [ecx+12]
  00432	88 48 0c	 mov	 BYTE PTR [eax+12], cl

; 626  :                         _Fixnodeparent->_Color = _Black;

  00435	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00438	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 627  :                         _Pnode->_Left->_Color  = _Black;

  0043c	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0043f	8b 00		 mov	 eax, DWORD PTR [eax]
  00441	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 628  :                         _Rrotate(_Fixnodeparent);

  00445	ff 75 f4	 push	 DWORD PTR __Fixnodeparent$[ebp]
  00448	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0044b	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Rrotate

; 629  :                         break; // tree now recolored/rebalanced

  00450	eb 05		 jmp	 SHORT $LN3@Extract
$LN27@Extract:

; 630  :                     }
; 631  :                 }
; 632  :             }

  00452	e9 15 fe ff ff	 jmp	 $LN2@Extract
$LN3@Extract:

; 633  : 
; 634  :             _Fixnode->_Color = _Black; // stopping node is black

  00457	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0045a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
$LN25@Extract:

; 635  :         }
; 636  : 
; 637  :         if (0 < _Mysize) {

  0045e	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00461	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00465	76 0d		 jbe	 SHORT $LN40@Extract

; 638  :             --_Mysize;

  00467	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0046a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0046d	48		 dec	 eax
  0046e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00471	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN40@Extract:

; 639  :         }
; 640  : 
; 641  :         return _Erasednode;

  00474	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]

; 642  :     }

  00477	c9		 leave
  00478	c2 04 00	 ret	 4
?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Extract
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Rrotate, COMDAT
; _this$ = ecx

; 480  :     void _Rrotate(_Nodeptr _Wherenode) noexcept { // promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00013	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00016	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00019	89 08		 mov	 DWORD PTR [eax], ecx

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 0c		 jne	 SHORT $LN2@Rrotate

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00032	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Rrotate:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  00035	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00049	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004c	75 0d		 jne	 SHORT $LN3@Rrotate

; 491  :             _Myhead->_Parent = _Pnode;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00056	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00059	eb 27		 jmp	 SHORT $LN4@Rrotate
$LN3@Rrotate:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  0005b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00061	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00064	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00067	75 0e		 jne	 SHORT $LN5@Rrotate

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  00069	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00072	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 494  :         } else {

  00075	eb 0b		 jmp	 SHORT $LN4@Rrotate
$LN5@Rrotate:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  00077	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0007a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00080	89 08		 mov	 DWORD PTR [eax], ecx
$LN4@Rrotate:

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  00082	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00085	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00088	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 499  :         _Wherenode->_Parent = _Pnode;

  0008b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00091	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 500  :     }

  00094	c9		 leave
  00095	c2 04 00	 ret	 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Lrotate, COMDAT
; _this$ = ecx

; 458  :     void _Lrotate(_Nodeptr _Wherenode) noexcept { // promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 459  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000e	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  00011	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00014	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00017	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 0b		 jne	 SHORT $LN2@Lrotate

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00031	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Lrotate:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00037	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 00		 mov	 eax, DWORD PTR [eax]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00048	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004b	75 0d		 jne	 SHORT $LN3@Lrotate

; 469  :             _Myhead->_Parent = _Pnode;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 00		 mov	 eax, DWORD PTR [eax]
  00052	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00055	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00058	eb 26		 jmp	 SHORT $LN4@Lrotate
$LN3@Lrotate:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00063	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00065	75 0d		 jne	 SHORT $LN5@Lrotate

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  00067	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00070	89 08		 mov	 DWORD PTR [eax], ecx

; 472  :         } else {

  00072	eb 0c		 jmp	 SHORT $LN4@Lrotate
$LN5@Lrotate:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  00074	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00077	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0007d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN4@Lrotate:

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;

  00080	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00083	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00086	89 08		 mov	 DWORD PTR [eax], ecx

; 477  :         _Wherenode->_Parent = _Pnode;

  00088	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0008e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 478  :     }

  00091	c9		 leave
  00092	c2 04 00	 ret	 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -28					; size = 4
__Scary$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
_$S20$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 2017 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 e8	 mov	 DWORD PTR __Scary$[ebp], eax

; 2018 :         const auto _Scary = _Get_scary();
; 2019 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00015	8d 45 ff	 lea	 eax, DWORD PTR _$S20$[ebp]
  00018	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0001e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00021	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax

; 2020 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 2021 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00027	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0002a	e8 00 00 00 00	 call	 ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >
  0002f	59		 pop	 ecx
  00030	8b 4d e8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00033	89 01		 mov	 DWORD PTR [ecx], eax

; 2022 :         _Proxy._Release();
; 2023 :     }

  00035	c9		 leave
  00036	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Check_grow_by_1, COMDAT
; _this$ = ecx

; 1718 :     void _Check_grow_by_1() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1719 :         if (max_size() == _Get_scary()->_Mysize) {

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?max_size@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::max_size
  0001d	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00020	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00023	75 05		 jne	 SHORT $LN3@Check_grow

; 1720 :             _Throw_tree_length_error();

  00025	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN3@Check_grow:

; 1721 :         }
; 1722 :     }

  0002a	c9		 leave
  0002b	c3		 ret	 0
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Check_grow_by_1
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@@2@ABK@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
___param0$ = -12					; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::find, COMDAT
; _this$ = ecx

; 1467 :     _NODISCARD iterator find(const key_type& _Keyval) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 1468 :         return iterator(_Find(_Keyval), _Get_scary());

  00015	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??$_Find@K@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Find<unsigned long>
  00020	89 45 f4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00026	8b 4d f4	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00029	89 08		 mov	 DWORD PTR [eax], ecx

; 1468 :         return iterator(_Find(_Keyval), _Get_scary());

  0002b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1469 :     }

  0002e	c9		 leave
  0002f	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
_this$ = -12						; size = 4
__Scary$ = -8						; size = 4
__Head$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::clear, COMDAT
; _this$ = ecx

; 1444 :     void clear() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1445 :         const auto _Scary = _Get_scary();
; 1446 :         _Scary->_Orphan_ptr(nullptr);
; 1447 :         auto _Head = _Scary->_Myhead;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	89 45 fc	 mov	 DWORD PTR __Head$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  0001d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00020	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00023	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00026	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1448 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0002c	ff 70 04	 push	 DWORD PTR [eax+4]
  0002f	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  00032	8b 4d f8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00035	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >

; 1449 :         _Head->_Parent  = _Head;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00040	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1450 :         _Head->_Left    = _Head;

  00043	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00049	89 08		 mov	 DWORD PTR [eax], ecx

; 1451 :         _Head->_Right   = _Head;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00051	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1452 :         _Scary->_Mysize = 0;

  00054	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00057	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1453 :     }

  0005b	c9		 leave
  0005c	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAEIABK@Z
_TEXT	SEGMENT
__Where$ = -32						; size = 8
__Num$ = -24						; size = 4
__Pnode$ = -20						; size = 4
__Pnode$ = -16						; size = 4
_this$ = -12						; size = 4
__First$ = -8						; size = 4
__Last$ = -4						; size = 4
__Keyval$ = 8						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAEIABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::erase, COMDAT
; _this$ = ecx

; 1435 :     size_type erase(const key_type& _Keyval) noexcept(noexcept(_Eqrange(_Keyval))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1436 :         const auto _Where = _Eqrange(_Keyval);

  00009	ff 75 08	 push	 DWORD PTR __Keyval$[ebp]
  0000c	8d 45 e0	 lea	 eax, DWORD PTR __Where$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Eqrange@K@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IBE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@PAU12@@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Eqrange<unsigned long>

; 1437 :         const _Unchecked_const_iterator _First(_Where.first, nullptr);

  00018	8b 45 e0	 mov	 eax, DWORD PTR __Where$[ebp]
  0001b	89 45 f0	 mov	 DWORD PTR __Pnode$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0001e	8b 45 f0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR __First$[ebp], eax

; 1438 :         const _Unchecked_const_iterator _Last(_Where.second, nullptr);

  00024	8b 45 e4	 mov	 eax, DWORD PTR __Where$[ebp+4]
  00027	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0002a	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002d	89 45 fc	 mov	 DWORD PTR __Last$[ebp], eax

; 1439 :         const auto _Num = static_cast<size_type>(_STD distance(_First, _Last));

  00030	ff 75 fc	 push	 DWORD PTR __Last$[ebp]
  00033	ff 75 f8	 push	 DWORD PTR __First$[ebp]
  00036	e8 00 00 00 00	 call	 ??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::distance<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >,std::_Iterator_base0> >
  0003b	59		 pop	 ecx
  0003c	59		 pop	 ecx
  0003d	89 45 e8	 mov	 DWORD PTR __Num$[ebp], eax

; 1440 :         _Erase_unchecked(_First, _Last);

  00040	ff 75 fc	 push	 DWORD PTR __Last$[ebp]
  00043	ff 75 f8	 push	 DWORD PTR __First$[ebp]
  00046	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Erase_unchecked

; 1441 :         return _Num;

  0004e	8b 45 e8	 mov	 eax, DWORD PTR __Num$[ebp]

; 1442 :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
?erase@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAEIABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z
_TEXT	SEGMENT
$T1 = -48						; size = 4
$T2 = -44						; size = 4
__Tmp$3 = -40						; size = 4
__Begin$ = -36						; size = 4
___param0$ = -32					; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
tv153 = -20						; size = 4
tv136 = -16						; size = 4
tv129 = -12						; size = 4
_this$ = -8						; size = 4
$T6 = -3						; size = 1
$T7 = -2						; size = 1
$T8 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Erase_unchecked, COMDAT
; _this$ = ecx

; 1395 :     _Nodeptr _Erase_unchecked(_Unchecked_const_iterator _First, _Unchecked_const_iterator _Last) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax

; 1259 :         return _Unchecked_iterator(_Get_scary()->_Myhead->_Left, nullptr);

  00015	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0001f	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00022	89 45 dc	 mov	 DWORD PTR __Begin$[ebp], eax

; 98   :         return _Ptr == _Right._Ptr;

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	3b 45 dc	 cmp	 eax, DWORD PTR __Begin$[ebp]
  0002b	75 09		 jne	 SHORT $LN26@Erase_unch
  0002d	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv129[ebp], 1
  00034	eb 04		 jmp	 SHORT $LN27@Erase_unch
$LN26@Erase_unch:
  00036	83 65 f4 00	 and	 DWORD PTR tv129[ebp], 0
$LN27@Erase_unch:
  0003a	8a 45 f4	 mov	 al, BYTE PTR tv129[ebp]
  0003d	88 45 ff	 mov	 BYTE PTR $T8[ebp], al

; 1396 :         const auto _Begin = _Unchecked_begin();
; 1397 :         if (_First == _Begin && _Last._Ptr->_Isnil) {

  00040	0f b6 45 ff	 movzx	 eax, BYTE PTR $T8[ebp]
  00044	85 c0		 test	 eax, eax
  00046	74 18		 je	 SHORT $LN2@Erase_unch
  00048	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0004b	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  0004f	85 c0		 test	 eax, eax
  00051	74 0d		 je	 SHORT $LN2@Erase_unch

; 1398 :             // erase all
; 1399 :             clear();

  00053	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::clear

; 1400 :             return _Last._Ptr;

  0005b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0005e	eb 6a		 jmp	 SHORT $LN5@Erase_unch
$LN2@Erase_unch:

; 98   :         return _Ptr == _Right._Ptr;

  00060	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00063	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00066	75 09		 jne	 SHORT $LN75@Erase_unch
  00068	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv136[ebp], 1
  0006f	eb 04		 jmp	 SHORT $LN76@Erase_unch
$LN75@Erase_unch:
  00071	83 65 f0 00	 and	 DWORD PTR tv136[ebp], 0
$LN76@Erase_unch:
  00075	8a 45 f0	 mov	 al, BYTE PTR tv136[ebp]
  00078	88 45 fe	 mov	 BYTE PTR $T7[ebp], al

; 102  :         return !(*this == _Right);

  0007b	0f b6 45 fe	 movzx	 eax, BYTE PTR $T7[ebp]
  0007f	85 c0		 test	 eax, eax
  00081	75 09		 jne	 SHORT $LN70@Erase_unch
  00083	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv153[ebp], 1
  0008a	eb 04		 jmp	 SHORT $LN71@Erase_unch
$LN70@Erase_unch:
  0008c	83 65 ec 00	 and	 DWORD PTR tv153[ebp], 0
$LN71@Erase_unch:
  00090	8a 45 ec	 mov	 al, BYTE PTR tv153[ebp]
  00093	88 45 fd	 mov	 BYTE PTR $T6[ebp], al

; 1401 :         }
; 1402 : 
; 1403 :         // partial erase, one at a time
; 1404 :         while (_First != _Last) {

  00096	0f b6 45 fd	 movzx	 eax, BYTE PTR $T6[ebp]
  0009a	85 c0		 test	 eax, eax
  0009c	74 29		 je	 SHORT $LN3@Erase_unch

; 67   :         _Tree_unchecked_const_iterator _Tmp = *this;

  0009e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000a1	89 45 d8	 mov	 DWORD PTR __Tmp$3[ebp], eax

; 68   :         ++*this;

  000a4	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  000a7	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >,std::_Iterator_base0>::operator++

; 69   :         return _Tmp;

  000ac	8b 45 d8	 mov	 eax, DWORD PTR __Tmp$3[ebp]
  000af	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
  000b2	8d 45 d4	 lea	 eax, DWORD PTR $T2[ebp]
  000b5	89 45 d0	 mov	 DWORD PTR $T1[ebp], eax

; 1405 :             _Erase_unchecked(_First++);

  000b8	8b 45 d0	 mov	 eax, DWORD PTR $T1[ebp]
  000bb	ff 30		 push	 DWORD PTR [eax]
  000bd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	e8 00 00 00 00	 call	 ?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Erase_unchecked

; 1406 :         }

  000c5	eb 99		 jmp	 SHORT $LN2@Erase_unch
$LN3@Erase_unch:

; 1407 : 
; 1408 :         return _Last._Ptr;

  000c7	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
$LN5@Erase_unch:

; 1409 :     }

  000ca	c9		 leave
  000cb	c2 08 00	 ret	 8
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Erase_unchecked
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
__Scary$ = -20						; size = 4
$T4 = -16						; size = 4
__Successor$ = -12					; size = 4
__Erasednode$ = -8					; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Erase_unchecked, COMDAT
; _this$ = ecx

; 1385 :     _Nodeptr _Erase_unchecked(_Unchecked_const_iterator _Where) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00012	89 45 ec	 mov	 DWORD PTR __Scary$[ebp], eax

; 1386 :         const auto _Scary                    = _Get_scary();
; 1387 :         _Unchecked_const_iterator _Successor = _Where;

  00015	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00018	89 45 f4	 mov	 DWORD PTR __Successor$[ebp], eax

; 1388 :         ++_Successor; // save successor iterator for return

  0001b	8d 4d f4	 lea	 ecx, DWORD PTR __Successor$[ebp]
  0001e	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >,std::_Iterator_base0>::operator++

; 1389 :         _Nodeptr _Erasednode = _Scary->_Extract(_Where); // node to erase

  00023	ff 75 08	 push	 DWORD PTR __Where$[ebp]
  00026	8b 4d ec	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00029	e8 00 00 00 00	 call	 ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Extract
  0002e	89 45 f8	 mov	 DWORD PTR __Erasednode$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00034	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00037	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  0003a	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax

; 379  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0003d	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00040	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00043	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 380  :         _Freenode0(_Al, _Ptr);

  00046	ff 75 f8	 push	 DWORD PTR __Erasednode$[ebp]
  00049	ff 75 e4	 push	 DWORD PTR $T2[ebp]
  0004c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >
  00051	59		 pop	 ecx
  00052	59		 pop	 ecx

; 1390 :         _Scary->_Orphan_ptr(_Erasednode);
; 1391 :         _Node::_Freenode(_Getal(), _Erasednode); // delete erased node
; 1392 :         return _Successor._Ptr; // return successor nodeptr

  00053	8b 45 f4	 mov	 eax, DWORD PTR __Successor$[ebp]

; 1393 :     }

  00056	c9		 leave
  00057	c2 04 00	 ret	 4
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Erase_unchecked
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
tv68 = -12						; size = 4
$T6 = -8						; size = 4
$T7 = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::max_size, COMDAT
; _this$ = ecx

; 1310 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2043 :         return _Mypair._Myval2._Get_first();

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2043 :         return _Mypair._Myval2._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	c7 45 fc c4 4e
	ec 04		 mov	 DWORD PTR $T7[ebp], 82595524 ; 04ec4ec4H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0001c	c7 45 e8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1311 :         return (_STD min)(

  00023	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00026	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00029	8b 45 fc	 mov	 eax, DWORD PTR $T7[ebp]
  0002c	3b 45 f8	 cmp	 eax, DWORD PTR $T6[ebp]
  0002f	73 08		 jae	 SHORT $LN17@max_size
  00031	8d 45 fc	 lea	 eax, DWORD PTR $T7[ebp]
  00034	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
  00037	eb 06		 jmp	 SHORT $LN18@max_size
$LN17@max_size:
  00039	8d 45 f8	 lea	 eax, DWORD PTR $T6[ebp]
  0003c	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
$LN18@max_size:
  0003f	8b 45 f4	 mov	 eax, DWORD PTR tv68[ebp]
  00042	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  00045	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00048	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1311 :         return (_STD min)(

  0004b	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1312 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1313 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Scary$ = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >, COMDAT
; _this$ = ecx

; 1189 :     ~_Tree() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Scary$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00021	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	ff 70 04	 push	 DWORD PTR [eax+4]
  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >

; 753  :         _Alnode::value_type::_Freenode0(_Al, _Myhead);

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00037	ff 30		 push	 DWORD PTR [eax]
  00039	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonMiniMap::SObserver>,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 1190 :         const auto _Scary = _Get_scary();
; 1191 :         _Scary->_Erase_head(_Getal());
; 1192 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1193 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1194 :         _Delete_plain_internal(_Alproxy, _Scary->_Myproxy);
; 1195 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1196 :     }

  00043	c9		 leave
  00044	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
$T1 = -20						; size = 4
_this$2 = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T3 = -1						; size = 1
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >, COMDAT
; _this$ = ecx

; 885  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0000f	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  00012	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00015	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00018	8a 00		 mov	 al, BYTE PTR [eax]
  0001a	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al
  0001d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00020	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00023	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00029	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  0002c	83 20 00	 and	 DWORD PTR [eax], 0
  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  00032	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 886  :         _Alloc_sentinel_and_proxy();

  00036	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Alloc_sentinel_and_proxy

; 887  :     }

  0003e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	c9		 leave
  00042	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?__UpdateWayPoint@CPythonMiniMap@@IAEXPAUTAtlasMarkInfo@1@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pkInfo$ = 8						; size = 4
_ix$ = 12						; size = 4
_iy$ = 16						; size = 4
?__UpdateWayPoint@CPythonMiniMap@@IAEXPAUTAtlasMarkInfo@1@HH@Z PROC ; CPythonMiniMap::__UpdateWayPoint, COMDAT
; _this$ = ecx

; 1295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1296 : 	pkInfo->m_fX = float(ix);

  00007	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _ix$[ebp]
  0000c	8b 45 08	 mov	 eax, DWORD PTR _pkInfo$[ebp]
  0000f	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 1297 : 	pkInfo->m_fY = float(iy);

  00014	f3 0f 2a 45 10	 cvtsi2ss xmm0, DWORD PTR _iy$[ebp]
  00019	8b 45 08	 mov	 eax, DWORD PTR _pkInfo$[ebp]
  0001c	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 1298 : 	pkInfo->m_fScreenX = pkInfo->m_fX / m_fAtlasMaxX * m_fAtlasImageSizeX;

  00021	8b 45 08	 mov	 eax, DWORD PTR _pkInfo$[ebp]
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0002c	f3 0f 5e 81 28
	03 00 00	 divss	 xmm0, DWORD PTR [ecx+808]
  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	f3 0f 59 80 30
	03 00 00	 mulss	 xmm0, DWORD PTR [eax+816]
  0003f	8b 45 08	 mov	 eax, DWORD PTR _pkInfo$[ebp]
  00042	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 1299 : 	pkInfo->m_fScreenY = pkInfo->m_fY / m_fAtlasMaxY * m_fAtlasImageSizeY;

  00047	8b 45 08	 mov	 eax, DWORD PTR _pkInfo$[ebp]
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00052	f3 0f 5e 81 2c
	03 00 00	 divss	 xmm0, DWORD PTR [ecx+812]
  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	f3 0f 59 80 34
	03 00 00	 mulss	 xmm0, DWORD PTR [eax+820]
  00065	8b 45 08	 mov	 eax, DWORD PTR _pkInfo$[ebp]
  00068	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 1300 : }

  0006d	c9		 leave
  0006e	c2 0c 00	 ret	 12			; 0000000cH
?__UpdateWayPoint@CPythonMiniMap@@IAEXPAUTAtlasMarkInfo@1@HH@Z ENDP ; CPythonMiniMap::__UpdateWayPoint
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?__GetWayPoint@CPythonMiniMap@@IAE_NKPAPAUTAtlasMarkInfo@1@@Z
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
$T5 = -44						; size = 4
___param0$ = -40					; size = 4
___param0$ = -36					; size = 4
_rInfo$6 = -32						; size = 4
tv163 = -28						; size = 4
tv177 = -24						; size = 4
__My_data$7 = -20					; size = 4
_this$ = -16						; size = 4
__My_data$8 = -12					; size = 4
_itor$ = -8						; size = 4
$T9 = -2						; size = 1
$T10 = -1						; size = 1
_dwID$ = 8						; size = 4
_ppkInfo$ = 12						; size = 4
?__GetWayPoint@CPythonMiniMap@@IAE_NKPAPAUTAtlasMarkInfo@1@@Z PROC ; CPythonMiniMap::__GetWayPoint, COMDAT
; _this$ = ecx

; 1279 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 10 0c 00 00	 add	 eax, 3088		; 00000c10H
  00011	89 45 f4	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00014	8b 45 f4	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00017	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0001a	8b 45 f4	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	89 45 dc	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00022	8b 45 dc	 mov	 eax, DWORD PTR ___param0$[ebp]
  00025	89 45 f8	 mov	 DWORD PTR _itor$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1281 : 	for (; itor != m_AtlasWayPointInfoVector.end(); ++itor)

  00028	eb 09		 jmp	 SHORT $LN4@GetWayPoin
$LN2@GetWayPoin:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _itor$[ebp]
  0002d	83 c0 3c	 add	 eax, 60			; 0000003cH
  00030	89 45 f8	 mov	 DWORD PTR _itor$[ebp], eax
$LN4@GetWayPoin:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00033	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00036	05 10 0c 00 00	 add	 eax, 3088		; 00000c10H
  0003b	89 45 ec	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0003e	8b 45 ec	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00041	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00044	8b 45 ec	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00047	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004a	89 45 d8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0004d	8b 45 d8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00050	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00053	8d 45 d4	 lea	 eax, DWORD PTR $T5[ebp]
  00056	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00059	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _itor$[ebp]
  0005f	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00061	75 09		 jne	 SHORT $LN50@GetWayPoin
  00063	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv177[ebp], 1
  0006a	eb 04		 jmp	 SHORT $LN51@GetWayPoin
$LN50@GetWayPoin:
  0006c	83 65 e8 00	 and	 DWORD PTR tv177[ebp], 0
$LN51@GetWayPoin:
  00070	8a 45 e8	 mov	 al, BYTE PTR tv177[ebp]
  00073	88 45 ff	 mov	 BYTE PTR $T10[ebp], al

; 153  :         return !(*this == _Right);

  00076	0f b6 45 ff	 movzx	 eax, BYTE PTR $T10[ebp]
  0007a	85 c0		 test	 eax, eax
  0007c	75 09		 jne	 SHORT $LN45@GetWayPoin
  0007e	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv163[ebp], 1
  00085	eb 04		 jmp	 SHORT $LN46@GetWayPoin
$LN45@GetWayPoin:
  00087	83 65 e4 00	 and	 DWORD PTR tv163[ebp], 0
$LN46@GetWayPoin:
  0008b	8a 45 e4	 mov	 al, BYTE PTR tv163[ebp]
  0008e	88 45 fe	 mov	 BYTE PTR $T9[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1281 : 	for (; itor != m_AtlasWayPointInfoVector.end(); ++itor)

  00091	0f b6 45 fe	 movzx	 eax, BYTE PTR $T9[ebp]
  00095	85 c0		 test	 eax, eax
  00097	74 28		 je	 SHORT $LN3@GetWayPoin
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  00099	8b 45 f8	 mov	 eax, DWORD PTR _itor$[ebp]
  0009c	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  0009f	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  000a2	89 45 e0	 mov	 DWORD PTR _rInfo$6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1284 : 		if (dwID == rInfo.m_dwID)

  000a5	8b 45 e0	 mov	 eax, DWORD PTR _rInfo$6[ebp]
  000a8	8b 4d 08	 mov	 ecx, DWORD PTR _dwID$[ebp]
  000ab	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000ae	75 0c		 jne	 SHORT $LN5@GetWayPoin

; 1285 : 		{
; 1286 : 			*ppkInfo = &rInfo;

  000b0	8b 45 0c	 mov	 eax, DWORD PTR _ppkInfo$[ebp]
  000b3	8b 4d e0	 mov	 ecx, DWORD PTR _rInfo$6[ebp]
  000b6	89 08		 mov	 DWORD PTR [eax], ecx

; 1287 : 			return true;

  000b8	b0 01		 mov	 al, 1
  000ba	eb 07		 jmp	 SHORT $LN1@GetWayPoin
$LN5@GetWayPoin:

; 1288 : 		}
; 1289 : 	}

  000bc	e9 69 ff ff ff	 jmp	 $LN2@GetWayPoin
$LN3@GetWayPoin:

; 1290 : 
; 1291 : 	return false;

  000c1	32 c0		 xor	 al, al
$LN1@GetWayPoin:

; 1292 : }

  000c3	c9		 leave
  000c4	c2 08 00	 ret	 8
?__GetWayPoint@CPythonMiniMap@@IAE_NKPAPAUTAtlasMarkInfo@1@@Z ENDP ; CPythonMiniMap::__GetWayPoint
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CPythonMiniMap::TMarkPosition> >::_Vector_val<std::_Simple_types<CPythonMiniMap::TMarkPosition> >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 20 00	 and	 DWORD PTR [eax], 0
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CPythonMiniMap::TMarkPosition> >::_Vector_val<std::_Simple_types<CPythonMiniMap::TMarkPosition> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@CAXXZ PROC ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@CAXXZ ENDP ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@AAEXXZ PROC ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 75		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@YAXPAUTMarkPosition@CPythonMiniMap@@QAU12@AAV?$allocator@UTMarkPosition@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TMarkPosition> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 0c		 push	 12			; 0000000cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00098	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009b	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009e	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a1	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a4	c9		 leave
  000a5	c3		 ret	 0
?_Tidy@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@AAEXXZ ENDP ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@AAEXQAUTMarkPosition@CPythonMiniMap@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@AAEXQAUTMarkPosition@CPythonMiniMap@@II@Z PROC ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 63		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@YAXPAUTMarkPosition@CPythonMiniMap@@QAU12@AAV?$allocator@UTMarkPosition@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TMarkPosition> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 0c		 push	 12			; 0000000cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00098	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  0009a	6b 45 0c 0c	 imul	 eax, DWORD PTR __Newsize$[ebp], 12
  0009e	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000a1	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a4	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a6	6b 45 10 0c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 12
  000aa	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b0	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b2	c9		 leave
  000b3	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@AAEXQAUTMarkPosition@CPythonMiniMap@@II@Z ENDP ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@ABEII@Z PROC ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	99		 cdq
  0001b	6a 0c		 push	 12			; 0000000cH
  0001d	59		 pop	 ecx
  0001e	f7 f9		 idiv	 ecx
  00020	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00023	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00026	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00029	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  0002c	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002f	c7 45 f0 55 55
	55 15		 mov	 DWORD PTR $T7[ebp], 357913941 ; 15555555H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00036	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003d	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  00040	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00043	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00046	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00049	73 08		 jae	 SHORT $LN25@Calculate_
  0004b	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  00051	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00053	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00056	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  0005c	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00062	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00065	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006d	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00070	d1 e8		 shr	 eax, 1
  00072	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00075	2b c8		 sub	 ecx, eax
  00077	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  0007a	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  0007c	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007f	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00081	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00084	d1 e8		 shr	 eax, 1
  00086	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00089	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  0008c	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008f	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00092	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00094	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00097	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00099	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  0009c	c9		 leave
  0009d	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@ABEII@Z ENDP ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@AAEXPAUTMarkPosition@CPythonMiniMap@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@AAEXPAUTMarkPosition@CPythonMiniMap@@0@Z PROC ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@YAXPAUTMarkPosition@CPythonMiniMap@@QAU12@AAV?$allocator@UTMarkPosition@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TMarkPosition> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@AAEXPAUTMarkPosition@CPythonMiniMap@@0@Z ENDP ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEXXZ PROC ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@YAXPAUTMarkPosition@CPythonMiniMap@@QAU12@AAV?$allocator@UTMarkPosition@CPythonMiniMap@@@0@@Z ; std::_Destroy_range<std::allocator<CPythonMiniMap::TMarkPosition> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEXXZ ENDP ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAE@XZ PROC ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::~vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@AAEXXZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAE@XZ ENDP ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::~vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@QAEXQAUTMarkPosition@CPythonMiniMap@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@QAEXQAUTMarkPosition@CPythonMiniMap@@I@Z PROC ; std::allocator<CPythonMiniMap::TMarkPosition>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	6b 45 0c 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx

; 811  :     }

  00016	c9		 leave
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@QAEXQAUTMarkPosition@CPythonMiniMap@@I@Z ENDP ; std::allocator<CPythonMiniMap::TMarkPosition>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??4TAtlasMarkInfo@CPythonMiniMap@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 1
$T2 = -16						; size = 4
_this$ = -12						; size = 4
__Right$ = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4TAtlasMarkInfo@CPythonMiniMap@@QAEAAU01@$$QAU01@@Z PROC ; CPythonMiniMap::TAtlasMarkInfo::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0000f	8a 09		 mov	 cl, BYTE PTR [ecx]
  00011	88 08		 mov	 BYTE PTR [eax], cl
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00019	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001c	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00025	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00028	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00031	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00034	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0003d	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00040	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00049	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0004c	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00055	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00058	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00061	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00064	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0006d	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00070	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00073	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00076	83 c0 24	 add	 eax, 36			; 00000024H
  00079	89 45 f8	 mov	 DWORD PTR __Right$[ebp], eax
  0007c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	83 c0 24	 add	 eax, 36			; 00000024H
  00082	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00085	8b 45 f8	 mov	 eax, DWORD PTR __Right$[ebp]
  00088	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2665 :         if (this != _STD addressof(_Right)) {

  0008b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	3b 45 f0	 cmp	 eax, DWORD PTR $T2[ebp]
  00091	74 13		 je	 SHORT $LN4@operator

; 2666 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});

  00093	33 c0		 xor	 eax, eax
  00095	88 45 ec	 mov	 BYTE PTR $T1[ebp], al
  00098	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0009b	ff 75 f8	 push	 DWORD PTR __Right$[ebp]
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	e8 00 00 00 00	 call	 ?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign
$LN4@operator:
  000a6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	c9		 leave
  000aa	c2 04 00	 ret	 4
??4TAtlasMarkInfo@CPythonMiniMap@@QAEAAU01@$$QAU01@@Z ENDP ; CPythonMiniMap::TAtlasMarkInfo::operator=
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0TAtlasMarkInfo@CPythonMiniMap@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0TAtlasMarkInfo@CPythonMiniMap@@QAE@$$QAU01@@Z PROC	; CPythonMiniMap::TAtlasMarkInfo::TAtlasMarkInfo, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0000d	8a 09		 mov	 cl, BYTE PTR [ecx]
  0000f	88 08		 mov	 BYTE PTR [eax], cl
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00017	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00023	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00026	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0002f	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00032	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0003b	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0003e	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00047	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0004a	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00053	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00056	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0005f	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00062	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00065	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00068	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0006b	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0006e	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00071	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00074	83 c0 24	 add	 eax, 36			; 00000024H
  00077	50		 push	 eax
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	83 c1 24	 add	 ecx, 36			; 00000024H
  0007e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00083	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00086	c9		 leave
  00087	c2 04 00	 ret	 4
??0TAtlasMarkInfo@CPythonMiniMap@@QAE@$$QAU01@@Z ENDP	; CPythonMiniMap::TAtlasMarkInfo::TAtlasMarkInfo
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0TAtlasMarkInfo@CPythonMiniMap@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0TAtlasMarkInfo@CPythonMiniMap@@QAE@ABU01@@Z PROC	; CPythonMiniMap::TAtlasMarkInfo::TAtlasMarkInfo, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0000d	8a 09		 mov	 cl, BYTE PTR [ecx]
  0000f	88 08		 mov	 BYTE PTR [eax], cl
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00017	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00023	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00026	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0002f	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00032	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0003b	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0003e	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00047	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0004a	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00053	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00056	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0005f	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00062	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00065	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00068	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0006b	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0006e	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00071	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00074	83 c0 24	 add	 eax, 36			; 00000024H
  00077	50		 push	 eax
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	83 c1 24	 add	 ecx, 36			; 00000024H
  0007e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00083	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00086	c9		 leave
  00087	c2 04 00	 ret	 4
??0TAtlasMarkInfo@CPythonMiniMap@@QAE@ABU01@@Z ENDP	; CPythonMiniMap::TAtlasMarkInfo::TAtlasMarkInfo
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1TAtlasMarkInfo@CPythonMiniMap@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1TAtlasMarkInfo@CPythonMiniMap@@QAE@XZ PROC		; CPythonMiniMap::TAtlasMarkInfo::~TAtlasMarkInfo, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 24	 add	 ecx, 36			; 00000024H

; 2801 :         _Tidy_deallocate();

  0000d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00012	c9		 leave
  00013	c3		 ret	 0
??1TAtlasMarkInfo@CPythonMiniMap@@QAE@XZ ENDP		; CPythonMiniMap::TAtlasMarkInfo::~TAtlasMarkInfo
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0TAtlasMarkInfo@CPythonMiniMap@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TAtlasMarkInfo@CPythonMiniMap@@QAE@XZ PROC		; CPythonMiniMap::TAtlasMarkInfo::TAtlasMarkInfo, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 24	 add	 ecx, 36			; 00000024H
  0000d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c9		 leave
  00016	c3		 ret	 0
??0TAtlasMarkInfo@CPythonMiniMap@@QAE@XZ ENDP		; CPythonMiniMap::TAtlasMarkInfo::TAtlasMarkInfo
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?__GlobalPositionToAtlasPosition@CPythonMiniMap@@IAEXJJPAM0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lx$ = 8						; size = 4
_ly$ = 12						; size = 4
_pfx$ = 16						; size = 4
_pfy$ = 20						; size = 4
?__GlobalPositionToAtlasPosition@CPythonMiniMap@@IAEXJJPAM0@Z PROC ; CPythonMiniMap::__GlobalPositionToAtlasPosition, COMDAT
; _this$ = ecx

; 921  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 922  : 	*pfx = lx / m_fAtlasMaxX * m_fAtlasImageSizeX;

  00007	f3 0f 2a 45 08	 cvtsi2ss xmm0, DWORD PTR _lx$[ebp]
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	f3 0f 5e 80 28
	03 00 00	 divss	 xmm0, DWORD PTR [eax+808]
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	f3 0f 59 80 30
	03 00 00	 mulss	 xmm0, DWORD PTR [eax+816]
  00022	8b 45 10	 mov	 eax, DWORD PTR _pfx$[ebp]
  00025	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 923  : 	*pfy = ly / m_fAtlasMaxY * m_fAtlasImageSizeY;

  00029	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _ly$[ebp]
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	f3 0f 5e 80 2c
	03 00 00	 divss	 xmm0, DWORD PTR [eax+812]
  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	f3 0f 59 80 34
	03 00 00	 mulss	 xmm0, DWORD PTR [eax+820]
  00044	8b 45 14	 mov	 eax, DWORD PTR _pfy$[ebp]
  00047	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 924  : }

  0004b	c9		 leave
  0004c	c2 10 00	 ret	 16			; 00000010H
?__GlobalPositionToAtlasPosition@CPythonMiniMap@@IAEXJJPAM0@Z ENDP ; CPythonMiniMap::__GlobalPositionToAtlasPosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?__RenderTargetMark@CPythonMiniMap@@IAEXHH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_iNum$ = -8						; size = 4
_rInstance$ = -4					; size = 4
_ixCenter$ = 8						; size = 4
_iyCenter$ = 12						; size = 4
?__RenderTargetMark@CPythonMiniMap@@IAEXHH@Z PROC	; CPythonMiniMap::__RenderTargetMark, COMDAT
; _this$ = ecx

; 1324 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1325 : 	int iNum = (ELTimer_GetMSec() / 80) % TARGET_MARK_IMAGE_COUNT;

  00009	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0000e	33 d2		 xor	 edx, edx
  00010	6a 50		 push	 80			; 00000050H
  00012	59		 pop	 ecx
  00013	f7 f1		 div	 ecx
  00015	33 d2		 xor	 edx, edx
  00017	6a 02		 push	 2
  00019	59		 pop	 ecx
  0001a	f7 f1		 div	 ecx
  0001c	89 55 f8	 mov	 DWORD PTR _iNum$[ebp], edx

; 1326 : 
; 1327 : 	CGraphicImageInstance & rInstance = m_TargetMarkGraphicImageInstances[iNum];

  0001f	6b 45 f8 4c	 imul	 eax, DWORD PTR _iNum$[ebp], 76
  00023	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8d 84 01 58 0b
	00 00		 lea	 eax, DWORD PTR [ecx+eax+2904]
  0002d	89 45 fc	 mov	 DWORD PTR _rInstance$[ebp], eax

; 1328 : 	rInstance.SetPosition(ixCenter - rInstance.GetWidth()/2, iyCenter - rInstance.GetHeight()/2);

  00030	8b 4d fc	 mov	 ecx, DWORD PTR _rInstance$[ebp]
  00033	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  00038	99		 cdq
  00039	2b c2		 sub	 eax, edx
  0003b	d1 f8		 sar	 eax, 1
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR _iyCenter$[ebp]
  00040	2b c8		 sub	 ecx, eax
  00042	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00046	51		 push	 ecx
  00047	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _rInstance$[ebp]
  0004f	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  00054	99		 cdq
  00055	2b c2		 sub	 eax, edx
  00057	d1 f8		 sar	 eax, 1
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _ixCenter$[ebp]
  0005c	2b c8		 sub	 ecx, eax
  0005e	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00062	51		 push	 ecx
  00063	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00068	8b 4d fc	 mov	 ecx, DWORD PTR _rInstance$[ebp]
  0006b	e8 00 00 00 00	 call	 ?SetPosition@CGraphicImageInstance@@QAEXMM@Z ; CGraphicImageInstance::SetPosition

; 1329 : 	rInstance.Render();

  00070	8b 4d fc	 mov	 ecx, DWORD PTR _rInstance$[ebp]
  00073	e8 00 00 00 00	 call	 ?Render@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Render

; 1330 : }

  00078	c9		 leave
  00079	c2 08 00	 ret	 8
?__RenderTargetMark@CPythonMiniMap@@IAEXHH@Z ENDP	; CPythonMiniMap::__RenderTargetMark
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?__RenderMiniWayPointMark@CPythonMiniMap@@IAEXHH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_iNum$ = -8						; size = 4
_rInstance$ = -4					; size = 4
_ixCenter$ = 8						; size = 4
_iyCenter$ = 12						; size = 4
?__RenderMiniWayPointMark@CPythonMiniMap@@IAEXHH@Z PROC	; CPythonMiniMap::__RenderMiniWayPointMark, COMDAT
; _this$ = ecx

; 1315 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1316 : 	int iNum = (ELTimer_GetMSec() / 67) % MINI_WAYPOINT_IMAGE_COUNT;

  00009	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0000e	33 d2		 xor	 edx, edx
  00010	6a 43		 push	 67			; 00000043H
  00012	59		 pop	 ecx
  00013	f7 f1		 div	 ecx
  00015	33 d2		 xor	 edx, edx
  00017	6a 0c		 push	 12			; 0000000cH
  00019	59		 pop	 ecx
  0001a	f7 f1		 div	 ecx
  0001c	89 55 f8	 mov	 DWORD PTR _iNum$[ebp], edx

; 1317 : 
; 1318 : 	CGraphicImageInstance & rInstance = m_MiniWayPointGraphicImageInstances[iNum];

  0001f	6b 45 f8 4c	 imul	 eax, DWORD PTR _iNum$[ebp], 76
  00023	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8d 84 01 54 03
	00 00		 lea	 eax, DWORD PTR [ecx+eax+852]
  0002d	89 45 fc	 mov	 DWORD PTR _rInstance$[ebp], eax

; 1319 : 	rInstance.SetPosition(ixCenter - rInstance.GetWidth()/2, iyCenter - rInstance.GetHeight()/2);

  00030	8b 4d fc	 mov	 ecx, DWORD PTR _rInstance$[ebp]
  00033	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  00038	99		 cdq
  00039	2b c2		 sub	 eax, edx
  0003b	d1 f8		 sar	 eax, 1
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR _iyCenter$[ebp]
  00040	2b c8		 sub	 ecx, eax
  00042	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00046	51		 push	 ecx
  00047	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _rInstance$[ebp]
  0004f	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  00054	99		 cdq
  00055	2b c2		 sub	 eax, edx
  00057	d1 f8		 sar	 eax, 1
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _ixCenter$[ebp]
  0005c	2b c8		 sub	 ecx, eax
  0005e	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00062	51		 push	 ecx
  00063	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00068	8b 4d fc	 mov	 ecx, DWORD PTR _rInstance$[ebp]
  0006b	e8 00 00 00 00	 call	 ?SetPosition@CGraphicImageInstance@@QAEXMM@Z ; CGraphicImageInstance::SetPosition

; 1320 : 	rInstance.Render();

  00070	8b 4d fc	 mov	 ecx, DWORD PTR _rInstance$[ebp]
  00073	e8 00 00 00 00	 call	 ?Render@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Render

; 1321 : }

  00078	c9		 leave
  00079	c2 08 00	 ret	 8
?__RenderMiniWayPointMark@CPythonMiniMap@@IAEXHH@Z ENDP	; CPythonMiniMap::__RenderMiniWayPointMark
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?__RenderWayPointMark@CPythonMiniMap@@IAEXHH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_iNum$ = -8						; size = 4
_rInstance$ = -4					; size = 4
_ixCenter$ = 8						; size = 4
_iyCenter$ = 12						; size = 4
?__RenderWayPointMark@CPythonMiniMap@@IAEXHH@Z PROC	; CPythonMiniMap::__RenderWayPointMark, COMDAT
; _this$ = ecx

; 1306 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1307 : 	int iNum = (ELTimer_GetMSec() / 67) % WAYPOINT_IMAGE_COUNT;

  00009	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0000e	33 d2		 xor	 edx, edx
  00010	6a 43		 push	 67			; 00000043H
  00012	59		 pop	 ecx
  00013	f7 f1		 div	 ecx
  00015	33 d2		 xor	 edx, edx
  00017	6a 0f		 push	 15			; 0000000fH
  00019	59		 pop	 ecx
  0001a	f7 f1		 div	 ecx
  0001c	89 55 f8	 mov	 DWORD PTR _iNum$[ebp], edx

; 1308 : 
; 1309 : 	CGraphicImageInstance & rInstance = m_WayPointGraphicImageInstances[iNum];

  0001f	6b 45 f8 4c	 imul	 eax, DWORD PTR _iNum$[ebp], 76
  00023	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8d 84 01 e4 06
	00 00		 lea	 eax, DWORD PTR [ecx+eax+1764]
  0002d	89 45 fc	 mov	 DWORD PTR _rInstance$[ebp], eax

; 1310 : 	rInstance.SetPosition(ixCenter - rInstance.GetWidth()/2, iyCenter - rInstance.GetHeight()/2);

  00030	8b 4d fc	 mov	 ecx, DWORD PTR _rInstance$[ebp]
  00033	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  00038	99		 cdq
  00039	2b c2		 sub	 eax, edx
  0003b	d1 f8		 sar	 eax, 1
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR _iyCenter$[ebp]
  00040	2b c8		 sub	 ecx, eax
  00042	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00046	51		 push	 ecx
  00047	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _rInstance$[ebp]
  0004f	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  00054	99		 cdq
  00055	2b c2		 sub	 eax, edx
  00057	d1 f8		 sar	 eax, 1
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _ixCenter$[ebp]
  0005c	2b c8		 sub	 ecx, eax
  0005e	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00062	51		 push	 ecx
  00063	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00068	8b 4d fc	 mov	 ecx, DWORD PTR _rInstance$[ebp]
  0006b	e8 00 00 00 00	 call	 ?SetPosition@CGraphicImageInstance@@QAEXMM@Z ; CGraphicImageInstance::SetPosition

; 1311 : 	rInstance.Render();

  00070	8b 4d fc	 mov	 ecx, DWORD PTR _rInstance$[ebp]
  00073	e8 00 00 00 00	 call	 ?Render@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Render

; 1312 : }

  00078	c9		 leave
  00079	c2 08 00	 ret	 8
?__RenderWayPointMark@CPythonMiniMap@@IAEXHH@Z ENDP	; CPythonMiniMap::__RenderWayPointMark
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ
_TEXT	SEGMENT
$T2 = -188						; size = 8
$T3 = -180						; size = 4
$T4 = -176						; size = 4
$T5 = -172						; size = 4
__My_data$6 = -168					; size = 4
$T7 = -164						; size = 4
$T8 = -160						; size = 4
__My_data$9 = -156					; size = 4
__My_data$10 = -152					; size = 4
$T11 = -148						; size = 4
$T12 = -144						; size = 4
__My_data$13 = -140					; size = 4
$T14 = -136						; size = 4
$T15 = -132						; size = 4
tv765 = -128						; size = 4
tv763 = -124						; size = 4
$T16 = -120						; size = 1
$T17 = -116						; size = 4
$T18 = -112						; size = 4
_c_rstrPositionY$19 = -108				; size = 4
$T20 = -104						; size = 4
_c_rstrPositionX$21 = -100				; size = 4
_c_rstrType$22 = -96					; size = 4
$T23 = -92						; size = 4
$T24 = -88						; size = 4
__Right$ = -84						; size = 4
_this$ = -80						; size = 4
$T25 = -76						; size = 4
$T26 = -72						; size = 4
$T27 = -68						; size = 4
$T28 = -64						; size = 4
_rkMap$ = -60						; size = 4
tv541 = -56						; size = 4
tv341 = -52						; size = 4
_c_rstrText$29 = -48					; size = 4
_rkBG$ = -44						; size = 4
_stTokenVectorMap$ = -40				; size = 8
_rVector$30 = -32					; size = 4
_i$31 = -28						; size = 4
_i$32 = -24						; size = 4
$T33 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T34 = 0						; size = 24
$T35 = 24						; size = 24
_$S16$36 = 48						; size = 24
_$S14$37 = 72						; size = 24
_$S13$38 = 96						; size = 24
_$S15$39 = 120						; size = 24
_aAtlasMarkInfo$40 = 144				; size = 60
_strType$ = 204						; size = 336
_szAtlasMarkInfoFileName$ = 540				; size = 65
_szMarkInfoName$41 = 608				; size = 33
__$ArrayPad$ = 644					; size = 4
?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ PROC	; CPythonMiniMap::__LoadAtlasMarkInfo, COMDAT
; _this$ = ecx

; 803  : {

  00000	55		 push	 ebp
  00001	8d ac 24 78 fd
	ff ff		 lea	 ebp, DWORD PTR [esp-648]
  00008	81 ec 88 02 00
	00		 sub	 esp, 648		; 00000288H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 85 84 02 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002f	50		 push	 eax
  00030	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00033	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00039	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 804  : 	ClearAtlasMarkInfo();

  0003c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?ClearAtlasMarkInfo@CPythonMiniMap@@QAEXXZ ; CPythonMiniMap::ClearAtlasMarkInfo

; 805  : 	ClearGuildArea();

  00044	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?ClearGuildArea@CPythonMiniMap@@QAEXXZ ; CPythonMiniMap::ClearGuildArea

; 806  : 
; 807  : 	CPythonBackground& rkBG=CPythonBackground::Instance();

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  00051	89 45 d4	 mov	 DWORD PTR _rkBG$[ebp], eax

; 808  : 	if (!rkBG.IsMapOutdoor())

  00054	8b 4d d4	 mov	 ecx, DWORD PTR _rkBG$[ebp]
  00057	e8 00 00 00 00	 call	 ?IsMapOutdoor@CMapManager@@QAE_NXZ ; CMapManager::IsMapOutdoor
  0005c	0f b6 c0	 movzx	 eax, al
  0005f	85 c0		 test	 eax, eax
  00061	75 05		 jne	 SHORT $LN10@LoadAtlasM

; 809  : 		return;

  00063	e9 1d 05 00 00	 jmp	 $LN1@LoadAtlasM
$LN10@LoadAtlasM:

; 810  : 
; 811  : 	CMapOutdoor& rkMap=rkBG.GetMapOutdoorRef();

  00068	8b 4d d4	 mov	 ecx, DWORD PTR _rkBG$[ebp]
  0006b	e8 00 00 00 00	 call	 ?GetMapOutdoorRef@CMapManager@@QAEAAVCMapOutdoor@@XZ ; CMapManager::GetMapOutdoorRef
  00070	89 45 c4	 mov	 DWORD PTR _rkMap$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  00073	8b 4d c4	 mov	 ecx, DWORD PTR _rkMap$[ebp]
  00076	83 c1 08	 add	 ecx, 8
  00079	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0007e	89 45 c0	 mov	 DWORD PTR $T28[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 815  : 	_snprintf(szAtlasMarkInfoFileName, sizeof(szAtlasMarkInfoFileName), "%s/map/%s_point.txt", LocaleService_GetLocalePath(), rkMap.GetName().c_str());

  00081	ff 75 c0	 push	 DWORD PTR $T28[ebp]
  00084	e8 00 00 00 00	 call	 ?LocaleService_GetLocalePath@@YAPBDXZ ; LocaleService_GetLocalePath
  00089	50		 push	 eax
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@LGPAIIIP@?$CFs?1map?1?$CFs_point?4txt@
  0008f	6a 41		 push	 65			; 00000041H
  00091	8d 85 1c 02 00
	00		 lea	 eax, DWORD PTR _szAtlasMarkInfoFileName$[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 __snprintf
  0009d	83 c4 14	 add	 esp, 20			; 00000014H

; 816  : 	// END_OF_LOCALE
; 817  : 
; 818  : 	CTokenVectorMap stTokenVectorMap;

  000a0	8d 4d d8	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  000a3	e8 00 00 00 00	 call	 ??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
  000a8	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 819  : 	
; 820  : 	if (!LoadMultipleTextData(szAtlasMarkInfoFileName, stTokenVectorMap))

  000ac	8d 45 d8	 lea	 eax, DWORD PTR _stTokenVectorMap$[ebp]
  000af	50		 push	 eax
  000b0	8d 85 1c 02 00
	00		 lea	 eax, DWORD PTR _szAtlasMarkInfoFileName$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?LoadMultipleTextData@@YA_NPBDAAV?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@@Z ; LoadMultipleTextData
  000bc	59		 pop	 ecx
  000bd	59		 pop	 ecx
  000be	0f b6 c0	 movzx	 eax, al
  000c1	85 c0		 test	 eax, eax
  000c3	75 24		 jne	 SHORT $LN11@LoadAtlasM

; 821  : 	{
; 822  : 		Tracef(" CPythonMiniMap::__LoadAtlasMarkInfo File Load %s ERROR\n", szAtlasMarkInfoFileName);

  000c5	8d 85 1c 02 00
	00		 lea	 eax, DWORD PTR _szAtlasMarkInfoFileName$[ebp]
  000cb	50		 push	 eax
  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@IGENJIBL@?5CPythonMiniMap?3?3__LoadAtlasMar@
  000d1	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  000d6	59		 pop	 ecx
  000d7	59		 pop	 ecx

; 823  : 		return;

  000d8	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000dc	8d 4d d8	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  000df	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
  000e4	e9 9c 04 00 00	 jmp	 $LN1@LoadAtlasM
$LN11@LoadAtlasM:

; 824  : 	}
; 825  : 
; 826  : 	const std::string strType[TYPE_COUNT] = { "OPC", "OPCPVP", "OPCPVPSELF", "NPC", "MONSTER", "WARP", "WAYPOINT" };

  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_03KKCEFKPO@OPC@
  000ee	8d 8d cc 00 00
	00		 lea	 ecx, DWORD PTR _strType$[ebp]
  000f4	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000f9	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_06NKIKAPIL@OPCPVP@
  00102	8d 8d e4 00 00
	00		 lea	 ecx, DWORD PTR _strType$[ebp+24]
  00108	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0010d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00111	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JKLELMDP@OPCPVPSELF@
  00116	8d 8d fc 00 00
	00		 lea	 ecx, DWORD PTR _strType$[ebp+48]
  0011c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00121	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00125	68 00 00 00 00	 push	 OFFSET ??_C@_03BCJIDNJL@NPC@
  0012a	8d 8d 14 01 00
	00		 lea	 ecx, DWORD PTR _strType$[ebp+72]
  00130	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00135	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00139	68 00 00 00 00	 push	 OFFSET ??_C@_07GKFEMEDF@MONSTER@
  0013e	8d 8d 2c 01 00
	00		 lea	 ecx, DWORD PTR _strType$[ebp+96]
  00144	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00149	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0014d	68 00 00 00 00	 push	 OFFSET ??_C@_04EFMFIDOL@WARP@
  00152	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR _strType$[ebp+120]
  00158	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0015d	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00161	68 00 00 00 00	 push	 OFFSET ??_C@_08MIFNEBLL@WAYPOINT@
  00166	8d 8d 5c 01 00
	00		 lea	 ecx, DWORD PTR _strType$[ebp+144]
  0016c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00171	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00175	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0017a	68 00 00 00 00	 push	 OFFSET ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0017f	6a 07		 push	 7
  00181	6a 18		 push	 24			; 00000018H
  00183	8d 85 74 01 00
	00		 lea	 eax, DWORD PTR _strType$[ebp+168]
  00189	50		 push	 eax
  0018a	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  0018f	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8

; 828  : 	for (DWORD i = 0; i < stTokenVectorMap.size(); ++i)

  00193	83 65 e4 00	 and	 DWORD PTR _i$31[ebp], 0
  00197	eb 07		 jmp	 SHORT $LN4@LoadAtlasM
$LN2@LoadAtlasM:
  00199	8b 45 e4	 mov	 eax, DWORD PTR _i$31[ebp]
  0019c	40		 inc	 eax
  0019d	89 45 e4	 mov	 DWORD PTR _i$31[ebp], eax
$LN4@LoadAtlasM:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  001a0	8d 45 d8	 lea	 eax, DWORD PTR _stTokenVectorMap$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  001a3	89 45 bc	 mov	 DWORD PTR $T27[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  001a6	8b 45 bc	 mov	 eax, DWORD PTR $T27[ebp]
  001a9	89 45 b8	 mov	 DWORD PTR $T26[ebp], eax

; 1307 :         return _Get_scary()->_Mysize;

  001ac	8b 45 b8	 mov	 eax, DWORD PTR $T26[ebp]
  001af	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001b2	89 45 b4	 mov	 DWORD PTR $T25[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 828  : 	for (DWORD i = 0; i < stTokenVectorMap.size(); ++i)

  001b5	8b 45 e4	 mov	 eax, DWORD PTR _i$31[ebp]
  001b8	3b 45 b4	 cmp	 eax, DWORD PTR $T25[ebp]
  001bb	0f 83 9f 03 00
	00		 jae	 $LN3@LoadAtlasM

; 829  : 	{
; 830  : 		char szMarkInfoName[32+1];
; 831  : 		_snprintf(szMarkInfoName, sizeof(szMarkInfoName), "%d", i);

  001c1	ff 75 e4	 push	 DWORD PTR _i$31[ebp]
  001c4	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  001c9	6a 21		 push	 33			; 00000021H
  001cb	8d 85 60 02 00
	00		 lea	 eax, DWORD PTR _szMarkInfoName$41[ebp]
  001d1	50		 push	 eax
  001d2	e8 00 00 00 00	 call	 __snprintf
  001d7	83 c4 10	 add	 esp, 16			; 00000010H

; 833  : 		if (stTokenVectorMap.end() == stTokenVectorMap.find(szMarkInfoName))

  001da	8d 85 60 02 00
	00		 lea	 eax, DWORD PTR _szMarkInfoName$41[ebp]
  001e0	50		 push	 eax
  001e1	8d 4d 00	 lea	 ecx, DWORD PTR $T34[ebp]
  001e4	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  001e9	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  001ed	8d 45 00	 lea	 eax, DWORD PTR $T34[ebp]
  001f0	50		 push	 eax
  001f1	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001f7	50		 push	 eax
  001f8	8d 4d d8	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  001fb	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
  00200	89 45 ac	 mov	 DWORD PTR __Right$[ebp], eax
  00203	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00209	50		 push	 eax
  0020a	8d 4d d8	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  0020d	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::end
  00212	89 45 b0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 232  :         return this->_Ptr == _Right._Ptr;

  00215	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00218	8b 4d ac	 mov	 ecx, DWORD PTR __Right$[ebp]
  0021b	8b 00		 mov	 eax, DWORD PTR [eax]
  0021d	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0021f	75 09		 jne	 SHORT $LN240@LoadAtlasM
  00221	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR tv541[ebp], 1
  00228	eb 04		 jmp	 SHORT $LN241@LoadAtlasM
$LN240@LoadAtlasM:
  0022a	83 65 c8 00	 and	 DWORD PTR tv541[ebp], 0
$LN241@LoadAtlasM:
  0022e	8a 45 c8	 mov	 al, BYTE PTR tv541[ebp]
  00231	88 45 ef	 mov	 BYTE PTR $T33[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 833  : 		if (stTokenVectorMap.end() == stTokenVectorMap.find(szMarkInfoName))

  00234	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00238	8d 4d 00	 lea	 ecx, DWORD PTR $T34[ebp]
  0023b	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 833  : 		if (stTokenVectorMap.end() == stTokenVectorMap.find(szMarkInfoName))

  00240	0f b6 45 ef	 movzx	 eax, BYTE PTR $T33[ebp]
  00244	85 c0		 test	 eax, eax
  00246	74 05		 je	 SHORT $LN12@LoadAtlasM

; 834  : 			continue;

  00248	e9 4c ff ff ff	 jmp	 $LN2@LoadAtlasM
$LN12@LoadAtlasM:

; 836  : 		const CTokenVector & rVector = stTokenVectorMap[szMarkInfoName];

  0024d	8d 85 60 02 00
	00		 lea	 eax, DWORD PTR _szMarkInfoName$41[ebp]
  00253	50		 push	 eax
  00254	8d 4d 18	 lea	 ecx, DWORD PTR $T35[ebp]
  00257	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0025c	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00260	8d 45 18	 lea	 eax, DWORD PTR $T35[ebp]
  00263	89 85 54 ff ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 154  :         return _Try_emplace(_STD move(_Keyval)).first->_Myval.second;

  00269	ff b5 54 ff ff
	ff		 push	 DWORD PTR $T5[ebp]
  0026f	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00275	50		 push	 eax
  00276	8d 4d d8	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00279	e8 00 00 00 00	 call	 ??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  0027e	8b 00		 mov	 eax, DWORD PTR [eax]
  00280	83 c0 28	 add	 eax, 40			; 00000028H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 836  : 		const CTokenVector & rVector = stTokenVectorMap[szMarkInfoName];

  00283	89 45 e0	 mov	 DWORD PTR _rVector$30[ebp], eax
  00286	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0028a	8d 4d 18	 lea	 ecx, DWORD PTR $T35[ebp]
  0028d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  00292	8b 45 e0	 mov	 eax, DWORD PTR _rVector$30[ebp]
  00295	89 85 58 ff ff
	ff		 mov	 DWORD PTR __My_data$6[ebp], eax

; 1509 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1510 :         _STL_VERIFY(
; 1511 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1512 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1513 : 
; 1514 :         return _My_data._Myfirst[_Pos];

  0029b	33 c0		 xor	 eax, eax
  0029d	6b c0 18	 imul	 eax, eax, 24
  002a0	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$6[ebp]
  002a6	03 01		 add	 eax, DWORD PTR [ecx]
  002a8	89 85 5c ff ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  002ae	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
  002b4	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  002b9	89 85 60 ff ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 838  : 		const std::string & c_rstrType = rVector[0].c_str();

  002bf	ff b5 60 ff ff
	ff		 push	 DWORD PTR $T8[ebp]
  002c5	8d 4d 60	 lea	 ecx, DWORD PTR _$S13$38[ebp]
  002c8	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  002cd	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  002d1	8d 45 60	 lea	 eax, DWORD PTR _$S13$38[ebp]
  002d4	89 45 a0	 mov	 DWORD PTR _c_rstrType$22[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  002d7	8b 45 e0	 mov	 eax, DWORD PTR _rVector$30[ebp]
  002da	89 85 64 ff ff
	ff		 mov	 DWORD PTR __My_data$9[ebp], eax

; 1509 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1510 :         _STL_VERIFY(
; 1511 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1512 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1513 : 
; 1514 :         return _My_data._Myfirst[_Pos];

  002e0	33 c0		 xor	 eax, eax
  002e2	40		 inc	 eax
  002e3	6b c0 18	 imul	 eax, eax, 24
  002e6	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$9[ebp]
  002ec	03 01		 add	 eax, DWORD PTR [ecx]
  002ee	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  002f4	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR $T11[ebp]
  002fa	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  002ff	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T12[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 839  : 		const std::string & c_rstrPositionX = rVector[1].c_str();

  00305	ff b5 70 ff ff
	ff		 push	 DWORD PTR $T12[ebp]
  0030b	8d 4d 48	 lea	 ecx, DWORD PTR _$S14$37[ebp]
  0030e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00313	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  00317	8d 45 48	 lea	 eax, DWORD PTR _$S14$37[ebp]
  0031a	89 45 9c	 mov	 DWORD PTR _c_rstrPositionX$21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  0031d	8b 45 e0	 mov	 eax, DWORD PTR _rVector$30[ebp]
  00320	89 85 74 ff ff
	ff		 mov	 DWORD PTR __My_data$13[ebp], eax

; 1509 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1510 :         _STL_VERIFY(
; 1511 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1512 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1513 : 
; 1514 :         return _My_data._Myfirst[_Pos];

  00326	6a 02		 push	 2
  00328	58		 pop	 eax
  00329	6b c0 18	 imul	 eax, eax, 24
  0032c	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$13[ebp]
  00332	03 01		 add	 eax, DWORD PTR [ecx]
  00334	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  0033a	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR $T14[ebp]
  00340	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00345	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T15[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 840  : 		const std::string & c_rstrPositionY = rVector[2].c_str();

  0034b	ff b5 7c ff ff
	ff		 push	 DWORD PTR $T15[ebp]
  00351	8d 4d 78	 lea	 ecx, DWORD PTR _$S15$39[ebp]
  00354	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00359	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  0035d	8d 45 78	 lea	 eax, DWORD PTR _$S15$39[ebp]
  00360	89 45 94	 mov	 DWORD PTR _c_rstrPositionY$19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  00363	8b 45 e0	 mov	 eax, DWORD PTR _rVector$30[ebp]
  00366	89 85 68 ff ff
	ff		 mov	 DWORD PTR __My_data$10[ebp], eax

; 1509 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1510 :         _STL_VERIFY(
; 1511 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1512 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1513 : 
; 1514 :         return _My_data._Myfirst[_Pos];

  0036c	6a 03		 push	 3
  0036e	58		 pop	 eax
  0036f	6b c0 18	 imul	 eax, eax, 24
  00372	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$10[ebp]
  00378	03 01		 add	 eax, DWORD PTR [ecx]
  0037a	89 45 a8	 mov	 DWORD PTR $T24[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  0037d	8b 4d a8	 mov	 ecx, DWORD PTR $T24[ebp]
  00380	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00385	89 45 a4	 mov	 DWORD PTR $T23[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 841  : 		const std::string & c_rstrText = rVector[3].c_str();

  00388	ff 75 a4	 push	 DWORD PTR $T23[ebp]
  0038b	8d 4d 30	 lea	 ecx, DWORD PTR _$S16$36[ebp]
  0038e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00393	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  00397	8d 45 30	 lea	 eax, DWORD PTR _$S16$36[ebp]
  0039a	89 45 d0	 mov	 DWORD PTR _c_rstrText$29[ebp], eax
  0039d	8d 8d b4 00 00
	00		 lea	 ecx, DWORD PTR _aAtlasMarkInfo$40[ebp+36]
  003a3	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 842  : 
; 843  : 		TAtlasMarkInfo aAtlasMarkInfo;

  003a8	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH

; 844  : 
; 845  : 		for ( int i = 0; i < TYPE_COUNT; ++i)

  003ac	83 65 e8 00	 and	 DWORD PTR _i$32[ebp], 0
  003b0	eb 07		 jmp	 SHORT $LN7@LoadAtlasM
$LN5@LoadAtlasM:
  003b2	8b 45 e8	 mov	 eax, DWORD PTR _i$32[ebp]
  003b5	40		 inc	 eax
  003b6	89 45 e8	 mov	 DWORD PTR _i$32[ebp], eax
$LN7@LoadAtlasM:
  003b9	83 7d e8 0e	 cmp	 DWORD PTR _i$32[ebp], 14 ; 0000000eH
  003bd	7d 23		 jge	 SHORT $LN6@LoadAtlasM

; 846  : 		{
; 847  : 			if (0 == c_rstrType.compare(strType[i]))

  003bf	6b 45 e8 18	 imul	 eax, DWORD PTR _i$32[ebp], 24
  003c3	8d 84 05 cc 00
	00 00		 lea	 eax, DWORD PTR _strType$[ebp+eax]
  003ca	50		 push	 eax
  003cb	8b 4d a0	 mov	 ecx, DWORD PTR _c_rstrType$22[ebp]
  003ce	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  003d3	85 c0		 test	 eax, eax
  003d5	75 09		 jne	 SHORT $LN13@LoadAtlasM

; 848  : 				aAtlasMarkInfo.m_byType = (BYTE)i;

  003d7	8a 45 e8	 mov	 al, BYTE PTR _i$32[ebp]
  003da	88 85 90 00 00
	00		 mov	 BYTE PTR _aAtlasMarkInfo$40[ebp], al
$LN13@LoadAtlasM:

; 849  : 		}

  003e0	eb d0		 jmp	 SHORT $LN5@LoadAtlasM
$LN6@LoadAtlasM:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  003e2	8b 4d 9c	 mov	 ecx, DWORD PTR _c_rstrPositionX$21[ebp]
  003e5	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  003ea	89 45 98	 mov	 DWORD PTR $T20[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 850  : 		aAtlasMarkInfo.m_fX = atof(c_rstrPositionX.c_str());

  003ed	ff 75 98	 push	 DWORD PTR $T20[ebp]
  003f0	e8 00 00 00 00	 call	 _atof
  003f5	59		 pop	 ecx
  003f6	d9 9d 98 00 00
	00		 fstp	 DWORD PTR _aAtlasMarkInfo$40[ebp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  003fc	8b 4d 94	 mov	 ecx, DWORD PTR _c_rstrPositionY$19[ebp]
  003ff	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00404	89 45 90	 mov	 DWORD PTR $T18[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 851  : 		aAtlasMarkInfo.m_fY = atof(c_rstrPositionY.c_str());

  00407	ff 75 90	 push	 DWORD PTR $T18[ebp]
  0040a	e8 00 00 00 00	 call	 _atof
  0040f	59		 pop	 ecx
  00410	d9 9d 9c 00 00
	00		 fstp	 DWORD PTR _aAtlasMarkInfo$40[ebp+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00416	8b 45 d0	 mov	 eax, DWORD PTR _c_rstrText$29[ebp]
  00419	89 45 8c	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  0041c	8d 85 b4 00 00
	00		 lea	 eax, DWORD PTR _aAtlasMarkInfo$40[ebp+36]
  00422	3b 45 8c	 cmp	 eax, DWORD PTR $T17[ebp]
  00425	74 16		 je	 SHORT $LN394@LoadAtlasM

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  00427	33 c0		 xor	 eax, eax
  00429	88 45 88	 mov	 BYTE PTR $T16[ebp], al
  0042c	ff 75 88	 push	 DWORD PTR $T16[ebp]
  0042f	ff 75 d0	 push	 DWORD PTR _c_rstrText$29[ebp]
  00432	8d 8d b4 00 00
	00		 lea	 ecx, DWORD PTR _aAtlasMarkInfo$40[ebp+36]
  00438	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
$LN394@LoadAtlasM:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 854  : 		aAtlasMarkInfo.m_fScreenX = aAtlasMarkInfo.m_fX / m_fAtlasMaxX * m_fAtlasImageSizeX - (float)m_WhiteMark.GetWidth() / 2.0f;

  0043d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00440	f3 0f 10 85 98
	00 00 00	 movss	 xmm0, DWORD PTR _aAtlasMarkInfo$40[ebp+8]
  00448	f3 0f 5e 80 28
	03 00 00	 divss	 xmm0, DWORD PTR [eax+808]
  00450	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00453	f3 0f 59 80 30
	03 00 00	 mulss	 xmm0, DWORD PTR [eax+816]
  0045b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0045e	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00464	f3 0f 11 45 84	 movss	 DWORD PTR tv763[ebp], xmm0
  00469	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  0046e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00472	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0047a	f3 0f 10 4d 84	 movss	 xmm1, DWORD PTR tv763[ebp]
  0047f	f3 0f 5c c8	 subss	 xmm1, xmm0
  00483	f3 0f 11 8d a0
	00 00 00	 movss	 DWORD PTR _aAtlasMarkInfo$40[ebp+16], xmm1

; 855  : 		aAtlasMarkInfo.m_fScreenY = aAtlasMarkInfo.m_fY / m_fAtlasMaxY * m_fAtlasImageSizeY - (float)m_WhiteMark.GetHeight() / 2.0f;

  0048b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0048e	f3 0f 10 85 9c
	00 00 00	 movss	 xmm0, DWORD PTR _aAtlasMarkInfo$40[ebp+12]
  00496	f3 0f 5e 80 2c
	03 00 00	 divss	 xmm0, DWORD PTR [eax+812]
  0049e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  004a1	f3 0f 59 80 34
	03 00 00	 mulss	 xmm0, DWORD PTR [eax+820]
  004a9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  004ac	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  004b2	f3 0f 11 45 80	 movss	 DWORD PTR tv765[ebp], xmm0
  004b7	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  004bc	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  004c0	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  004c8	f3 0f 10 4d 80	 movss	 xmm1, DWORD PTR tv765[ebp]
  004cd	f3 0f 5c c8	 subss	 xmm1, xmm0
  004d1	f3 0f 11 8d a4
	00 00 00	 movss	 DWORD PTR _aAtlasMarkInfo$40[ebp+20], xmm1

; 856  : 
; 857  : 		switch(aAtlasMarkInfo.m_byType)

  004d9	8a 85 90 00 00
	00		 mov	 al, BYTE PTR _aAtlasMarkInfo$40[ebp]
  004df	88 45 cc	 mov	 BYTE PTR tv341[ebp], al
  004e2	80 7d cc 03	 cmp	 BYTE PTR tv341[ebp], 3
  004e6	74 08		 je	 SHORT $LN14@LoadAtlasM
  004e8	80 7d cc 05	 cmp	 BYTE PTR tv341[ebp], 5
  004ec	74 19		 je	 SHORT $LN15@LoadAtlasM
  004ee	eb 2c		 jmp	 SHORT $LN8@LoadAtlasM
$LN14@LoadAtlasM:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  004f0	8d 85 90 00 00
	00		 lea	 eax, DWORD PTR _aAtlasMarkInfo$40[ebp]
  004f6	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 860  : 				m_AtlasNPCInfoVector.push_back(aAtlasMarkInfo);

  004f7	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  004fa	81 c1 3c 03 00
	00		 add	 ecx, 828		; 0000033cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00500	e8 00 00 00 00	 call	 ??$emplace_back@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEXABUTAtlasMarkInfo@CPythonMiniMap@@@Z ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::emplace_back<CPythonMiniMap::TAtlasMarkInfo const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 861  : 				break;

  00505	eb 15		 jmp	 SHORT $LN8@LoadAtlasM
$LN15@LoadAtlasM:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00507	8d 85 90 00 00
	00		 lea	 eax, DWORD PTR _aAtlasMarkInfo$40[ebp]
  0050d	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 863  : 				m_AtlasWarpInfoVector.push_back(aAtlasMarkInfo);

  0050e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00511	81 c1 48 03 00
	00		 add	 ecx, 840		; 00000348H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00517	e8 00 00 00 00	 call	 ??$emplace_back@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEXABUTAtlasMarkInfo@CPythonMiniMap@@@Z ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::emplace_back<CPythonMiniMap::TAtlasMarkInfo const &>
$LN8@LoadAtlasM:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 866  : 	}

  0051c	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  00520	8d 8d b4 00 00
	00		 lea	 ecx, DWORD PTR _aAtlasMarkInfo$40[ebp+36]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00526	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 866  : 	}

  0052b	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0052f	8d 4d 30	 lea	 ecx, DWORD PTR _$S16$36[ebp]
  00532	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 866  : 	}

  00537	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0053b	8d 4d 78	 lea	 ecx, DWORD PTR _$S15$39[ebp]
  0053e	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 866  : 	}

  00543	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00547	8d 4d 48	 lea	 ecx, DWORD PTR _$S14$37[ebp]
  0054a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 866  : 	}

  0054f	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00553	8d 4d 60	 lea	 ecx, DWORD PTR _$S13$38[ebp]
  00556	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 866  : 	}

  0055b	e9 39 fc ff ff	 jmp	 $LN2@LoadAtlasM
$LN3@LoadAtlasM:

; 867  : }

  00560	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00564	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00569	6a 0e		 push	 14			; 0000000eH
  0056b	6a 18		 push	 24			; 00000018H
  0056d	8d 85 cc 00 00
	00		 lea	 eax, DWORD PTR _strType$[ebp]
  00573	50		 push	 eax
  00574	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00579	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0057d	8d 4d d8	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00580	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
$LN1@LoadAtlasM:
  00585	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00588	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0058f	59		 pop	 ecx
  00590	8b 8d 84 02 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00596	33 cd		 xor	 ecx, ebp
  00598	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0059d	81 c5 88 02 00
	00		 add	 ebp, 648		; 00000288H
  005a3	c9		 leave
  005a4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ
__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$1:
  00008	8d 8d cc 00 00
	00		 lea	 ecx, DWORD PTR _strType$[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$2:
  00013	8d 8d e4 00 00
	00		 lea	 ecx, DWORD PTR _strType$[ebp+24]
  00019	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$3:
  0001e	8d 8d fc 00 00
	00		 lea	 ecx, DWORD PTR _strType$[ebp+48]
  00024	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$4:
  00029	8d 8d 14 01 00
	00		 lea	 ecx, DWORD PTR _strType$[ebp+72]
  0002f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$5:
  00034	8d 8d 2c 01 00
	00		 lea	 ecx, DWORD PTR _strType$[ebp+96]
  0003a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$6:
  0003f	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR _strType$[ebp+120]
  00045	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$7:
  0004a	8d 8d 5c 01 00
	00		 lea	 ecx, DWORD PTR _strType$[ebp+144]
  00050	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$9:
  00055	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0005a	6a 0e		 push	 14			; 0000000eH
  0005c	6a 18		 push	 24			; 00000018H
  0005e	8d 85 cc 00 00
	00		 lea	 eax, DWORD PTR _strType$[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0006a	c3		 ret	 0
__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$10:
  0006b	8d 4d 00	 lea	 ecx, DWORD PTR $T34[ebp]
  0006e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$11:
  00073	8d 4d 18	 lea	 ecx, DWORD PTR $T35[ebp]
  00076	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$12:
  0007b	8d 4d 60	 lea	 ecx, DWORD PTR _$S13$38[ebp]
  0007e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$13:
  00083	8d 4d 48	 lea	 ecx, DWORD PTR _$S14$37[ebp]
  00086	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$14:
  0008b	8d 4d 78	 lea	 ecx, DWORD PTR _$S15$39[ebp]
  0008e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$15:
  00093	8d 4d 30	 lea	 ecx, DWORD PTR _$S16$36[ebp]
  00096	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ$16:
  0009b	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR _aAtlasMarkInfo$40[ebp]
  000a1	e9 00 00 00 00	 jmp	 ??1TAtlasMarkInfo@CPythonMiniMap@@QAE@XZ
  000a6	cc		 int	 3
  000a7	cc		 int	 3
  000a8	cc		 int	 3
  000a9	cc		 int	 3
  000aa	cc		 int	 3
__ehhandler$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ:
  000ab	90		 npad	 1
  000ac	90		 npad	 1
  000ad	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000b1	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000b4	8b 8a 4c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-180]
  000ba	33 c8		 xor	 ecx, eax
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b 8a 90 02 00
	00		 mov	 ecx, DWORD PTR [edx+656]
  000c7	33 c8		 xor	 ecx, eax
  000c9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ce	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ
  000d3	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ ENDP	; CPythonMiniMap::__LoadAtlasMarkInfo
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?__SetPosition@CPythonMiniMap@@IAEXXZ
_TEXT	SEGMENT
tv348 = -12						; size = 4
tv346 = -8						; size = 4
_this$ = -4						; size = 4
?__SetPosition@CPythonMiniMap@@IAEXXZ PROC		; CPythonMiniMap::__SetPosition, COMDAT
; _this$ = ecx

; 666  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 667  : 	m_fMiniMapRadius = fMIN(6400.0f / ((float) CTerrainImpl::CELLSCALE) * m_fScale, 64.0f);

  00009	51		 push	 ecx
  0000a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42800000
  00012	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42000000
  00022	f3 0f 59 40 10	 mulss	 xmm0, DWORD PTR [eax+16]
  00027	51		 push	 ecx
  00028	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0002d	e8 00 00 00 00	 call	 ?fMIN@@YAMMM@Z		; fMIN
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	d9 58 2c	 fstp	 DWORD PTR [eax+44]

; 668  : 
; 669  : 	m_matWorld._11 = m_fWidth * m_fScale;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00045	f3 0f 59 41 10	 mulss	 xmm0, DWORD PTR [ecx+16]
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	f3 0f 11 80 e8
	01 00 00	 movss	 DWORD PTR [eax+488], xmm0

; 670  : 	m_matWorld._22 = m_fHeight * m_fScale;

  00055	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00060	f3 0f 59 41 10	 mulss	 xmm0, DWORD PTR [ecx+16]
  00065	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00068	f3 0f 11 80 fc
	01 00 00	 movss	 DWORD PTR [eax+508], xmm0

; 671  : 	m_matWorld._41 = (1.0f + m_fScale) * m_fWidth * 0.5f - m_fCenterCellX * m_fScale + m_fScreenX;

  00070	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00073	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0007b	f3 0f 58 40 10	 addss	 xmm0, DWORD PTR [eax+16]
  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  00088	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00090	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	f3 0f 10 48 1c	 movss	 xmm1, DWORD PTR [eax+28]
  0009b	f3 0f 59 49 10	 mulss	 xmm1, DWORD PTR [ecx+16]
  000a0	f3 0f 5c c1	 subss	 xmm0, xmm1
  000a4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a7	f3 0f 58 40 24	 addss	 xmm0, DWORD PTR [eax+36]
  000ac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000af	f3 0f 11 80 18
	02 00 00	 movss	 DWORD PTR [eax+536], xmm0

; 672  : 	m_matWorld._42 = (1.0f + m_fScale) * m_fHeight * 0.5f - m_fCenterCellY * m_fScale + m_fScreenY;

  000b7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ba	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000c2	f3 0f 58 40 10	 addss	 xmm0, DWORD PTR [eax+16]
  000c7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ca	f3 0f 59 40 0c	 mulss	 xmm0, DWORD PTR [eax+12]
  000cf	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  000d7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000da	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000dd	f3 0f 10 48 20	 movss	 xmm1, DWORD PTR [eax+32]
  000e2	f3 0f 59 49 10	 mulss	 xmm1, DWORD PTR [ecx+16]
  000e7	f3 0f 5c c1	 subss	 xmm0, xmm1
  000eb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ee	f3 0f 58 40 28	 addss	 xmm0, DWORD PTR [eax+40]
  000f3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f6	f3 0f 11 80 1c
	02 00 00	 movss	 DWORD PTR [eax+540], xmm0

; 673  : 
; 674  : 	if (!m_MiniMapFilterGraphicImageInstance.IsEmpty())

  000fe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00101	83 c1 54	 add	 ecx, 84			; 00000054H
  00104	e8 00 00 00 00	 call	 ?IsEmpty@CGraphicImageInstance@@QBE_NXZ ; CGraphicImageInstance::IsEmpty
  00109	0f b6 c0	 movzx	 eax, al
  0010c	85 c0		 test	 eax, eax
  0010e	75 6e		 jne	 SHORT $LN2@SetPositio

; 675  : 	{
; 676  : 		m_matMiniMapCover._41 = -(m_fScreenX) / ((float)m_MiniMapFilterGraphicImageInstance.GetWidth());

  00110	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00113	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00118	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0011f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00122	83 c1 54	 add	 ecx, 84			; 00000054H
  00125	f3 0f 11 45 f8	 movss	 DWORD PTR tv346[ebp], xmm0
  0012a	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  0012f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00133	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR tv346[ebp]
  00138	f3 0f 5e c8	 divss	 xmm1, xmm0
  0013c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0013f	f3 0f 11 88 58
	02 00 00	 movss	 DWORD PTR [eax+600], xmm1

; 677  : 		m_matMiniMapCover._42 = -(m_fScreenY) / ((float)m_MiniMapFilterGraphicImageInstance.GetHeight());

  00147	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0014a	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [eax+40]
  0014f	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00156	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00159	83 c1 54	 add	 ecx, 84			; 00000054H
  0015c	f3 0f 11 45 f4	 movss	 DWORD PTR tv348[ebp], xmm0
  00161	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  00166	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0016a	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR tv348[ebp]
  0016f	f3 0f 5e c8	 divss	 xmm1, xmm0
  00173	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00176	f3 0f 11 88 5c
	02 00 00	 movss	 DWORD PTR [eax+604], xmm1
$LN2@SetPositio:

; 678  : 	}
; 679  : 
; 680  : 	if (!m_PlayerMark.IsEmpty())

  0017e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00181	81 c1 c0 00 00
	00		 add	 ecx, 192		; 000000c0H
  00187	e8 00 00 00 00	 call	 ?IsEmpty@CGraphicImageInstance@@QBE_NXZ ; CGraphicImageInstance::IsEmpty
  0018c	0f b6 c0	 movzx	 eax, al
  0018f	85 c0		 test	 eax, eax
  00191	75 76		 jne	 SHORT $LN3@SetPositio

; 681  : 		m_PlayerMark.SetPosition( ( m_fWidth - (float)m_PlayerMark.GetWidth() ) / 2.0f + m_fScreenX,

  00193	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00196	81 c1 c0 00 00
	00		 add	 ecx, 192		; 000000c0H
  0019c	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  001a1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001a8	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [eax+12]
  001ad	f3 0f 5c c8	 subss	 xmm1, xmm0
  001b1	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  001b9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001bc	f3 0f 58 48 28	 addss	 xmm1, DWORD PTR [eax+40]
  001c1	51		 push	 ecx
  001c2	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  001c7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ca	81 c1 c0 00 00
	00		 add	 ecx, 192		; 000000c0H
  001d0	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  001d5	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001dc	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  001e1	f3 0f 5c c8	 subss	 xmm1, xmm0
  001e5	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  001ed	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001f0	f3 0f 58 48 24	 addss	 xmm1, DWORD PTR [eax+36]
  001f5	51		 push	 ecx
  001f6	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  001fb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001fe	81 c1 c0 00 00
	00		 add	 ecx, 192		; 000000c0H
  00204	e8 00 00 00 00	 call	 ?SetPosition@CGraphicImageInstance@@QAEXMM@Z ; CGraphicImageInstance::SetPosition
$LN3@SetPositio:

; 682  : 		( m_fHeight - (float)m_PlayerMark.GetHeight() ) / 2.0f  + m_fScreenY );
; 683  : 
; 684  : 	if (!m_MiniMapCameraraphicImageInstance.IsEmpty())

  00209	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0020c	83 c1 74	 add	 ecx, 116		; 00000074H
  0020f	e8 00 00 00 00	 call	 ?IsEmpty@CGraphicImageInstance@@QBE_NXZ ; CGraphicImageInstance::IsEmpty
  00214	0f b6 c0	 movzx	 eax, al
  00217	85 c0		 test	 eax, eax
  00219	75 6d		 jne	 SHORT $LN4@SetPositio

; 685  : 		m_MiniMapCameraraphicImageInstance.SetPosition( ( m_fWidth - (float)m_MiniMapCameraraphicImageInstance.GetWidth() ) / 2.0f + m_fScreenX,

  0021b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0021e	83 c1 74	 add	 ecx, 116		; 00000074H
  00221	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  00226	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0022a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0022d	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [eax+12]
  00232	f3 0f 5c c8	 subss	 xmm1, xmm0
  00236	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  0023e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00241	f3 0f 58 48 28	 addss	 xmm1, DWORD PTR [eax+40]
  00246	51		 push	 ecx
  00247	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  0024c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0024f	83 c1 74	 add	 ecx, 116		; 00000074H
  00252	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  00257	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0025b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0025e	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  00263	f3 0f 5c c8	 subss	 xmm1, xmm0
  00267	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  0026f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00272	f3 0f 58 48 24	 addss	 xmm1, DWORD PTR [eax+36]
  00277	51		 push	 ecx
  00278	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  0027d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00280	83 c1 74	 add	 ecx, 116		; 00000074H
  00283	e8 00 00 00 00	 call	 ?SetPosition@CGraphicImageInstance@@QAEXMM@Z ; CGraphicImageInstance::SetPosition
$LN4@SetPositio:

; 686  : 		( m_fHeight - (float)m_MiniMapCameraraphicImageInstance.GetHeight() ) / 2.0f  + m_fScreenY );
; 687  : }

  00288	c9		 leave
  00289	c3		 ret	 0
?__SetPosition@CPythonMiniMap@@IAEXXZ ENDP		; CPythonMiniMap::__SetPosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?__Initialize@CPythonMiniMap@@IAEXXZ
_TEXT	SEGMENT
_pOut$ = -20						; size = 4
_pOut$ = -16						; size = 4
_pOut$ = -12						; size = 4
_pOut$ = -8						; size = 4
_this$ = -4						; size = 4
?__Initialize@CPythonMiniMap@@IAEXXZ PROC		; CPythonMiniMap::__Initialize, COMDAT
; _this$ = ecx

; 1423 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1424 : 	m_poHandler = 0;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 a0 34 0c 00
	00 00		 and	 DWORD PTR [eax+3124], 0

; 1425 : 
; 1426 : 	SetMiniMapSize(128.0f, 128.0f);

  00013	51		 push	 ecx
  00014	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@43000000
  0001c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00021	51		 push	 ecx
  00022	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@43000000
  0002a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?SetMiniMapSize@CPythonMiniMap@@QAEXMM@Z ; CPythonMiniMap::SetMiniMapSize

; 1427 : 
; 1428 : 	m_fScale = 2.0f;

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00042	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 1429 : 
; 1430 : 	m_fCenterX = m_fWidth * 0.5f;

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0004f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 1431 : 	m_fCenterY = m_fHeight * 0.5f;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00067	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0006f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00072	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0

; 1432 : 
; 1433 : 	m_fScreenX = 0.0f;

  00077	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	0f 57 c0	 xorps	 xmm0, xmm0
  0007d	f3 0f 11 40 24	 movss	 DWORD PTR [eax+36], xmm0

; 1434 : 	m_fScreenY = 0.0f;

  00082	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00085	0f 57 c0	 xorps	 xmm0, xmm0
  00088	f3 0f 11 40 28	 movss	 DWORD PTR [eax+40], xmm0

; 1435 : 
; 1436 : 	m_fAtlasScreenX = 0.0f;

  0008d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00090	0f 57 c0	 xorps	 xmm0, xmm0
  00093	f3 0f 11 80 18
	03 00 00	 movss	 DWORD PTR [eax+792], xmm0

; 1437 : 	m_fAtlasScreenY = 0.0f;

  0009b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	0f 57 c0	 xorps	 xmm0, xmm0
  000a1	f3 0f 11 80 1c
	03 00 00	 movss	 DWORD PTR [eax+796], xmm0

; 1438 : 
; 1439 : 	m_dwAtlasBaseX = 0;

  000a9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	83 a0 20 03 00
	00 00		 and	 DWORD PTR [eax+800], 0

; 1440 : 	m_dwAtlasBaseY = 0;

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	83 a0 24 03 00
	00 00		 and	 DWORD PTR [eax+804], 0

; 1441 : 
; 1442 : 	m_fAtlasMaxX = 0.0f;

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	0f 57 c0	 xorps	 xmm0, xmm0
  000c3	f3 0f 11 80 28
	03 00 00	 movss	 DWORD PTR [eax+808], xmm0

; 1443 : 	m_fAtlasMaxY = 0.0f;

  000cb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ce	0f 57 c0	 xorps	 xmm0, xmm0
  000d1	f3 0f 11 80 2c
	03 00 00	 movss	 DWORD PTR [eax+812], xmm0

; 1444 : 	
; 1445 : 	m_fAtlasImageSizeX = 0.0f;

  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	0f 57 c0	 xorps	 xmm0, xmm0
  000df	f3 0f 11 80 30
	03 00 00	 movss	 DWORD PTR [eax+816], xmm0

; 1446 : 	m_fAtlasImageSizeY = 0.0f;

  000e7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ea	0f 57 c0	 xorps	 xmm0, xmm0
  000ed	f3 0f 11 80 34
	03 00 00	 movss	 DWORD PTR [eax+820], xmm0

; 1447 : 
; 1448 : 	m_bAtlas = false;

  000f5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	c6 80 70 01 00
	00 00		 mov	 BYTE PTR [eax+368], 0

; 1449 : 	
; 1450 : 	m_bShow = false;

  000ff	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00102	c6 80 71 01 00
	00 00		 mov	 BYTE PTR [eax+369], 0

; 1451 : 	m_bShowAtlas = false;

  00109	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0010c	c6 80 68 02 00
	00 00		 mov	 BYTE PTR [eax+616], 0

; 1452 : 
; 1453 : 	D3DXMatrixIdentity(&m_matIdentity);

  00113	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00116	05 a8 01 00 00	 add	 eax, 424		; 000001a8H
  0011b	89 45 f8	 mov	 DWORD PTR _pOut$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  0011e	6a 10		 push	 16			; 00000010H
  00120	58		 pop	 eax
  00121	6b c0 03	 imul	 eax, eax, 3
  00124	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00127	6a 04		 push	 4
  00129	59		 pop	 ecx
  0012a	d1 e1		 shl	 ecx, 1
  0012c	0f 57 c0	 xorps	 xmm0, xmm0
  0012f	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00134	6a 10		 push	 16			; 00000010H
  00136	58		 pop	 eax
  00137	6b c0 03	 imul	 eax, eax, 3
  0013a	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  0013d	6a 04		 push	 4
  0013f	59		 pop	 ecx
  00140	c1 e1 00	 shl	 ecx, 0
  00143	0f 57 c0	 xorps	 xmm0, xmm0
  00146	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0014b	6a 10		 push	 16			; 00000010H
  0014d	58		 pop	 eax
  0014e	6b c0 03	 imul	 eax, eax, 3
  00151	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00154	6a 04		 push	 4
  00156	59		 pop	 ecx
  00157	6b c9 00	 imul	 ecx, ecx, 0
  0015a	0f 57 c0	 xorps	 xmm0, xmm0
  0015d	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00162	6a 10		 push	 16			; 00000010H
  00164	58		 pop	 eax
  00165	d1 e0		 shl	 eax, 1
  00167	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  0016a	6a 04		 push	 4
  0016c	59		 pop	 ecx
  0016d	6b c9 03	 imul	 ecx, ecx, 3
  00170	0f 57 c0	 xorps	 xmm0, xmm0
  00173	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00178	6a 10		 push	 16			; 00000010H
  0017a	58		 pop	 eax
  0017b	d1 e0		 shl	 eax, 1
  0017d	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00180	6a 04		 push	 4
  00182	59		 pop	 ecx
  00183	c1 e1 00	 shl	 ecx, 0
  00186	0f 57 c0	 xorps	 xmm0, xmm0
  00189	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0018e	6a 10		 push	 16			; 00000010H
  00190	58		 pop	 eax
  00191	d1 e0		 shl	 eax, 1
  00193	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00196	6a 04		 push	 4
  00198	59		 pop	 ecx
  00199	6b c9 00	 imul	 ecx, ecx, 0
  0019c	0f 57 c0	 xorps	 xmm0, xmm0
  0019f	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001a4	6a 10		 push	 16			; 00000010H
  001a6	58		 pop	 eax
  001a7	c1 e0 00	 shl	 eax, 0
  001aa	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  001ad	6a 04		 push	 4
  001af	59		 pop	 ecx
  001b0	6b c9 03	 imul	 ecx, ecx, 3
  001b3	0f 57 c0	 xorps	 xmm0, xmm0
  001b6	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001bb	6a 10		 push	 16			; 00000010H
  001bd	58		 pop	 eax
  001be	c1 e0 00	 shl	 eax, 0
  001c1	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  001c4	6a 04		 push	 4
  001c6	59		 pop	 ecx
  001c7	d1 e1		 shl	 ecx, 1
  001c9	0f 57 c0	 xorps	 xmm0, xmm0
  001cc	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001d1	6a 10		 push	 16			; 00000010H
  001d3	58		 pop	 eax
  001d4	c1 e0 00	 shl	 eax, 0
  001d7	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  001da	6a 04		 push	 4
  001dc	59		 pop	 ecx
  001dd	6b c9 00	 imul	 ecx, ecx, 0
  001e0	0f 57 c0	 xorps	 xmm0, xmm0
  001e3	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001e8	6a 10		 push	 16			; 00000010H
  001ea	58		 pop	 eax
  001eb	6b c0 00	 imul	 eax, eax, 0
  001ee	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  001f1	6a 04		 push	 4
  001f3	59		 pop	 ecx
  001f4	6b c9 03	 imul	 ecx, ecx, 3
  001f7	0f 57 c0	 xorps	 xmm0, xmm0
  001fa	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001ff	6a 10		 push	 16			; 00000010H
  00201	58		 pop	 eax
  00202	6b c0 00	 imul	 eax, eax, 0
  00205	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00208	6a 04		 push	 4
  0020a	59		 pop	 ecx
  0020b	d1 e1		 shl	 ecx, 1
  0020d	0f 57 c0	 xorps	 xmm0, xmm0
  00210	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00215	6a 10		 push	 16			; 00000010H
  00217	58		 pop	 eax
  00218	6b c0 00	 imul	 eax, eax, 0
  0021b	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  0021e	6a 04		 push	 4
  00220	59		 pop	 ecx
  00221	c1 e1 00	 shl	 ecx, 0
  00224	0f 57 c0	 xorps	 xmm0, xmm0
  00227	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  0022c	6a 10		 push	 16			; 00000010H
  0022e	58		 pop	 eax
  0022f	6b c0 03	 imul	 eax, eax, 3
  00232	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00235	6a 04		 push	 4
  00237	59		 pop	 ecx
  00238	6b c9 03	 imul	 ecx, ecx, 3
  0023b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00243	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00248	6a 10		 push	 16			; 00000010H
  0024a	58		 pop	 eax
  0024b	d1 e0		 shl	 eax, 1
  0024d	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00250	6a 04		 push	 4
  00252	59		 pop	 ecx
  00253	d1 e1		 shl	 ecx, 1
  00255	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0025d	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00262	6a 10		 push	 16			; 00000010H
  00264	58		 pop	 eax
  00265	c1 e0 00	 shl	 eax, 0
  00268	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  0026b	6a 04		 push	 4
  0026d	59		 pop	 ecx
  0026e	c1 e1 00	 shl	 ecx, 0
  00271	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00279	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0027e	6a 10		 push	 16			; 00000010H
  00280	58		 pop	 eax
  00281	6b c0 00	 imul	 eax, eax, 0
  00284	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00287	6a 04		 push	 4
  00289	59		 pop	 ecx
  0028a	6b c9 00	 imul	 ecx, ecx, 0
  0028d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00295	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1454 : 	D3DXMatrixIdentity(&m_matWorld);

  0029a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0029d	05 e8 01 00 00	 add	 eax, 488		; 000001e8H
  002a2	89 45 f4	 mov	 DWORD PTR _pOut$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  002a5	6a 10		 push	 16			; 00000010H
  002a7	58		 pop	 eax
  002a8	6b c0 03	 imul	 eax, eax, 3
  002ab	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  002ae	6a 04		 push	 4
  002b0	59		 pop	 ecx
  002b1	d1 e1		 shl	 ecx, 1
  002b3	0f 57 c0	 xorps	 xmm0, xmm0
  002b6	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  002bb	6a 10		 push	 16			; 00000010H
  002bd	58		 pop	 eax
  002be	6b c0 03	 imul	 eax, eax, 3
  002c1	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  002c4	6a 04		 push	 4
  002c6	59		 pop	 ecx
  002c7	c1 e1 00	 shl	 ecx, 0
  002ca	0f 57 c0	 xorps	 xmm0, xmm0
  002cd	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  002d2	6a 10		 push	 16			; 00000010H
  002d4	58		 pop	 eax
  002d5	6b c0 03	 imul	 eax, eax, 3
  002d8	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  002db	6a 04		 push	 4
  002dd	59		 pop	 ecx
  002de	6b c9 00	 imul	 ecx, ecx, 0
  002e1	0f 57 c0	 xorps	 xmm0, xmm0
  002e4	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  002e9	6a 10		 push	 16			; 00000010H
  002eb	58		 pop	 eax
  002ec	d1 e0		 shl	 eax, 1
  002ee	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  002f1	6a 04		 push	 4
  002f3	59		 pop	 ecx
  002f4	6b c9 03	 imul	 ecx, ecx, 3
  002f7	0f 57 c0	 xorps	 xmm0, xmm0
  002fa	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  002ff	6a 10		 push	 16			; 00000010H
  00301	58		 pop	 eax
  00302	d1 e0		 shl	 eax, 1
  00304	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  00307	6a 04		 push	 4
  00309	59		 pop	 ecx
  0030a	c1 e1 00	 shl	 ecx, 0
  0030d	0f 57 c0	 xorps	 xmm0, xmm0
  00310	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00315	6a 10		 push	 16			; 00000010H
  00317	58		 pop	 eax
  00318	d1 e0		 shl	 eax, 1
  0031a	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  0031d	6a 04		 push	 4
  0031f	59		 pop	 ecx
  00320	6b c9 00	 imul	 ecx, ecx, 0
  00323	0f 57 c0	 xorps	 xmm0, xmm0
  00326	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0032b	6a 10		 push	 16			; 00000010H
  0032d	58		 pop	 eax
  0032e	c1 e0 00	 shl	 eax, 0
  00331	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  00334	6a 04		 push	 4
  00336	59		 pop	 ecx
  00337	6b c9 03	 imul	 ecx, ecx, 3
  0033a	0f 57 c0	 xorps	 xmm0, xmm0
  0033d	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00342	6a 10		 push	 16			; 00000010H
  00344	58		 pop	 eax
  00345	c1 e0 00	 shl	 eax, 0
  00348	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  0034b	6a 04		 push	 4
  0034d	59		 pop	 ecx
  0034e	d1 e1		 shl	 ecx, 1
  00350	0f 57 c0	 xorps	 xmm0, xmm0
  00353	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00358	6a 10		 push	 16			; 00000010H
  0035a	58		 pop	 eax
  0035b	c1 e0 00	 shl	 eax, 0
  0035e	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  00361	6a 04		 push	 4
  00363	59		 pop	 ecx
  00364	6b c9 00	 imul	 ecx, ecx, 0
  00367	0f 57 c0	 xorps	 xmm0, xmm0
  0036a	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0036f	6a 10		 push	 16			; 00000010H
  00371	58		 pop	 eax
  00372	6b c0 00	 imul	 eax, eax, 0
  00375	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  00378	6a 04		 push	 4
  0037a	59		 pop	 ecx
  0037b	6b c9 03	 imul	 ecx, ecx, 3
  0037e	0f 57 c0	 xorps	 xmm0, xmm0
  00381	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00386	6a 10		 push	 16			; 00000010H
  00388	58		 pop	 eax
  00389	6b c0 00	 imul	 eax, eax, 0
  0038c	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  0038f	6a 04		 push	 4
  00391	59		 pop	 ecx
  00392	d1 e1		 shl	 ecx, 1
  00394	0f 57 c0	 xorps	 xmm0, xmm0
  00397	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0039c	6a 10		 push	 16			; 00000010H
  0039e	58		 pop	 eax
  0039f	6b c0 00	 imul	 eax, eax, 0
  003a2	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  003a5	6a 04		 push	 4
  003a7	59		 pop	 ecx
  003a8	c1 e1 00	 shl	 ecx, 0
  003ab	0f 57 c0	 xorps	 xmm0, xmm0
  003ae	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  003b3	6a 10		 push	 16			; 00000010H
  003b5	58		 pop	 eax
  003b6	6b c0 03	 imul	 eax, eax, 3
  003b9	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  003bc	6a 04		 push	 4
  003be	59		 pop	 ecx
  003bf	6b c9 03	 imul	 ecx, ecx, 3
  003c2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003ca	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  003cf	6a 10		 push	 16			; 00000010H
  003d1	58		 pop	 eax
  003d2	d1 e0		 shl	 eax, 1
  003d4	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  003d7	6a 04		 push	 4
  003d9	59		 pop	 ecx
  003da	d1 e1		 shl	 ecx, 1
  003dc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003e4	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  003e9	6a 10		 push	 16			; 00000010H
  003eb	58		 pop	 eax
  003ec	c1 e0 00	 shl	 eax, 0
  003ef	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  003f2	6a 04		 push	 4
  003f4	59		 pop	 ecx
  003f5	c1 e1 00	 shl	 ecx, 0
  003f8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00400	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00405	6a 10		 push	 16			; 00000010H
  00407	58		 pop	 eax
  00408	6b c0 00	 imul	 eax, eax, 0
  0040b	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  0040e	6a 04		 push	 4
  00410	59		 pop	 ecx
  00411	6b c9 00	 imul	 ecx, ecx, 0
  00414	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0041c	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1455 : 	D3DXMatrixIdentity(&m_matMiniMapCover);

  00421	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00424	05 28 02 00 00	 add	 eax, 552		; 00000228H
  00429	89 45 f0	 mov	 DWORD PTR _pOut$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  0042c	6a 10		 push	 16			; 00000010H
  0042e	58		 pop	 eax
  0042f	6b c0 03	 imul	 eax, eax, 3
  00432	03 45 f0	 add	 eax, DWORD PTR _pOut$[ebp]
  00435	6a 04		 push	 4
  00437	59		 pop	 ecx
  00438	d1 e1		 shl	 ecx, 1
  0043a	0f 57 c0	 xorps	 xmm0, xmm0
  0043d	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00442	6a 10		 push	 16			; 00000010H
  00444	58		 pop	 eax
  00445	6b c0 03	 imul	 eax, eax, 3
  00448	03 45 f0	 add	 eax, DWORD PTR _pOut$[ebp]
  0044b	6a 04		 push	 4
  0044d	59		 pop	 ecx
  0044e	c1 e1 00	 shl	 ecx, 0
  00451	0f 57 c0	 xorps	 xmm0, xmm0
  00454	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00459	6a 10		 push	 16			; 00000010H
  0045b	58		 pop	 eax
  0045c	6b c0 03	 imul	 eax, eax, 3
  0045f	03 45 f0	 add	 eax, DWORD PTR _pOut$[ebp]
  00462	6a 04		 push	 4
  00464	59		 pop	 ecx
  00465	6b c9 00	 imul	 ecx, ecx, 0
  00468	0f 57 c0	 xorps	 xmm0, xmm0
  0046b	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00470	6a 10		 push	 16			; 00000010H
  00472	58		 pop	 eax
  00473	d1 e0		 shl	 eax, 1
  00475	03 45 f0	 add	 eax, DWORD PTR _pOut$[ebp]
  00478	6a 04		 push	 4
  0047a	59		 pop	 ecx
  0047b	6b c9 03	 imul	 ecx, ecx, 3
  0047e	0f 57 c0	 xorps	 xmm0, xmm0
  00481	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00486	6a 10		 push	 16			; 00000010H
  00488	58		 pop	 eax
  00489	d1 e0		 shl	 eax, 1
  0048b	03 45 f0	 add	 eax, DWORD PTR _pOut$[ebp]
  0048e	6a 04		 push	 4
  00490	59		 pop	 ecx
  00491	c1 e1 00	 shl	 ecx, 0
  00494	0f 57 c0	 xorps	 xmm0, xmm0
  00497	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0049c	6a 10		 push	 16			; 00000010H
  0049e	58		 pop	 eax
  0049f	d1 e0		 shl	 eax, 1
  004a1	03 45 f0	 add	 eax, DWORD PTR _pOut$[ebp]
  004a4	6a 04		 push	 4
  004a6	59		 pop	 ecx
  004a7	6b c9 00	 imul	 ecx, ecx, 0
  004aa	0f 57 c0	 xorps	 xmm0, xmm0
  004ad	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  004b2	6a 10		 push	 16			; 00000010H
  004b4	58		 pop	 eax
  004b5	c1 e0 00	 shl	 eax, 0
  004b8	03 45 f0	 add	 eax, DWORD PTR _pOut$[ebp]
  004bb	6a 04		 push	 4
  004bd	59		 pop	 ecx
  004be	6b c9 03	 imul	 ecx, ecx, 3
  004c1	0f 57 c0	 xorps	 xmm0, xmm0
  004c4	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  004c9	6a 10		 push	 16			; 00000010H
  004cb	58		 pop	 eax
  004cc	c1 e0 00	 shl	 eax, 0
  004cf	03 45 f0	 add	 eax, DWORD PTR _pOut$[ebp]
  004d2	6a 04		 push	 4
  004d4	59		 pop	 ecx
  004d5	d1 e1		 shl	 ecx, 1
  004d7	0f 57 c0	 xorps	 xmm0, xmm0
  004da	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  004df	6a 10		 push	 16			; 00000010H
  004e1	58		 pop	 eax
  004e2	c1 e0 00	 shl	 eax, 0
  004e5	03 45 f0	 add	 eax, DWORD PTR _pOut$[ebp]
  004e8	6a 04		 push	 4
  004ea	59		 pop	 ecx
  004eb	6b c9 00	 imul	 ecx, ecx, 0
  004ee	0f 57 c0	 xorps	 xmm0, xmm0
  004f1	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  004f6	6a 10		 push	 16			; 00000010H
  004f8	58		 pop	 eax
  004f9	6b c0 00	 imul	 eax, eax, 0
  004fc	03 45 f0	 add	 eax, DWORD PTR _pOut$[ebp]
  004ff	6a 04		 push	 4
  00501	59		 pop	 ecx
  00502	6b c9 03	 imul	 ecx, ecx, 3
  00505	0f 57 c0	 xorps	 xmm0, xmm0
  00508	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0050d	6a 10		 push	 16			; 00000010H
  0050f	58		 pop	 eax
  00510	6b c0 00	 imul	 eax, eax, 0
  00513	03 45 f0	 add	 eax, DWORD PTR _pOut$[ebp]
  00516	6a 04		 push	 4
  00518	59		 pop	 ecx
  00519	d1 e1		 shl	 ecx, 1
  0051b	0f 57 c0	 xorps	 xmm0, xmm0
  0051e	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00523	6a 10		 push	 16			; 00000010H
  00525	58		 pop	 eax
  00526	6b c0 00	 imul	 eax, eax, 0
  00529	03 45 f0	 add	 eax, DWORD PTR _pOut$[ebp]
  0052c	6a 04		 push	 4
  0052e	59		 pop	 ecx
  0052f	c1 e1 00	 shl	 ecx, 0
  00532	0f 57 c0	 xorps	 xmm0, xmm0
  00535	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  0053a	6a 10		 push	 16			; 00000010H
  0053c	58		 pop	 eax
  0053d	6b c0 03	 imul	 eax, eax, 3
  00540	03 45 f0	 add	 eax, DWORD PTR _pOut$[ebp]
  00543	6a 04		 push	 4
  00545	59		 pop	 ecx
  00546	6b c9 03	 imul	 ecx, ecx, 3
  00549	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00551	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00556	6a 10		 push	 16			; 00000010H
  00558	58		 pop	 eax
  00559	d1 e0		 shl	 eax, 1
  0055b	03 45 f0	 add	 eax, DWORD PTR _pOut$[ebp]
  0055e	6a 04		 push	 4
  00560	59		 pop	 ecx
  00561	d1 e1		 shl	 ecx, 1
  00563	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0056b	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00570	6a 10		 push	 16			; 00000010H
  00572	58		 pop	 eax
  00573	c1 e0 00	 shl	 eax, 0
  00576	03 45 f0	 add	 eax, DWORD PTR _pOut$[ebp]
  00579	6a 04		 push	 4
  0057b	59		 pop	 ecx
  0057c	c1 e1 00	 shl	 ecx, 0
  0057f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00587	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0058c	6a 10		 push	 16			; 00000010H
  0058e	58		 pop	 eax
  0058f	6b c0 00	 imul	 eax, eax, 0
  00592	03 45 f0	 add	 eax, DWORD PTR _pOut$[ebp]
  00595	6a 04		 push	 4
  00597	59		 pop	 ecx
  00598	6b c9 00	 imul	 ecx, ecx, 0
  0059b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  005a3	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1456 : 	D3DXMatrixIdentity(&m_matWorldAtlas);

  005a8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005ab	05 8c 02 00 00	 add	 eax, 652		; 0000028cH
  005b0	89 45 ec	 mov	 DWORD PTR _pOut$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  005b3	6a 10		 push	 16			; 00000010H
  005b5	58		 pop	 eax
  005b6	6b c0 03	 imul	 eax, eax, 3
  005b9	03 45 ec	 add	 eax, DWORD PTR _pOut$[ebp]
  005bc	6a 04		 push	 4
  005be	59		 pop	 ecx
  005bf	d1 e1		 shl	 ecx, 1
  005c1	0f 57 c0	 xorps	 xmm0, xmm0
  005c4	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  005c9	6a 10		 push	 16			; 00000010H
  005cb	58		 pop	 eax
  005cc	6b c0 03	 imul	 eax, eax, 3
  005cf	03 45 ec	 add	 eax, DWORD PTR _pOut$[ebp]
  005d2	6a 04		 push	 4
  005d4	59		 pop	 ecx
  005d5	c1 e1 00	 shl	 ecx, 0
  005d8	0f 57 c0	 xorps	 xmm0, xmm0
  005db	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  005e0	6a 10		 push	 16			; 00000010H
  005e2	58		 pop	 eax
  005e3	6b c0 03	 imul	 eax, eax, 3
  005e6	03 45 ec	 add	 eax, DWORD PTR _pOut$[ebp]
  005e9	6a 04		 push	 4
  005eb	59		 pop	 ecx
  005ec	6b c9 00	 imul	 ecx, ecx, 0
  005ef	0f 57 c0	 xorps	 xmm0, xmm0
  005f2	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  005f7	6a 10		 push	 16			; 00000010H
  005f9	58		 pop	 eax
  005fa	d1 e0		 shl	 eax, 1
  005fc	03 45 ec	 add	 eax, DWORD PTR _pOut$[ebp]
  005ff	6a 04		 push	 4
  00601	59		 pop	 ecx
  00602	6b c9 03	 imul	 ecx, ecx, 3
  00605	0f 57 c0	 xorps	 xmm0, xmm0
  00608	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0060d	6a 10		 push	 16			; 00000010H
  0060f	58		 pop	 eax
  00610	d1 e0		 shl	 eax, 1
  00612	03 45 ec	 add	 eax, DWORD PTR _pOut$[ebp]
  00615	6a 04		 push	 4
  00617	59		 pop	 ecx
  00618	c1 e1 00	 shl	 ecx, 0
  0061b	0f 57 c0	 xorps	 xmm0, xmm0
  0061e	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00623	6a 10		 push	 16			; 00000010H
  00625	58		 pop	 eax
  00626	d1 e0		 shl	 eax, 1
  00628	03 45 ec	 add	 eax, DWORD PTR _pOut$[ebp]
  0062b	6a 04		 push	 4
  0062d	59		 pop	 ecx
  0062e	6b c9 00	 imul	 ecx, ecx, 0
  00631	0f 57 c0	 xorps	 xmm0, xmm0
  00634	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00639	6a 10		 push	 16			; 00000010H
  0063b	58		 pop	 eax
  0063c	c1 e0 00	 shl	 eax, 0
  0063f	03 45 ec	 add	 eax, DWORD PTR _pOut$[ebp]
  00642	6a 04		 push	 4
  00644	59		 pop	 ecx
  00645	6b c9 03	 imul	 ecx, ecx, 3
  00648	0f 57 c0	 xorps	 xmm0, xmm0
  0064b	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00650	6a 10		 push	 16			; 00000010H
  00652	58		 pop	 eax
  00653	c1 e0 00	 shl	 eax, 0
  00656	03 45 ec	 add	 eax, DWORD PTR _pOut$[ebp]
  00659	6a 04		 push	 4
  0065b	59		 pop	 ecx
  0065c	d1 e1		 shl	 ecx, 1
  0065e	0f 57 c0	 xorps	 xmm0, xmm0
  00661	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00666	6a 10		 push	 16			; 00000010H
  00668	58		 pop	 eax
  00669	c1 e0 00	 shl	 eax, 0
  0066c	03 45 ec	 add	 eax, DWORD PTR _pOut$[ebp]
  0066f	6a 04		 push	 4
  00671	59		 pop	 ecx
  00672	6b c9 00	 imul	 ecx, ecx, 0
  00675	0f 57 c0	 xorps	 xmm0, xmm0
  00678	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0067d	6a 10		 push	 16			; 00000010H
  0067f	58		 pop	 eax
  00680	6b c0 00	 imul	 eax, eax, 0
  00683	03 45 ec	 add	 eax, DWORD PTR _pOut$[ebp]
  00686	6a 04		 push	 4
  00688	59		 pop	 ecx
  00689	6b c9 03	 imul	 ecx, ecx, 3
  0068c	0f 57 c0	 xorps	 xmm0, xmm0
  0068f	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00694	6a 10		 push	 16			; 00000010H
  00696	58		 pop	 eax
  00697	6b c0 00	 imul	 eax, eax, 0
  0069a	03 45 ec	 add	 eax, DWORD PTR _pOut$[ebp]
  0069d	6a 04		 push	 4
  0069f	59		 pop	 ecx
  006a0	d1 e1		 shl	 ecx, 1
  006a2	0f 57 c0	 xorps	 xmm0, xmm0
  006a5	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  006aa	6a 10		 push	 16			; 00000010H
  006ac	58		 pop	 eax
  006ad	6b c0 00	 imul	 eax, eax, 0
  006b0	03 45 ec	 add	 eax, DWORD PTR _pOut$[ebp]
  006b3	6a 04		 push	 4
  006b5	59		 pop	 ecx
  006b6	c1 e1 00	 shl	 ecx, 0
  006b9	0f 57 c0	 xorps	 xmm0, xmm0
  006bc	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  006c1	6a 10		 push	 16			; 00000010H
  006c3	58		 pop	 eax
  006c4	6b c0 03	 imul	 eax, eax, 3
  006c7	03 45 ec	 add	 eax, DWORD PTR _pOut$[ebp]
  006ca	6a 04		 push	 4
  006cc	59		 pop	 ecx
  006cd	6b c9 03	 imul	 ecx, ecx, 3
  006d0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  006d8	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  006dd	6a 10		 push	 16			; 00000010H
  006df	58		 pop	 eax
  006e0	d1 e0		 shl	 eax, 1
  006e2	03 45 ec	 add	 eax, DWORD PTR _pOut$[ebp]
  006e5	6a 04		 push	 4
  006e7	59		 pop	 ecx
  006e8	d1 e1		 shl	 ecx, 1
  006ea	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  006f2	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  006f7	6a 10		 push	 16			; 00000010H
  006f9	58		 pop	 eax
  006fa	c1 e0 00	 shl	 eax, 0
  006fd	03 45 ec	 add	 eax, DWORD PTR _pOut$[ebp]
  00700	6a 04		 push	 4
  00702	59		 pop	 ecx
  00703	c1 e1 00	 shl	 ecx, 0
  00706	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0070e	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00713	6a 10		 push	 16			; 00000010H
  00715	58		 pop	 eax
  00716	6b c0 00	 imul	 eax, eax, 0
  00719	03 45 ec	 add	 eax, DWORD PTR _pOut$[ebp]
  0071c	6a 04		 push	 4
  0071e	59		 pop	 ecx
  0071f	6b c9 00	 imul	 ecx, ecx, 0
  00722	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0072a	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1457 : }

  0072f	c9		 leave
  00730	c3		 ret	 0
?__Initialize@CPythonMiniMap@@IAEXXZ ENDP		; CPythonMiniMap::__Initialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?DeleteTarget@CPythonMiniMap@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iID$ = 8						; size = 4
?DeleteTarget@CPythonMiniMap@@QAEXH@Z PROC		; CPythonMiniMap::DeleteTarget, COMDAT
; _this$ = ecx

; 798  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 799  : 	RemoveWayPoint(iID);

  00007	ff 75 08	 push	 DWORD PTR _iID$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ?RemoveWayPoint@CPythonMiniMap@@QAEXK@Z ; CPythonMiniMap::RemoveWayPoint

; 800  : }

  00012	c9		 leave
  00013	c2 04 00	 ret	 4
?DeleteTarget@CPythonMiniMap@@QAEXH@Z ENDP		; CPythonMiniMap::DeleteTarget
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?UpdateTarget@CPythonMiniMap@@QAEXHHH@Z
_TEXT	SEGMENT
tv78 = -12						; size = 4
_pkInfo$ = -8						; size = 4
_this$ = -4						; size = 4
_iID$ = 8						; size = 4
_ix$ = 12						; size = 4
_iy$ = 16						; size = 4
?UpdateTarget@CPythonMiniMap@@QAEXHHH@Z PROC		; CPythonMiniMap::UpdateTarget, COMDAT
; _this$ = ecx

; 769  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 770  : 	TAtlasMarkInfo * pkInfo;
; 771  : 	if (!__GetWayPoint(iID, &pkInfo))

  00009	8d 45 f8	 lea	 eax, DWORD PTR _pkInfo$[ebp]
  0000c	50		 push	 eax
  0000d	ff 75 08	 push	 DWORD PTR _iID$[ebp]
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?__GetWayPoint@CPythonMiniMap@@IAE_NKPAPAUTAtlasMarkInfo@1@@Z ; CPythonMiniMap::__GetWayPoint
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	75 05		 jne	 SHORT $LN2@UpdateTarg

; 772  : 		return;

  0001f	e9 b3 00 00 00	 jmp	 $LN1@UpdateTarg
$LN2@UpdateTarg:

; 773  : 
; 774  : 	if (0 != pkInfo->m_dwChrVID)

  00024	8b 45 f8	 mov	 eax, DWORD PTR _pkInfo$[ebp]
  00027	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0002b	74 25		 je	 SHORT $LN4@UpdateTarg

; 775  : 	{
; 776  : 		if (CPythonCharacterManager::Instance().GetInstancePtr(pkInfo->m_dwChrVID))

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  00032	83 c0 04	 add	 eax, 4
  00035	89 45 f4	 mov	 DWORD PTR tv78[ebp], eax
  00038	8b 45 f8	 mov	 eax, DWORD PTR _pkInfo$[ebp]
  0003b	ff 70 20	 push	 DWORD PTR [eax+32]
  0003e	8b 45 f4	 mov	 eax, DWORD PTR tv78[ebp]
  00041	8b 00		 mov	 eax, DWORD PTR [eax]
  00043	8b 4d f4	 mov	 ecx, DWORD PTR tv78[ebp]
  00046	ff 50 08	 call	 DWORD PTR [eax+8]
  00049	85 c0		 test	 eax, eax
  0004b	74 05		 je	 SHORT $LN4@UpdateTarg

; 777  : 			return;

  0004d	e9 85 00 00 00	 jmp	 $LN1@UpdateTarg
$LN4@UpdateTarg:

; 778  : 	}
; 779  : 
; 780  : 	if (ix < m_dwAtlasBaseX)

  00052	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b 4d 0c	 mov	 ecx, DWORD PTR _ix$[ebp]
  00058	3b 88 20 03 00
	00		 cmp	 ecx, DWORD PTR [eax+800]
  0005e	73 02		 jae	 SHORT $LN5@UpdateTarg

; 781  : 		return;

  00060	eb 75		 jmp	 SHORT $LN1@UpdateTarg
$LN5@UpdateTarg:

; 782  : 	if (iy < m_dwAtlasBaseY)

  00062	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00065	8b 4d 10	 mov	 ecx, DWORD PTR _iy$[ebp]
  00068	3b 88 24 03 00
	00		 cmp	 ecx, DWORD PTR [eax+804]
  0006e	73 02		 jae	 SHORT $LN6@UpdateTarg

; 783  : 		return;

  00070	eb 65		 jmp	 SHORT $LN1@UpdateTarg
$LN6@UpdateTarg:

; 784  : 	if (ix > m_dwAtlasBaseX+DWORD(m_fAtlasMaxX))

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	f3 0f 10 80 28
	03 00 00	 movss	 xmm0, DWORD PTR [eax+808]
  0007d	e8 00 00 00 00	 call	 __ftoui3
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	03 81 20 03 00
	00		 add	 eax, DWORD PTR [ecx+800]
  0008b	39 45 0c	 cmp	 DWORD PTR _ix$[ebp], eax
  0008e	76 02		 jbe	 SHORT $LN7@UpdateTarg

; 785  : 		return;

  00090	eb 45		 jmp	 SHORT $LN1@UpdateTarg
$LN7@UpdateTarg:

; 786  : 	if (iy > m_dwAtlasBaseY+DWORD(m_fAtlasMaxY))

  00092	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00095	f3 0f 10 80 2c
	03 00 00	 movss	 xmm0, DWORD PTR [eax+812]
  0009d	e8 00 00 00 00	 call	 __ftoui3
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	03 81 24 03 00
	00		 add	 eax, DWORD PTR [ecx+804]
  000ab	39 45 10	 cmp	 DWORD PTR _iy$[ebp], eax
  000ae	76 02		 jbe	 SHORT $LN8@UpdateTarg

; 787  : 		return;

  000b0	eb 25		 jmp	 SHORT $LN1@UpdateTarg
$LN8@UpdateTarg:

; 788  : 
; 789  : 	__UpdateWayPoint(pkInfo, ix-int(m_dwAtlasBaseX), iy-int(m_dwAtlasBaseY));

  000b2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	8b 4d 10	 mov	 ecx, DWORD PTR _iy$[ebp]
  000b8	2b 88 24 03 00
	00		 sub	 ecx, DWORD PTR [eax+804]
  000be	51		 push	 ecx
  000bf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	8b 4d 0c	 mov	 ecx, DWORD PTR _ix$[ebp]
  000c5	2b 88 20 03 00
	00		 sub	 ecx, DWORD PTR [eax+800]
  000cb	51		 push	 ecx
  000cc	ff 75 f8	 push	 DWORD PTR _pkInfo$[ebp]
  000cf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d2	e8 00 00 00 00	 call	 ?__UpdateWayPoint@CPythonMiniMap@@IAEXPAUTAtlasMarkInfo@1@HH@Z ; CPythonMiniMap::__UpdateWayPoint
$LN1@UpdateTarg:

; 790  : }

  000d7	c9		 leave
  000d8	c2 0c 00	 ret	 12			; 0000000cH
?UpdateTarget@CPythonMiniMap@@QAEXHHH@Z ENDP		; CPythonMiniMap::UpdateTarget
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?CreateTarget@CPythonMiniMap@@QAEXHPBDK@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_iID$ = 8						; size = 4
_c_szName$ = 12						; size = 4
_dwVID$ = 16						; size = 4
?CreateTarget@CPythonMiniMap@@QAEXHPBDK@Z PROC		; CPythonMiniMap::CreateTarget, COMDAT
; _this$ = ecx

; 793  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 794  : 	AddWayPoint(TYPE_TARGET, iID, 0.0f, 0.0f, c_szName, dwVID);

  00008	ff 75 10	 push	 DWORD PTR _dwVID$[ebp]
  0000b	83 ec 18	 sub	 esp, 24			; 00000018H
  0000e	8b cc		 mov	 ecx, esp
  00010	89 65 f8	 mov	 DWORD PTR $T1[ebp], esp
  00013	ff 75 0c	 push	 DWORD PTR _c_szName$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001b	51		 push	 ecx
  0001c	0f 57 c0	 xorps	 xmm0, xmm0
  0001f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00024	51		 push	 ecx
  00025	0f 57 c0	 xorps	 xmm0, xmm0
  00028	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0002d	ff 75 08	 push	 DWORD PTR _iID$[ebp]
  00030	6a 0d		 push	 13			; 0000000dH
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?AddWayPoint@CPythonMiniMap@@QAEXEKMMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CPythonMiniMap::AddWayPoint

; 795  : }

  0003a	c9		 leave
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?CreateTarget@CPythonMiniMap@@QAEXHPBDK@Z ENDP		; CPythonMiniMap::CreateTarget
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?CreateTarget@CPythonMiniMap@@QAEXHPBD@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_iID$ = 8						; size = 4
_c_szName$ = 12						; size = 4
?CreateTarget@CPythonMiniMap@@QAEXHPBD@Z PROC		; CPythonMiniMap::CreateTarget, COMDAT
; _this$ = ecx

; 764  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 765  : 	AddWayPoint(TYPE_TARGET, iID, 0.0f, 0.0f, c_szName);

  00008	6a 00		 push	 0
  0000a	83 ec 18	 sub	 esp, 24			; 00000018H
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 f8	 mov	 DWORD PTR $T1[ebp], esp
  00012	ff 75 0c	 push	 DWORD PTR _c_szName$[ebp]
  00015	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001a	51		 push	 ecx
  0001b	0f 57 c0	 xorps	 xmm0, xmm0
  0001e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00023	51		 push	 ecx
  00024	0f 57 c0	 xorps	 xmm0, xmm0
  00027	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0002c	ff 75 08	 push	 DWORD PTR _iID$[ebp]
  0002f	6a 0d		 push	 13			; 0000000dH
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ?AddWayPoint@CPythonMiniMap@@QAEXEKMMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CPythonMiniMap::AddWayPoint

; 766  : }

  00039	c9		 leave
  0003a	c2 08 00	 ret	 8
?CreateTarget@CPythonMiniMap@@QAEXHPBD@Z ENDP		; CPythonMiniMap::CreateTarget
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?GetGuildAreaID@CPythonMiniMap@@QAEKKK@Z
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
$T5 = -44						; size = 4
___param0$ = -40					; size = 4
___param0$ = -36					; size = 4
tv174 = -32						; size = 4
tv188 = -28						; size = 4
__My_data$6 = -24					; size = 4
_this$ = -20						; size = 4
__My_data$7 = -16					; size = 4
_itor$ = -12						; size = 4
_rAreaInfo$8 = -8					; size = 4
$T9 = -2						; size = 1
$T10 = -1						; size = 1
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?GetGuildAreaID@CPythonMiniMap@@QAEKKK@Z PROC		; CPythonMiniMap::GetGuildAreaID, COMDAT
; _this$ = ecx

; 745  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 1c 0c 00 00	 add	 eax, 3100		; 00000c1cH
  00011	89 45 f0	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00014	8b 45 f0	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00017	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0001a	8b 45 f0	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	89 45 dc	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00022	8b 45 dc	 mov	 eax, DWORD PTR ___param0$[ebp]
  00025	89 45 f4	 mov	 DWORD PTR _itor$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 747  : 	for (; itor != m_GuildAreaInfoVector.end(); ++itor)

  00028	eb 09		 jmp	 SHORT $LN4@GetGuildAr
$LN2@GetGuildAr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  0002a	8b 45 f4	 mov	 eax, DWORD PTR _itor$[ebp]
  0002d	83 c0 24	 add	 eax, 36			; 00000024H
  00030	89 45 f4	 mov	 DWORD PTR _itor$[ebp], eax
$LN4@GetGuildAr:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00033	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00036	05 1c 0c 00 00	 add	 eax, 3100		; 00000c1cH
  0003b	89 45 e8	 mov	 DWORD PTR __My_data$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0003e	8b 45 e8	 mov	 eax, DWORD PTR __My_data$6[ebp]
  00041	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00044	8b 45 e8	 mov	 eax, DWORD PTR __My_data$6[ebp]
  00047	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004a	89 45 d8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0004d	8b 45 d8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00050	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00053	8d 45 d4	 lea	 eax, DWORD PTR $T5[ebp]
  00056	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00059	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR _itor$[ebp]
  0005f	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00061	75 09		 jne	 SHORT $LN53@GetGuildAr
  00063	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv188[ebp], 1
  0006a	eb 04		 jmp	 SHORT $LN54@GetGuildAr
$LN53@GetGuildAr:
  0006c	83 65 e4 00	 and	 DWORD PTR tv188[ebp], 0
$LN54@GetGuildAr:
  00070	8a 45 e4	 mov	 al, BYTE PTR tv188[ebp]
  00073	88 45 ff	 mov	 BYTE PTR $T10[ebp], al

; 153  :         return !(*this == _Right);

  00076	0f b6 45 ff	 movzx	 eax, BYTE PTR $T10[ebp]
  0007a	85 c0		 test	 eax, eax
  0007c	75 09		 jne	 SHORT $LN48@GetGuildAr
  0007e	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv174[ebp], 1
  00085	eb 04		 jmp	 SHORT $LN49@GetGuildAr
$LN48@GetGuildAr:
  00087	83 65 e0 00	 and	 DWORD PTR tv174[ebp], 0
$LN49@GetGuildAr:
  0008b	8a 45 e0	 mov	 al, BYTE PTR tv174[ebp]
  0008e	88 45 fe	 mov	 BYTE PTR $T9[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 747  : 	for (; itor != m_GuildAreaInfoVector.end(); ++itor)

  00091	0f b6 45 fe	 movzx	 eax, BYTE PTR $T9[ebp]
  00095	85 c0		 test	 eax, eax
  00097	74 50		 je	 SHORT $LN3@GetGuildAr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  00099	8b 45 f4	 mov	 eax, DWORD PTR _itor$[ebp]
  0009c	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  0009f	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  000a2	89 45 f8	 mov	 DWORD PTR _rAreaInfo$8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 751  : 		if (x >= rAreaInfo.lx)

  000a5	8b 45 f8	 mov	 eax, DWORD PTR _rAreaInfo$8[ebp]
  000a8	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  000ab	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000ae	72 34		 jb	 SHORT $LN5@GetGuildAr

; 752  : 		if (y >= rAreaInfo.ly)

  000b0	8b 45 f8	 mov	 eax, DWORD PTR _rAreaInfo$8[ebp]
  000b3	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  000b6	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  000b9	72 29		 jb	 SHORT $LN5@GetGuildAr

; 753  : 		if (x <= rAreaInfo.lx + rAreaInfo.lwidth)

  000bb	8b 45 f8	 mov	 eax, DWORD PTR _rAreaInfo$8[ebp]
  000be	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c1	8b 4d f8	 mov	 ecx, DWORD PTR _rAreaInfo$8[ebp]
  000c4	03 41 0c	 add	 eax, DWORD PTR [ecx+12]
  000c7	39 45 08	 cmp	 DWORD PTR _x$[ebp], eax
  000ca	77 18		 ja	 SHORT $LN5@GetGuildAr

; 754  : 		if (y <= rAreaInfo.ly + rAreaInfo.lheight)

  000cc	8b 45 f8	 mov	 eax, DWORD PTR _rAreaInfo$8[ebp]
  000cf	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000d2	8b 4d f8	 mov	 ecx, DWORD PTR _rAreaInfo$8[ebp]
  000d5	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  000d8	39 45 0c	 cmp	 DWORD PTR _y$[ebp], eax
  000db	77 07		 ja	 SHORT $LN5@GetGuildAr

; 755  : 		{
; 756  : 			return rAreaInfo.dwGuildID;

  000dd	8b 45 f8	 mov	 eax, DWORD PTR _rAreaInfo$8[ebp]
  000e0	8b 00		 mov	 eax, DWORD PTR [eax]
  000e2	eb 08		 jmp	 SHORT $LN1@GetGuildAr
$LN5@GetGuildAr:

; 757  : 		}
; 758  : 	}

  000e4	e9 41 ff ff ff	 jmp	 $LN2@GetGuildAr
$LN3@GetGuildAr:

; 759  : 
; 760  : 	return 0xffffffff;

  000e9	83 c8 ff	 or	 eax, -1
$LN1@GetGuildAr:

; 761  : }

  000ec	c9		 leave
  000ed	c2 08 00	 ret	 8
?GetGuildAreaID@CPythonMiniMap@@QAEKKK@Z ENDP		; CPythonMiniMap::GetGuildAreaID
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?RegisterGuildArea@CPythonMiniMap@@QAEXKKJJJJ@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
_kGuildAreaInfo$ = -40					; size = 36
__$ArrayPad$ = -4					; size = 4
_dwID$ = 8						; size = 4
_dwGuildID$ = 12					; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_width$ = 24						; size = 4
_height$ = 28						; size = 4
?RegisterGuildArea@CPythonMiniMap@@QAEXKKJJJJ@Z PROC	; CPythonMiniMap::RegisterGuildArea, COMDAT
; _this$ = ecx

; 734  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 735  : 	TGuildAreaInfo kGuildAreaInfo;
; 736  : 	kGuildAreaInfo.dwGuildID = dwGuildID;

  00013	8b 45 0c	 mov	 eax, DWORD PTR _dwGuildID$[ebp]
  00016	89 45 d8	 mov	 DWORD PTR _kGuildAreaInfo$[ebp], eax

; 737  : 	kGuildAreaInfo.lx = x;

  00019	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  0001c	89 45 dc	 mov	 DWORD PTR _kGuildAreaInfo$[ebp+4], eax

; 738  : 	kGuildAreaInfo.ly = y;

  0001f	8b 45 14	 mov	 eax, DWORD PTR _y$[ebp]
  00022	89 45 e0	 mov	 DWORD PTR _kGuildAreaInfo$[ebp+8], eax

; 739  : 	kGuildAreaInfo.lwidth = width;

  00025	8b 45 18	 mov	 eax, DWORD PTR _width$[ebp]
  00028	89 45 e4	 mov	 DWORD PTR _kGuildAreaInfo$[ebp+12], eax

; 740  : 	kGuildAreaInfo.lheight = height;

  0002b	8b 45 1c	 mov	 eax, DWORD PTR _height$[ebp]
  0002e	89 45 e8	 mov	 DWORD PTR _kGuildAreaInfo$[ebp+16], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00031	8d 45 d8	 lea	 eax, DWORD PTR _kGuildAreaInfo$[ebp]
  00034	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 741  : 	m_GuildAreaInfoVector.push_back(kGuildAreaInfo);

  00035	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	81 c1 1c 0c 00
	00		 add	 ecx, 3100		; 00000c1cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0003e	e8 00 00 00 00	 call	 ??$emplace_back@ABUTGuildAreaInfo@CPythonMiniMap@@@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEXABUTGuildAreaInfo@CPythonMiniMap@@@Z ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::emplace_back<CPythonMiniMap::TGuildAreaInfo const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 742  : }

  00043	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00046	33 cd		 xor	 ecx, ebp
  00048	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004d	c9		 leave
  0004e	c2 18 00	 ret	 24			; 00000018H
?RegisterGuildArea@CPythonMiniMap@@QAEXKKJJJJ@Z ENDP	; CPythonMiniMap::RegisterGuildArea
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?ClearGuildArea@CPythonMiniMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearGuildArea@CPythonMiniMap@@QAEXXZ PROC		; CPythonMiniMap::ClearGuildArea, COMDAT
; _this$ = ecx

; 729  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 730  : 	m_GuildAreaInfoVector.clear();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 1c 0c 00
	00		 add	 ecx, 3100		; 00000c1cH
  00010	e8 00 00 00 00	 call	 ?clear@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAEXXZ ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::clear

; 731  : }

  00015	c9		 leave
  00016	c3		 ret	 0
?ClearGuildArea@CPythonMiniMap@@QAEXXZ ENDP		; CPythonMiniMap::ClearGuildArea
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?RegisterAtlasMark@CPythonMiniMap@@QAEXEPBDJJ@Z
_TEXT	SEGMENT
tv262 = -104						; size = 4
tv224 = -100						; size = 4
$T2 = -96						; size = 4
$T3 = -92						; size = 4
_iPos$4 = -88						; size = 4
tv92 = -84						; size = 4
_this$ = -80						; size = 4
_aAtlasMarkInfo$ = -76					; size = 60
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_byType$ = 8						; size = 1
_c_szName$ = 12						; size = 4
_lx$ = 16						; size = 4
_ly$ = 20						; size = 4
?RegisterAtlasMark@CPythonMiniMap@@QAEXEPBDJJ@Z PROC	; CPythonMiniMap::RegisterAtlasMark, COMDAT
; _this$ = ecx

; 699  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RegisterAtlasMark@CPythonMiniMap@@QAEXEPBDJJ@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx

; 700  : 	TAtlasMarkInfo aAtlasMarkInfo;

  0002b	8d 4d b4	 lea	 ecx, DWORD PTR _aAtlasMarkInfo$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0TAtlasMarkInfo@CPythonMiniMap@@QAE@XZ
  00033	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 701  : 
; 702  : 	aAtlasMarkInfo.m_fX = float(lx);

  00037	f3 0f 2a 45 10	 cvtsi2ss xmm0, DWORD PTR _lx$[ebp]
  0003c	f3 0f 11 45 bc	 movss	 DWORD PTR _aAtlasMarkInfo$[ebp+8], xmm0

; 703  : 	aAtlasMarkInfo.m_fY = float(ly);

  00041	f3 0f 2a 45 14	 cvtsi2ss xmm0, DWORD PTR _ly$[ebp]
  00046	f3 0f 11 45 c0	 movss	 DWORD PTR _aAtlasMarkInfo$[ebp+12], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0004b	ff 75 0c	 push	 DWORD PTR _c_szName$[ebp]
  0004e	e8 00 00 00 00	 call	 _strlen
  00053	59		 pop	 ecx
  00054	89 45 a4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00057	8b 45 a4	 mov	 eax, DWORD PTR $T3[ebp]
  0005a	89 45 a0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0005d	ff 75 a0	 push	 DWORD PTR $T2[ebp]
  00060	ff 75 0c	 push	 DWORD PTR _c_szName$[ebp]
  00063	8d 4d d8	 lea	 ecx, DWORD PTR _aAtlasMarkInfo$[ebp+36]
  00066	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 706  : 	aAtlasMarkInfo.m_fScreenX = aAtlasMarkInfo.m_fX / m_fAtlasMaxX * m_fAtlasImageSizeX - (float)m_WhiteMark.GetWidth() / 2.0f;

  0006b	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _aAtlasMarkInfo$[ebp+8]
  00073	f3 0f 5e 80 28
	03 00 00	 divss	 xmm0, DWORD PTR [eax+808]
  0007b	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	f3 0f 59 80 30
	03 00 00	 mulss	 xmm0, DWORD PTR [eax+816]
  00086	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  0008f	f3 0f 11 45 9c	 movss	 DWORD PTR tv224[ebp], xmm0
  00094	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  00099	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0009d	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  000a5	f3 0f 10 4d 9c	 movss	 xmm1, DWORD PTR tv224[ebp]
  000aa	f3 0f 5c c8	 subss	 xmm1, xmm0
  000ae	f3 0f 11 4d c4	 movss	 DWORD PTR _aAtlasMarkInfo$[ebp+16], xmm1

; 707  : 	aAtlasMarkInfo.m_fScreenY = aAtlasMarkInfo.m_fY / m_fAtlasMaxY * m_fAtlasImageSizeY - (float)m_WhiteMark.GetHeight() / 2.0f;

  000b3	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _aAtlasMarkInfo$[ebp+12]
  000bb	f3 0f 5e 80 2c
	03 00 00	 divss	 xmm0, DWORD PTR [eax+812]
  000c3	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  000c6	f3 0f 59 80 34
	03 00 00	 mulss	 xmm0, DWORD PTR [eax+820]
  000ce	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d1	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  000d7	f3 0f 11 45 98	 movss	 DWORD PTR tv262[ebp], xmm0
  000dc	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  000e1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000e5	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  000ed	f3 0f 10 4d 98	 movss	 xmm1, DWORD PTR tv262[ebp]
  000f2	f3 0f 5c c8	 subss	 xmm1, xmm0
  000f6	f3 0f 11 4d c8	 movss	 DWORD PTR _aAtlasMarkInfo$[ebp+20], xmm1

; 708  : 
; 709  : 	switch(byType)

  000fb	8a 45 08	 mov	 al, BYTE PTR _byType$[ebp]
  000fe	88 45 ac	 mov	 BYTE PTR tv92[ebp], al
  00101	80 7d ac 01	 cmp	 BYTE PTR tv92[ebp], 1
  00105	74 08		 je	 SHORT $LN4@RegisterAt
  00107	80 7d ac 03	 cmp	 BYTE PTR tv92[ebp], 3
  0010b	74 1a		 je	 SHORT $LN5@RegisterAt
  0010d	eb 54		 jmp	 SHORT $LN2@RegisterAt
$LN4@RegisterAt:

; 710  : 	{
; 711  : 		case CActorInstance::TYPE_NPC:
; 712  : 			aAtlasMarkInfo.m_byType = TYPE_NPC;

  0010f	c6 45 b4 03	 mov	 BYTE PTR _aAtlasMarkInfo$[ebp], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00113	8d 45 b4	 lea	 eax, DWORD PTR _aAtlasMarkInfo$[ebp]
  00116	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 713  : 			m_AtlasNPCInfoVector.push_back(aAtlasMarkInfo);

  00117	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	81 c1 3c 03 00
	00		 add	 ecx, 828		; 0000033cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00120	e8 00 00 00 00	 call	 ??$emplace_back@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEXABUTAtlasMarkInfo@CPythonMiniMap@@@Z ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::emplace_back<CPythonMiniMap::TAtlasMarkInfo const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 714  : 			break;

  00125	eb 3c		 jmp	 SHORT $LN2@RegisterAt
$LN5@RegisterAt:

; 715  : 		case CActorInstance::TYPE_WARP:
; 716  : 			aAtlasMarkInfo.m_byType = TYPE_WARP;

  00127	c6 45 b4 05	 mov	 BYTE PTR _aAtlasMarkInfo$[ebp], 5

; 717  : 			{
; 718  : 				int iPos = aAtlasMarkInfo.m_strText.find(" ");

  0012b	6a 00		 push	 0
  0012d	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  00132	8d 4d d8	 lea	 ecx, DWORD PTR _aAtlasMarkInfo$[ebp+36]
  00135	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0013a	89 45 a8	 mov	 DWORD PTR _iPos$4[ebp], eax

; 719  : 				if (iPos >= 0)

  0013d	83 7d a8 00	 cmp	 DWORD PTR _iPos$4[ebp], 0
  00141	7c 0e		 jl	 SHORT $LN6@RegisterAt

; 720  : 					aAtlasMarkInfo.m_strText[iPos]=0;

  00143	ff 75 a8	 push	 DWORD PTR _iPos$4[ebp]
  00146	8d 4d d8	 lea	 ecx, DWORD PTR _aAtlasMarkInfo$[ebp+36]
  00149	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  0014e	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN6@RegisterAt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00151	8d 45 b4	 lea	 eax, DWORD PTR _aAtlasMarkInfo$[ebp]
  00154	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 723  : 			m_AtlasWarpInfoVector.push_back(aAtlasMarkInfo);

  00155	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00158	81 c1 48 03 00
	00		 add	 ecx, 840		; 00000348H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0015e	e8 00 00 00 00	 call	 ??$emplace_back@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEXABUTAtlasMarkInfo@CPythonMiniMap@@@Z ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::emplace_back<CPythonMiniMap::TAtlasMarkInfo const &>
$LN2@RegisterAt:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 726  : }

  00163	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00167	8d 4d d8	 lea	 ecx, DWORD PTR _aAtlasMarkInfo$[ebp+36]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0016a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 726  : }

  0016f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00172	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00179	59		 pop	 ecx
  0017a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017d	33 cd		 xor	 ecx, ebp
  0017f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00184	c9		 leave
  00185	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RegisterAtlasMark@CPythonMiniMap@@QAEXEPBDJJ@Z$0:
  00000	8d 4d b4	 lea	 ecx, DWORD PTR _aAtlasMarkInfo$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1TAtlasMarkInfo@CPythonMiniMap@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?RegisterAtlasMark@CPythonMiniMap@@QAEXEPBDJJ@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RegisterAtlasMark@CPythonMiniMap@@QAEXEPBDJJ@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RegisterAtlasMark@CPythonMiniMap@@QAEXEPBDJJ@Z ENDP	; CPythonMiniMap::RegisterAtlasMark
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?ClearAtlasMarkInfo@CPythonMiniMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearAtlasMarkInfo@CPythonMiniMap@@QAEXXZ PROC		; CPythonMiniMap::ClearAtlasMarkInfo, COMDAT
; _this$ = ecx

; 693  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 694  : 	m_AtlasNPCInfoVector.clear();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 3c 03 00
	00		 add	 ecx, 828		; 0000033cH
  00010	e8 00 00 00 00	 call	 ?clear@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEXXZ ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::clear

; 695  : 	m_AtlasWarpInfoVector.clear();

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	81 c1 48 03 00
	00		 add	 ecx, 840		; 00000348H
  0001e	e8 00 00 00 00	 call	 ?clear@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEXXZ ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::clear

; 696  : }

  00023	c9		 leave
  00024	c3		 ret	 0
?ClearAtlasMarkInfo@CPythonMiniMap@@QAEXXZ ENDP		; CPythonMiniMap::ClearAtlasMarkInfo
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?SetAtlasCenterPosition@CPythonMiniMap@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?SetAtlasCenterPosition@CPythonMiniMap@@QAEXHH@Z PROC	; CPythonMiniMap::SetAtlasCenterPosition, COMDAT
; _this$ = ecx

; 1377 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1378 : 	if (m_poHandler)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 b8 34 0c 00
	00 00		 cmp	 DWORD PTR [eax+3124], 0
  00011	74 2b		 je	 SHORT $LN1@SetAtlasCe

; 1379 : 	{
; 1380 : 		//int sw = UI::CWindowManager::Instance().GetScreenWidth();
; 1381 : 		//int sh = UI::CWindowManager::Instance().GetScreenHeight();
; 1382 : 		//PyCallClassMemberFunc(m_poHandler,"SetPosition", Py_BuildValue("(ii)",sw/2+x,sh/2+y));
; 1383 : 		PyCallClassMemberFunc(m_poHandler,"SetCenterPositionAdjust", Py_BuildValue("(ii)",x,y));

  00013	ff 75 0c	 push	 DWORD PTR _y$[ebp]
  00016	ff 75 08	 push	 DWORD PTR _x$[ebp]
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ@
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	50		 push	 eax
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@DPOECPOI@SetCenterPositionAdjust@
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	ff b0 34 0c 00
	00		 push	 DWORD PTR [eax+3124]
  00036	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@SetAtlasCe:

; 1384 : 	}
; 1385 : }

  0003e	c9		 leave
  0003f	c2 08 00	 ret	 8
?SetAtlasCenterPosition@CPythonMiniMap@@QAEXHH@Z ENDP	; CPythonMiniMap::SetAtlasCenterPosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?OpenAtlasWindow@CPythonMiniMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OpenAtlasWindow@CPythonMiniMap@@QAEXXZ PROC		; CPythonMiniMap::OpenAtlasWindow, COMDAT
; _this$ = ecx

; 1369 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1370 : 	if (m_poHandler)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 b8 34 0c 00
	00 00		 cmp	 DWORD PTR [eax+3124], 0
  00011	74 23		 je	 SHORT $LN1@OpenAtlasW

; 1371 : 	{
; 1372 : 		PyCallClassMemberFunc(m_poHandler,"Show", Py_BuildValue("()"));

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ@
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001e	59		 pop	 ecx
  0001f	50		 push	 eax
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_04JLAJABDJ@Show@
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	ff b0 34 0c 00
	00		 push	 DWORD PTR [eax+3124]
  0002e	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@OpenAtlasW:

; 1373 : 	}
; 1374 : }

  00036	c9		 leave
  00037	c3		 ret	 0
?OpenAtlasWindow@CPythonMiniMap@@QAEXXZ ENDP		; CPythonMiniMap::OpenAtlasWindow
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?UnregisterAtlasWindow@CPythonMiniMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?UnregisterAtlasWindow@CPythonMiniMap@@QAEXXZ PROC	; CPythonMiniMap::UnregisterAtlasWindow, COMDAT
; _this$ = ecx

; 1364 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1365 : 	m_poHandler = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 a0 34 0c 00
	00 00		 and	 DWORD PTR [eax+3124], 0

; 1366 : }

  00011	c9		 leave
  00012	c3		 ret	 0
?UnregisterAtlasWindow@CPythonMiniMap@@QAEXXZ ENDP	; CPythonMiniMap::UnregisterAtlasWindow
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?RegisterAtlasWindow@CPythonMiniMap@@QAEXPAU_object@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_poHandler$ = 8						; size = 4
?RegisterAtlasWindow@CPythonMiniMap@@QAEXPAU_object@@@Z PROC ; CPythonMiniMap::RegisterAtlasWindow, COMDAT
; _this$ = ecx

; 1359 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1360 : 	m_poHandler = poHandler;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _poHandler$[ebp]
  0000d	89 88 34 0c 00
	00		 mov	 DWORD PTR [eax+3124], ecx

; 1361 : }

  00013	c9		 leave
  00014	c2 04 00	 ret	 4
?RegisterAtlasWindow@CPythonMiniMap@@QAEXPAU_object@@@Z ENDP ; CPythonMiniMap::RegisterAtlasWindow
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?ClearAllSignalPoint@CPythonMiniMap@@QAEXXZ
_TEXT	SEGMENT
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
___param0$ = -44					; size = 4
$T7 = -40						; size = 4
$T8 = -36						; size = 4
___param0$ = -32					; size = 4
tv177 = -28						; size = 4
tv191 = -24						; size = 4
__My_data$9 = -20					; size = 4
__My_data$10 = -16					; size = 4
_this$ = -12						; size = 4
_it$ = -8						; size = 4
$T11 = -2						; size = 1
$T12 = -1						; size = 1
?ClearAllSignalPoint@CPythonMiniMap@@QAEXXZ PROC	; CPythonMiniMap::ClearAllSignalPoint, COMDAT
; _this$ = ecx

; 1349 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  00009	83 65 f8 00	 and	 DWORD PTR _it$[ebp], 0

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0000d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00010	05 28 0c 00 00	 add	 eax, 3112		; 00000c28H
  00015	89 45 f0	 mov	 DWORD PTR __My_data$10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __My_data$10[ebp]
  0001b	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0001e	8b 45 f0	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00026	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00029	89 45 dc	 mov	 DWORD PTR $T8[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0002c	8d 45 dc	 lea	 eax, DWORD PTR $T8[ebp]
  0002f	89 45 d8	 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1351 : 	for(it = m_SignalPointVector.begin();it!=m_SignalPointVector.end();++it)

  00032	8b 45 d8	 mov	 eax, DWORD PTR $T7[ebp]
  00035	8b 00		 mov	 eax, DWORD PTR [eax]
  00037	89 45 f8	 mov	 DWORD PTR _it$[ebp], eax
  0003a	eb 09		 jmp	 SHORT $LN4@ClearAllSi
$LN2@ClearAllSi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _it$[ebp]
  0003f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00042	89 45 f8	 mov	 DWORD PTR _it$[ebp], eax
$LN4@ClearAllSi:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00045	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00048	05 28 0c 00 00	 add	 eax, 3112		; 00000c28H
  0004d	89 45 ec	 mov	 DWORD PTR __My_data$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00050	8b 45 ec	 mov	 eax, DWORD PTR __My_data$9[ebp]
  00053	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00056	8b 45 ec	 mov	 eax, DWORD PTR __My_data$9[ebp]
  00059	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005c	89 45 d4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0005f	8b 45 d4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00062	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00065	8d 45 d0	 lea	 eax, DWORD PTR $T6[ebp]
  00068	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  0006b	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  0006e	8b 4d f8	 mov	 ecx, DWORD PTR _it$[ebp]
  00071	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00073	75 09		 jne	 SHORT $LN55@ClearAllSi
  00075	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv191[ebp], 1
  0007c	eb 04		 jmp	 SHORT $LN56@ClearAllSi
$LN55@ClearAllSi:
  0007e	83 65 e8 00	 and	 DWORD PTR tv191[ebp], 0
$LN56@ClearAllSi:
  00082	8a 45 e8	 mov	 al, BYTE PTR tv191[ebp]
  00085	88 45 ff	 mov	 BYTE PTR $T12[ebp], al

; 153  :         return !(*this == _Right);

  00088	0f b6 45 ff	 movzx	 eax, BYTE PTR $T12[ebp]
  0008c	85 c0		 test	 eax, eax
  0008e	75 09		 jne	 SHORT $LN50@ClearAllSi
  00090	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv177[ebp], 1
  00097	eb 04		 jmp	 SHORT $LN51@ClearAllSi
$LN50@ClearAllSi:
  00099	83 65 e4 00	 and	 DWORD PTR tv177[ebp], 0
$LN51@ClearAllSi:
  0009d	8a 45 e4	 mov	 al, BYTE PTR tv177[ebp]
  000a0	88 45 fe	 mov	 BYTE PTR $T11[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1351 : 	for(it = m_SignalPointVector.begin();it!=m_SignalPointVector.end();++it)

  000a3	0f b6 45 fe	 movzx	 eax, BYTE PTR $T11[ebp]
  000a7	85 c0		 test	 eax, eax
  000a9	74 25		 je	 SHORT $LN3@ClearAllSi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _it$[ebp]
  000ae	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  000b1	ff 75 c8	 push	 DWORD PTR $T4[ebp]
  000b4	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBUTSignalPoint@CPythonMiniMap@@@std@@YAPAUTSignalPoint@CPythonMiniMap@@PBU12@@Z ; std::_Const_cast<CPythonMiniMap::TSignalPoint const >
  000b9	59		 pop	 ecx
  000ba	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1353 : 		RemoveWayPoint(it->id);

  000bd	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  000c0	ff 70 08	 push	 DWORD PTR [eax+8]
  000c3	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000c6	e8 00 00 00 00	 call	 ?RemoveWayPoint@CPythonMiniMap@@QAEXK@Z ; CPythonMiniMap::RemoveWayPoint

; 1354 : 	}

  000cb	e9 6c ff ff ff	 jmp	 $LN2@ClearAllSi
$LN3@ClearAllSi:

; 1355 : 	m_SignalPointVector.clear();

  000d0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d3	81 c1 28 0c 00
	00		 add	 ecx, 3112		; 00000c28H
  000d9	e8 00 00 00 00	 call	 ?clear@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEXXZ ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::clear

; 1356 : }

  000de	c9		 leave
  000df	c3		 ret	 0
?ClearAllSignalPoint@CPythonMiniMap@@QAEXXZ ENDP	; CPythonMiniMap::ClearAllSignalPoint
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?AddSignalPoint@CPythonMiniMap@@QAEXMM@Z
_TEXT	SEGMENT
_sp$ = -20						; size = 12
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_fX$ = 8						; size = 4
_fY$ = 12						; size = 4
?AddSignalPoint@CPythonMiniMap@@QAEXMM@Z PROC		; CPythonMiniMap::AddSignalPoint, COMDAT
; _this$ = ecx

; 1333 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1334 : 	static unsigned int g_id = 255;
; 1335 : 
; 1336 : 	TSignalPoint sp;
; 1337 : 	sp.id = g_id;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_id@?1??AddSignalPoint@CPythonMiniMap@@QAEXMM@Z@4IA
  0000e	89 45 f4	 mov	 DWORD PTR _sp$[ebp+8], eax

; 1338 : 	sp.v2Pos.x = fX;

  00011	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fX$[ebp]
  00016	f3 0f 11 45 ec	 movss	 DWORD PTR _sp$[ebp], xmm0

; 1339 : 	sp.v2Pos.y = fY;

  0001b	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fY$[ebp]
  00020	f3 0f 11 45 f0	 movss	 DWORD PTR _sp$[ebp+4], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00025	8d 45 ec	 lea	 eax, DWORD PTR _sp$[ebp]
  00028	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1341 : 	m_SignalPointVector.push_back(sp);

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	81 c1 28 0c 00
	00		 add	 ecx, 3112		; 00000c28H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00032	e8 00 00 00 00	 call	 ??$emplace_back@ABUTSignalPoint@CPythonMiniMap@@@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAEXABUTSignalPoint@CPythonMiniMap@@@Z ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::emplace_back<CPythonMiniMap::TSignalPoint const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1343 : 	AddWayPoint(TYPE_WAYPOINT, g_id, fX, fY, "");

  00037	6a 00		 push	 0
  00039	83 ec 18	 sub	 esp, 24			; 00000018H
  0003c	8b cc		 mov	 ecx, esp
  0003e	89 65 f8	 mov	 DWORD PTR $T1[ebp], esp
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00046	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0004b	51		 push	 ecx
  0004c	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fY$[ebp]
  00051	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00056	51		 push	 ecx
  00057	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fX$[ebp]
  0005c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00061	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_id@?1??AddSignalPoint@CPythonMiniMap@@QAEXMM@Z@4IA
  00067	6a 06		 push	 6
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?AddWayPoint@CPythonMiniMap@@QAEXEKMMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CPythonMiniMap::AddWayPoint

; 1344 : 
; 1345 : 	g_id++;

  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_id@?1??AddSignalPoint@CPythonMiniMap@@QAEXMM@Z@4IA
  00076	40		 inc	 eax
  00077	a3 00 00 00 00	 mov	 DWORD PTR ?g_id@?1??AddSignalPoint@CPythonMiniMap@@QAEXMM@Z@4IA, eax

; 1346 : }

  0007c	c9		 leave
  0007d	c2 08 00	 ret	 8
?AddSignalPoint@CPythonMiniMap@@QAEXMM@Z ENDP		; CPythonMiniMap::AddSignalPoint
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?RemoveWayPoint@CPythonMiniMap@@QAEXK@Z
_TEXT	SEGMENT
$T1 = -76						; size = 4
$T2 = -72						; size = 4
$T3 = -68						; size = 4
$T4 = -64						; size = 4
_rAtlasMarkInfo$5 = -60					; size = 4
$T6 = -56						; size = 4
$T7 = -52						; size = 4
$T8 = -48						; size = 4
___param0$ = -44					; size = 4
$T9 = -40						; size = 4
$T10 = -36						; size = 4
___param0$ = -32					; size = 4
_this$ = -28						; size = 4
tv176 = -24						; size = 4
tv190 = -20						; size = 4
__My_data$11 = -16					; size = 4
__My_data$12 = -12					; size = 4
_this$ = -8						; size = 4
$T13 = -2						; size = 1
$T14 = -1						; size = 1
_dwID$ = 8						; size = 4
?RemoveWayPoint@CPythonMiniMap@@QAEXK@Z PROC		; CPythonMiniMap::RemoveWayPoint, COMDAT
; _this$ = ecx

; 1264 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 10 0c 00 00	 add	 eax, 3088		; 00000c10H
  00011	89 45 f4	 mov	 DWORD PTR __My_data$12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00014	8b 45 f4	 mov	 eax, DWORD PTR __My_data$12[ebp]
  00017	89 45 bc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0001a	8b 45 f4	 mov	 eax, DWORD PTR __My_data$12[ebp]
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00022	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00025	89 45 dc	 mov	 DWORD PTR $T10[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00028	8d 45 dc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 d8	 mov	 DWORD PTR $T9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1265 : 	m_AtlasMarkInfoVectorIterator = m_AtlasWayPointInfoVector.begin();

  0002e	8b 45 d8	 mov	 eax, DWORD PTR $T9[ebp]
  00031	8b 00		 mov	 eax, DWORD PTR [eax]
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	89 81 38 03 00
	00		 mov	 DWORD PTR [ecx+824], eax
$LN2@RemoveWayP:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	05 10 0c 00 00	 add	 eax, 3088		; 00000c10H
  00044	89 45 f0	 mov	 DWORD PTR __My_data$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00047	8b 45 f0	 mov	 eax, DWORD PTR __My_data$11[ebp]
  0004a	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0004d	8b 45 f0	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00050	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00053	89 45 d4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00056	8b 45 d4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00059	89 45 d0	 mov	 DWORD PTR $T8[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0005c	8d 45 d0	 lea	 eax, DWORD PTR $T8[ebp]
  0005f	89 45 cc	 mov	 DWORD PTR $T7[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00062	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00065	8b 4d cc	 mov	 ecx, DWORD PTR $T7[ebp]
  00068	8b 80 38 03 00
	00		 mov	 eax, DWORD PTR [eax+824]
  0006e	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00070	75 09		 jne	 SHORT $LN43@RemoveWayP
  00072	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv190[ebp], 1
  00079	eb 04		 jmp	 SHORT $LN44@RemoveWayP
$LN43@RemoveWayP:
  0007b	83 65 ec 00	 and	 DWORD PTR tv190[ebp], 0
$LN44@RemoveWayP:
  0007f	8a 45 ec	 mov	 al, BYTE PTR tv190[ebp]
  00082	88 45 ff	 mov	 BYTE PTR $T14[ebp], al

; 153  :         return !(*this == _Right);

  00085	0f b6 45 ff	 movzx	 eax, BYTE PTR $T14[ebp]
  00089	85 c0		 test	 eax, eax
  0008b	75 09		 jne	 SHORT $LN38@RemoveWayP
  0008d	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv176[ebp], 1
  00094	eb 04		 jmp	 SHORT $LN39@RemoveWayP
$LN38@RemoveWayP:
  00096	83 65 e8 00	 and	 DWORD PTR tv176[ebp], 0
$LN39@RemoveWayP:
  0009a	8a 45 e8	 mov	 al, BYTE PTR tv176[ebp]
  0009d	88 45 fe	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1266 : 	while (m_AtlasMarkInfoVectorIterator != m_AtlasWayPointInfoVector.end())

  000a0	0f b6 45 fe	 movzx	 eax, BYTE PTR $T13[ebp]
  000a4	85 c0		 test	 eax, eax
  000a6	74 68		 je	 SHORT $LN1@RemoveWayP
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000a8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	8b 80 38 03 00
	00		 mov	 eax, DWORD PTR [eax+824]
  000b1	89 45 c8	 mov	 DWORD PTR $T6[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  000b4	8b 45 c8	 mov	 eax, DWORD PTR $T6[ebp]
  000b7	89 45 c4	 mov	 DWORD PTR _rAtlasMarkInfo$5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1269 : 		if (rAtlasMarkInfo.m_dwID == dwID)

  000ba	8b 45 c4	 mov	 eax, DWORD PTR _rAtlasMarkInfo$5[ebp]
  000bd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c0	3b 45 08	 cmp	 eax, DWORD PTR _dwID$[ebp]
  000c3	75 2e		 jne	 SHORT $LN4@RemoveWayP

; 1270 : 		{
; 1271 : 			m_AtlasMarkInfoVectorIterator = m_AtlasWayPointInfoVector.erase(m_AtlasMarkInfoVectorIterator);

  000c5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c8	8b 80 38 03 00
	00		 mov	 eax, DWORD PTR [eax+824]
  000ce	89 45 c0	 mov	 DWORD PTR $T4[ebp], eax
  000d1	ff 75 c0	 push	 DWORD PTR $T4[ebp]
  000d4	8d 45 b4	 lea	 eax, DWORD PTR $T1[ebp]
  000d7	50		 push	 eax
  000d8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000db	81 c1 10 0c 00
	00		 add	 ecx, 3088		; 00000c10H
  000e1	e8 00 00 00 00	 call	 ?erase@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@@2@@Z ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::erase
  000e6	8b 00		 mov	 eax, DWORD PTR [eax]
  000e8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	89 81 38 03 00
	00		 mov	 DWORD PTR [ecx+824], eax

; 1272 : 			return;

  000f1	eb 1d		 jmp	 SHORT $LN1@RemoveWayP
$LN4@RemoveWayP:

; 1273 : 		}
; 1274 : 		++m_AtlasMarkInfoVectorIterator;

  000f3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f6	05 38 03 00 00	 add	 eax, 824		; 00000338H
  000fb	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  000fe	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00101	8b 00		 mov	 eax, DWORD PTR [eax]
  00103	83 c0 3c	 add	 eax, 60			; 0000003cH
  00106	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1275 : 	}

  0010b	e9 2c ff ff ff	 jmp	 $LN2@RemoveWayP
$LN1@RemoveWayP:

; 1276 : }

  00110	c9		 leave
  00111	c2 04 00	 ret	 4
?RemoveWayPoint@CPythonMiniMap@@QAEXK@Z ENDP		; CPythonMiniMap::RemoveWayPoint
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?AddWayPoint@CPythonMiniMap@@QAEXEKMMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z
_TEXT	SEGMENT
$T2 = -76						; size = 4
$T3 = -72						; size = 4
$T4 = -68						; size = 1
$T5 = -64						; size = 4
_rAtlasMarkInfo$6 = -60					; size = 4
$T7 = -56						; size = 4
$T8 = -52						; size = 4
$T9 = -48						; size = 4
___param0$ = -44					; size = 4
$T10 = -40						; size = 4
$T11 = -36						; size = 4
___param0$ = -32					; size = 4
_this$ = -28						; size = 4
tv214 = -24						; size = 4
tv228 = -20						; size = 4
__My_data$12 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__My_data$13 = 0					; size = 4
$T14 = 6						; size = 1
$T15 = 7						; size = 1
_this$ = 8						; size = 4
_aAtlasMarkInfo$ = 12					; size = 60
__$ArrayPad$ = 72					; size = 4
_byType$ = 84						; size = 1
_dwID$ = 88						; size = 4
_fX$ = 92						; size = 4
_fY$ = 96						; size = 4
_strText$ = 100						; size = 24
_dwChrVID$ = 124					; size = 4
?AddWayPoint@CPythonMiniMap@@QAEXEKMMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z PROC ; CPythonMiniMap::AddWayPoint, COMDAT
; _this$ = ecx

; 1237 : {

  00000	55		 push	 ebp
  00001	8d 6c 24 b4	 lea	 ebp, DWORD PTR [esp-76]
  00005	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$?AddWayPoint@CPythonMiniMap@@QAEXEKMMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 40	 sub	 esp, 64			; 00000040H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 48	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	89 4d 08	 mov	 DWORD PTR _this$[ebp], ecx
  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00034	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00037	05 10 0c 00 00	 add	 eax, 3088		; 00000c10H
  0003c	89 45 00	 mov	 DWORD PTR __My_data$13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0003f	8b 45 00	 mov	 eax, DWORD PTR __My_data$13[ebp]
  00042	89 45 b8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00045	8b 45 00	 mov	 eax, DWORD PTR __My_data$13[ebp]
  00048	8b 00		 mov	 eax, DWORD PTR [eax]
  0004a	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0004d	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00050	89 45 dc	 mov	 DWORD PTR $T11[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00053	8d 45 dc	 lea	 eax, DWORD PTR $T11[ebp]
  00056	89 45 d8	 mov	 DWORD PTR $T10[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1238 : 	m_AtlasMarkInfoVectorIterator = m_AtlasWayPointInfoVector.begin();

  00059	8b 45 d8	 mov	 eax, DWORD PTR $T10[ebp]
  0005c	8b 00		 mov	 eax, DWORD PTR [eax]
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	89 81 38 03 00
	00		 mov	 DWORD PTR [ecx+824], eax
$LN2@AddWayPoin:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00067	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	05 10 0c 00 00	 add	 eax, 3088		; 00000c10H
  0006f	89 45 f0	 mov	 DWORD PTR __My_data$12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00072	8b 45 f0	 mov	 eax, DWORD PTR __My_data$12[ebp]
  00075	89 45 b4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00078	8b 45 f0	 mov	 eax, DWORD PTR __My_data$12[ebp]
  0007b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007e	89 45 d4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00081	8b 45 d4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00084	89 45 d0	 mov	 DWORD PTR $T9[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00087	8d 45 d0	 lea	 eax, DWORD PTR $T9[ebp]
  0008a	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  0008d	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00090	8b 4d cc	 mov	 ecx, DWORD PTR $T8[ebp]
  00093	8b 80 38 03 00
	00		 mov	 eax, DWORD PTR [eax+824]
  00099	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0009b	75 09		 jne	 SHORT $LN45@AddWayPoin
  0009d	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv228[ebp], 1
  000a4	eb 04		 jmp	 SHORT $LN46@AddWayPoin
$LN45@AddWayPoin:
  000a6	83 65 ec 00	 and	 DWORD PTR tv228[ebp], 0
$LN46@AddWayPoin:
  000aa	8a 45 ec	 mov	 al, BYTE PTR tv228[ebp]
  000ad	88 45 07	 mov	 BYTE PTR $T15[ebp], al

; 153  :         return !(*this == _Right);

  000b0	0f b6 45 07	 movzx	 eax, BYTE PTR $T15[ebp]
  000b4	85 c0		 test	 eax, eax
  000b6	75 09		 jne	 SHORT $LN40@AddWayPoin
  000b8	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv214[ebp], 1
  000bf	eb 04		 jmp	 SHORT $LN41@AddWayPoin
$LN40@AddWayPoin:
  000c1	83 65 e8 00	 and	 DWORD PTR tv214[ebp], 0
$LN41@AddWayPoin:
  000c5	8a 45 e8	 mov	 al, BYTE PTR tv214[ebp]
  000c8	88 45 06	 mov	 BYTE PTR $T14[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1239 : 	while (m_AtlasMarkInfoVectorIterator != m_AtlasWayPointInfoVector.end())

  000cb	0f b6 45 06	 movzx	 eax, BYTE PTR $T14[ebp]
  000cf	85 c0		 test	 eax, eax
  000d1	74 4b		 je	 SHORT $LN3@AddWayPoin
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000d3	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	8b 80 38 03 00
	00		 mov	 eax, DWORD PTR [eax+824]
  000dc	89 45 c8	 mov	 DWORD PTR $T7[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  000df	8b 45 c8	 mov	 eax, DWORD PTR $T7[ebp]
  000e2	89 45 c4	 mov	 DWORD PTR _rAtlasMarkInfo$6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1242 : 		if (rAtlasMarkInfo.m_dwID == dwID)

  000e5	8b 45 c4	 mov	 eax, DWORD PTR _rAtlasMarkInfo$6[ebp]
  000e8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000eb	3b 45 58	 cmp	 eax, DWORD PTR _dwID$[ebp]
  000ee	75 11		 jne	 SHORT $LN4@AddWayPoin

; 1243 : 			return;

  000f0	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000f4	8d 4d 64	 lea	 ecx, DWORD PTR _strText$[ebp]
  000f7	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1243 : 			return;

  000fc	e9 d3 00 00 00	 jmp	 $LN1@AddWayPoin
$LN4@AddWayPoin:

; 1244 : 		++m_AtlasMarkInfoVectorIterator;

  00101	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00104	05 38 03 00 00	 add	 eax, 824		; 00000338H
  00109	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  0010c	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0010f	8b 00		 mov	 eax, DWORD PTR [eax]
  00111	83 c0 3c	 add	 eax, 60			; 0000003cH
  00114	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1245 : 	}

  00119	e9 49 ff ff ff	 jmp	 $LN2@AddWayPoin
$LN3@AddWayPoin:

; 1246 : 
; 1247 : 	TAtlasMarkInfo aAtlasMarkInfo;

  0011e	8d 4d 0c	 lea	 ecx, DWORD PTR _aAtlasMarkInfo$[ebp]
  00121	e8 00 00 00 00	 call	 ??0TAtlasMarkInfo@CPythonMiniMap@@QAE@XZ
  00126	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 1248 : 	aAtlasMarkInfo.m_byType = byType;

  0012a	8a 45 54	 mov	 al, BYTE PTR _byType$[ebp]
  0012d	88 45 0c	 mov	 BYTE PTR _aAtlasMarkInfo$[ebp], al

; 1249 : 	aAtlasMarkInfo.m_dwID = dwID;

  00130	8b 45 58	 mov	 eax, DWORD PTR _dwID$[ebp]
  00133	89 45 10	 mov	 DWORD PTR _aAtlasMarkInfo$[ebp+4], eax

; 1250 : 	aAtlasMarkInfo.m_fX = fX;

  00136	f3 0f 10 45 5c	 movss	 xmm0, DWORD PTR _fX$[ebp]
  0013b	f3 0f 11 45 14	 movss	 DWORD PTR _aAtlasMarkInfo$[ebp+8], xmm0

; 1251 : 	aAtlasMarkInfo.m_fY = fY;

  00140	f3 0f 10 45 60	 movss	 xmm0, DWORD PTR _fY$[ebp]
  00145	f3 0f 11 45 18	 movss	 DWORD PTR _aAtlasMarkInfo$[ebp+12], xmm0

; 1252 : 	aAtlasMarkInfo.m_fScreenX = 0.0f;

  0014a	0f 57 c0	 xorps	 xmm0, xmm0
  0014d	f3 0f 11 45 1c	 movss	 DWORD PTR _aAtlasMarkInfo$[ebp+16], xmm0

; 1253 : 	aAtlasMarkInfo.m_fScreenY = 0.0f;

  00152	0f 57 c0	 xorps	 xmm0, xmm0
  00155	f3 0f 11 45 20	 movss	 DWORD PTR _aAtlasMarkInfo$[ebp+20], xmm0

; 1254 : 	aAtlasMarkInfo.m_fMiniMapX = 0.0f;

  0015a	0f 57 c0	 xorps	 xmm0, xmm0
  0015d	f3 0f 11 45 24	 movss	 DWORD PTR _aAtlasMarkInfo$[ebp+24], xmm0

; 1255 : 	aAtlasMarkInfo.m_fMiniMapY = 0.0f;

  00162	0f 57 c0	 xorps	 xmm0, xmm0
  00165	f3 0f 11 45 28	 movss	 DWORD PTR _aAtlasMarkInfo$[ebp+28], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0016a	8d 45 64	 lea	 eax, DWORD PTR _strText$[ebp]
  0016d	89 45 c0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  00170	8d 45 30	 lea	 eax, DWORD PTR _aAtlasMarkInfo$[ebp+36]
  00173	3b 45 c0	 cmp	 eax, DWORD PTR $T5[ebp]
  00176	74 14		 je	 SHORT $LN91@AddWayPoin

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  00178	33 c0		 xor	 eax, eax
  0017a	88 45 bc	 mov	 BYTE PTR $T4[ebp], al
  0017d	ff 75 bc	 push	 DWORD PTR $T4[ebp]
  00180	8d 45 64	 lea	 eax, DWORD PTR _strText$[ebp]
  00183	50		 push	 eax
  00184	8d 4d 30	 lea	 ecx, DWORD PTR _aAtlasMarkInfo$[ebp+36]
  00187	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
$LN91@AddWayPoin:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1257 : 	aAtlasMarkInfo.m_dwChrVID = dwChrVID;

  0018c	8b 45 7c	 mov	 eax, DWORD PTR _dwChrVID$[ebp]
  0018f	89 45 2c	 mov	 DWORD PTR _aAtlasMarkInfo$[ebp+32], eax

; 1258 : 	__UpdateWayPoint(&aAtlasMarkInfo, fX, fY);

  00192	f3 0f 2c 45 60	 cvttss2si eax, DWORD PTR _fY$[ebp]
  00197	50		 push	 eax
  00198	f3 0f 2c 45 5c	 cvttss2si eax, DWORD PTR _fX$[ebp]
  0019d	50		 push	 eax
  0019e	8d 45 0c	 lea	 eax, DWORD PTR _aAtlasMarkInfo$[ebp]
  001a1	50		 push	 eax
  001a2	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001a5	e8 00 00 00 00	 call	 ?__UpdateWayPoint@CPythonMiniMap@@IAEXPAUTAtlasMarkInfo@1@HH@Z ; CPythonMiniMap::__UpdateWayPoint
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  001aa	8d 45 0c	 lea	 eax, DWORD PTR _aAtlasMarkInfo$[ebp]
  001ad	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1259 : 	m_AtlasWayPointInfoVector.push_back(aAtlasMarkInfo);

  001ae	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001b1	81 c1 10 0c 00
	00		 add	 ecx, 3088		; 00000c10H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  001b7	e8 00 00 00 00	 call	 ??$emplace_back@ABUTAtlasMarkInfo@CPythonMiniMap@@@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEXABUTAtlasMarkInfo@CPythonMiniMap@@@Z ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::emplace_back<CPythonMiniMap::TAtlasMarkInfo const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1261 : }

  001bc	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  001c0	8d 4d 30	 lea	 ecx, DWORD PTR _aAtlasMarkInfo$[ebp+36]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  001c3	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1261 : }

  001c8	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  001cc	8d 4d 64	 lea	 ecx, DWORD PTR _strText$[ebp]
  001cf	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN1@AddWayPoin:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1261 : }

  001d4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001d7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001de	59		 pop	 ecx
  001df	8b 4d 48	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e2	33 cd		 xor	 ecx, ebp
  001e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e9	83 c5 4c	 add	 ebp, 76			; 0000004cH
  001ec	c9		 leave
  001ed	c2 2c 00	 ret	 44			; 0000002cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddWayPoint@CPythonMiniMap@@QAEXEKMMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z$0:
  00000	8d 4d 64	 lea	 ecx, DWORD PTR _strText$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?AddWayPoint@CPythonMiniMap@@QAEXEKMMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z$1:
  00008	8d 4d 0c	 lea	 ecx, DWORD PTR _aAtlasMarkInfo$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1TAtlasMarkInfo@CPythonMiniMap@@QAE@XZ
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?AddWayPoint@CPythonMiniMap@@QAEXEKMMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a 54	 mov	 ecx, DWORD PTR [edx+84]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AddWayPoint@CPythonMiniMap@@QAEXEKMMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AddWayPoint@CPythonMiniMap@@QAEXEKMMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ENDP ; CPythonMiniMap::AddWayPoint
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?RemoveObserver@CPythonMiniMap@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwVID$ = 8						; size = 4
?RemoveObserver@CPythonMiniMap@@QAEXK@Z PROC		; CPythonMiniMap::RemoveObserver, COMDAT
; _this$ = ecx

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 63   : 	m_kMap_dwVID_kObserver.erase(dwVID);

  00007	8d 45 08	 lea	 eax, DWORD PTR _dwVID$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  00014	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAEIABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::erase

; 64   : }

  00019	c9		 leave
  0001a	c2 04 00	 ret	 4
?RemoveObserver@CPythonMiniMap@@QAEXK@Z ENDP		; CPythonMiniMap::RemoveObserver
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?MoveObserver@CPythonMiniMap@@QAEXKMM@Z
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
___param0$ = -32					; size = 4
__Scary$8 = -28						; size = 4
$T9 = -24						; size = 4
_f$ = -20						; size = 4
tv200 = -16						; size = 4
_this$ = -12						; size = 4
_rkObserver$ = -8					; size = 4
$T10 = -1						; size = 1
_dwVID$ = 8						; size = 4
_fDstX$ = 12						; size = 4
_fDstY$ = 16						; size = 4
?MoveObserver@CPythonMiniMap@@QAEXKMM@Z PROC		; CPythonMiniMap::MoveObserver, COMDAT
; _this$ = ecx

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 48   : 	std::map<DWORD, SObserver>::iterator f=m_kMap_dwVID_kObserver.find(dwVID);

  00009	8d 45 08	 lea	 eax, DWORD PTR _dwVID$[ebp]
  0000c	50		 push	 eax
  0000d	8d 45 ec	 lea	 eax, DWORD PTR _f$[ebp]
  00010	50		 push	 eax
  00011	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  0001a	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::find
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0001f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00022	05 68 01 00 00	 add	 eax, 360		; 00000168H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00027	89 45 e8	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T9[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR __Scary$8[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00030	8b 45 e4	 mov	 eax, DWORD PTR __Scary$8[ebp]
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
  00035	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00038	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  0003b	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  0003e	8d 45 dc	 lea	 eax, DWORD PTR $T7[ebp]
  00041	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 232  :         return this->_Ptr == _Right._Ptr;

  00044	8b 45 d8	 mov	 eax, DWORD PTR $T6[ebp]
  00047	8b 00		 mov	 eax, DWORD PTR [eax]
  00049	3b 45 ec	 cmp	 eax, DWORD PTR _f$[ebp]
  0004c	75 09		 jne	 SHORT $LN72@MoveObserv
  0004e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv200[ebp], 1
  00055	eb 04		 jmp	 SHORT $LN73@MoveObserv
$LN72@MoveObserv:
  00057	83 65 f0 00	 and	 DWORD PTR tv200[ebp], 0
$LN73@MoveObserv:
  0005b	8a 45 f0	 mov	 al, BYTE PTR tv200[ebp]
  0005e	88 45 ff	 mov	 BYTE PTR $T10[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 49   : 	if (m_kMap_dwVID_kObserver.end()==f)

  00061	0f b6 45 ff	 movzx	 eax, BYTE PTR $T10[ebp]
  00065	85 c0		 test	 eax, eax
  00067	74 02		 je	 SHORT $LN2@MoveObserv

; 50   : 		return;

  00069	eb 77		 jmp	 SHORT $LN1@MoveObserv
$LN2@MoveObserv:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 185  :         return this->_Ptr->_Myval;

  0006b	8b 45 ec	 mov	 eax, DWORD PTR _f$[ebp]
  0006e	83 c0 10	 add	 eax, 16			; 00000010H
  00071	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax

; 273  :         return const_cast<reference>(_Mybase::operator*());

  00074	8b 45 d4	 mov	 eax, DWORD PTR $T5[ebp]
  00077	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0007a	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0007d	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  00080	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  00083	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 277  :         return pointer_traits<pointer>::pointer_to(**this);

  00086	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00089	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 52   : 	SObserver& rkObserver=f->second;

  0008c	8b 45 c4	 mov	 eax, DWORD PTR $T1[ebp]
  0008f	83 c0 04	 add	 eax, 4
  00092	89 45 f8	 mov	 DWORD PTR _rkObserver$[ebp], eax

; 53   : 	rkObserver.dwSrcTime=ELTimer_GetMSec();

  00095	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _rkObserver$[ebp]
  0009d	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 54   : 	rkObserver.dwDstTime=rkObserver.dwSrcTime+1000;

  000a0	8b 45 f8	 mov	 eax, DWORD PTR _rkObserver$[ebp]
  000a3	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  000a6	05 e8 03 00 00	 add	 eax, 1000		; 000003e8H
  000ab	8b 4d f8	 mov	 ecx, DWORD PTR _rkObserver$[ebp]
  000ae	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 55   : 	rkObserver.fSrcX=rkObserver.fCurX;

  000b1	8b 45 f8	 mov	 eax, DWORD PTR _rkObserver$[ebp]
  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _rkObserver$[ebp]
  000b7	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000b9	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 56   : 	rkObserver.fSrcY=rkObserver.fCurY;

  000bc	8b 45 f8	 mov	 eax, DWORD PTR _rkObserver$[ebp]
  000bf	8b 4d f8	 mov	 ecx, DWORD PTR _rkObserver$[ebp]
  000c2	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000c5	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 57   : 	rkObserver.fDstX=fDstX;

  000c8	8b 45 f8	 mov	 eax, DWORD PTR _rkObserver$[ebp]
  000cb	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fDstX$[ebp]
  000d0	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 58   : 	rkObserver.fDstY=fDstY;

  000d5	8b 45 f8	 mov	 eax, DWORD PTR _rkObserver$[ebp]
  000d8	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fDstY$[ebp]
  000dd	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0
$LN1@MoveObserv:

; 59   : }

  000e2	c9		 leave
  000e3	c2 0c 00	 ret	 12			; 0000000cH
?MoveObserver@CPythonMiniMap@@QAEXKMM@Z ENDP		; CPythonMiniMap::MoveObserver
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?AddObserver@CPythonMiniMap@@QAEXKMM@Z
_TEXT	SEGMENT
$T1 = -40						; size = 8
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
$T6 = -16						; size = 4
$T7 = -12						; size = 4
$T8 = -8						; size = 4
$T9 = -4						; size = 4
$T10 = 0						; size = 4
___param0$ = 4						; size = 4
__Scary$11 = 8						; size = 4
$T12 = 12						; size = 4
_f$ = 16						; size = 4
tv246 = 20						; size = 4
_this$ = 24						; size = 4
$T13 = 31						; size = 1
_rkObserver$14 = 32					; size = 4
$T15 = 36						; size = 36
_kObserver$16 = 72					; size = 32
__$ArrayPad$ = 104					; size = 4
_dwVID$ = 116						; size = 4
_fSrcX$ = 120						; size = 4
_fSrcY$ = 124						; size = 4
?AddObserver@CPythonMiniMap@@QAEXKMM@Z PROC		; CPythonMiniMap::AddObserver, COMDAT
; _this$ = ecx

; 17   : {

  00000	55		 push	 ebp
  00001	8d 6c 24 94	 lea	 ebp, DWORD PTR [esp-108]
  00005	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 68	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	89 4d 18	 mov	 DWORD PTR _this$[ebp], ecx

; 18   : 	std::map<DWORD, SObserver>::iterator f=m_kMap_dwVID_kObserver.find(dwVID);

  0001a	8d 45 74	 lea	 eax, DWORD PTR _dwVID$[ebp]
  0001d	50		 push	 eax
  0001e	8d 45 10	 lea	 eax, DWORD PTR _f$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 18	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  0002b	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::find
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00030	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  00033	05 68 01 00 00	 add	 eax, 360		; 00000168H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00038	89 45 0c	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0003b	8b 45 0c	 mov	 eax, DWORD PTR $T12[ebp]
  0003e	89 45 08	 mov	 DWORD PTR __Scary$11[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00041	8b 45 08	 mov	 eax, DWORD PTR __Scary$11[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	89 45 04	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00049	8b 45 04	 mov	 eax, DWORD PTR ___param0$[ebp]
  0004c	89 45 00	 mov	 DWORD PTR $T10[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  0004f	8d 45 00	 lea	 eax, DWORD PTR $T10[ebp]
  00052	89 45 fc	 mov	 DWORD PTR $T9[ebp], eax

; 232  :         return this->_Ptr == _Right._Ptr;

  00055	8b 45 fc	 mov	 eax, DWORD PTR $T9[ebp]
  00058	8b 00		 mov	 eax, DWORD PTR [eax]
  0005a	3b 45 10	 cmp	 eax, DWORD PTR _f$[ebp]
  0005d	75 09		 jne	 SHORT $LN73@AddObserve
  0005f	c7 45 14 01 00
	00 00		 mov	 DWORD PTR tv246[ebp], 1
  00066	eb 04		 jmp	 SHORT $LN74@AddObserve
$LN73@AddObserve:
  00068	83 65 14 00	 and	 DWORD PTR tv246[ebp], 0
$LN74@AddObserve:
  0006c	8a 45 14	 mov	 al, BYTE PTR tv246[ebp]
  0006f	88 45 1f	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 19   : 	if (m_kMap_dwVID_kObserver.end()==f)

  00072	0f b6 45 1f	 movzx	 eax, BYTE PTR $T13[ebp]
  00076	85 c0		 test	 eax, eax
  00078	0f 84 89 00 00
	00		 je	 $LN2@AddObserve

; 20   : 	{
; 21   : 		SObserver kObserver;
; 22   : 		kObserver.dwSrcTime=ELTimer_GetMSec();

  0007e	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  00083	89 45 60	 mov	 DWORD PTR _kObserver$16[ebp+24], eax

; 23   : 		kObserver.dwDstTime=kObserver.dwSrcTime+1000;

  00086	8b 45 60	 mov	 eax, DWORD PTR _kObserver$16[ebp+24]
  00089	05 e8 03 00 00	 add	 eax, 1000		; 000003e8H
  0008e	89 45 64	 mov	 DWORD PTR _kObserver$16[ebp+28], eax

; 24   : 		kObserver.fSrcX=fSrcX;

  00091	f3 0f 10 45 78	 movss	 xmm0, DWORD PTR _fSrcX$[ebp]
  00096	f3 0f 11 45 50	 movss	 DWORD PTR _kObserver$16[ebp+8], xmm0

; 25   : 		kObserver.fSrcY=fSrcY;

  0009b	f3 0f 10 45 7c	 movss	 xmm0, DWORD PTR _fSrcY$[ebp]
  000a0	f3 0f 11 45 54	 movss	 DWORD PTR _kObserver$16[ebp+12], xmm0

; 26   : 		kObserver.fDstX=fSrcX;

  000a5	f3 0f 10 45 78	 movss	 xmm0, DWORD PTR _fSrcX$[ebp]
  000aa	f3 0f 11 45 58	 movss	 DWORD PTR _kObserver$16[ebp+16], xmm0

; 27   : 		kObserver.fDstY=fSrcY;

  000af	f3 0f 10 45 7c	 movss	 xmm0, DWORD PTR _fSrcY$[ebp]
  000b4	f3 0f 11 45 5c	 movss	 DWORD PTR _kObserver$16[ebp+20], xmm0

; 28   : 		kObserver.fCurX=fSrcX;

  000b9	f3 0f 10 45 78	 movss	 xmm0, DWORD PTR _fSrcX$[ebp]
  000be	f3 0f 11 45 48	 movss	 DWORD PTR _kObserver$16[ebp], xmm0

; 29   : 		kObserver.fCurY=fSrcY;

  000c3	f3 0f 10 45 7c	 movss	 xmm0, DWORD PTR _fSrcY$[ebp]
  000c8	f3 0f 11 45 4c	 movss	 DWORD PTR _kObserver$16[ebp+4], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000cd	8d 45 74	 lea	 eax, DWORD PTR _dwVID$[ebp]
  000d0	89 45 f8	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000d3	8b 45 f8	 mov	 eax, DWORD PTR $T8[ebp]
  000d6	8b 00		 mov	 eax, DWORD PTR [eax]
  000d8	89 45 24	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000db	8d 45 48	 lea	 eax, DWORD PTR _kObserver$16[ebp]
  000de	89 45 f4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000e1	8d 7d 28	 lea	 edi, DWORD PTR $T15[ebp+4]
  000e4	6a 08		 push	 8
  000e6	59		 pop	 ecx
  000e7	8b 75 f4	 mov	 esi, DWORD PTR $T7[ebp]
  000ea	f3 a5		 rep movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 30   : 		m_kMap_dwVID_kObserver.insert(std::map<DWORD, SObserver>::value_type(dwVID, kObserver));

  000ec	8d 45 24	 lea	 eax, DWORD PTR $T15[ebp]
  000ef	50		 push	 eax
  000f0	8d 45 d8	 lea	 eax, DWORD PTR $T1[ebp]
  000f3	50		 push	 eax
  000f4	8b 4d 18	 mov	 ecx, DWORD PTR _this$[ebp]
  000f7	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  000fd	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKUSObserver@CPythonMiniMap@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::insert<0,0>

; 31   : 	}

  00102	e9 93 00 00 00	 jmp	 $LN3@AddObserve
$LN2@AddObserve:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 185  :         return this->_Ptr->_Myval;

  00107	8b 45 10	 mov	 eax, DWORD PTR _f$[ebp]
  0010a	83 c0 10	 add	 eax, 16			; 00000010H
  0010d	89 45 f0	 mov	 DWORD PTR $T6[ebp], eax

; 273  :         return const_cast<reference>(_Mybase::operator*());

  00110	8b 45 f0	 mov	 eax, DWORD PTR $T6[ebp]
  00113	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00116	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00119	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  0011c	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  0011f	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 277  :         return pointer_traits<pointer>::pointer_to(**this);

  00122	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00125	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 34   : 		SObserver& rkObserver=f->second;

  00128	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  0012b	83 c0 04	 add	 eax, 4
  0012e	89 45 20	 mov	 DWORD PTR _rkObserver$14[ebp], eax

; 35   : 		rkObserver.dwSrcTime=ELTimer_GetMSec();

  00131	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  00136	8b 4d 20	 mov	 ecx, DWORD PTR _rkObserver$14[ebp]
  00139	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 36   : 		rkObserver.dwDstTime=rkObserver.dwSrcTime+1000;

  0013c	8b 45 20	 mov	 eax, DWORD PTR _rkObserver$14[ebp]
  0013f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00142	05 e8 03 00 00	 add	 eax, 1000		; 000003e8H
  00147	8b 4d 20	 mov	 ecx, DWORD PTR _rkObserver$14[ebp]
  0014a	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 37   : 		rkObserver.fSrcX=fSrcX;

  0014d	8b 45 20	 mov	 eax, DWORD PTR _rkObserver$14[ebp]
  00150	f3 0f 10 45 78	 movss	 xmm0, DWORD PTR _fSrcX$[ebp]
  00155	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 38   : 		rkObserver.fSrcY=fSrcY;

  0015a	8b 45 20	 mov	 eax, DWORD PTR _rkObserver$14[ebp]
  0015d	f3 0f 10 45 7c	 movss	 xmm0, DWORD PTR _fSrcY$[ebp]
  00162	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 39   : 		rkObserver.fDstX=fSrcX;

  00167	8b 45 20	 mov	 eax, DWORD PTR _rkObserver$14[ebp]
  0016a	f3 0f 10 45 78	 movss	 xmm0, DWORD PTR _fSrcX$[ebp]
  0016f	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 40   : 		rkObserver.fDstY=fSrcY;

  00174	8b 45 20	 mov	 eax, DWORD PTR _rkObserver$14[ebp]
  00177	f3 0f 10 45 7c	 movss	 xmm0, DWORD PTR _fSrcY$[ebp]
  0017c	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 41   : 		rkObserver.fCurX=fSrcX;

  00181	8b 45 20	 mov	 eax, DWORD PTR _rkObserver$14[ebp]
  00184	f3 0f 10 45 78	 movss	 xmm0, DWORD PTR _fSrcX$[ebp]
  00189	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 42   : 		rkObserver.fCurY=fSrcY;		

  0018d	8b 45 20	 mov	 eax, DWORD PTR _rkObserver$14[ebp]
  00190	f3 0f 10 45 7c	 movss	 xmm0, DWORD PTR _fSrcY$[ebp]
  00195	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
$LN3@AddObserve:

; 43   : 	}
; 44   : }

  0019a	5f		 pop	 edi
  0019b	5e		 pop	 esi
  0019c	8b 4d 68	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019f	33 cd		 xor	 ecx, ebp
  001a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a6	83 c5 6c	 add	 ebp, 108		; 0000006cH
  001a9	c9		 leave
  001aa	c2 0c 00	 ret	 12			; 0000000cH
?AddObserver@CPythonMiniMap@@QAEXKMM@Z ENDP		; CPythonMiniMap::AddObserver
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?GetAtlasSize@CPythonMiniMap@@QAE_NPAM0@Z
_TEXT	SEGMENT
_rkBG$ = -8						; size = 4
_this$ = -4						; size = 4
_pfSizeX$ = 8						; size = 4
_pfSizeY$ = 12						; size = 4
?GetAtlasSize@CPythonMiniMap@@QAE_NPAM0@Z PROC		; CPythonMiniMap::GetAtlasSize, COMDAT
; _this$ = ecx

; 1220 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1221 : 	CPythonBackground& rkBG=CPythonBackground::Instance();

  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  0000d	89 45 f8	 mov	 DWORD PTR _rkBG$[ebp], eax

; 1222 : 	if (!rkBG.IsMapOutdoor())

  00010	8b 4d f8	 mov	 ecx, DWORD PTR _rkBG$[ebp]
  00013	e8 00 00 00 00	 call	 ?IsMapOutdoor@CMapManager@@QAE_NXZ ; CMapManager::IsMapOutdoor
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	75 04		 jne	 SHORT $LN2@GetAtlasSi

; 1223 : 		return false;

  0001f	32 c0		 xor	 al, al
  00021	eb 1e		 jmp	 SHORT $LN1@GetAtlasSi
$LN2@GetAtlasSi:

; 1224 : 
; 1225 : 	*pfSizeX = m_fAtlasImageSizeX;

  00023	8b 45 08	 mov	 eax, DWORD PTR _pfSizeX$[ebp]
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 89 30 03 00
	00		 mov	 ecx, DWORD PTR [ecx+816]
  0002f	89 08		 mov	 DWORD PTR [eax], ecx

; 1226 : 	*pfSizeY = m_fAtlasImageSizeY;

  00031	8b 45 0c	 mov	 eax, DWORD PTR _pfSizeY$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 89 34 03 00
	00		 mov	 ecx, DWORD PTR [ecx+820]
  0003d	89 08		 mov	 DWORD PTR [eax], ecx

; 1227 : 
; 1228 : 	return true;

  0003f	b0 01		 mov	 al, 1
$LN1@GetAtlasSi:

; 1229 : }

  00041	c9		 leave
  00042	c2 08 00	 ret	 8
?GetAtlasSize@CPythonMiniMap@@QAE_NPAM0@Z ENDP		; CPythonMiniMap::GetAtlasSize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?GetAtlasInfo@CPythonMiniMap@@QAE_NMMAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM1PAK2@Z
_TEXT	SEGMENT
$T1 = -512						; size = 4
$T2 = -508						; size = 4
$T3 = -504						; size = 4
$T4 = -500						; size = 4
$T5 = -496						; size = 4
$T6 = -492						; size = 4
$T7 = -488						; size = 4
$T8 = -484						; size = 4
___param0$ = -480					; size = 4
_dwB$9 = -476						; size = 4
_dwA$10 = -472						; size = 4
_dwR$11 = -468						; size = 4
_dwG$12 = -464						; size = 4
$T13 = -460						; size = 4
$T14 = -456						; size = 4
$T15 = -452						; size = 4
$T16 = -448						; size = 4
$T17 = -444						; size = 4
$T18 = -440						; size = 4
$T19 = -436						; size = 1
___param0$ = -432					; size = 4
_dwB$20 = -428						; size = 4
_dwA$21 = -424						; size = 4
_dwR$22 = -420						; size = 4
_dwG$23 = -416						; size = 4
$T24 = -412						; size = 1
$T25 = -408						; size = 4
$T26 = -404						; size = 4
$T27 = -400						; size = 4
$T28 = -396						; size = 4
___param0$ = -392					; size = 4
$T29 = -388						; size = 4
$T30 = -384						; size = 4
___param0$ = -380					; size = 4
_dwB$31 = -376						; size = 4
_dwA$32 = -372						; size = 4
_dwR$33 = -368						; size = 4
_dwG$34 = -364						; size = 4
$T35 = -360						; size = 4
$T36 = -356						; size = 4
$T37 = -352						; size = 4
$T38 = -348						; size = 4
$T39 = -344						; size = 4
___param0$ = -340					; size = 4
$T40 = -336						; size = 4
$T41 = -332						; size = 4
___param0$ = -328					; size = 4
_dwB$42 = -324						; size = 4
_dwA$43 = -320						; size = 4
_dwR$44 = -316						; size = 4
_dwG$45 = -312						; size = 4
$T46 = -308						; size = 1
$T47 = -304						; size = 4
$T48 = -300						; size = 4
$T49 = -296						; size = 4
$T50 = -292						; size = 4
___param0$ = -288					; size = 4
$T51 = -284						; size = 4
$T52 = -280						; size = 4
___param0$ = -276					; size = 4
_dwB$53 = -272						; size = 4
_dwA$54 = -268						; size = 4
_dwR$55 = -264						; size = 4
_dwG$56 = -260						; size = 4
$T57 = -256						; size = 4
$T58 = -252						; size = 4
__Ptr$ = -248						; size = 4
tv1013 = -244						; size = 4
tv992 = -240						; size = 4
tv989 = -236						; size = 4
tv990 = -232						; size = 4
tv1019 = -228						; size = 4
tv993 = -224						; size = 4
tv1009 = -220						; size = 4
tv1005 = -216						; size = 4
tv960 = -212						; size = 4
tv974 = -208						; size = 4
__My_data$59 = -204					; size = 4
__My_data$60 = -200					; size = 4
_this$ = -196						; size = 4
tv906 = -192						; size = 4
tv905 = -188						; size = 4
tv895 = -184						; size = 4
tv894 = -180						; size = 4
tv821 = -176						; size = 4
tv824 = -172						; size = 4
tv882 = -168						; size = 4
tv884 = -164						; size = 4
__Right$ = -160						; size = 4
tv797 = -156						; size = 4
tv811 = -152						; size = 4
__My_data$61 = -148					; size = 4
__My_data$62 = -144					; size = 4
_this$ = -140						; size = 4
tv749 = -136						; size = 4
tv748 = -132						; size = 4
tv738 = -128						; size = 4
tv737 = -124						; size = 4
tv727 = -120						; size = 4
tv726 = -116						; size = 4
tv705 = -112						; size = 4
tv706 = -108						; size = 4
__Right$ = -104						; size = 4
tv674 = -100						; size = 4
tv688 = -96						; size = 4
__My_data$63 = -92					; size = 4
__My_data$64 = -88					; size = 4
_this$ = -84						; size = 4
tv594 = -80						; size = 4
tv593 = -76						; size = 4
tv583 = -72						; size = 4
tv582 = -68						; size = 4
tv572 = -64						; size = 4
tv571 = -60						; size = 4
tv550 = -56						; size = 4
tv551 = -52						; size = 4
__Right$ = -48						; size = 4
tv519 = -44						; size = 4
tv533 = -40						; size = 4
__My_data$65 = -36					; size = 4
__My_data$66 = -32					; size = 4
tv477 = -28						; size = 4
tv476 = -24						; size = 4
tv466 = -20						; size = 4
tv465 = -16						; size = 4
tv455 = -12						; size = 4
tv454 = -8						; size = 4
tv412 = -4						; size = 4
tv411 = 0						; size = 4
_itor$ = 4						; size = 4
_pkInst$ = 8						; size = 4
_fCheckHeight$ = 12					; size = 4
_rAtlasMarkInfo$67 = 16					; size = 4
_rAtlasMarkInfo$68 = 20					; size = 4
$T69 = 24						; size = 1
$T70 = 25						; size = 1
$T71 = 26						; size = 1
$T72 = 27						; size = 1
$T73 = 28						; size = 1
$T74 = 29						; size = 1
$T75 = 30						; size = 1
$T76 = 31						; size = 1
_fRealY$ = 32						; size = 4
_fRealX$ = 36						; size = 4
_rAtlasMarkInfo$77 = 40					; size = 4
_rInfo$78 = 44						; size = 4
_fCheckWidth$ = 48					; size = 4
_this$ = 52						; size = 4
_this$ = 56						; size = 4
_this$ = 60						; size = 4
_this$ = 64						; size = 4
_this$ = 68						; size = 4
_this$ = 72						; size = 4
_kInstPos$79 = 76					; size = 12
__$ArrayPad$ = 88					; size = 4
_fScreenX$ = 100					; size = 4
_fScreenY$ = 104					; size = 4
_rReturnString$ = 108					; size = 4
_pReturnPosX$ = 112					; size = 4
_pReturnPosY$ = 116					; size = 4
_pdwTextColor$ = 120					; size = 4
_pdwGuildID$ = 124					; size = 4
?GetAtlasInfo@CPythonMiniMap@@QAE_NMMAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM1PAK2@Z PROC ; CPythonMiniMap::GetAtlasInfo, COMDAT
; _this$ = ecx

; 1114 : {

  00000	55		 push	 ebp
  00001	8d 6c 24 a4	 lea	 ebp, DWORD PTR [esp-92]
  00005	81 ec 5c 02 00
	00		 sub	 esp, 604		; 0000025cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 58	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	89 4d 48	 mov	 DWORD PTR _this$[ebp], ecx

; 1115 : 	float fRealX = (fScreenX - m_fAtlasScreenX) * (m_fAtlasMaxX / m_fAtlasImageSizeX);

  00018	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR _fScreenX$[ebp]
  00020	f3 0f 5c 80 18
	03 00 00	 subss	 xmm0, DWORD PTR [eax+792]
  00028	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 48	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	f3 0f 10 88 28
	03 00 00	 movss	 xmm1, DWORD PTR [eax+808]
  00036	f3 0f 5e 89 30
	03 00 00	 divss	 xmm1, DWORD PTR [ecx+816]
  0003e	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00042	f3 0f 11 45 24	 movss	 DWORD PTR _fRealX$[ebp], xmm0

; 1116 : 	float fRealY = (fScreenY - m_fAtlasScreenY) * (m_fAtlasMaxY / m_fAtlasImageSizeY);

  00047	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	f3 0f 10 45 68	 movss	 xmm0, DWORD PTR _fScreenY$[ebp]
  0004f	f3 0f 5c 80 1c
	03 00 00	 subss	 xmm0, DWORD PTR [eax+796]
  00057	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 4d 48	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	f3 0f 10 88 2c
	03 00 00	 movss	 xmm1, DWORD PTR [eax+812]
  00065	f3 0f 5e 89 34
	03 00 00	 divss	 xmm1, DWORD PTR [ecx+820]
  0006d	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00071	f3 0f 11 45 20	 movss	 DWORD PTR _fRealY$[ebp], xmm0

; 1117 : 
; 1118 : 	//((float) CTerrainImpl::CELLSCALE) * 10.0f
; 1119 : 	float fCheckWidth = (m_fAtlasMaxX / m_fAtlasImageSizeX) * 5.0f;

  00076	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00079	8b 4d 48	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	f3 0f 10 80 28
	03 00 00	 movss	 xmm0, DWORD PTR [eax+808]
  00084	f3 0f 5e 81 30
	03 00 00	 divss	 xmm0, DWORD PTR [ecx+816]
  0008c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40a00000
  00094	f3 0f 11 45 30	 movss	 DWORD PTR _fCheckWidth$[ebp], xmm0

; 1120 : 	float fCheckHeight = (m_fAtlasMaxY / m_fAtlasImageSizeY) * 5.0f;

  00099	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  0009c	8b 4d 48	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	f3 0f 10 80 2c
	03 00 00	 movss	 xmm0, DWORD PTR [eax+812]
  000a7	f3 0f 5e 81 34
	03 00 00	 divss	 xmm0, DWORD PTR [ecx+820]
  000af	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40a00000
  000b7	f3 0f 11 45 0c	 movss	 DWORD PTR _fCheckHeight$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  000bc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  000c1	89 85 98 fe ff
	ff		 mov	 DWORD PTR $T35[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1122 : 	CInstanceBase * pkInst = CPythonCharacterManager::Instance().GetMainInstancePtr();

  000c7	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR $T35[ebp]
  000cd	e8 00 00 00 00	 call	 ?GetMainInstancePtr@CPythonCharacterManager@@QAEPAVCInstanceBase@@XZ ; CPythonCharacterManager::GetMainInstancePtr
  000d2	89 45 08	 mov	 DWORD PTR _pkInst$[ebp], eax

; 1123 : 
; 1124 : 	if (pkInst)

  000d5	83 7d 08 00	 cmp	 DWORD PTR _pkInst$[ebp], 0
  000d9	0f 84 61 02 00
	00		 je	 $LN12@GetAtlasIn

; 1125 : 	{
; 1126 : 		TPixelPosition kInstPos;
; 1127 : 		pkInst->NEW_GetPixelPosition(&kInstPos);

  000df	8d 45 4c	 lea	 eax, DWORD PTR _kInstPos$79[ebp]
  000e2	50		 push	 eax
  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _pkInst$[ebp]
  000e6	e8 00 00 00 00	 call	 ?NEW_GetPixelPosition@CInstanceBase@@QAEXPAUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_GetPixelPosition

; 1128 : 
; 1129 : 		if (kInstPos.x-fCheckWidth<fRealX && kInstPos.x+fCheckWidth>fRealX && 
; 1130 : 			kInstPos.y-fCheckHeight<fRealY && kInstPos.y+fCheckHeight>fRealY)

  000eb	f3 0f 10 45 4c	 movss	 xmm0, DWORD PTR _kInstPos$79[ebp]
  000f0	f3 0f 5c 45 30	 subss	 xmm0, DWORD PTR _fCheckWidth$[ebp]
  000f5	f3 0f 10 4d 24	 movss	 xmm1, DWORD PTR _fRealX$[ebp]
  000fa	0f 2f c8	 comiss	 xmm1, xmm0
  000fd	0f 86 3d 02 00
	00		 jbe	 $LN12@GetAtlasIn
  00103	f3 0f 10 45 4c	 movss	 xmm0, DWORD PTR _kInstPos$79[ebp]
  00108	f3 0f 58 45 30	 addss	 xmm0, DWORD PTR _fCheckWidth$[ebp]
  0010d	0f 2f 45 24	 comiss	 xmm0, DWORD PTR _fRealX$[ebp]
  00111	0f 86 29 02 00
	00		 jbe	 $LN12@GetAtlasIn
  00117	f3 0f 10 45 50	 movss	 xmm0, DWORD PTR _kInstPos$79[ebp+4]
  0011c	f3 0f 5c 45 0c	 subss	 xmm0, DWORD PTR _fCheckHeight$[ebp]
  00121	f3 0f 10 4d 20	 movss	 xmm1, DWORD PTR _fRealY$[ebp]
  00126	0f 2f c8	 comiss	 xmm1, xmm0
  00129	0f 86 11 02 00
	00		 jbe	 $LN12@GetAtlasIn
  0012f	f3 0f 10 45 50	 movss	 xmm0, DWORD PTR _kInstPos$79[ebp+4]
  00134	f3 0f 58 45 0c	 addss	 xmm0, DWORD PTR _fCheckHeight$[ebp]
  00139	0f 2f 45 20	 comiss	 xmm0, DWORD PTR _fRealY$[ebp]
  0013d	0f 86 fd 01 00
	00		 jbe	 $LN12@GetAtlasIn

; 1131 : 		{
; 1132 : 			rReturnString = pkInst->GetNameString();

  00143	8b 4d 08	 mov	 ecx, DWORD PTR _pkInst$[ebp]
  00146	e8 00 00 00 00	 call	 ?GetNameString@CInstanceBase@@QAEPBDXZ ; CInstanceBase::GetNameString
  0014b	89 85 08 ff ff
	ff		 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00151	ff b5 08 ff ff
	ff		 push	 DWORD PTR __Ptr$[ebp]
  00157	e8 00 00 00 00	 call	 _strlen
  0015c	59		 pop	 ecx
  0015d	89 85 04 ff ff
	ff		 mov	 DWORD PTR $T58[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00163	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR $T58[ebp]
  00169	89 85 00 ff ff
	ff		 mov	 DWORD PTR $T57[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0016f	ff b5 00 ff ff
	ff		 push	 DWORD PTR $T57[ebp]
  00175	ff b5 08 ff ff
	ff		 push	 DWORD PTR __Ptr$[ebp]
  0017b	8b 4d 6c	 mov	 ecx, DWORD PTR _rReturnString$[ebp]
  0017e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1133 : 			*pReturnPosX = kInstPos.x;

  00183	8b 45 70	 mov	 eax, DWORD PTR _pReturnPosX$[ebp]
  00186	f3 0f 10 45 4c	 movss	 xmm0, DWORD PTR _kInstPos$79[ebp]
  0018b	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1134 : 			*pReturnPosY = kInstPos.y;

  0018f	8b 45 74	 mov	 eax, DWORD PTR _pReturnPosY$[ebp]
  00192	f3 0f 10 45 50	 movss	 xmm0, DWORD PTR _kInstPos$79[ebp+4]
  00197	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1135 : 			*pdwTextColor = pkInst->GetNameColor();

  0019b	8b 4d 08	 mov	 ecx, DWORD PTR _pkInst$[ebp]
  0019e	e8 00 00 00 00	 call	 ?GetNameColor@CInstanceBase@@QAEABUD3DXCOLOR@@XZ ; CInstanceBase::GetNameColor
  001a3	89 45 44	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  001a6	8b 45 44	 mov	 eax, DWORD PTR _this$[ebp]
  001a9	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001ad	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  001b4	72 09		 jb	 SHORT $LN43@GetAtlasIn
  001b6	c7 45 fc ff 00
	00 00		 mov	 DWORD PTR tv412[ebp], 255 ; 000000ffH
  001bd	eb 36		 jmp	 SHORT $LN44@GetAtlasIn
$LN43@GetAtlasIn:
  001bf	8b 45 44	 mov	 eax, DWORD PTR _this$[ebp]
  001c2	0f 57 c0	 xorps	 xmm0, xmm0
  001c5	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  001c8	72 06		 jb	 SHORT $LN41@GetAtlasIn
  001ca	83 65 00 00	 and	 DWORD PTR tv411[ebp], 0
  001ce	eb 1f		 jmp	 SHORT $LN42@GetAtlasIn
$LN41@GetAtlasIn:
  001d0	8b 45 44	 mov	 eax, DWORD PTR _this$[ebp]
  001d3	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001d7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  001df	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  001e7	e8 00 00 00 00	 call	 __ftoui3
  001ec	89 45 00	 mov	 DWORD PTR tv411[ebp], eax
$LN42@GetAtlasIn:
  001ef	8b 45 00	 mov	 eax, DWORD PTR tv411[ebp]
  001f2	89 45 fc	 mov	 DWORD PTR tv412[ebp], eax
$LN44@GetAtlasIn:
  001f5	8b 45 fc	 mov	 eax, DWORD PTR tv412[ebp]
  001f8	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _dwR$55[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  001fe	8b 45 44	 mov	 eax, DWORD PTR _this$[ebp]
  00201	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00206	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0020d	72 09		 jb	 SHORT $LN47@GetAtlasIn
  0020f	c7 45 f4 ff 00
	00 00		 mov	 DWORD PTR tv455[ebp], 255 ; 000000ffH
  00216	eb 38		 jmp	 SHORT $LN48@GetAtlasIn
$LN47@GetAtlasIn:
  00218	8b 45 44	 mov	 eax, DWORD PTR _this$[ebp]
  0021b	0f 57 c0	 xorps	 xmm0, xmm0
  0021e	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  00222	72 06		 jb	 SHORT $LN45@GetAtlasIn
  00224	83 65 f8 00	 and	 DWORD PTR tv454[ebp], 0
  00228	eb 20		 jmp	 SHORT $LN46@GetAtlasIn
$LN45@GetAtlasIn:
  0022a	8b 45 44	 mov	 eax, DWORD PTR _this$[ebp]
  0022d	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00232	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0023a	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00242	e8 00 00 00 00	 call	 __ftoui3
  00247	89 45 f8	 mov	 DWORD PTR tv454[ebp], eax
$LN46@GetAtlasIn:
  0024a	8b 45 f8	 mov	 eax, DWORD PTR tv454[ebp]
  0024d	89 45 f4	 mov	 DWORD PTR tv455[ebp], eax
$LN48@GetAtlasIn:
  00250	8b 45 f4	 mov	 eax, DWORD PTR tv455[ebp]
  00253	89 85 fc fe ff
	ff		 mov	 DWORD PTR _dwG$56[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  00259	8b 45 44	 mov	 eax, DWORD PTR _this$[ebp]
  0025c	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00261	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00268	72 09		 jb	 SHORT $LN51@GetAtlasIn
  0026a	c7 45 ec ff 00
	00 00		 mov	 DWORD PTR tv466[ebp], 255 ; 000000ffH
  00271	eb 38		 jmp	 SHORT $LN52@GetAtlasIn
$LN51@GetAtlasIn:
  00273	8b 45 44	 mov	 eax, DWORD PTR _this$[ebp]
  00276	0f 57 c0	 xorps	 xmm0, xmm0
  00279	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  0027d	72 06		 jb	 SHORT $LN49@GetAtlasIn
  0027f	83 65 f0 00	 and	 DWORD PTR tv465[ebp], 0
  00283	eb 20		 jmp	 SHORT $LN50@GetAtlasIn
$LN49@GetAtlasIn:
  00285	8b 45 44	 mov	 eax, DWORD PTR _this$[ebp]
  00288	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0028d	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00295	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0029d	e8 00 00 00 00	 call	 __ftoui3
  002a2	89 45 f0	 mov	 DWORD PTR tv465[ebp], eax
$LN50@GetAtlasIn:
  002a5	8b 45 f0	 mov	 eax, DWORD PTR tv465[ebp]
  002a8	89 45 ec	 mov	 DWORD PTR tv466[ebp], eax
$LN52@GetAtlasIn:
  002ab	8b 45 ec	 mov	 eax, DWORD PTR tv466[ebp]
  002ae	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _dwB$53[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  002b4	8b 45 44	 mov	 eax, DWORD PTR _this$[ebp]
  002b7	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  002bc	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  002c3	72 09		 jb	 SHORT $LN55@GetAtlasIn
  002c5	c7 45 e4 ff 00
	00 00		 mov	 DWORD PTR tv477[ebp], 255 ; 000000ffH
  002cc	eb 38		 jmp	 SHORT $LN56@GetAtlasIn
$LN55@GetAtlasIn:
  002ce	8b 45 44	 mov	 eax, DWORD PTR _this$[ebp]
  002d1	0f 57 c0	 xorps	 xmm0, xmm0
  002d4	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  002d8	72 06		 jb	 SHORT $LN53@GetAtlasIn
  002da	83 65 e8 00	 and	 DWORD PTR tv476[ebp], 0
  002de	eb 20		 jmp	 SHORT $LN54@GetAtlasIn
$LN53@GetAtlasIn:
  002e0	8b 45 44	 mov	 eax, DWORD PTR _this$[ebp]
  002e3	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  002e8	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  002f0	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  002f8	e8 00 00 00 00	 call	 __ftoui3
  002fd	89 45 e8	 mov	 DWORD PTR tv476[ebp], eax
$LN54@GetAtlasIn:
  00300	8b 45 e8	 mov	 eax, DWORD PTR tv476[ebp]
  00303	89 45 e4	 mov	 DWORD PTR tv477[ebp], eax
$LN56@GetAtlasIn:
  00306	8b 45 e4	 mov	 eax, DWORD PTR tv477[ebp]
  00309	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _dwA$54[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  0030f	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _dwG$56[ebp]
  00315	c1 e0 08	 shl	 eax, 8
  00318	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _dwR$55[ebp]
  0031e	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00321	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _dwA$54[ebp]
  00327	c1 e2 18	 shl	 edx, 24			; 00000018H
  0032a	0b d1		 or	 edx, ecx
  0032c	0b d0		 or	 edx, eax
  0032e	0b 95 f0 fe ff
	ff		 or	 edx, DWORD PTR _dwB$53[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1135 : 			*pdwTextColor = pkInst->GetNameColor();

  00334	8b 45 78	 mov	 eax, DWORD PTR _pdwTextColor$[ebp]
  00337	89 10		 mov	 DWORD PTR [eax], edx

; 1136 : 			return true;		

  00339	b0 01		 mov	 al, 1
  0033b	e9 02 0f 00 00	 jmp	 $LN1@GetAtlasIn
$LN12@GetAtlasIn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00340	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00343	05 3c 03 00 00	 add	 eax, 828		; 0000033cH
  00348	89 45 e0	 mov	 DWORD PTR __My_data$66[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0034b	8b 45 e0	 mov	 eax, DWORD PTR __My_data$66[ebp]
  0034e	89 85 00 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00354	8b 45 e0	 mov	 eax, DWORD PTR __My_data$66[ebp]
  00357	8b 00		 mov	 eax, DWORD PTR [eax]
  00359	89 85 ec fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0035f	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  00365	89 85 e8 fe ff
	ff		 mov	 DWORD PTR $T52[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0036b	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR $T52[ebp]
  00371	89 85 e4 fe ff
	ff		 mov	 DWORD PTR $T51[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1140 : 	m_AtlasMarkInfoVectorIterator = m_AtlasNPCInfoVector.begin();

  00377	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR $T51[ebp]
  0037d	8b 00		 mov	 eax, DWORD PTR [eax]
  0037f	8b 4d 48	 mov	 ecx, DWORD PTR _this$[ebp]
  00382	89 81 38 03 00
	00		 mov	 DWORD PTR [ecx+824], eax
$LN2@GetAtlasIn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00388	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  0038b	05 3c 03 00 00	 add	 eax, 828		; 0000033cH
  00390	89 45 dc	 mov	 DWORD PTR __My_data$65[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00393	8b 45 dc	 mov	 eax, DWORD PTR __My_data$65[ebp]
  00396	89 85 1c fe ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0039c	8b 45 dc	 mov	 eax, DWORD PTR __My_data$65[ebp]
  0039f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  003a2	89 85 e0 fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  003a8	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  003ae	89 85 dc fe ff
	ff		 mov	 DWORD PTR $T50[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  003b4	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR $T50[ebp]
  003ba	89 85 d8 fe ff
	ff		 mov	 DWORD PTR $T49[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  003c0	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  003c3	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR $T49[ebp]
  003c9	8b 80 38 03 00
	00		 mov	 eax, DWORD PTR [eax+824]
  003cf	3b 01		 cmp	 eax, DWORD PTR [ecx]
  003d1	75 09		 jne	 SHORT $LN94@GetAtlasIn
  003d3	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv533[ebp], 1
  003da	eb 04		 jmp	 SHORT $LN95@GetAtlasIn
$LN94@GetAtlasIn:
  003dc	83 65 d8 00	 and	 DWORD PTR tv533[ebp], 0
$LN95@GetAtlasIn:
  003e0	8a 45 d8	 mov	 al, BYTE PTR tv533[ebp]
  003e3	88 45 1f	 mov	 BYTE PTR $T76[ebp], al

; 153  :         return !(*this == _Right);

  003e6	0f b6 45 1f	 movzx	 eax, BYTE PTR $T76[ebp]
  003ea	85 c0		 test	 eax, eax
  003ec	75 09		 jne	 SHORT $LN89@GetAtlasIn
  003ee	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR tv519[ebp], 1
  003f5	eb 04		 jmp	 SHORT $LN90@GetAtlasIn
$LN89@GetAtlasIn:
  003f7	83 65 d4 00	 and	 DWORD PTR tv519[ebp], 0
$LN90@GetAtlasIn:
  003fb	8a 45 d4	 mov	 al, BYTE PTR tv519[ebp]
  003fe	88 45 1e	 mov	 BYTE PTR $T75[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1141 : 	while (m_AtlasMarkInfoVectorIterator != m_AtlasNPCInfoVector.end())

  00401	0f b6 45 1e	 movzx	 eax, BYTE PTR $T75[ebp]
  00405	85 c0		 test	 eax, eax
  00407	0f 84 a2 02 00
	00		 je	 $LN3@GetAtlasIn
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  0040d	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00410	8b 80 38 03 00
	00		 mov	 eax, DWORD PTR [eax+824]
  00416	89 85 d4 fe ff
	ff		 mov	 DWORD PTR $T48[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  0041c	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR $T48[ebp]
  00422	89 45 14	 mov	 DWORD PTR _rAtlasMarkInfo$68[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1146 : 			rAtlasMarkInfo.m_fY-fCheckWidth/2<fRealY && rAtlasMarkInfo.m_fY+fCheckHeight>fRealY)		

  00425	f3 0f 10 45 30	 movss	 xmm0, DWORD PTR _fCheckWidth$[ebp]
  0042a	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00432	8b 45 14	 mov	 eax, DWORD PTR _rAtlasMarkInfo$68[ebp]
  00435	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  0043a	f3 0f 5c c8	 subss	 xmm1, xmm0
  0043e	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fRealX$[ebp]
  00443	0f 2f c1	 comiss	 xmm0, xmm1
  00446	0f 86 46 02 00
	00		 jbe	 $LN13@GetAtlasIn
  0044c	8b 45 14	 mov	 eax, DWORD PTR _rAtlasMarkInfo$68[ebp]
  0044f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00454	f3 0f 58 45 30	 addss	 xmm0, DWORD PTR _fCheckWidth$[ebp]
  00459	0f 2f 45 24	 comiss	 xmm0, DWORD PTR _fRealX$[ebp]
  0045d	0f 86 2f 02 00
	00		 jbe	 $LN13@GetAtlasIn
  00463	f3 0f 10 45 30	 movss	 xmm0, DWORD PTR _fCheckWidth$[ebp]
  00468	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00470	8b 45 14	 mov	 eax, DWORD PTR _rAtlasMarkInfo$68[ebp]
  00473	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [eax+12]
  00478	f3 0f 5c c8	 subss	 xmm1, xmm0
  0047c	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _fRealY$[ebp]
  00481	0f 2f c1	 comiss	 xmm0, xmm1
  00484	0f 86 08 02 00
	00		 jbe	 $LN13@GetAtlasIn
  0048a	8b 45 14	 mov	 eax, DWORD PTR _rAtlasMarkInfo$68[ebp]
  0048d	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00492	f3 0f 58 45 0c	 addss	 xmm0, DWORD PTR _fCheckHeight$[ebp]
  00497	0f 2f 45 20	 comiss	 xmm0, DWORD PTR _fRealY$[ebp]
  0049b	0f 86 f1 01 00
	00		 jbe	 $LN13@GetAtlasIn

; 1147 : 		{
; 1148 : 			rReturnString = rAtlasMarkInfo.m_strText;

  004a1	8b 45 14	 mov	 eax, DWORD PTR _rAtlasMarkInfo$68[ebp]
  004a4	83 c0 24	 add	 eax, 36			; 00000024H
  004a7	89 45 d0	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  004aa	8b 45 d0	 mov	 eax, DWORD PTR __Right$[ebp]
  004ad	89 85 d0 fe ff
	ff		 mov	 DWORD PTR $T47[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  004b3	8b 45 6c	 mov	 eax, DWORD PTR _rReturnString$[ebp]
  004b6	3b 85 d0 fe ff
	ff		 cmp	 eax, DWORD PTR $T47[ebp]
  004bc	74 19		 je	 SHORT $LN107@GetAtlasIn

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  004be	33 c0		 xor	 eax, eax
  004c0	88 85 cc fe ff
	ff		 mov	 BYTE PTR $T46[ebp], al
  004c6	ff b5 cc fe ff
	ff		 push	 DWORD PTR $T46[ebp]
  004cc	ff 75 d0	 push	 DWORD PTR __Right$[ebp]
  004cf	8b 4d 6c	 mov	 ecx, DWORD PTR _rReturnString$[ebp]
  004d2	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
$LN107@GetAtlasIn:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1149 : 			*pReturnPosX = rAtlasMarkInfo.m_fX;

  004d7	8b 45 70	 mov	 eax, DWORD PTR _pReturnPosX$[ebp]
  004da	8b 4d 14	 mov	 ecx, DWORD PTR _rAtlasMarkInfo$68[ebp]
  004dd	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  004e0	89 08		 mov	 DWORD PTR [eax], ecx

; 1150 : 			*pReturnPosY = rAtlasMarkInfo.m_fY;

  004e2	8b 45 74	 mov	 eax, DWORD PTR _pReturnPosY$[ebp]
  004e5	8b 4d 14	 mov	 ecx, DWORD PTR _rAtlasMarkInfo$68[ebp]
  004e8	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  004eb	89 08		 mov	 DWORD PTR [eax], ecx

; 1151 : 			*pdwTextColor = CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_NPC);//m_MarkTypeToColorMap[rAtlasMarkInfo.m_byType];

  004ed	6a 01		 push	 1
  004ef	e8 00 00 00 00	 call	 ?GetIndexedNameColor@CInstanceBase@@SAABUD3DXCOLOR@@I@Z ; CInstanceBase::GetIndexedNameColor
  004f4	59		 pop	 ecx
  004f5	89 45 40	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  004f8	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  004fb	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  004ff	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00506	72 09		 jb	 SHORT $LN130@GetAtlasIn
  00508	c7 45 c8 ff 00
	00 00		 mov	 DWORD PTR tv550[ebp], 255 ; 000000ffH
  0050f	eb 36		 jmp	 SHORT $LN131@GetAtlasIn
$LN130@GetAtlasIn:
  00511	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  00514	0f 57 c0	 xorps	 xmm0, xmm0
  00517	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  0051a	72 06		 jb	 SHORT $LN128@GetAtlasIn
  0051c	83 65 cc 00	 and	 DWORD PTR tv551[ebp], 0
  00520	eb 1f		 jmp	 SHORT $LN129@GetAtlasIn
$LN128@GetAtlasIn:
  00522	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  00525	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00529	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00531	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00539	e8 00 00 00 00	 call	 __ftoui3
  0053e	89 45 cc	 mov	 DWORD PTR tv551[ebp], eax
$LN129@GetAtlasIn:
  00541	8b 45 cc	 mov	 eax, DWORD PTR tv551[ebp]
  00544	89 45 c8	 mov	 DWORD PTR tv550[ebp], eax
$LN131@GetAtlasIn:
  00547	8b 45 c8	 mov	 eax, DWORD PTR tv550[ebp]
  0054a	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _dwR$44[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  00550	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  00553	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00558	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0055f	72 09		 jb	 SHORT $LN134@GetAtlasIn
  00561	c7 45 c0 ff 00
	00 00		 mov	 DWORD PTR tv572[ebp], 255 ; 000000ffH
  00568	eb 38		 jmp	 SHORT $LN135@GetAtlasIn
$LN134@GetAtlasIn:
  0056a	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  0056d	0f 57 c0	 xorps	 xmm0, xmm0
  00570	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  00574	72 06		 jb	 SHORT $LN132@GetAtlasIn
  00576	83 65 c4 00	 and	 DWORD PTR tv571[ebp], 0
  0057a	eb 20		 jmp	 SHORT $LN133@GetAtlasIn
$LN132@GetAtlasIn:
  0057c	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  0057f	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00584	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0058c	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00594	e8 00 00 00 00	 call	 __ftoui3
  00599	89 45 c4	 mov	 DWORD PTR tv571[ebp], eax
$LN133@GetAtlasIn:
  0059c	8b 45 c4	 mov	 eax, DWORD PTR tv571[ebp]
  0059f	89 45 c0	 mov	 DWORD PTR tv572[ebp], eax
$LN135@GetAtlasIn:
  005a2	8b 45 c0	 mov	 eax, DWORD PTR tv572[ebp]
  005a5	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _dwG$45[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  005ab	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  005ae	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  005b3	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  005ba	72 09		 jb	 SHORT $LN138@GetAtlasIn
  005bc	c7 45 b8 ff 00
	00 00		 mov	 DWORD PTR tv583[ebp], 255 ; 000000ffH
  005c3	eb 38		 jmp	 SHORT $LN139@GetAtlasIn
$LN138@GetAtlasIn:
  005c5	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  005c8	0f 57 c0	 xorps	 xmm0, xmm0
  005cb	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  005cf	72 06		 jb	 SHORT $LN136@GetAtlasIn
  005d1	83 65 bc 00	 and	 DWORD PTR tv582[ebp], 0
  005d5	eb 20		 jmp	 SHORT $LN137@GetAtlasIn
$LN136@GetAtlasIn:
  005d7	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  005da	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  005df	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  005e7	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  005ef	e8 00 00 00 00	 call	 __ftoui3
  005f4	89 45 bc	 mov	 DWORD PTR tv582[ebp], eax
$LN137@GetAtlasIn:
  005f7	8b 45 bc	 mov	 eax, DWORD PTR tv582[ebp]
  005fa	89 45 b8	 mov	 DWORD PTR tv583[ebp], eax
$LN139@GetAtlasIn:
  005fd	8b 45 b8	 mov	 eax, DWORD PTR tv583[ebp]
  00600	89 85 bc fe ff
	ff		 mov	 DWORD PTR _dwB$42[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  00606	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  00609	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0060e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00615	72 09		 jb	 SHORT $LN142@GetAtlasIn
  00617	c7 45 b0 ff 00
	00 00		 mov	 DWORD PTR tv594[ebp], 255 ; 000000ffH
  0061e	eb 38		 jmp	 SHORT $LN143@GetAtlasIn
$LN142@GetAtlasIn:
  00620	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  00623	0f 57 c0	 xorps	 xmm0, xmm0
  00626	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  0062a	72 06		 jb	 SHORT $LN140@GetAtlasIn
  0062c	83 65 b4 00	 and	 DWORD PTR tv593[ebp], 0
  00630	eb 20		 jmp	 SHORT $LN141@GetAtlasIn
$LN140@GetAtlasIn:
  00632	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  00635	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0063a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00642	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0064a	e8 00 00 00 00	 call	 __ftoui3
  0064f	89 45 b4	 mov	 DWORD PTR tv593[ebp], eax
$LN141@GetAtlasIn:
  00652	8b 45 b4	 mov	 eax, DWORD PTR tv593[ebp]
  00655	89 45 b0	 mov	 DWORD PTR tv594[ebp], eax
$LN143@GetAtlasIn:
  00658	8b 45 b0	 mov	 eax, DWORD PTR tv594[ebp]
  0065b	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _dwA$43[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  00661	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _dwG$45[ebp]
  00667	c1 e0 08	 shl	 eax, 8
  0066a	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _dwR$44[ebp]
  00670	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00673	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR _dwA$43[ebp]
  00679	c1 e2 18	 shl	 edx, 24			; 00000018H
  0067c	0b d1		 or	 edx, ecx
  0067e	0b d0		 or	 edx, eax
  00680	0b 95 bc fe ff
	ff		 or	 edx, DWORD PTR _dwB$42[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1151 : 			*pdwTextColor = CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_NPC);//m_MarkTypeToColorMap[rAtlasMarkInfo.m_byType];

  00686	8b 45 78	 mov	 eax, DWORD PTR _pdwTextColor$[ebp]
  00689	89 10		 mov	 DWORD PTR [eax], edx

; 1152 : 			return true;

  0068b	b0 01		 mov	 al, 1
  0068d	e9 b0 0b 00 00	 jmp	 $LN1@GetAtlasIn
$LN13@GetAtlasIn:

; 1153 : 		}
; 1154 : 		++m_AtlasMarkInfoVectorIterator;

  00692	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00695	05 38 03 00 00	 add	 eax, 824		; 00000338H
  0069a	89 45 ac	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  0069d	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  006a0	8b 00		 mov	 eax, DWORD PTR [eax]
  006a2	83 c0 3c	 add	 eax, 60			; 0000003cH
  006a5	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  006a8	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1155 : 	}

  006aa	e9 d9 fc ff ff	 jmp	 $LN2@GetAtlasIn
$LN3@GetAtlasIn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  006af	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  006b2	05 48 03 00 00	 add	 eax, 840		; 00000348H
  006b7	89 45 a8	 mov	 DWORD PTR __My_data$64[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  006ba	8b 45 a8	 mov	 eax, DWORD PTR __My_data$64[ebp]
  006bd	89 85 18 fe ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  006c3	8b 45 a8	 mov	 eax, DWORD PTR __My_data$64[ebp]
  006c6	8b 00		 mov	 eax, DWORD PTR [eax]
  006c8	89 85 b8 fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  006ce	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  006d4	89 85 b4 fe ff
	ff		 mov	 DWORD PTR $T41[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  006da	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR $T41[ebp]
  006e0	89 85 b0 fe ff
	ff		 mov	 DWORD PTR $T40[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1157 : 	m_AtlasMarkInfoVectorIterator = m_AtlasWarpInfoVector.begin();

  006e6	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR $T40[ebp]
  006ec	8b 00		 mov	 eax, DWORD PTR [eax]
  006ee	8b 4d 48	 mov	 ecx, DWORD PTR _this$[ebp]
  006f1	89 81 38 03 00
	00		 mov	 DWORD PTR [ecx+824], eax
$LN4@GetAtlasIn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  006f7	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  006fa	05 48 03 00 00	 add	 eax, 840		; 00000348H
  006ff	89 45 a4	 mov	 DWORD PTR __My_data$63[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00702	8b 45 a4	 mov	 eax, DWORD PTR __My_data$63[ebp]
  00705	89 85 14 fe ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0070b	8b 45 a4	 mov	 eax, DWORD PTR __My_data$63[ebp]
  0070e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00711	89 85 ac fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00717	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  0071d	89 85 a8 fe ff
	ff		 mov	 DWORD PTR $T39[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00723	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR $T39[ebp]
  00729	89 85 a4 fe ff
	ff		 mov	 DWORD PTR $T38[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  0072f	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00732	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR $T38[ebp]
  00738	8b 80 38 03 00
	00		 mov	 eax, DWORD PTR [eax+824]
  0073e	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00740	75 09		 jne	 SHORT $LN187@GetAtlasIn
  00742	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv688[ebp], 1
  00749	eb 04		 jmp	 SHORT $LN188@GetAtlasIn
$LN187@GetAtlasIn:
  0074b	83 65 a0 00	 and	 DWORD PTR tv688[ebp], 0
$LN188@GetAtlasIn:
  0074f	8a 45 a0	 mov	 al, BYTE PTR tv688[ebp]
  00752	88 45 1d	 mov	 BYTE PTR $T74[ebp], al

; 153  :         return !(*this == _Right);

  00755	0f b6 45 1d	 movzx	 eax, BYTE PTR $T74[ebp]
  00759	85 c0		 test	 eax, eax
  0075b	75 09		 jne	 SHORT $LN182@GetAtlasIn
  0075d	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv674[ebp], 1
  00764	eb 04		 jmp	 SHORT $LN183@GetAtlasIn
$LN182@GetAtlasIn:
  00766	83 65 9c 00	 and	 DWORD PTR tv674[ebp], 0
$LN183@GetAtlasIn:
  0076a	8a 45 9c	 mov	 al, BYTE PTR tv674[ebp]
  0076d	88 45 1c	 mov	 BYTE PTR $T73[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1158 : 	while (m_AtlasMarkInfoVectorIterator != m_AtlasWarpInfoVector.end())

  00770	0f b6 45 1c	 movzx	 eax, BYTE PTR $T73[ebp]
  00774	85 c0		 test	 eax, eax
  00776	0f 84 bd 02 00
	00		 je	 $LN5@GetAtlasIn
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  0077c	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  0077f	8b 80 38 03 00
	00		 mov	 eax, DWORD PTR [eax+824]
  00785	89 85 a0 fe ff
	ff		 mov	 DWORD PTR $T37[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  0078b	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR $T37[ebp]
  00791	89 45 10	 mov	 DWORD PTR _rAtlasMarkInfo$67[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1162 : 			rAtlasMarkInfo.m_fY-fCheckWidth/2<fRealY && rAtlasMarkInfo.m_fY+fCheckHeight>fRealY)

  00794	f3 0f 10 45 30	 movss	 xmm0, DWORD PTR _fCheckWidth$[ebp]
  00799	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  007a1	8b 45 10	 mov	 eax, DWORD PTR _rAtlasMarkInfo$67[ebp]
  007a4	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  007a9	f3 0f 5c c8	 subss	 xmm1, xmm0
  007ad	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fRealX$[ebp]
  007b2	0f 2f c1	 comiss	 xmm0, xmm1
  007b5	0f 86 58 02 00
	00		 jbe	 $LN14@GetAtlasIn
  007bb	8b 45 10	 mov	 eax, DWORD PTR _rAtlasMarkInfo$67[ebp]
  007be	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  007c3	f3 0f 58 45 30	 addss	 xmm0, DWORD PTR _fCheckWidth$[ebp]
  007c8	0f 2f 45 24	 comiss	 xmm0, DWORD PTR _fRealX$[ebp]
  007cc	0f 86 41 02 00
	00		 jbe	 $LN14@GetAtlasIn
  007d2	f3 0f 10 45 30	 movss	 xmm0, DWORD PTR _fCheckWidth$[ebp]
  007d7	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  007df	8b 45 10	 mov	 eax, DWORD PTR _rAtlasMarkInfo$67[ebp]
  007e2	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [eax+12]
  007e7	f3 0f 5c c8	 subss	 xmm1, xmm0
  007eb	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _fRealY$[ebp]
  007f0	0f 2f c1	 comiss	 xmm0, xmm1
  007f3	0f 86 1a 02 00
	00		 jbe	 $LN14@GetAtlasIn
  007f9	8b 45 10	 mov	 eax, DWORD PTR _rAtlasMarkInfo$67[ebp]
  007fc	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00801	f3 0f 58 45 0c	 addss	 xmm0, DWORD PTR _fCheckHeight$[ebp]
  00806	0f 2f 45 20	 comiss	 xmm0, DWORD PTR _fRealY$[ebp]
  0080a	0f 86 03 02 00
	00		 jbe	 $LN14@GetAtlasIn

; 1163 : 		{
; 1164 : 			rReturnString = rAtlasMarkInfo.m_strText;

  00810	8b 45 10	 mov	 eax, DWORD PTR _rAtlasMarkInfo$67[ebp]
  00813	83 c0 24	 add	 eax, 36			; 00000024H
  00816	89 45 98	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00819	8b 45 98	 mov	 eax, DWORD PTR __Right$[ebp]
  0081c	89 85 9c fe ff
	ff		 mov	 DWORD PTR $T36[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  00822	8b 45 6c	 mov	 eax, DWORD PTR _rReturnString$[ebp]
  00825	3b 85 9c fe ff
	ff		 cmp	 eax, DWORD PTR $T36[ebp]
  0082b	74 19		 je	 SHORT $LN200@GetAtlasIn

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  0082d	33 c0		 xor	 eax, eax
  0082f	88 85 4c fe ff
	ff		 mov	 BYTE PTR $T19[ebp], al
  00835	ff b5 4c fe ff
	ff		 push	 DWORD PTR $T19[ebp]
  0083b	ff 75 98	 push	 DWORD PTR __Right$[ebp]
  0083e	8b 4d 6c	 mov	 ecx, DWORD PTR _rReturnString$[ebp]
  00841	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
$LN200@GetAtlasIn:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1165 : 			*pReturnPosX = rAtlasMarkInfo.m_fX;

  00846	8b 45 70	 mov	 eax, DWORD PTR _pReturnPosX$[ebp]
  00849	8b 4d 10	 mov	 ecx, DWORD PTR _rAtlasMarkInfo$67[ebp]
  0084c	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0084f	89 08		 mov	 DWORD PTR [eax], ecx

; 1166 : 			*pReturnPosY = rAtlasMarkInfo.m_fY;

  00851	8b 45 74	 mov	 eax, DWORD PTR _pReturnPosY$[ebp]
  00854	8b 4d 10	 mov	 ecx, DWORD PTR _rAtlasMarkInfo$67[ebp]
  00857	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0085a	89 08		 mov	 DWORD PTR [eax], ecx

; 1167 : 			*pdwTextColor = CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_WARP);//m_MarkTypeToColorMap[rAtlasMarkInfo.m_byType];

  0085c	6a 19		 push	 25			; 00000019H
  0085e	e8 00 00 00 00	 call	 ?GetIndexedNameColor@CInstanceBase@@SAABUD3DXCOLOR@@I@Z ; CInstanceBase::GetIndexedNameColor
  00863	59		 pop	 ecx
  00864	89 45 3c	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00867	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  0086a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0086e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00875	72 09		 jb	 SHORT $LN223@GetAtlasIn
  00877	c7 45 90 ff 00
	00 00		 mov	 DWORD PTR tv705[ebp], 255 ; 000000ffH
  0087e	eb 36		 jmp	 SHORT $LN224@GetAtlasIn
$LN223@GetAtlasIn:
  00880	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  00883	0f 57 c0	 xorps	 xmm0, xmm0
  00886	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  00889	72 06		 jb	 SHORT $LN221@GetAtlasIn
  0088b	83 65 94 00	 and	 DWORD PTR tv706[ebp], 0
  0088f	eb 1f		 jmp	 SHORT $LN222@GetAtlasIn
$LN221@GetAtlasIn:
  00891	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  00894	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00898	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  008a0	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  008a8	e8 00 00 00 00	 call	 __ftoui3
  008ad	89 45 94	 mov	 DWORD PTR tv706[ebp], eax
$LN222@GetAtlasIn:
  008b0	8b 45 94	 mov	 eax, DWORD PTR tv706[ebp]
  008b3	89 45 90	 mov	 DWORD PTR tv705[ebp], eax
$LN224@GetAtlasIn:
  008b6	8b 45 90	 mov	 eax, DWORD PTR tv705[ebp]
  008b9	89 85 90 fe ff
	ff		 mov	 DWORD PTR _dwR$33[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  008bf	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  008c2	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  008c7	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  008ce	72 09		 jb	 SHORT $LN227@GetAtlasIn
  008d0	c7 45 88 ff 00
	00 00		 mov	 DWORD PTR tv727[ebp], 255 ; 000000ffH
  008d7	eb 38		 jmp	 SHORT $LN228@GetAtlasIn
$LN227@GetAtlasIn:
  008d9	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  008dc	0f 57 c0	 xorps	 xmm0, xmm0
  008df	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  008e3	72 06		 jb	 SHORT $LN225@GetAtlasIn
  008e5	83 65 8c 00	 and	 DWORD PTR tv726[ebp], 0
  008e9	eb 20		 jmp	 SHORT $LN226@GetAtlasIn
$LN225@GetAtlasIn:
  008eb	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  008ee	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  008f3	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  008fb	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00903	e8 00 00 00 00	 call	 __ftoui3
  00908	89 45 8c	 mov	 DWORD PTR tv726[ebp], eax
$LN226@GetAtlasIn:
  0090b	8b 45 8c	 mov	 eax, DWORD PTR tv726[ebp]
  0090e	89 45 88	 mov	 DWORD PTR tv727[ebp], eax
$LN228@GetAtlasIn:
  00911	8b 45 88	 mov	 eax, DWORD PTR tv727[ebp]
  00914	89 85 94 fe ff
	ff		 mov	 DWORD PTR _dwG$34[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  0091a	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  0091d	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00922	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00929	72 09		 jb	 SHORT $LN231@GetAtlasIn
  0092b	c7 45 80 ff 00
	00 00		 mov	 DWORD PTR tv738[ebp], 255 ; 000000ffH
  00932	eb 38		 jmp	 SHORT $LN232@GetAtlasIn
$LN231@GetAtlasIn:
  00934	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  00937	0f 57 c0	 xorps	 xmm0, xmm0
  0093a	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  0093e	72 06		 jb	 SHORT $LN229@GetAtlasIn
  00940	83 65 84 00	 and	 DWORD PTR tv737[ebp], 0
  00944	eb 20		 jmp	 SHORT $LN230@GetAtlasIn
$LN229@GetAtlasIn:
  00946	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  00949	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0094e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00956	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0095e	e8 00 00 00 00	 call	 __ftoui3
  00963	89 45 84	 mov	 DWORD PTR tv737[ebp], eax
$LN230@GetAtlasIn:
  00966	8b 45 84	 mov	 eax, DWORD PTR tv737[ebp]
  00969	89 45 80	 mov	 DWORD PTR tv738[ebp], eax
$LN232@GetAtlasIn:
  0096c	8b 45 80	 mov	 eax, DWORD PTR tv738[ebp]
  0096f	89 85 88 fe ff
	ff		 mov	 DWORD PTR _dwB$31[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  00975	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  00978	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0097d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00984	72 0c		 jb	 SHORT $LN235@GetAtlasIn
  00986	c7 85 78 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv749[ebp], 255 ; 000000ffH
  00990	eb 44		 jmp	 SHORT $LN236@GetAtlasIn
$LN235@GetAtlasIn:
  00992	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  00995	0f 57 c0	 xorps	 xmm0, xmm0
  00998	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  0099c	72 09		 jb	 SHORT $LN233@GetAtlasIn
  0099e	83 a5 7c ff ff
	ff 00		 and	 DWORD PTR tv748[ebp], 0
  009a5	eb 23		 jmp	 SHORT $LN234@GetAtlasIn
$LN233@GetAtlasIn:
  009a7	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  009aa	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  009af	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  009b7	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  009bf	e8 00 00 00 00	 call	 __ftoui3
  009c4	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv748[ebp], eax
$LN234@GetAtlasIn:
  009ca	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv748[ebp]
  009d0	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv749[ebp], eax
$LN236@GetAtlasIn:
  009d6	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv749[ebp]
  009dc	89 85 8c fe ff
	ff		 mov	 DWORD PTR _dwA$32[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  009e2	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _dwG$34[ebp]
  009e8	c1 e0 08	 shl	 eax, 8
  009eb	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _dwR$33[ebp]
  009f1	c1 e1 10	 shl	 ecx, 16			; 00000010H
  009f4	8b 95 8c fe ff
	ff		 mov	 edx, DWORD PTR _dwA$32[ebp]
  009fa	c1 e2 18	 shl	 edx, 24			; 00000018H
  009fd	0b d1		 or	 edx, ecx
  009ff	0b d0		 or	 edx, eax
  00a01	0b 95 88 fe ff
	ff		 or	 edx, DWORD PTR _dwB$31[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1167 : 			*pdwTextColor = CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_WARP);//m_MarkTypeToColorMap[rAtlasMarkInfo.m_byType];

  00a07	8b 45 78	 mov	 eax, DWORD PTR _pdwTextColor$[ebp]
  00a0a	89 10		 mov	 DWORD PTR [eax], edx

; 1168 : 			return true;

  00a0c	b0 01		 mov	 al, 1
  00a0e	e9 2f 08 00 00	 jmp	 $LN1@GetAtlasIn
$LN14@GetAtlasIn:

; 1169 : 		}
; 1170 : 		++m_AtlasMarkInfoVectorIterator;

  00a13	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00a16	05 38 03 00 00	 add	 eax, 824		; 00000338H
  00a1b	89 85 74 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00a21	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00a27	8b 00		 mov	 eax, DWORD PTR [eax]
  00a29	83 c0 3c	 add	 eax, 60			; 0000003cH
  00a2c	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00a32	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1171 : 	}

  00a34	e9 be fc ff ff	 jmp	 $LN4@GetAtlasIn
$LN5@GetAtlasIn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00a39	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00a3c	05 10 0c 00 00	 add	 eax, 3088		; 00000c10H
  00a41	89 85 70 ff ff
	ff		 mov	 DWORD PTR __My_data$62[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00a47	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$62[ebp]
  00a4d	89 85 10 fe ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00a53	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$62[ebp]
  00a59	8b 00		 mov	 eax, DWORD PTR [eax]
  00a5b	89 85 84 fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00a61	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  00a67	89 85 80 fe ff
	ff		 mov	 DWORD PTR $T30[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00a6d	8d 85 80 fe ff
	ff		 lea	 eax, DWORD PTR $T30[ebp]
  00a73	89 85 7c fe ff
	ff		 mov	 DWORD PTR $T29[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1173 : 	m_AtlasMarkInfoVectorIterator = m_AtlasWayPointInfoVector.begin();

  00a79	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR $T29[ebp]
  00a7f	8b 00		 mov	 eax, DWORD PTR [eax]
  00a81	8b 4d 48	 mov	 ecx, DWORD PTR _this$[ebp]
  00a84	89 81 38 03 00
	00		 mov	 DWORD PTR [ecx+824], eax
$LN6@GetAtlasIn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00a8a	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00a8d	05 10 0c 00 00	 add	 eax, 3088		; 00000c10H
  00a92	89 85 6c ff ff
	ff		 mov	 DWORD PTR __My_data$61[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00a98	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR __My_data$61[ebp]
  00a9e	89 85 0c fe ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00aa4	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR __My_data$61[ebp]
  00aaa	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00aad	89 85 78 fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00ab3	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  00ab9	89 85 74 fe ff
	ff		 mov	 DWORD PTR $T28[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00abf	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR $T28[ebp]
  00ac5	89 85 70 fe ff
	ff		 mov	 DWORD PTR $T27[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00acb	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00ace	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR $T27[ebp]
  00ad4	8b 80 38 03 00
	00		 mov	 eax, DWORD PTR [eax+824]
  00ada	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00adc	75 0c		 jne	 SHORT $LN280@GetAtlasIn
  00ade	c7 85 68 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv811[ebp], 1
  00ae8	eb 07		 jmp	 SHORT $LN281@GetAtlasIn
$LN280@GetAtlasIn:
  00aea	83 a5 68 ff ff
	ff 00		 and	 DWORD PTR tv811[ebp], 0
$LN281@GetAtlasIn:
  00af1	8a 85 68 ff ff
	ff		 mov	 al, BYTE PTR tv811[ebp]
  00af7	88 45 1b	 mov	 BYTE PTR $T72[ebp], al

; 153  :         return !(*this == _Right);

  00afa	0f b6 45 1b	 movzx	 eax, BYTE PTR $T72[ebp]
  00afe	85 c0		 test	 eax, eax
  00b00	75 0c		 jne	 SHORT $LN275@GetAtlasIn
  00b02	c7 85 64 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv797[ebp], 1
  00b0c	eb 07		 jmp	 SHORT $LN276@GetAtlasIn
$LN275@GetAtlasIn:
  00b0e	83 a5 64 ff ff
	ff 00		 and	 DWORD PTR tv797[ebp], 0
$LN276@GetAtlasIn:
  00b15	8a 85 64 ff ff
	ff		 mov	 al, BYTE PTR tv797[ebp]
  00b1b	88 45 1a	 mov	 BYTE PTR $T71[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1174 : 	while (m_AtlasMarkInfoVectorIterator != m_AtlasWayPointInfoVector.end())

  00b1e	0f b6 45 1a	 movzx	 eax, BYTE PTR $T71[ebp]
  00b22	85 c0		 test	 eax, eax
  00b24	0f 84 26 03 00
	00		 je	 $LN7@GetAtlasIn
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  00b2a	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00b2d	8b 80 38 03 00
	00		 mov	 eax, DWORD PTR [eax+824]
  00b33	89 85 6c fe ff
	ff		 mov	 DWORD PTR $T26[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  00b39	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR $T26[ebp]
  00b3f	89 45 28	 mov	 DWORD PTR _rAtlasMarkInfo$77[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1177 : 		if (rAtlasMarkInfo.m_fScreenX > 0.0f)

  00b42	8b 45 28	 mov	 eax, DWORD PTR _rAtlasMarkInfo$77[ebp]
  00b45	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00b4a	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00b51	0f 86 d3 02 00
	00		 jbe	 $LN17@GetAtlasIn

; 1178 : 		if (rAtlasMarkInfo.m_fScreenY > 0.0f)

  00b57	8b 45 28	 mov	 eax, DWORD PTR _rAtlasMarkInfo$77[ebp]
  00b5a	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00b5f	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00b66	0f 86 be 02 00
	00		 jbe	 $LN17@GetAtlasIn

; 1179 : 		if (rAtlasMarkInfo.m_fX-fCheckWidth/2<fRealX && rAtlasMarkInfo.m_fX+fCheckWidth>fRealX && 
; 1180 : 			rAtlasMarkInfo.m_fY-fCheckWidth/2<fRealY && rAtlasMarkInfo.m_fY+fCheckHeight>fRealY)		

  00b6c	f3 0f 10 45 30	 movss	 xmm0, DWORD PTR _fCheckWidth$[ebp]
  00b71	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00b79	8b 45 28	 mov	 eax, DWORD PTR _rAtlasMarkInfo$77[ebp]
  00b7c	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  00b81	f3 0f 5c c8	 subss	 xmm1, xmm0
  00b85	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fRealX$[ebp]
  00b8a	0f 2f c1	 comiss	 xmm0, xmm1
  00b8d	0f 86 97 02 00
	00		 jbe	 $LN17@GetAtlasIn
  00b93	8b 45 28	 mov	 eax, DWORD PTR _rAtlasMarkInfo$77[ebp]
  00b96	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00b9b	f3 0f 58 45 30	 addss	 xmm0, DWORD PTR _fCheckWidth$[ebp]
  00ba0	0f 2f 45 24	 comiss	 xmm0, DWORD PTR _fRealX$[ebp]
  00ba4	0f 86 80 02 00
	00		 jbe	 $LN17@GetAtlasIn
  00baa	f3 0f 10 45 30	 movss	 xmm0, DWORD PTR _fCheckWidth$[ebp]
  00baf	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00bb7	8b 45 28	 mov	 eax, DWORD PTR _rAtlasMarkInfo$77[ebp]
  00bba	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [eax+12]
  00bbf	f3 0f 5c c8	 subss	 xmm1, xmm0
  00bc3	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _fRealY$[ebp]
  00bc8	0f 2f c1	 comiss	 xmm0, xmm1
  00bcb	0f 86 59 02 00
	00		 jbe	 $LN17@GetAtlasIn
  00bd1	8b 45 28	 mov	 eax, DWORD PTR _rAtlasMarkInfo$77[ebp]
  00bd4	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00bd9	f3 0f 58 45 0c	 addss	 xmm0, DWORD PTR _fCheckHeight$[ebp]
  00bde	0f 2f 45 20	 comiss	 xmm0, DWORD PTR _fRealY$[ebp]
  00be2	0f 86 42 02 00
	00		 jbe	 $LN17@GetAtlasIn

; 1181 : 		{
; 1182 : 			rReturnString = rAtlasMarkInfo.m_strText;

  00be8	8b 45 28	 mov	 eax, DWORD PTR _rAtlasMarkInfo$77[ebp]
  00beb	83 c0 24	 add	 eax, 36			; 00000024H
  00bee	89 85 60 ff ff
	ff		 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00bf4	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR __Right$[ebp]
  00bfa	89 85 68 fe ff
	ff		 mov	 DWORD PTR $T25[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  00c00	8b 45 6c	 mov	 eax, DWORD PTR _rReturnString$[ebp]
  00c03	3b 85 68 fe ff
	ff		 cmp	 eax, DWORD PTR $T25[ebp]
  00c09	74 1c		 je	 SHORT $LN293@GetAtlasIn

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  00c0b	33 c0		 xor	 eax, eax
  00c0d	88 85 64 fe ff
	ff		 mov	 BYTE PTR $T24[ebp], al
  00c13	ff b5 64 fe ff
	ff		 push	 DWORD PTR $T24[ebp]
  00c19	ff b5 60 ff ff
	ff		 push	 DWORD PTR __Right$[ebp]
  00c1f	8b 4d 6c	 mov	 ecx, DWORD PTR _rReturnString$[ebp]
  00c22	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
$LN293@GetAtlasIn:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1183 : 			*pReturnPosX = rAtlasMarkInfo.m_fX;

  00c27	8b 45 70	 mov	 eax, DWORD PTR _pReturnPosX$[ebp]
  00c2a	8b 4d 28	 mov	 ecx, DWORD PTR _rAtlasMarkInfo$77[ebp]
  00c2d	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00c30	89 08		 mov	 DWORD PTR [eax], ecx

; 1184 : 			*pReturnPosY = rAtlasMarkInfo.m_fY;

  00c32	8b 45 74	 mov	 eax, DWORD PTR _pReturnPosY$[ebp]
  00c35	8b 4d 28	 mov	 ecx, DWORD PTR _rAtlasMarkInfo$77[ebp]
  00c38	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00c3b	89 08		 mov	 DWORD PTR [eax], ecx

; 1185 : 			*pdwTextColor = CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_WAYPOINT);//m_MarkTypeToColorMap[rAtlasMarkInfo.m_byType];

  00c3d	6a 1a		 push	 26			; 0000001aH
  00c3f	e8 00 00 00 00	 call	 ?GetIndexedNameColor@CInstanceBase@@SAABUD3DXCOLOR@@I@Z ; CInstanceBase::GetIndexedNameColor
  00c44	59		 pop	 ecx
  00c45	89 45 38	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00c48	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  00c4b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00c4f	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00c56	72 0c		 jb	 SHORT $LN328@GetAtlasIn
  00c58	c7 85 58 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv882[ebp], 255 ; 000000ffH
  00c62	eb 42		 jmp	 SHORT $LN329@GetAtlasIn
$LN328@GetAtlasIn:
  00c64	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  00c67	0f 57 c0	 xorps	 xmm0, xmm0
  00c6a	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  00c6d	72 09		 jb	 SHORT $LN326@GetAtlasIn
  00c6f	83 a5 5c ff ff
	ff 00		 and	 DWORD PTR tv884[ebp], 0
  00c76	eb 22		 jmp	 SHORT $LN327@GetAtlasIn
$LN326@GetAtlasIn:
  00c78	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  00c7b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00c7f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00c87	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00c8f	e8 00 00 00 00	 call	 __ftoui3
  00c94	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv884[ebp], eax
$LN327@GetAtlasIn:
  00c9a	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR tv884[ebp]
  00ca0	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv882[ebp], eax
$LN329@GetAtlasIn:
  00ca6	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv882[ebp]
  00cac	89 85 5c fe ff
	ff		 mov	 DWORD PTR _dwR$22[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  00cb2	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  00cb5	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00cba	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00cc1	72 0c		 jb	 SHORT $LN332@GetAtlasIn
  00cc3	c7 85 50 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv821[ebp], 255 ; 000000ffH
  00ccd	eb 44		 jmp	 SHORT $LN333@GetAtlasIn
$LN332@GetAtlasIn:
  00ccf	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  00cd2	0f 57 c0	 xorps	 xmm0, xmm0
  00cd5	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  00cd9	72 09		 jb	 SHORT $LN330@GetAtlasIn
  00cdb	83 a5 54 ff ff
	ff 00		 and	 DWORD PTR tv824[ebp], 0
  00ce2	eb 23		 jmp	 SHORT $LN331@GetAtlasIn
$LN330@GetAtlasIn:
  00ce4	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  00ce7	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00cec	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00cf4	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00cfc	e8 00 00 00 00	 call	 __ftoui3
  00d01	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv824[ebp], eax
$LN331@GetAtlasIn:
  00d07	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR tv824[ebp]
  00d0d	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv821[ebp], eax
$LN333@GetAtlasIn:
  00d13	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR tv821[ebp]
  00d19	89 85 60 fe ff
	ff		 mov	 DWORD PTR _dwG$23[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  00d1f	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  00d22	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00d27	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00d2e	72 0c		 jb	 SHORT $LN336@GetAtlasIn
  00d30	c7 85 48 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv895[ebp], 255 ; 000000ffH
  00d3a	eb 44		 jmp	 SHORT $LN337@GetAtlasIn
$LN336@GetAtlasIn:
  00d3c	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  00d3f	0f 57 c0	 xorps	 xmm0, xmm0
  00d42	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  00d46	72 09		 jb	 SHORT $LN334@GetAtlasIn
  00d48	83 a5 4c ff ff
	ff 00		 and	 DWORD PTR tv894[ebp], 0
  00d4f	eb 23		 jmp	 SHORT $LN335@GetAtlasIn
$LN334@GetAtlasIn:
  00d51	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  00d54	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00d59	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00d61	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00d69	e8 00 00 00 00	 call	 __ftoui3
  00d6e	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv894[ebp], eax
$LN335@GetAtlasIn:
  00d74	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR tv894[ebp]
  00d7a	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv895[ebp], eax
$LN337@GetAtlasIn:
  00d80	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR tv895[ebp]
  00d86	89 85 54 fe ff
	ff		 mov	 DWORD PTR _dwB$20[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  00d8c	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  00d8f	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00d94	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00d9b	72 0c		 jb	 SHORT $LN340@GetAtlasIn
  00d9d	c7 85 40 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv906[ebp], 255 ; 000000ffH
  00da7	eb 44		 jmp	 SHORT $LN341@GetAtlasIn
$LN340@GetAtlasIn:
  00da9	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  00dac	0f 57 c0	 xorps	 xmm0, xmm0
  00daf	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  00db3	72 09		 jb	 SHORT $LN338@GetAtlasIn
  00db5	83 a5 44 ff ff
	ff 00		 and	 DWORD PTR tv905[ebp], 0
  00dbc	eb 23		 jmp	 SHORT $LN339@GetAtlasIn
$LN338@GetAtlasIn:
  00dbe	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  00dc1	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00dc6	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00dce	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00dd6	e8 00 00 00 00	 call	 __ftoui3
  00ddb	89 85 44 ff ff
	ff		 mov	 DWORD PTR tv905[ebp], eax
$LN339@GetAtlasIn:
  00de1	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR tv905[ebp]
  00de7	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv906[ebp], eax
$LN341@GetAtlasIn:
  00ded	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv906[ebp]
  00df3	89 85 58 fe ff
	ff		 mov	 DWORD PTR _dwA$21[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  00df9	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR _dwG$23[ebp]
  00dff	c1 e0 08	 shl	 eax, 8
  00e02	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR _dwR$22[ebp]
  00e08	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00e0b	8b 95 58 fe ff
	ff		 mov	 edx, DWORD PTR _dwA$21[ebp]
  00e11	c1 e2 18	 shl	 edx, 24			; 00000018H
  00e14	0b d1		 or	 edx, ecx
  00e16	0b d0		 or	 edx, eax
  00e18	0b 95 54 fe ff
	ff		 or	 edx, DWORD PTR _dwB$20[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1185 : 			*pdwTextColor = CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_WAYPOINT);//m_MarkTypeToColorMap[rAtlasMarkInfo.m_byType];

  00e1e	8b 45 78	 mov	 eax, DWORD PTR _pdwTextColor$[ebp]
  00e21	89 10		 mov	 DWORD PTR [eax], edx

; 1186 : 			return true;

  00e23	b0 01		 mov	 al, 1
  00e25	e9 18 04 00 00	 jmp	 $LN1@GetAtlasIn
$LN17@GetAtlasIn:

; 1187 : 		}
; 1188 : 		++m_AtlasMarkInfoVectorIterator;

  00e2a	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00e2d	05 38 03 00 00	 add	 eax, 824		; 00000338H
  00e32	89 85 3c ff ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00e38	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00e3e	8b 00		 mov	 eax, DWORD PTR [eax]
  00e40	83 c0 3c	 add	 eax, 60			; 0000003cH
  00e43	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00e49	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1189 : 	}

  00e4b	e9 3a fc ff ff	 jmp	 $LN6@GetAtlasIn
$LN7@GetAtlasIn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00e50	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00e53	05 1c 0c 00 00	 add	 eax, 3100		; 00000c1cH
  00e58	89 85 38 ff ff
	ff		 mov	 DWORD PTR __My_data$60[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00e5e	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$60[ebp]
  00e64	89 85 08 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00e6a	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$60[ebp]
  00e70	8b 00		 mov	 eax, DWORD PTR [eax]
  00e72	89 85 50 fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00e78	8b 85 50 fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  00e7e	89 45 04	 mov	 DWORD PTR _itor$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1192 : 	for (; itor!=m_GuildAreaInfoVector.end(); ++itor)

  00e81	eb 09		 jmp	 SHORT $LN363@GetAtlasIn
$LN8@GetAtlasIn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00e83	8b 45 04	 mov	 eax, DWORD PTR _itor$[ebp]
  00e86	83 c0 24	 add	 eax, 36			; 00000024H
  00e89	89 45 04	 mov	 DWORD PTR _itor$[ebp], eax
$LN363@GetAtlasIn:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00e8c	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00e8f	05 1c 0c 00 00	 add	 eax, 3100		; 00000c1cH
  00e94	89 85 34 ff ff
	ff		 mov	 DWORD PTR __My_data$59[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00e9a	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$59[ebp]
  00ea0	89 85 04 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00ea6	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$59[ebp]
  00eac	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00eaf	89 85 20 fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00eb5	8b 85 20 fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  00ebb	89 85 48 fe ff
	ff		 mov	 DWORD PTR $T18[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00ec1	8d 85 48 fe ff
	ff		 lea	 eax, DWORD PTR $T18[ebp]
  00ec7	89 85 44 fe ff
	ff		 mov	 DWORD PTR $T17[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00ecd	8b 85 44 fe ff
	ff		 mov	 eax, DWORD PTR $T17[ebp]
  00ed3	8b 4d 04	 mov	 ecx, DWORD PTR _itor$[ebp]
  00ed6	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00ed8	75 0c		 jne	 SHORT $LN391@GetAtlasIn
  00eda	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv974[ebp], 1
  00ee4	eb 07		 jmp	 SHORT $LN392@GetAtlasIn
$LN391@GetAtlasIn:
  00ee6	83 a5 30 ff ff
	ff 00		 and	 DWORD PTR tv974[ebp], 0
$LN392@GetAtlasIn:
  00eed	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv974[ebp]
  00ef3	88 45 19	 mov	 BYTE PTR $T70[ebp], al

; 153  :         return !(*this == _Right);

  00ef6	0f b6 45 19	 movzx	 eax, BYTE PTR $T70[ebp]
  00efa	85 c0		 test	 eax, eax
  00efc	75 0c		 jne	 SHORT $LN386@GetAtlasIn
  00efe	c7 85 2c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv960[ebp], 1
  00f08	eb 07		 jmp	 SHORT $LN387@GetAtlasIn
$LN386@GetAtlasIn:
  00f0a	83 a5 2c ff ff
	ff 00		 and	 DWORD PTR tv960[ebp], 0
$LN387@GetAtlasIn:
  00f11	8a 85 2c ff ff
	ff		 mov	 al, BYTE PTR tv960[ebp]
  00f17	88 45 18	 mov	 BYTE PTR $T69[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1192 : 	for (; itor!=m_GuildAreaInfoVector.end(); ++itor)

  00f1a	0f b6 45 18	 movzx	 eax, BYTE PTR $T69[ebp]
  00f1e	85 c0		 test	 eax, eax
  00f20	0f 84 1a 03 00
	00		 je	 $LN9@GetAtlasIn
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  00f26	8b 45 04	 mov	 eax, DWORD PTR _itor$[ebp]
  00f29	89 85 40 fe ff
	ff		 mov	 DWORD PTR $T16[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  00f2f	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR $T16[ebp]
  00f35	89 45 2c	 mov	 DWORD PTR _rInfo$78[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1195 : 		if (fScreenX - m_fAtlasScreenX >= rInfo.fsxRender)

  00f38	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00f3b	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR _fScreenX$[ebp]
  00f40	f3 0f 5c 80 18
	03 00 00	 subss	 xmm0, DWORD PTR [eax+792]
  00f48	8b 45 2c	 mov	 eax, DWORD PTR _rInfo$78[ebp]
  00f4b	0f 2f 40 14	 comiss	 xmm0, DWORD PTR [eax+20]
  00f4f	0f 82 e6 02 00
	00		 jb	 $LN21@GetAtlasIn

; 1196 : 		if (fScreenY - m_fAtlasScreenY >= rInfo.fsyRender)

  00f55	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00f58	f3 0f 10 45 68	 movss	 xmm0, DWORD PTR _fScreenY$[ebp]
  00f5d	f3 0f 5c 80 1c
	03 00 00	 subss	 xmm0, DWORD PTR [eax+796]
  00f65	8b 45 2c	 mov	 eax, DWORD PTR _rInfo$78[ebp]
  00f68	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [eax+24]
  00f6c	0f 82 c9 02 00
	00		 jb	 $LN21@GetAtlasIn

; 1197 : 		if (fScreenX - m_fAtlasScreenX <= rInfo.fexRender)

  00f72	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00f75	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR _fScreenX$[ebp]
  00f7a	f3 0f 5c 80 18
	03 00 00	 subss	 xmm0, DWORD PTR [eax+792]
  00f82	8b 45 2c	 mov	 eax, DWORD PTR _rInfo$78[ebp]
  00f85	f3 0f 10 48 1c	 movss	 xmm1, DWORD PTR [eax+28]
  00f8a	0f 2f c8	 comiss	 xmm1, xmm0
  00f8d	0f 82 a8 02 00
	00		 jb	 $LN21@GetAtlasIn

; 1198 : 		if (fScreenY - m_fAtlasScreenY <= rInfo.feyRender)

  00f93	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00f96	f3 0f 10 45 68	 movss	 xmm0, DWORD PTR _fScreenY$[ebp]
  00f9b	f3 0f 5c 80 1c
	03 00 00	 subss	 xmm0, DWORD PTR [eax+796]
  00fa3	8b 45 2c	 mov	 eax, DWORD PTR _rInfo$78[ebp]
  00fa6	f3 0f 10 48 20	 movss	 xmm1, DWORD PTR [eax+32]
  00fab	0f 2f c8	 comiss	 xmm1, xmm0
  00fae	0f 82 87 02 00
	00		 jb	 $LN21@GetAtlasIn
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00fb4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  00fb9	89 85 3c fe ff
	ff		 mov	 DWORD PTR $T15[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1200 : 			if (CPythonGuild::Instance().GetGuildName(rInfo.dwGuildID, &rReturnString))

  00fbf	ff 75 6c	 push	 DWORD PTR _rReturnString$[ebp]
  00fc2	8b 45 2c	 mov	 eax, DWORD PTR _rInfo$78[ebp]
  00fc5	ff 30		 push	 DWORD PTR [eax]
  00fc7	8b 8d 3c fe ff
	ff		 mov	 ecx, DWORD PTR $T15[ebp]
  00fcd	e8 00 00 00 00	 call	 ?GetGuildName@CPythonGuild@@QAE_NKPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CPythonGuild::GetGuildName
  00fd2	0f b6 c0	 movzx	 eax, al
  00fd5	85 c0		 test	 eax, eax
  00fd7	74 0c		 je	 SHORT $LN22@GetAtlasIn

; 1201 : 			{
; 1202 : 				*pdwGuildID = rInfo.dwGuildID;

  00fd9	8b 45 7c	 mov	 eax, DWORD PTR _pdwGuildID$[ebp]
  00fdc	8b 4d 2c	 mov	 ecx, DWORD PTR _rInfo$78[ebp]
  00fdf	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00fe1	89 08		 mov	 DWORD PTR [eax], ecx

; 1203 : 			}

  00fe3	eb 30		 jmp	 SHORT $LN405@GetAtlasIn
$LN22@GetAtlasIn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00fe5	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MMPFNHIC@empty_guild_area@
  00fea	e8 00 00 00 00	 call	 _strlen
  00fef	59		 pop	 ecx
  00ff0	89 85 38 fe ff
	ff		 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00ff6	8b 85 38 fe ff
	ff		 mov	 eax, DWORD PTR $T14[ebp]
  00ffc	89 85 34 fe ff
	ff		 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  01002	ff b5 34 fe ff
	ff		 push	 DWORD PTR $T13[ebp]
  01008	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MMPFNHIC@empty_guild_area@
  0100d	8b 4d 6c	 mov	 ecx, DWORD PTR _rReturnString$[ebp]
  01010	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN405@GetAtlasIn:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1209 : 			*pReturnPosX = rInfo.lx + rInfo.lwidth/2;

  01015	8b 45 2c	 mov	 eax, DWORD PTR _rInfo$78[ebp]
  01018	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0101b	99		 cdq
  0101c	2b c2		 sub	 eax, edx
  0101e	d1 f8		 sar	 eax, 1
  01020	8b 4d 2c	 mov	 ecx, DWORD PTR _rInfo$78[ebp]
  01023	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  01026	03 c8		 add	 ecx, eax
  01028	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0102c	8b 45 70	 mov	 eax, DWORD PTR _pReturnPosX$[ebp]
  0102f	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1210 : 			*pReturnPosY = rInfo.ly + rInfo.lheight/2;

  01033	8b 45 2c	 mov	 eax, DWORD PTR _rInfo$78[ebp]
  01036	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  01039	99		 cdq
  0103a	2b c2		 sub	 eax, edx
  0103c	d1 f8		 sar	 eax, 1
  0103e	8b 4d 2c	 mov	 ecx, DWORD PTR _rInfo$78[ebp]
  01041	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  01044	03 c8		 add	 ecx, eax
  01046	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0104a	8b 45 74	 mov	 eax, DWORD PTR _pReturnPosY$[ebp]
  0104d	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1211 : 			*pdwTextColor = CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_PARTY);

  01051	6a 18		 push	 24			; 00000018H
  01053	e8 00 00 00 00	 call	 ?GetIndexedNameColor@CInstanceBase@@SAABUD3DXCOLOR@@I@Z ; CInstanceBase::GetIndexedNameColor
  01058	59		 pop	 ecx
  01059	89 45 34	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  0105c	8b 45 34	 mov	 eax, DWORD PTR _this$[ebp]
  0105f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  01063	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0106a	72 0c		 jb	 SHORT $LN440@GetAtlasIn
  0106c	c7 85 24 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1009[ebp], 255 ; 000000ffH
  01076	eb 42		 jmp	 SHORT $LN441@GetAtlasIn
$LN440@GetAtlasIn:
  01078	8b 45 34	 mov	 eax, DWORD PTR _this$[ebp]
  0107b	0f 57 c0	 xorps	 xmm0, xmm0
  0107e	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  01081	72 09		 jb	 SHORT $LN438@GetAtlasIn
  01083	83 a5 28 ff ff
	ff 00		 and	 DWORD PTR tv1005[ebp], 0
  0108a	eb 22		 jmp	 SHORT $LN439@GetAtlasIn
$LN438@GetAtlasIn:
  0108c	8b 45 34	 mov	 eax, DWORD PTR _this$[ebp]
  0108f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  01093	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0109b	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  010a3	e8 00 00 00 00	 call	 __ftoui3
  010a8	89 85 28 ff ff
	ff		 mov	 DWORD PTR tv1005[ebp], eax
$LN439@GetAtlasIn:
  010ae	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR tv1005[ebp]
  010b4	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv1009[ebp], eax
$LN441@GetAtlasIn:
  010ba	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv1009[ebp]
  010c0	89 85 2c fe ff
	ff		 mov	 DWORD PTR _dwR$11[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  010c6	8b 45 34	 mov	 eax, DWORD PTR _this$[ebp]
  010c9	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  010ce	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  010d5	72 0c		 jb	 SHORT $LN444@GetAtlasIn
  010d7	c7 85 1c ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1019[ebp], 255 ; 000000ffH
  010e1	eb 44		 jmp	 SHORT $LN445@GetAtlasIn
$LN444@GetAtlasIn:
  010e3	8b 45 34	 mov	 eax, DWORD PTR _this$[ebp]
  010e6	0f 57 c0	 xorps	 xmm0, xmm0
  010e9	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  010ed	72 09		 jb	 SHORT $LN442@GetAtlasIn
  010ef	83 a5 20 ff ff
	ff 00		 and	 DWORD PTR tv993[ebp], 0
  010f6	eb 23		 jmp	 SHORT $LN443@GetAtlasIn
$LN442@GetAtlasIn:
  010f8	8b 45 34	 mov	 eax, DWORD PTR _this$[ebp]
  010fb	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  01100	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  01108	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  01110	e8 00 00 00 00	 call	 __ftoui3
  01115	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv993[ebp], eax
$LN443@GetAtlasIn:
  0111b	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv993[ebp]
  01121	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv1019[ebp], eax
$LN445@GetAtlasIn:
  01127	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR tv1019[ebp]
  0112d	89 85 30 fe ff
	ff		 mov	 DWORD PTR _dwG$12[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  01133	8b 45 34	 mov	 eax, DWORD PTR _this$[ebp]
  01136	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0113b	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  01142	72 0c		 jb	 SHORT $LN448@GetAtlasIn
  01144	c7 85 14 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv989[ebp], 255 ; 000000ffH
  0114e	eb 44		 jmp	 SHORT $LN449@GetAtlasIn
$LN448@GetAtlasIn:
  01150	8b 45 34	 mov	 eax, DWORD PTR _this$[ebp]
  01153	0f 57 c0	 xorps	 xmm0, xmm0
  01156	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  0115a	72 09		 jb	 SHORT $LN446@GetAtlasIn
  0115c	83 a5 18 ff ff
	ff 00		 and	 DWORD PTR tv990[ebp], 0
  01163	eb 23		 jmp	 SHORT $LN447@GetAtlasIn
$LN446@GetAtlasIn:
  01165	8b 45 34	 mov	 eax, DWORD PTR _this$[ebp]
  01168	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0116d	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  01175	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0117d	e8 00 00 00 00	 call	 __ftoui3
  01182	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv990[ebp], eax
$LN447@GetAtlasIn:
  01188	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv990[ebp]
  0118e	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv989[ebp], eax
$LN449@GetAtlasIn:
  01194	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR tv989[ebp]
  0119a	89 85 24 fe ff
	ff		 mov	 DWORD PTR _dwB$9[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  011a0	8b 45 34	 mov	 eax, DWORD PTR _this$[ebp]
  011a3	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  011a8	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  011af	72 0c		 jb	 SHORT $LN452@GetAtlasIn
  011b1	c7 85 0c ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1013[ebp], 255 ; 000000ffH
  011bb	eb 44		 jmp	 SHORT $LN453@GetAtlasIn
$LN452@GetAtlasIn:
  011bd	8b 45 34	 mov	 eax, DWORD PTR _this$[ebp]
  011c0	0f 57 c0	 xorps	 xmm0, xmm0
  011c3	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  011c7	72 09		 jb	 SHORT $LN450@GetAtlasIn
  011c9	83 a5 10 ff ff
	ff 00		 and	 DWORD PTR tv992[ebp], 0
  011d0	eb 23		 jmp	 SHORT $LN451@GetAtlasIn
$LN450@GetAtlasIn:
  011d2	8b 45 34	 mov	 eax, DWORD PTR _this$[ebp]
  011d5	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  011da	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  011e2	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  011ea	e8 00 00 00 00	 call	 __ftoui3
  011ef	89 85 10 ff ff
	ff		 mov	 DWORD PTR tv992[ebp], eax
$LN451@GetAtlasIn:
  011f5	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR tv992[ebp]
  011fb	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv1013[ebp], eax
$LN453@GetAtlasIn:
  01201	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv1013[ebp]
  01207	89 85 28 fe ff
	ff		 mov	 DWORD PTR _dwA$10[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  0120d	8b 85 30 fe ff
	ff		 mov	 eax, DWORD PTR _dwG$12[ebp]
  01213	c1 e0 08	 shl	 eax, 8
  01216	8b 8d 2c fe ff
	ff		 mov	 ecx, DWORD PTR _dwR$11[ebp]
  0121c	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0121f	8b 95 28 fe ff
	ff		 mov	 edx, DWORD PTR _dwA$10[ebp]
  01225	c1 e2 18	 shl	 edx, 24			; 00000018H
  01228	0b d1		 or	 edx, ecx
  0122a	0b d0		 or	 edx, eax
  0122c	0b 95 24 fe ff
	ff		 or	 edx, DWORD PTR _dwB$9[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1211 : 			*pdwTextColor = CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_PARTY);

  01232	8b 45 78	 mov	 eax, DWORD PTR _pdwTextColor$[ebp]
  01235	89 10		 mov	 DWORD PTR [eax], edx

; 1212 : 			return true;

  01237	b0 01		 mov	 al, 1
  01239	eb 07		 jmp	 SHORT $LN1@GetAtlasIn
$LN21@GetAtlasIn:

; 1213 : 		}
; 1214 : 	}

  0123b	e9 43 fc ff ff	 jmp	 $LN8@GetAtlasIn
$LN9@GetAtlasIn:

; 1215 : 
; 1216 : 	return false;

  01240	32 c0		 xor	 al, al
$LN1@GetAtlasIn:

; 1217 : }

  01242	8b 4d 58	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01245	33 cd		 xor	 ecx, ebp
  01247	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0124c	83 c5 5c	 add	 ebp, 92			; 0000005cH
  0124f	c9		 leave
  01250	c2 1c 00	 ret	 28			; 0000001cH
?GetAtlasInfo@CPythonMiniMap@@QAE_NMMAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM1PAK2@Z ENDP ; CPythonMiniMap::GetAtlasInfo
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?HideAtlas@CPythonMiniMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HideAtlas@CPythonMiniMap@@QAEXXZ PROC			; CPythonMiniMap::HideAtlas, COMDAT
; _this$ = ecx

; 1398 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1399 : 	m_bShowAtlas=false;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 80 68 02 00
	00 00		 mov	 BYTE PTR [eax+616], 0

; 1400 : }

  00011	c9		 leave
  00012	c3		 ret	 0
?HideAtlas@CPythonMiniMap@@QAEXXZ ENDP			; CPythonMiniMap::HideAtlas
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?ShowAtlas@CPythonMiniMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ShowAtlas@CPythonMiniMap@@QAEXXZ PROC			; CPythonMiniMap::ShowAtlas, COMDAT
; _this$ = ecx

; 1393 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1394 : 	m_bShowAtlas=true;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 80 68 02 00
	00 01		 mov	 BYTE PTR [eax+616], 1

; 1395 : }

  00011	c9		 leave
  00012	c3		 ret	 0
?ShowAtlas@CPythonMiniMap@@QAEXXZ ENDP			; CPythonMiniMap::ShowAtlas
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?RenderAtlas@CPythonMiniMap@@QAEXMM@Z
_TEXT	SEGMENT
$T1 = -296						; size = 4
$T2 = -292						; size = 4
$T3 = -288						; size = 4
$T4 = -284						; size = 4
$T5 = -280						; size = 4
$T6 = -276						; size = 4
$T7 = -272						; size = 4
tv1160 = -268						; size = 4
tv1158 = -264						; size = 4
$T8 = -260						; size = 4
$T9 = -256						; size = 4
$T10 = -252						; size = 4
___param0$ = -248					; size = 4
___param0$ = -244					; size = 4
$T11 = -240						; size = 4
$T12 = -236						; size = 4
$T13 = -232						; size = 4
___param0$ = -228					; size = 4
$T14 = -224						; size = 4
$T15 = -220						; size = 4
___param0$ = -216					; size = 4
_dwB$16 = -212						; size = 4
_dwA$17 = -208						; size = 4
_dwR$18 = -204						; size = 4
_dwG$19 = -200						; size = 4
$T20 = -196						; size = 4
$T21 = -192						; size = 4
$T22 = -188						; size = 4
___param0$ = -184					; size = 4
$T23 = -180						; size = 4
$T24 = -176						; size = 4
___param0$ = -172					; size = 4
_dwB$25 = -168						; size = 4
_dwA$26 = -164						; size = 4
_dwR$27 = -160						; size = 4
_dwG$28 = -156						; size = 4
$T29 = -152						; size = 4
$T30 = -148						; size = 4
$T31 = -144						; size = 4
___param0$ = -140					; size = 4
$T32 = -136						; size = 4
$T33 = -132						; size = 4
$T34 = -128						; size = 4
___param0$ = -124					; size = 4
_dwB$35 = -120						; size = 4
_dwA$36 = -116						; size = 4
_dwR$37 = -112						; size = 4
_dwG$38 = -108						; size = 4
tv823 = -104						; size = 4
tv837 = -100						; size = 4
__My_data$39 = -96					; size = 4
__My_data$40 = -92					; size = 4
tv735 = -88						; size = 4
tv781 = -84						; size = 4
__My_data$41 = -80					; size = 4
_this$ = -76						; size = 4
__My_data$42 = -72					; size = 4
tv687 = -68						; size = 4
tv686 = -64						; size = 4
tv676 = -60						; size = 4
tv675 = -56						; size = 4
tv665 = -52						; size = 4
tv664 = -48						; size = 4
tv654 = -44						; size = 4
tv653 = -40						; size = 4
_this$ = -36						; size = 4
_rAtlasMarkInfo$43 = -32				; size = 4
tv624 = -28						; size = 4
tv638 = -24						; size = 4
__My_data$44 = -20					; size = 4
__My_data$45 = -16					; size = 4
tv582 = -12						; size = 4
tv581 = -8						; size = 4
tv571 = -4						; size = 4
tv570 = 0						; size = 4
tv560 = 4						; size = 4
tv559 = 8						; size = 4
tv549 = 12						; size = 4
tv548 = 16						; size = 4
_this$ = 20						; size = 4
_rAtlasMarkInfo$46 = 24					; size = 4
tv492 = 28						; size = 4
tv501 = 32						; size = 4
__My_data$47 = 36					; size = 4
__My_data$48 = 40					; size = 4
tv451 = 44						; size = 4
tv450 = 48						; size = 4
tv440 = 52						; size = 4
tv439 = 56						; size = 4
tv429 = 60						; size = 4
tv428 = 64						; size = 4
tv418 = 68						; size = 4
tv417 = 72						; size = 4
_rInfo$49 = 76						; size = 4
_itor$50 = 80						; size = 4
_rAtlasMarkInfo$51 = 84					; size = 4
$T52 = 88						; size = 1
$T53 = 89						; size = 1
$T54 = 90						; size = 1
$T55 = 91						; size = 1
$T56 = 92						; size = 1
$T57 = 93						; size = 1
$T58 = 94						; size = 1
$T59 = 95						; size = 1
_this$ = 96						; size = 4
_this$ = 100						; size = 4
_this$ = 104						; size = 4
_this$ = 108						; size = 4
_fScreenX$ = 120					; size = 4
_fScreenY$ = 124					; size = 4
?RenderAtlas@CPythonMiniMap@@QAEXMM@Z PROC		; CPythonMiniMap::RenderAtlas, COMDAT
; _this$ = ecx

; 959  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	81 ec 98 01 00
	00		 sub	 esp, 408		; 00000198H
  0000b	89 4d 6c	 mov	 DWORD PTR _this$[ebp], ecx

; 960  : 	if (!m_bShowAtlas)

  0000e	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00011	0f b6 80 68 02
	00 00		 movzx	 eax, BYTE PTR [eax+616]
  00018	85 c0		 test	 eax, eax
  0001a	75 05		 jne	 SHORT $LN12@RenderAtla

; 961  : 		return;

  0001c	e9 df 0b 00 00	 jmp	 $LN1@RenderAtla
$LN12@RenderAtla:

; 962  : 
; 963  : 	if (m_fAtlasScreenX != fScreenX || m_fAtlasScreenY != fScreenY)

  00021	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00024	f3 0f 10 80 18
	03 00 00	 movss	 xmm0, DWORD PTR [eax+792]
  0002c	0f 2e 45 78	 ucomiss xmm0, DWORD PTR _fScreenX$[ebp]
  00030	9f		 lahf
  00031	f6 c4 44	 test	 ah, 68			; 00000044H
  00034	7a 15		 jp	 SHORT $LN14@RenderAtla
  00036	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00039	f3 0f 10 80 1c
	03 00 00	 movss	 xmm0, DWORD PTR [eax+796]
  00041	0f 2e 45 7c	 ucomiss xmm0, DWORD PTR _fScreenY$[ebp]
  00045	9f		 lahf
  00046	f6 c4 44	 test	 ah, 68			; 00000044H
  00049	7b 40		 jnp	 SHORT $LN13@RenderAtla
$LN14@RenderAtla:

; 964  : 	{
; 965  : 		m_matWorldAtlas._41 = fScreenX;

  0004b	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	f3 0f 10 45 78	 movss	 xmm0, DWORD PTR _fScreenX$[ebp]
  00053	f3 0f 11 80 bc
	02 00 00	 movss	 DWORD PTR [eax+700], xmm0

; 966  : 		m_matWorldAtlas._42 = fScreenY;

  0005b	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	f3 0f 10 45 7c	 movss	 xmm0, DWORD PTR _fScreenY$[ebp]
  00063	f3 0f 11 80 c0
	02 00 00	 movss	 DWORD PTR [eax+704], xmm0

; 967  : 		m_fAtlasScreenX = fScreenX;

  0006b	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	f3 0f 10 45 78	 movss	 xmm0, DWORD PTR _fScreenX$[ebp]
  00073	f3 0f 11 80 18
	03 00 00	 movss	 DWORD PTR [eax+792], xmm0

; 968  : 		m_fAtlasScreenY = fScreenY;

  0007b	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	f3 0f 10 45 7c	 movss	 xmm0, DWORD PTR _fScreenY$[ebp]
  00083	f3 0f 11 80 1c
	03 00 00	 movss	 DWORD PTR [eax+796], xmm0
$LN13@RenderAtla:

; 969  : 	}
; 970  : 
; 971  : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &m_matWorldAtlas);

  0008b	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	05 8c 02 00 00	 add	 eax, 652		; 0000028cH
  00093	50		 push	 eax
  00094	68 00 01 00 00	 push	 256			; 00000100H
  00099	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0009f	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 972  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_POINT);

  000a4	6a 01		 push	 1
  000a6	6a 11		 push	 17			; 00000011H
  000a8	6a 00		 push	 0
  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000b0	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 973  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_POINT);

  000b5	6a 01		 push	 1
  000b7	6a 10		 push	 16			; 00000010H
  000b9	6a 00		 push	 0
  000bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000c1	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 974  : 	m_AtlasImageInstance.Render();

  000c6	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	81 c1 6c 02 00
	00		 add	 ecx, 620		; 0000026cH
  000cf	e8 00 00 00 00	 call	 ?Render@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Render

; 975  : 
; 976  : 	STATEMANAGER.SaveRenderState(D3DRS_TEXTUREFACTOR, 0xFFFFFFFF);

  000d4	6a ff		 push	 -1
  000d6	6a 3c		 push	 60			; 0000003cH
  000d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000de	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 977  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);

  000e3	6a 03		 push	 3
  000e5	6a 02		 push	 2
  000e7	6a 00		 push	 0
  000e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000ef	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 978  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLORARG2, D3DTA_TEXTURE);

  000f4	6a 02		 push	 2
  000f6	6a 03		 push	 3
  000f8	6a 00		 push	 0
  000fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00100	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 979  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);

  00105	6a 04		 push	 4
  00107	6a 01		 push	 1
  00109	6a 00		 push	 0
  0010b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00111	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 981  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_NPC));

  00116	6a 01		 push	 1
  00118	e8 00 00 00 00	 call	 ?GetIndexedNameColor@CInstanceBase@@SAABUD3DXCOLOR@@I@Z ; CInstanceBase::GetIndexedNameColor
  0011d	59		 pop	 ecx
  0011e	89 45 68	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00121	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00124	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00128	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0012f	72 09		 jb	 SHORT $LN39@RenderAtla
  00131	c7 45 44 ff 00
	00 00		 mov	 DWORD PTR tv418[ebp], 255 ; 000000ffH
  00138	eb 36		 jmp	 SHORT $LN40@RenderAtla
$LN39@RenderAtla:
  0013a	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  0013d	0f 57 c0	 xorps	 xmm0, xmm0
  00140	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  00143	72 06		 jb	 SHORT $LN37@RenderAtla
  00145	83 65 48 00	 and	 DWORD PTR tv417[ebp], 0
  00149	eb 1f		 jmp	 SHORT $LN38@RenderAtla
$LN37@RenderAtla:
  0014b	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  0014e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00152	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0015a	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00162	e8 00 00 00 00	 call	 __ftoui3
  00167	89 45 48	 mov	 DWORD PTR tv417[ebp], eax
$LN38@RenderAtla:
  0016a	8b 45 48	 mov	 eax, DWORD PTR tv417[ebp]
  0016d	89 45 44	 mov	 DWORD PTR tv418[ebp], eax
$LN40@RenderAtla:
  00170	8b 45 44	 mov	 eax, DWORD PTR tv418[ebp]
  00173	89 45 90	 mov	 DWORD PTR _dwR$37[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  00176	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00179	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0017e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00185	72 09		 jb	 SHORT $LN43@RenderAtla
  00187	c7 45 3c ff 00
	00 00		 mov	 DWORD PTR tv429[ebp], 255 ; 000000ffH
  0018e	eb 38		 jmp	 SHORT $LN44@RenderAtla
$LN43@RenderAtla:
  00190	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00193	0f 57 c0	 xorps	 xmm0, xmm0
  00196	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  0019a	72 06		 jb	 SHORT $LN41@RenderAtla
  0019c	83 65 40 00	 and	 DWORD PTR tv428[ebp], 0
  001a0	eb 20		 jmp	 SHORT $LN42@RenderAtla
$LN41@RenderAtla:
  001a2	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  001a5	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001aa	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  001b2	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  001ba	e8 00 00 00 00	 call	 __ftoui3
  001bf	89 45 40	 mov	 DWORD PTR tv428[ebp], eax
$LN42@RenderAtla:
  001c2	8b 45 40	 mov	 eax, DWORD PTR tv428[ebp]
  001c5	89 45 3c	 mov	 DWORD PTR tv429[ebp], eax
$LN44@RenderAtla:
  001c8	8b 45 3c	 mov	 eax, DWORD PTR tv429[ebp]
  001cb	89 45 94	 mov	 DWORD PTR _dwG$38[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  001ce	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  001d1	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001d6	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  001dd	72 09		 jb	 SHORT $LN47@RenderAtla
  001df	c7 45 34 ff 00
	00 00		 mov	 DWORD PTR tv440[ebp], 255 ; 000000ffH
  001e6	eb 38		 jmp	 SHORT $LN48@RenderAtla
$LN47@RenderAtla:
  001e8	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  001eb	0f 57 c0	 xorps	 xmm0, xmm0
  001ee	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  001f2	72 06		 jb	 SHORT $LN45@RenderAtla
  001f4	83 65 38 00	 and	 DWORD PTR tv439[ebp], 0
  001f8	eb 20		 jmp	 SHORT $LN46@RenderAtla
$LN45@RenderAtla:
  001fa	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  001fd	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00202	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0020a	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00212	e8 00 00 00 00	 call	 __ftoui3
  00217	89 45 38	 mov	 DWORD PTR tv439[ebp], eax
$LN46@RenderAtla:
  0021a	8b 45 38	 mov	 eax, DWORD PTR tv439[ebp]
  0021d	89 45 34	 mov	 DWORD PTR tv440[ebp], eax
$LN48@RenderAtla:
  00220	8b 45 34	 mov	 eax, DWORD PTR tv440[ebp]
  00223	89 45 88	 mov	 DWORD PTR _dwB$35[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  00226	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00229	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0022e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00235	72 09		 jb	 SHORT $LN51@RenderAtla
  00237	c7 45 2c ff 00
	00 00		 mov	 DWORD PTR tv451[ebp], 255 ; 000000ffH
  0023e	eb 38		 jmp	 SHORT $LN52@RenderAtla
$LN51@RenderAtla:
  00240	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00243	0f 57 c0	 xorps	 xmm0, xmm0
  00246	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  0024a	72 06		 jb	 SHORT $LN49@RenderAtla
  0024c	83 65 30 00	 and	 DWORD PTR tv450[ebp], 0
  00250	eb 20		 jmp	 SHORT $LN50@RenderAtla
$LN49@RenderAtla:
  00252	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00255	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0025a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00262	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0026a	e8 00 00 00 00	 call	 __ftoui3
  0026f	89 45 30	 mov	 DWORD PTR tv450[ebp], eax
$LN50@RenderAtla:
  00272	8b 45 30	 mov	 eax, DWORD PTR tv450[ebp]
  00275	89 45 2c	 mov	 DWORD PTR tv451[ebp], eax
$LN52@RenderAtla:
  00278	8b 45 2c	 mov	 eax, DWORD PTR tv451[ebp]
  0027b	89 45 8c	 mov	 DWORD PTR _dwA$36[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  0027e	8b 45 94	 mov	 eax, DWORD PTR _dwG$38[ebp]
  00281	c1 e0 08	 shl	 eax, 8
  00284	8b 4d 90	 mov	 ecx, DWORD PTR _dwR$37[ebp]
  00287	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0028a	8b 55 8c	 mov	 edx, DWORD PTR _dwA$36[ebp]
  0028d	c1 e2 18	 shl	 edx, 24			; 00000018H
  00290	0b d1		 or	 edx, ecx
  00292	0b d0		 or	 edx, eax
  00294	0b 55 88	 or	 edx, DWORD PTR _dwB$35[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 981  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_NPC));

  00297	52		 push	 edx
  00298	6a 3c		 push	 60			; 0000003cH
  0029a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002a0	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  002a5	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  002a8	05 3c 03 00 00	 add	 eax, 828		; 0000033cH
  002ad	89 45 28	 mov	 DWORD PTR __My_data$48[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  002b0	8b 45 28	 mov	 eax, DWORD PTR __My_data$48[ebp]
  002b3	89 85 f0 fe ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  002b9	8b 45 28	 mov	 eax, DWORD PTR __My_data$48[ebp]
  002bc	8b 00		 mov	 eax, DWORD PTR [eax]
  002be	89 45 84	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  002c1	8b 45 84	 mov	 eax, DWORD PTR ___param0$[ebp]
  002c4	89 45 80	 mov	 DWORD PTR $T34[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  002c7	8d 45 80	 lea	 eax, DWORD PTR $T34[ebp]
  002ca	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T33[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 982  : 	m_AtlasMarkInfoVectorIterator = m_AtlasNPCInfoVector.begin();

  002d0	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR $T33[ebp]
  002d6	8b 00		 mov	 eax, DWORD PTR [eax]
  002d8	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  002db	89 81 38 03 00
	00		 mov	 DWORD PTR [ecx+824], eax
$LN2@RenderAtla:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  002e1	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  002e4	05 3c 03 00 00	 add	 eax, 828		; 0000033cH
  002e9	89 45 24	 mov	 DWORD PTR __My_data$47[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  002ec	8b 45 24	 mov	 eax, DWORD PTR __My_data$47[ebp]
  002ef	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T32[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  002f5	8b 45 24	 mov	 eax, DWORD PTR __My_data$47[ebp]
  002f8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002fb	89 85 74 ff ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax
  00301	ff b5 78 ff ff
	ff		 push	 DWORD PTR $T32[ebp]
  00307	ff b5 74 ff ff
	ff		 push	 DWORD PTR ___param0$[ebp]
  0030d	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T31[ebp]
  00313	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@@std@@QAE@PAUTAtlasMarkInfo@CPythonMiniMap@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPythonMiniMap::TAtlasMarkInfo> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPythonMiniMap::TAtlasMarkInfo> > >
  00318	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR $T31[ebp]
  0031e	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T30[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00324	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00327	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR $T30[ebp]
  0032d	8b 80 38 03 00
	00		 mov	 eax, DWORD PTR [eax+824]
  00333	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00335	75 09		 jne	 SHORT $LN86@RenderAtla
  00337	c7 45 20 01 00
	00 00		 mov	 DWORD PTR tv501[ebp], 1
  0033e	eb 04		 jmp	 SHORT $LN87@RenderAtla
$LN86@RenderAtla:
  00340	83 65 20 00	 and	 DWORD PTR tv501[ebp], 0
$LN87@RenderAtla:
  00344	8a 45 20	 mov	 al, BYTE PTR tv501[ebp]
  00347	88 45 5f	 mov	 BYTE PTR $T59[ebp], al

; 153  :         return !(*this == _Right);

  0034a	0f b6 45 5f	 movzx	 eax, BYTE PTR $T59[ebp]
  0034e	85 c0		 test	 eax, eax
  00350	75 09		 jne	 SHORT $LN81@RenderAtla
  00352	c7 45 1c 01 00
	00 00		 mov	 DWORD PTR tv492[ebp], 1
  00359	eb 04		 jmp	 SHORT $LN82@RenderAtla
$LN81@RenderAtla:
  0035b	83 65 1c 00	 and	 DWORD PTR tv492[ebp], 0
$LN82@RenderAtla:
  0035f	8a 45 1c	 mov	 al, BYTE PTR tv492[ebp]
  00362	88 45 5e	 mov	 BYTE PTR $T58[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 983  : 	while (m_AtlasMarkInfoVectorIterator != m_AtlasNPCInfoVector.end())

  00365	0f b6 45 5e	 movzx	 eax, BYTE PTR $T58[ebp]
  00369	85 c0		 test	 eax, eax
  0036b	74 6d		 je	 SHORT $LN3@RenderAtla
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  0036d	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00370	8b 80 38 03 00
	00		 mov	 eax, DWORD PTR [eax+824]
  00376	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T29[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  0037c	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR $T29[ebp]
  00382	89 45 18	 mov	 DWORD PTR _rAtlasMarkInfo$46[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 986  : 		m_WhiteMark.SetPosition(rAtlasMarkInfo.m_fScreenX, rAtlasMarkInfo.m_fScreenY);

  00385	8b 45 18	 mov	 eax, DWORD PTR _rAtlasMarkInfo$46[ebp]
  00388	51		 push	 ecx
  00389	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  0038e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00393	8b 45 18	 mov	 eax, DWORD PTR _rAtlasMarkInfo$46[ebp]
  00396	51		 push	 ecx
  00397	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  0039c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003a1	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  003a4	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  003aa	e8 00 00 00 00	 call	 ?SetPosition@CGraphicImageInstance@@QAEXMM@Z ; CGraphicImageInstance::SetPosition

; 987  : 		m_WhiteMark.Render();

  003af	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  003b2	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  003b8	e8 00 00 00 00	 call	 ?Render@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Render

; 988  : 		++m_AtlasMarkInfoVectorIterator;

  003bd	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  003c0	05 38 03 00 00	 add	 eax, 824		; 00000338H
  003c5	89 45 14	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  003c8	8b 45 14	 mov	 eax, DWORD PTR _this$[ebp]
  003cb	8b 00		 mov	 eax, DWORD PTR [eax]
  003cd	83 c0 3c	 add	 eax, 60			; 0000003cH
  003d0	8b 4d 14	 mov	 ecx, DWORD PTR _this$[ebp]
  003d3	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 989  : 	}

  003d5	e9 07 ff ff ff	 jmp	 $LN2@RenderAtla
$LN3@RenderAtla:

; 991  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_WARP));

  003da	6a 19		 push	 25			; 00000019H
  003dc	e8 00 00 00 00	 call	 ?GetIndexedNameColor@CInstanceBase@@SAABUD3DXCOLOR@@I@Z ; CInstanceBase::GetIndexedNameColor
  003e1	59		 pop	 ecx
  003e2	89 45 64	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  003e5	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  003e8	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  003ec	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  003f3	72 09		 jb	 SHORT $LN108@RenderAtla
  003f5	c7 45 0c ff 00
	00 00		 mov	 DWORD PTR tv549[ebp], 255 ; 000000ffH
  003fc	eb 36		 jmp	 SHORT $LN109@RenderAtla
$LN108@RenderAtla:
  003fe	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  00401	0f 57 c0	 xorps	 xmm0, xmm0
  00404	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  00407	72 06		 jb	 SHORT $LN106@RenderAtla
  00409	83 65 10 00	 and	 DWORD PTR tv548[ebp], 0
  0040d	eb 1f		 jmp	 SHORT $LN107@RenderAtla
$LN106@RenderAtla:
  0040f	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  00412	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00416	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0041e	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00426	e8 00 00 00 00	 call	 __ftoui3
  0042b	89 45 10	 mov	 DWORD PTR tv548[ebp], eax
$LN107@RenderAtla:
  0042e	8b 45 10	 mov	 eax, DWORD PTR tv548[ebp]
  00431	89 45 0c	 mov	 DWORD PTR tv549[ebp], eax
$LN109@RenderAtla:
  00434	8b 45 0c	 mov	 eax, DWORD PTR tv549[ebp]
  00437	89 85 60 ff ff
	ff		 mov	 DWORD PTR _dwR$27[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  0043d	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  00440	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00445	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0044c	72 09		 jb	 SHORT $LN112@RenderAtla
  0044e	c7 45 04 ff 00
	00 00		 mov	 DWORD PTR tv560[ebp], 255 ; 000000ffH
  00455	eb 38		 jmp	 SHORT $LN113@RenderAtla
$LN112@RenderAtla:
  00457	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  0045a	0f 57 c0	 xorps	 xmm0, xmm0
  0045d	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  00461	72 06		 jb	 SHORT $LN110@RenderAtla
  00463	83 65 08 00	 and	 DWORD PTR tv559[ebp], 0
  00467	eb 20		 jmp	 SHORT $LN111@RenderAtla
$LN110@RenderAtla:
  00469	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  0046c	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00471	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00479	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00481	e8 00 00 00 00	 call	 __ftoui3
  00486	89 45 08	 mov	 DWORD PTR tv559[ebp], eax
$LN111@RenderAtla:
  00489	8b 45 08	 mov	 eax, DWORD PTR tv559[ebp]
  0048c	89 45 04	 mov	 DWORD PTR tv560[ebp], eax
$LN113@RenderAtla:
  0048f	8b 45 04	 mov	 eax, DWORD PTR tv560[ebp]
  00492	89 85 64 ff ff
	ff		 mov	 DWORD PTR _dwG$28[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  00498	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  0049b	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  004a0	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  004a7	72 09		 jb	 SHORT $LN116@RenderAtla
  004a9	c7 45 fc ff 00
	00 00		 mov	 DWORD PTR tv571[ebp], 255 ; 000000ffH
  004b0	eb 38		 jmp	 SHORT $LN117@RenderAtla
$LN116@RenderAtla:
  004b2	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  004b5	0f 57 c0	 xorps	 xmm0, xmm0
  004b8	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  004bc	72 06		 jb	 SHORT $LN114@RenderAtla
  004be	83 65 00 00	 and	 DWORD PTR tv570[ebp], 0
  004c2	eb 20		 jmp	 SHORT $LN115@RenderAtla
$LN114@RenderAtla:
  004c4	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  004c7	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  004cc	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  004d4	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  004dc	e8 00 00 00 00	 call	 __ftoui3
  004e1	89 45 00	 mov	 DWORD PTR tv570[ebp], eax
$LN115@RenderAtla:
  004e4	8b 45 00	 mov	 eax, DWORD PTR tv570[ebp]
  004e7	89 45 fc	 mov	 DWORD PTR tv571[ebp], eax
$LN117@RenderAtla:
  004ea	8b 45 fc	 mov	 eax, DWORD PTR tv571[ebp]
  004ed	89 85 58 ff ff
	ff		 mov	 DWORD PTR _dwB$25[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  004f3	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  004f6	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  004fb	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00502	72 09		 jb	 SHORT $LN120@RenderAtla
  00504	c7 45 f4 ff 00
	00 00		 mov	 DWORD PTR tv582[ebp], 255 ; 000000ffH
  0050b	eb 38		 jmp	 SHORT $LN121@RenderAtla
$LN120@RenderAtla:
  0050d	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  00510	0f 57 c0	 xorps	 xmm0, xmm0
  00513	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  00517	72 06		 jb	 SHORT $LN118@RenderAtla
  00519	83 65 f8 00	 and	 DWORD PTR tv581[ebp], 0
  0051d	eb 20		 jmp	 SHORT $LN119@RenderAtla
$LN118@RenderAtla:
  0051f	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  00522	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00527	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0052f	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00537	e8 00 00 00 00	 call	 __ftoui3
  0053c	89 45 f8	 mov	 DWORD PTR tv581[ebp], eax
$LN119@RenderAtla:
  0053f	8b 45 f8	 mov	 eax, DWORD PTR tv581[ebp]
  00542	89 45 f4	 mov	 DWORD PTR tv582[ebp], eax
$LN121@RenderAtla:
  00545	8b 45 f4	 mov	 eax, DWORD PTR tv582[ebp]
  00548	89 85 5c ff ff
	ff		 mov	 DWORD PTR _dwA$26[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  0054e	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _dwG$28[ebp]
  00554	c1 e0 08	 shl	 eax, 8
  00557	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _dwR$27[ebp]
  0055d	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00560	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _dwA$26[ebp]
  00566	c1 e2 18	 shl	 edx, 24			; 00000018H
  00569	0b d1		 or	 edx, ecx
  0056b	0b d0		 or	 edx, eax
  0056d	0b 95 58 ff ff
	ff		 or	 edx, DWORD PTR _dwB$25[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 991  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_WARP));

  00573	52		 push	 edx
  00574	6a 3c		 push	 60			; 0000003cH
  00576	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0057c	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00581	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00584	05 48 03 00 00	 add	 eax, 840		; 00000348H
  00589	89 45 f0	 mov	 DWORD PTR __My_data$45[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0058c	8b 45 f0	 mov	 eax, DWORD PTR __My_data$45[ebp]
  0058f	89 85 ec fe ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00595	8b 45 f0	 mov	 eax, DWORD PTR __My_data$45[ebp]
  00598	8b 00		 mov	 eax, DWORD PTR [eax]
  0059a	89 85 54 ff ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  005a0	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  005a6	89 85 50 ff ff
	ff		 mov	 DWORD PTR $T24[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  005ac	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR $T24[ebp]
  005b2	89 85 4c ff ff
	ff		 mov	 DWORD PTR $T23[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 992  : 	m_AtlasMarkInfoVectorIterator = m_AtlasWarpInfoVector.begin();

  005b8	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR $T23[ebp]
  005be	8b 00		 mov	 eax, DWORD PTR [eax]
  005c0	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  005c3	89 81 38 03 00
	00		 mov	 DWORD PTR [ecx+824], eax
$LN4@RenderAtla:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  005c9	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  005cc	05 48 03 00 00	 add	 eax, 840		; 00000348H
  005d1	89 45 ec	 mov	 DWORD PTR __My_data$44[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  005d4	8b 45 ec	 mov	 eax, DWORD PTR __My_data$44[ebp]
  005d7	89 85 e8 fe ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  005dd	8b 45 ec	 mov	 eax, DWORD PTR __My_data$44[ebp]
  005e0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  005e3	89 85 48 ff ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  005e9	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  005ef	89 85 44 ff ff
	ff		 mov	 DWORD PTR $T22[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  005f5	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR $T22[ebp]
  005fb	89 85 40 ff ff
	ff		 mov	 DWORD PTR $T21[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00601	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00604	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR $T21[ebp]
  0060a	8b 80 38 03 00
	00		 mov	 eax, DWORD PTR [eax+824]
  00610	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00612	75 09		 jne	 SHORT $LN161@RenderAtla
  00614	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv638[ebp], 1
  0061b	eb 04		 jmp	 SHORT $LN162@RenderAtla
$LN161@RenderAtla:
  0061d	83 65 e8 00	 and	 DWORD PTR tv638[ebp], 0
$LN162@RenderAtla:
  00621	8a 45 e8	 mov	 al, BYTE PTR tv638[ebp]
  00624	88 45 5d	 mov	 BYTE PTR $T57[ebp], al

; 153  :         return !(*this == _Right);

  00627	0f b6 45 5d	 movzx	 eax, BYTE PTR $T57[ebp]
  0062b	85 c0		 test	 eax, eax
  0062d	75 09		 jne	 SHORT $LN156@RenderAtla
  0062f	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv624[ebp], 1
  00636	eb 04		 jmp	 SHORT $LN157@RenderAtla
$LN156@RenderAtla:
  00638	83 65 e4 00	 and	 DWORD PTR tv624[ebp], 0
$LN157@RenderAtla:
  0063c	8a 45 e4	 mov	 al, BYTE PTR tv624[ebp]
  0063f	88 45 5c	 mov	 BYTE PTR $T56[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 993  : 	while (m_AtlasMarkInfoVectorIterator != m_AtlasWarpInfoVector.end())

  00642	0f b6 45 5c	 movzx	 eax, BYTE PTR $T56[ebp]
  00646	85 c0		 test	 eax, eax
  00648	74 6d		 je	 SHORT $LN5@RenderAtla
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  0064a	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  0064d	8b 80 38 03 00
	00		 mov	 eax, DWORD PTR [eax+824]
  00653	89 85 3c ff ff
	ff		 mov	 DWORD PTR $T20[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  00659	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR $T20[ebp]
  0065f	89 45 e0	 mov	 DWORD PTR _rAtlasMarkInfo$43[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 996  : 		m_WhiteMark.SetPosition(rAtlasMarkInfo.m_fScreenX, rAtlasMarkInfo.m_fScreenY);

  00662	8b 45 e0	 mov	 eax, DWORD PTR _rAtlasMarkInfo$43[ebp]
  00665	51		 push	 ecx
  00666	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  0066b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00670	8b 45 e0	 mov	 eax, DWORD PTR _rAtlasMarkInfo$43[ebp]
  00673	51		 push	 ecx
  00674	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00679	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0067e	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  00681	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00687	e8 00 00 00 00	 call	 ?SetPosition@CGraphicImageInstance@@QAEXMM@Z ; CGraphicImageInstance::SetPosition

; 997  : 		m_WhiteMark.Render();

  0068c	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  0068f	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00695	e8 00 00 00 00	 call	 ?Render@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Render

; 998  : 		++m_AtlasMarkInfoVectorIterator;

  0069a	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  0069d	05 38 03 00 00	 add	 eax, 824		; 00000338H
  006a2	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  006a5	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  006a8	8b 00		 mov	 eax, DWORD PTR [eax]
  006aa	83 c0 3c	 add	 eax, 60			; 0000003cH
  006ad	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  006b0	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 999  : 	}

  006b2	e9 12 ff ff ff	 jmp	 $LN4@RenderAtla
$LN5@RenderAtla:

; 1000 : 
; 1001 : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_LINEAR);

  006b7	6a 02		 push	 2
  006b9	6a 11		 push	 17			; 00000011H
  006bb	6a 00		 push	 0
  006bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  006c3	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 1002 : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);

  006c8	6a 02		 push	 2
  006ca	6a 10		 push	 16			; 00000010H
  006cc	6a 00		 push	 0
  006ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  006d4	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 1003 : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_WAYPOINT));

  006d9	6a 1a		 push	 26			; 0000001aH
  006db	e8 00 00 00 00	 call	 ?GetIndexedNameColor@CInstanceBase@@SAABUD3DXCOLOR@@I@Z ; CInstanceBase::GetIndexedNameColor
  006e0	59		 pop	 ecx
  006e1	89 45 60	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  006e4	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  006e7	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  006eb	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  006f2	72 09		 jb	 SHORT $LN187@RenderAtla
  006f4	c7 45 d4 ff 00
	00 00		 mov	 DWORD PTR tv654[ebp], 255 ; 000000ffH
  006fb	eb 36		 jmp	 SHORT $LN188@RenderAtla
$LN187@RenderAtla:
  006fd	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  00700	0f 57 c0	 xorps	 xmm0, xmm0
  00703	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  00706	72 06		 jb	 SHORT $LN185@RenderAtla
  00708	83 65 d8 00	 and	 DWORD PTR tv653[ebp], 0
  0070c	eb 1f		 jmp	 SHORT $LN186@RenderAtla
$LN185@RenderAtla:
  0070e	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  00711	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00715	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0071d	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00725	e8 00 00 00 00	 call	 __ftoui3
  0072a	89 45 d8	 mov	 DWORD PTR tv653[ebp], eax
$LN186@RenderAtla:
  0072d	8b 45 d8	 mov	 eax, DWORD PTR tv653[ebp]
  00730	89 45 d4	 mov	 DWORD PTR tv654[ebp], eax
$LN188@RenderAtla:
  00733	8b 45 d4	 mov	 eax, DWORD PTR tv654[ebp]
  00736	89 85 34 ff ff
	ff		 mov	 DWORD PTR _dwR$18[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  0073c	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  0073f	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00744	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0074b	72 09		 jb	 SHORT $LN191@RenderAtla
  0074d	c7 45 cc ff 00
	00 00		 mov	 DWORD PTR tv665[ebp], 255 ; 000000ffH
  00754	eb 38		 jmp	 SHORT $LN192@RenderAtla
$LN191@RenderAtla:
  00756	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  00759	0f 57 c0	 xorps	 xmm0, xmm0
  0075c	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  00760	72 06		 jb	 SHORT $LN189@RenderAtla
  00762	83 65 d0 00	 and	 DWORD PTR tv664[ebp], 0
  00766	eb 20		 jmp	 SHORT $LN190@RenderAtla
$LN189@RenderAtla:
  00768	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  0076b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00770	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00778	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00780	e8 00 00 00 00	 call	 __ftoui3
  00785	89 45 d0	 mov	 DWORD PTR tv664[ebp], eax
$LN190@RenderAtla:
  00788	8b 45 d0	 mov	 eax, DWORD PTR tv664[ebp]
  0078b	89 45 cc	 mov	 DWORD PTR tv665[ebp], eax
$LN192@RenderAtla:
  0078e	8b 45 cc	 mov	 eax, DWORD PTR tv665[ebp]
  00791	89 85 38 ff ff
	ff		 mov	 DWORD PTR _dwG$19[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  00797	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  0079a	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0079f	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  007a6	72 09		 jb	 SHORT $LN195@RenderAtla
  007a8	c7 45 c4 ff 00
	00 00		 mov	 DWORD PTR tv676[ebp], 255 ; 000000ffH
  007af	eb 38		 jmp	 SHORT $LN196@RenderAtla
$LN195@RenderAtla:
  007b1	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  007b4	0f 57 c0	 xorps	 xmm0, xmm0
  007b7	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  007bb	72 06		 jb	 SHORT $LN193@RenderAtla
  007bd	83 65 c8 00	 and	 DWORD PTR tv675[ebp], 0
  007c1	eb 20		 jmp	 SHORT $LN194@RenderAtla
$LN193@RenderAtla:
  007c3	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  007c6	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  007cb	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  007d3	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  007db	e8 00 00 00 00	 call	 __ftoui3
  007e0	89 45 c8	 mov	 DWORD PTR tv675[ebp], eax
$LN194@RenderAtla:
  007e3	8b 45 c8	 mov	 eax, DWORD PTR tv675[ebp]
  007e6	89 45 c4	 mov	 DWORD PTR tv676[ebp], eax
$LN196@RenderAtla:
  007e9	8b 45 c4	 mov	 eax, DWORD PTR tv676[ebp]
  007ec	89 85 2c ff ff
	ff		 mov	 DWORD PTR _dwB$16[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  007f2	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  007f5	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  007fa	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00801	72 09		 jb	 SHORT $LN199@RenderAtla
  00803	c7 45 bc ff 00
	00 00		 mov	 DWORD PTR tv687[ebp], 255 ; 000000ffH
  0080a	eb 38		 jmp	 SHORT $LN200@RenderAtla
$LN199@RenderAtla:
  0080c	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  0080f	0f 57 c0	 xorps	 xmm0, xmm0
  00812	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  00816	72 06		 jb	 SHORT $LN197@RenderAtla
  00818	83 65 c0 00	 and	 DWORD PTR tv686[ebp], 0
  0081c	eb 20		 jmp	 SHORT $LN198@RenderAtla
$LN197@RenderAtla:
  0081e	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  00821	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00826	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0082e	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00836	e8 00 00 00 00	 call	 __ftoui3
  0083b	89 45 c0	 mov	 DWORD PTR tv686[ebp], eax
$LN198@RenderAtla:
  0083e	8b 45 c0	 mov	 eax, DWORD PTR tv686[ebp]
  00841	89 45 bc	 mov	 DWORD PTR tv687[ebp], eax
$LN200@RenderAtla:
  00844	8b 45 bc	 mov	 eax, DWORD PTR tv687[ebp]
  00847	89 85 30 ff ff
	ff		 mov	 DWORD PTR _dwA$17[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  0084d	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _dwG$19[ebp]
  00853	c1 e0 08	 shl	 eax, 8
  00856	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _dwR$18[ebp]
  0085c	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0085f	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _dwA$17[ebp]
  00865	c1 e2 18	 shl	 edx, 24			; 00000018H
  00868	0b d1		 or	 edx, ecx
  0086a	0b d0		 or	 edx, eax
  0086c	0b 95 2c ff ff
	ff		 or	 edx, DWORD PTR _dwB$16[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1003 : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_WAYPOINT));

  00872	52		 push	 edx
  00873	6a 3c		 push	 60			; 0000003cH
  00875	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0087b	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00880	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00883	05 10 0c 00 00	 add	 eax, 3088		; 00000c10H
  00888	89 45 b8	 mov	 DWORD PTR __My_data$42[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0088b	8b 45 b8	 mov	 eax, DWORD PTR __My_data$42[ebp]
  0088e	89 85 e4 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00894	8b 45 b8	 mov	 eax, DWORD PTR __My_data$42[ebp]
  00897	8b 00		 mov	 eax, DWORD PTR [eax]
  00899	89 85 28 ff ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0089f	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  008a5	89 85 24 ff ff
	ff		 mov	 DWORD PTR $T15[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  008ab	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  008b1	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T14[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1004 : 	m_AtlasMarkInfoVectorIterator = m_AtlasWayPointInfoVector.begin();

  008b7	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR $T14[ebp]
  008bd	8b 00		 mov	 eax, DWORD PTR [eax]
  008bf	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  008c2	89 81 38 03 00
	00		 mov	 DWORD PTR [ecx+824], eax
  008c8	eb 18		 jmp	 SHORT $LN218@RenderAtla
$LN6@RenderAtla:

; 1005 : 	for (; m_AtlasMarkInfoVectorIterator != m_AtlasWayPointInfoVector.end(); ++m_AtlasMarkInfoVectorIterator)

  008ca	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  008cd	05 38 03 00 00	 add	 eax, 824		; 00000338H
  008d2	89 45 b4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  008d5	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  008d8	8b 00		 mov	 eax, DWORD PTR [eax]
  008da	83 c0 3c	 add	 eax, 60			; 0000003cH
  008dd	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  008e0	89 01		 mov	 DWORD PTR [ecx], eax
$LN218@RenderAtla:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  008e2	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  008e5	05 10 0c 00 00	 add	 eax, 3088		; 00000c10H
  008ea	89 45 b0	 mov	 DWORD PTR __My_data$41[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  008ed	8b 45 b0	 mov	 eax, DWORD PTR __My_data$41[ebp]
  008f0	89 85 e0 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  008f6	8b 45 b0	 mov	 eax, DWORD PTR __My_data$41[ebp]
  008f9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  008fc	89 85 1c ff ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00902	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  00908	89 85 18 ff ff
	ff		 mov	 DWORD PTR $T13[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0090e	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  00914	89 85 14 ff ff
	ff		 mov	 DWORD PTR $T12[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  0091a	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  0091d	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR $T12[ebp]
  00923	8b 80 38 03 00
	00		 mov	 eax, DWORD PTR [eax+824]
  00929	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0092b	75 09		 jne	 SHORT $LN246@RenderAtla
  0092d	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv781[ebp], 1
  00934	eb 04		 jmp	 SHORT $LN247@RenderAtla
$LN246@RenderAtla:
  00936	83 65 ac 00	 and	 DWORD PTR tv781[ebp], 0
$LN247@RenderAtla:
  0093a	8a 45 ac	 mov	 al, BYTE PTR tv781[ebp]
  0093d	88 45 5b	 mov	 BYTE PTR $T55[ebp], al

; 153  :         return !(*this == _Right);

  00940	0f b6 45 5b	 movzx	 eax, BYTE PTR $T55[ebp]
  00944	85 c0		 test	 eax, eax
  00946	75 09		 jne	 SHORT $LN241@RenderAtla
  00948	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv735[ebp], 1
  0094f	eb 04		 jmp	 SHORT $LN242@RenderAtla
$LN241@RenderAtla:
  00951	83 65 a8 00	 and	 DWORD PTR tv735[ebp], 0
$LN242@RenderAtla:
  00955	8a 45 a8	 mov	 al, BYTE PTR tv735[ebp]
  00958	88 45 5a	 mov	 BYTE PTR $T54[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1005 : 	for (; m_AtlasMarkInfoVectorIterator != m_AtlasWayPointInfoVector.end(); ++m_AtlasMarkInfoVectorIterator)

  0095b	0f b6 45 5a	 movzx	 eax, BYTE PTR $T54[ebp]
  0095f	85 c0		 test	 eax, eax
  00961	0f 84 80 00 00
	00		 je	 $LN7@RenderAtla
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  00967	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  0096a	8b 80 38 03 00
	00		 mov	 eax, DWORD PTR [eax+824]
  00970	89 85 10 ff ff
	ff		 mov	 DWORD PTR $T11[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  00976	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR $T11[ebp]
  0097c	89 45 54	 mov	 DWORD PTR _rAtlasMarkInfo$51[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1009 : 		if (rAtlasMarkInfo.m_fScreenX <= 0.0f)

  0097f	8b 45 54	 mov	 eax, DWORD PTR _rAtlasMarkInfo$51[ebp]
  00982	0f 57 c0	 xorps	 xmm0, xmm0
  00985	0f 2f 40 10	 comiss	 xmm0, DWORD PTR [eax+16]
  00989	72 05		 jb	 SHORT $LN15@RenderAtla

; 1010 : 			continue;

  0098b	e9 3a ff ff ff	 jmp	 $LN6@RenderAtla
$LN15@RenderAtla:

; 1011 : 		if (rAtlasMarkInfo.m_fScreenY <= 0.0f)

  00990	8b 45 54	 mov	 eax, DWORD PTR _rAtlasMarkInfo$51[ebp]
  00993	0f 57 c0	 xorps	 xmm0, xmm0
  00996	0f 2f 40 14	 comiss	 xmm0, DWORD PTR [eax+20]
  0099a	72 05		 jb	 SHORT $LN16@RenderAtla

; 1012 : 			continue;

  0099c	e9 29 ff ff ff	 jmp	 $LN6@RenderAtla
$LN16@RenderAtla:

; 1013 : 
; 1014 : 		if (TYPE_TARGET == rAtlasMarkInfo.m_byType)

  009a1	8b 45 54	 mov	 eax, DWORD PTR _rAtlasMarkInfo$51[ebp]
  009a4	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  009a7	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  009aa	75 1c		 jne	 SHORT $LN17@RenderAtla

; 1015 : 		{
; 1016 : 			__RenderMiniWayPointMark(rAtlasMarkInfo.m_fScreenX, rAtlasMarkInfo.m_fScreenY);

  009ac	8b 45 54	 mov	 eax, DWORD PTR _rAtlasMarkInfo$51[ebp]
  009af	f3 0f 2c 40 14	 cvttss2si eax, DWORD PTR [eax+20]
  009b4	50		 push	 eax
  009b5	8b 45 54	 mov	 eax, DWORD PTR _rAtlasMarkInfo$51[ebp]
  009b8	f3 0f 2c 40 10	 cvttss2si eax, DWORD PTR [eax+16]
  009bd	50		 push	 eax
  009be	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  009c1	e8 00 00 00 00	 call	 ?__RenderMiniWayPointMark@CPythonMiniMap@@IAEXHH@Z ; CPythonMiniMap::__RenderMiniWayPointMark

; 1017 : 		}

  009c6	eb 1a		 jmp	 SHORT $LN18@RenderAtla
$LN17@RenderAtla:

; 1018 : 		else
; 1019 : 		{
; 1020 : 			__RenderWayPointMark(rAtlasMarkInfo.m_fScreenX, rAtlasMarkInfo.m_fScreenY);

  009c8	8b 45 54	 mov	 eax, DWORD PTR _rAtlasMarkInfo$51[ebp]
  009cb	f3 0f 2c 40 14	 cvttss2si eax, DWORD PTR [eax+20]
  009d0	50		 push	 eax
  009d1	8b 45 54	 mov	 eax, DWORD PTR _rAtlasMarkInfo$51[ebp]
  009d4	f3 0f 2c 40 10	 cvttss2si eax, DWORD PTR [eax+16]
  009d9	50		 push	 eax
  009da	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  009dd	e8 00 00 00 00	 call	 ?__RenderWayPointMark@CPythonMiniMap@@IAEXHH@Z ; CPythonMiniMap::__RenderWayPointMark
$LN18@RenderAtla:

; 1021 : 		}
; 1022 : 	}

  009e2	e9 e3 fe ff ff	 jmp	 $LN6@RenderAtla
$LN7@RenderAtla:

; 1023 : 
; 1024 : 	STATEMANAGER.RestoreRenderState(D3DRS_TEXTUREFACTOR);

  009e7	6a 3c		 push	 60			; 0000003cH
  009e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  009ef	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 1025 : 
; 1026 : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLORARG1);

  009f4	6a 02		 push	 2
  009f6	6a 00		 push	 0
  009f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  009fe	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 1027 : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLORARG2);

  00a03	6a 03		 push	 3
  00a05	6a 00		 push	 0
  00a07	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00a0d	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 1028 : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLOROP);

  00a12	6a 01		 push	 1
  00a14	6a 00		 push	 0
  00a16	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00a1c	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 1029 : 
; 1030 : 	if ((ELTimer_GetMSec() / 500) % 2)

  00a21	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  00a26	33 d2		 xor	 edx, edx
  00a28	b9 f4 01 00 00	 mov	 ecx, 500		; 000001f4H
  00a2d	f7 f1		 div	 ecx
  00a2f	33 d2		 xor	 edx, edx
  00a31	6a 02		 push	 2
  00a33	59		 pop	 ecx
  00a34	f7 f1		 div	 ecx
  00a36	85 d2		 test	 edx, edx
  00a38	74 0e		 je	 SHORT $LN19@RenderAtla

; 1031 : 		m_AtlasPlayerMark.Render();

  00a3a	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  00a3d	81 c1 cc 02 00
	00		 add	 ecx, 716		; 000002ccH
  00a43	e8 00 00 00 00	 call	 ?Render@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Render
$LN19@RenderAtla:

; 1032 : 
; 1033 : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_MINFILTER);

  00a48	6a 11		 push	 17			; 00000011H
  00a4a	6a 00		 push	 0
  00a4c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00a52	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 1034 : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_MAGFILTER);

  00a57	6a 10		 push	 16			; 00000010H
  00a59	6a 00		 push	 0
  00a5b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00a61	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 1035 : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &m_matIdentity);

  00a66	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00a69	05 a8 01 00 00	 add	 eax, 424		; 000001a8H
  00a6e	50		 push	 eax
  00a6f	68 00 01 00 00	 push	 256			; 00000100H
  00a74	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00a7a	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00a7f	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00a82	05 1c 0c 00 00	 add	 eax, 3100		; 00000c1cH
  00a87	89 45 a4	 mov	 DWORD PTR __My_data$40[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00a8a	8b 45 a4	 mov	 eax, DWORD PTR __My_data$40[ebp]
  00a8d	89 85 dc fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00a93	8b 45 a4	 mov	 eax, DWORD PTR __My_data$40[ebp]
  00a96	8b 00		 mov	 eax, DWORD PTR [eax]
  00a98	89 85 0c ff ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00a9e	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  00aa4	89 45 50	 mov	 DWORD PTR _itor$50[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1039 : 		for (; itor != m_GuildAreaInfoVector.end(); ++itor)

  00aa7	eb 09		 jmp	 SHORT $LN287@RenderAtla
$LN9@RenderAtla:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00aa9	8b 45 50	 mov	 eax, DWORD PTR _itor$50[ebp]
  00aac	83 c0 24	 add	 eax, 36			; 00000024H
  00aaf	89 45 50	 mov	 DWORD PTR _itor$50[ebp], eax
$LN287@RenderAtla:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00ab2	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00ab5	05 1c 0c 00 00	 add	 eax, 3100		; 00000c1cH
  00aba	89 45 a0	 mov	 DWORD PTR __My_data$39[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00abd	8b 45 a0	 mov	 eax, DWORD PTR __My_data$39[ebp]
  00ac0	89 85 d8 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00ac6	8b 45 a0	 mov	 eax, DWORD PTR __My_data$39[ebp]
  00ac9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00acc	89 85 08 ff ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00ad2	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  00ad8	89 85 04 ff ff
	ff		 mov	 DWORD PTR $T10[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00ade	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  00ae4	89 85 00 ff ff
	ff		 mov	 DWORD PTR $T9[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00aea	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  00af0	8b 4d 50	 mov	 ecx, DWORD PTR _itor$50[ebp]
  00af3	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00af5	75 09		 jne	 SHORT $LN315@RenderAtla
  00af7	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv837[ebp], 1
  00afe	eb 04		 jmp	 SHORT $LN316@RenderAtla
$LN315@RenderAtla:
  00b00	83 65 9c 00	 and	 DWORD PTR tv837[ebp], 0
$LN316@RenderAtla:
  00b04	8a 45 9c	 mov	 al, BYTE PTR tv837[ebp]
  00b07	88 45 59	 mov	 BYTE PTR $T53[ebp], al

; 153  :         return !(*this == _Right);

  00b0a	0f b6 45 59	 movzx	 eax, BYTE PTR $T53[ebp]
  00b0e	85 c0		 test	 eax, eax
  00b10	75 09		 jne	 SHORT $LN310@RenderAtla
  00b12	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv823[ebp], 1
  00b19	eb 04		 jmp	 SHORT $LN311@RenderAtla
$LN310@RenderAtla:
  00b1b	83 65 98 00	 and	 DWORD PTR tv823[ebp], 0
$LN311@RenderAtla:
  00b1f	8a 45 98	 mov	 al, BYTE PTR tv823[ebp]
  00b22	88 45 58	 mov	 BYTE PTR $T52[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1039 : 		for (; itor != m_GuildAreaInfoVector.end(); ++itor)

  00b25	0f b6 45 58	 movzx	 eax, BYTE PTR $T52[ebp]
  00b29	85 c0		 test	 eax, eax
  00b2b	0f 84 cf 00 00
	00		 je	 $LN10@RenderAtla
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  00b31	8b 45 50	 mov	 eax, DWORD PTR _itor$50[ebp]
  00b34	89 85 fc fe ff
	ff		 mov	 DWORD PTR $T8[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  00b3a	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR $T8[ebp]
  00b40	89 45 4c	 mov	 DWORD PTR _rInfo$49[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1043 : 			m_GuildAreaFlagImageInstance.SetPosition(fScreenX+(rInfo.fsxRender+rInfo.fexRender)/2.0f - m_GuildAreaFlagImageInstance.GetWidth()/2,

  00b43	8b 45 4c	 mov	 eax, DWORD PTR _rInfo$49[ebp]
  00b46	8b 4d 4c	 mov	 ecx, DWORD PTR _rInfo$49[ebp]
  00b49	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00b4e	f3 0f 58 41 20	 addss	 xmm0, DWORD PTR [ecx+32]
  00b53	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00b5b	f3 0f 58 45 7c	 addss	 xmm0, DWORD PTR _fScreenY$[ebp]
  00b60	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  00b63	81 c1 f0 0b 00
	00		 add	 ecx, 3056		; 00000bf0H
  00b69	f3 0f 11 85 f8
	fe ff ff	 movss	 DWORD PTR tv1158[ebp], xmm0
  00b71	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  00b76	99		 cdq
  00b77	2b c2		 sub	 eax, edx
  00b79	d1 f8		 sar	 eax, 1
  00b7b	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00b7f	f3 0f 10 8d f8
	fe ff ff	 movss	 xmm1, DWORD PTR tv1158[ebp]
  00b87	f3 0f 5c c8	 subss	 xmm1, xmm0
  00b8b	51		 push	 ecx
  00b8c	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00b91	8b 45 4c	 mov	 eax, DWORD PTR _rInfo$49[ebp]
  00b94	8b 4d 4c	 mov	 ecx, DWORD PTR _rInfo$49[ebp]
  00b97	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00b9c	f3 0f 58 41 1c	 addss	 xmm0, DWORD PTR [ecx+28]
  00ba1	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00ba9	f3 0f 58 45 78	 addss	 xmm0, DWORD PTR _fScreenX$[ebp]
  00bae	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  00bb1	81 c1 f0 0b 00
	00		 add	 ecx, 3056		; 00000bf0H
  00bb7	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR tv1160[ebp], xmm0
  00bbf	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  00bc4	99		 cdq
  00bc5	2b c2		 sub	 eax, edx
  00bc7	d1 f8		 sar	 eax, 1
  00bc9	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00bcd	f3 0f 10 8d f4
	fe ff ff	 movss	 xmm1, DWORD PTR tv1160[ebp]
  00bd5	f3 0f 5c c8	 subss	 xmm1, xmm0
  00bd9	51		 push	 ecx
  00bda	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00bdf	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  00be2	81 c1 f0 0b 00
	00		 add	 ecx, 3056		; 00000bf0H
  00be8	e8 00 00 00 00	 call	 ?SetPosition@CGraphicImageInstance@@QAEXMM@Z ; CGraphicImageInstance::SetPosition

; 1044 : 													 fScreenY+(rInfo.fsyRender+rInfo.feyRender)/2.0f - m_GuildAreaFlagImageInstance.GetHeight()/2);
; 1045 : 			m_GuildAreaFlagImageInstance.Render();

  00bed	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  00bf0	81 c1 f0 0b 00
	00		 add	 ecx, 3056		; 00000bf0H
  00bf6	e8 00 00 00 00	 call	 ?Render@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Render

; 1046 : 
; 1047 : //			CScreen::RenderBar2d(fScreenX+rInfo.fsxRender,
; 1048 : //								 fScreenY+rInfo.fsyRender,
; 1049 : //								 fScreenX+rInfo.fexRender,
; 1050 : //								 fScreenY+rInfo.feyRender);
; 1051 : 		}

  00bfb	e9 a9 fe ff ff	 jmp	 $LN9@RenderAtla
$LN10@RenderAtla:
$LN1@RenderAtla:

; 1052 : 	}
; 1053 : }

  00c00	83 c5 70	 add	 ebp, 112		; 00000070H
  00c03	c9		 leave
  00c04	c2 08 00	 ret	 8
?RenderAtlas@CPythonMiniMap@@QAEXMM@Z ENDP		; CPythonMiniMap::RenderAtlas
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?UpdateAtlas@CPythonMiniMap@@QAEXXZ
_TEXT	SEGMENT
$T1 = -100						; size = 4
$T2 = -96						; size = 4
$T3 = -92						; size = 4
$T4 = -88						; size = 4
$T5 = -84						; size = 4
___param0$ = -80					; size = 4
___param0$ = -76					; size = 4
tv327 = -72						; size = 4
tv325 = -68						; size = 4
tv274 = -64						; size = 4
$T6 = -60						; size = 4
tv249 = -56						; size = 4
tv263 = -52						; size = 4
__My_data$7 = -48					; size = 4
__My_data$8 = -44					; size = 4
_pkInst$ = -40						; size = 4
_itor$9 = -36						; size = 4
_fRotation$10 = -32					; size = 4
$T11 = -26						; size = 1
$T12 = -25						; size = 1
_rInfo$13 = -24						; size = 4
_this$ = -20						; size = 4
_kInstPos$14 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
?UpdateAtlas@CPythonMiniMap@@QAEXXZ PROC		; CPythonMiniMap::UpdateAtlas, COMDAT
; _this$ = ecx

; 927  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  00018	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 928  : 	CInstanceBase * pkInst = CPythonCharacterManager::Instance().GetMainInstancePtr();

  0001b	8b 4d c4	 mov	 ecx, DWORD PTR $T6[ebp]
  0001e	e8 00 00 00 00	 call	 ?GetMainInstancePtr@CPythonCharacterManager@@QAEPAVCInstanceBase@@XZ ; CPythonCharacterManager::GetMainInstancePtr
  00023	89 45 d8	 mov	 DWORD PTR _pkInst$[ebp], eax

; 929  : 
; 930  : 	if (pkInst)

  00026	83 7d d8 00	 cmp	 DWORD PTR _pkInst$[ebp], 0
  0002a	0f 84 21 01 00
	00		 je	 $LN9@UpdateAtla

; 931  : 	{
; 932  : 		TPixelPosition kInstPos;
; 933  : 		pkInst->NEW_GetPixelPosition(&kInstPos);

  00030	8d 45 f0	 lea	 eax, DWORD PTR _kInstPos$14[ebp]
  00033	50		 push	 eax
  00034	8b 4d d8	 mov	 ecx, DWORD PTR _pkInst$[ebp]
  00037	e8 00 00 00 00	 call	 ?NEW_GetPixelPosition@CInstanceBase@@QAEXPAUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_GetPixelPosition

; 934  : 
; 935  : 		float fRotation;
; 936  : 		fRotation = (540.0f - pkInst->GetRotation());

  0003c	8b 4d d8	 mov	 ecx, DWORD PTR _pkInst$[ebp]
  0003f	e8 00 00 00 00	 call	 ?GetRotation@CInstanceBase@@QAEMXZ ; CInstanceBase::GetRotation
  00044	d9 5d c0	 fstp	 DWORD PTR tv274[ebp]
  00047	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@44070000
  0004f	f3 0f 5c 45 c0	 subss	 xmm0, DWORD PTR tv274[ebp]
  00054	f3 0f 11 45 e0	 movss	 DWORD PTR _fRotation$10[ebp], xmm0
$LN2@UpdateAtla:

; 937  : 		while(fRotation > 360.0f)

  00059	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fRotation$10[ebp]
  0005e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@43b40000
  00065	76 14		 jbe	 SHORT $LN3@UpdateAtla

; 938  : 			fRotation -= 360.0f;

  00067	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fRotation$10[ebp]
  0006c	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@43b40000
  00074	f3 0f 11 45 e0	 movss	 DWORD PTR _fRotation$10[ebp], xmm0
  00079	eb de		 jmp	 SHORT $LN2@UpdateAtla
$LN3@UpdateAtla:

; 939  : 		while(fRotation < 0.0f)

  0007b	0f 57 c0	 xorps	 xmm0, xmm0
  0007e	0f 2f 45 e0	 comiss	 xmm0, DWORD PTR _fRotation$10[ebp]
  00082	76 14		 jbe	 SHORT $LN5@UpdateAtla

; 940  : 			fRotation += 360.0f;

  00084	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fRotation$10[ebp]
  00089	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@43b40000
  00091	f3 0f 11 45 e0	 movss	 DWORD PTR _fRotation$10[ebp], xmm0
  00096	eb e3		 jmp	 SHORT $LN3@UpdateAtla
$LN5@UpdateAtla:

; 941  : 
; 942  : 		m_AtlasPlayerMark.SetPosition(kInstPos.x / m_fAtlasMaxX * m_fAtlasImageSizeX - (float)m_AtlasPlayerMark.GetWidth() / 2.0f,

  00098	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _kInstPos$14[ebp+4]
  000a0	f3 0f 5e 80 2c
	03 00 00	 divss	 xmm0, DWORD PTR [eax+812]
  000a8	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	f3 0f 59 80 34
	03 00 00	 mulss	 xmm0, DWORD PTR [eax+820]
  000b3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	81 c1 cc 02 00
	00		 add	 ecx, 716		; 000002ccH
  000bc	f3 0f 11 45 bc	 movss	 DWORD PTR tv325[ebp], xmm0
  000c1	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  000c6	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000ca	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  000d2	f3 0f 10 4d bc	 movss	 xmm1, DWORD PTR tv325[ebp]
  000d7	f3 0f 5c c8	 subss	 xmm1, xmm0
  000db	51		 push	 ecx
  000dc	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  000e1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e4	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _kInstPos$14[ebp]
  000e9	f3 0f 5e 80 28
	03 00 00	 divss	 xmm0, DWORD PTR [eax+808]
  000f1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f4	f3 0f 59 80 30
	03 00 00	 mulss	 xmm0, DWORD PTR [eax+816]
  000fc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	81 c1 cc 02 00
	00		 add	 ecx, 716		; 000002ccH
  00105	f3 0f 11 45 b8	 movss	 DWORD PTR tv327[ebp], xmm0
  0010a	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  0010f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00113	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0011b	f3 0f 10 4d b8	 movss	 xmm1, DWORD PTR tv327[ebp]
  00120	f3 0f 5c c8	 subss	 xmm1, xmm0
  00124	51		 push	 ecx
  00125	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  0012a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012d	81 c1 cc 02 00
	00		 add	 ecx, 716		; 000002ccH
  00133	e8 00 00 00 00	 call	 ?SetPosition@CGraphicImageInstance@@QAEXMM@Z ; CGraphicImageInstance::SetPosition

; 943  : 			kInstPos.y / m_fAtlasMaxY * m_fAtlasImageSizeY - (float)m_AtlasPlayerMark.GetHeight() / 2.0f);
; 944  : 		m_AtlasPlayerMark.SetRotation(fRotation);

  00138	51		 push	 ecx
  00139	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fRotation$10[ebp]
  0013e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00143	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00146	81 c1 cc 02 00
	00		 add	 ecx, 716		; 000002ccH
  0014c	e8 00 00 00 00	 call	 ?SetRotation@CGraphicExpandedImageInstance@@QAEXM@Z ; CGraphicExpandedImageInstance::SetRotation
$LN9@UpdateAtla:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00151	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00154	05 1c 0c 00 00	 add	 eax, 3100		; 00000c1cH
  00159	89 45 d4	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0015c	8b 45 d4	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0015f	89 45 a0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00162	8b 45 d4	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 b4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0016a	8b 45 b4	 mov	 eax, DWORD PTR ___param0$[ebp]
  0016d	89 45 dc	 mov	 DWORD PTR _itor$9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 949  : 		for (; itor != m_GuildAreaInfoVector.end(); ++itor)

  00170	eb 09		 jmp	 SHORT $LN30@UpdateAtla
$LN6@UpdateAtla:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00172	8b 45 dc	 mov	 eax, DWORD PTR _itor$9[ebp]
  00175	83 c0 24	 add	 eax, 36			; 00000024H
  00178	89 45 dc	 mov	 DWORD PTR _itor$9[ebp], eax
$LN30@UpdateAtla:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  0017b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0017e	05 1c 0c 00 00	 add	 eax, 3100		; 00000c1cH
  00183	89 45 d0	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00186	8b 45 d0	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00189	89 45 9c	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0018c	8b 45 d0	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0018f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00192	89 45 b0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00195	8b 45 b0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00198	89 45 ac	 mov	 DWORD PTR $T5[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0019b	8d 45 ac	 lea	 eax, DWORD PTR $T5[ebp]
  0019e	89 45 a8	 mov	 DWORD PTR $T4[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  001a1	8b 45 a8	 mov	 eax, DWORD PTR $T4[ebp]
  001a4	8b 4d dc	 mov	 ecx, DWORD PTR _itor$9[ebp]
  001a7	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001a9	75 09		 jne	 SHORT $LN58@UpdateAtla
  001ab	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR tv263[ebp], 1
  001b2	eb 04		 jmp	 SHORT $LN59@UpdateAtla
$LN58@UpdateAtla:
  001b4	83 65 cc 00	 and	 DWORD PTR tv263[ebp], 0
$LN59@UpdateAtla:
  001b8	8a 45 cc	 mov	 al, BYTE PTR tv263[ebp]
  001bb	88 45 e7	 mov	 BYTE PTR $T12[ebp], al

; 153  :         return !(*this == _Right);

  001be	0f b6 45 e7	 movzx	 eax, BYTE PTR $T12[ebp]
  001c2	85 c0		 test	 eax, eax
  001c4	75 09		 jne	 SHORT $LN53@UpdateAtla
  001c6	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR tv249[ebp], 1
  001cd	eb 04		 jmp	 SHORT $LN54@UpdateAtla
$LN53@UpdateAtla:
  001cf	83 65 c8 00	 and	 DWORD PTR tv249[ebp], 0
$LN54@UpdateAtla:
  001d3	8a 45 c8	 mov	 al, BYTE PTR tv249[ebp]
  001d6	88 45 e6	 mov	 BYTE PTR $T11[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 949  : 		for (; itor != m_GuildAreaInfoVector.end(); ++itor)

  001d9	0f b6 45 e6	 movzx	 eax, BYTE PTR $T11[ebp]
  001dd	85 c0		 test	 eax, eax
  001df	74 63		 je	 SHORT $LN7@UpdateAtla
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  001e1	8b 45 dc	 mov	 eax, DWORD PTR _itor$9[ebp]
  001e4	89 45 a4	 mov	 DWORD PTR $T3[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  001e7	8b 45 a4	 mov	 eax, DWORD PTR $T3[ebp]
  001ea	89 45 e8	 mov	 DWORD PTR _rInfo$13[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 952  : 			__GlobalPositionToAtlasPosition(rInfo.lx, rInfo.ly, &rInfo.fsxRender, &rInfo.fsyRender);

  001ed	8b 45 e8	 mov	 eax, DWORD PTR _rInfo$13[ebp]
  001f0	83 c0 18	 add	 eax, 24			; 00000018H
  001f3	50		 push	 eax
  001f4	8b 45 e8	 mov	 eax, DWORD PTR _rInfo$13[ebp]
  001f7	83 c0 14	 add	 eax, 20			; 00000014H
  001fa	50		 push	 eax
  001fb	8b 45 e8	 mov	 eax, DWORD PTR _rInfo$13[ebp]
  001fe	ff 70 08	 push	 DWORD PTR [eax+8]
  00201	8b 45 e8	 mov	 eax, DWORD PTR _rInfo$13[ebp]
  00204	ff 70 04	 push	 DWORD PTR [eax+4]
  00207	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0020a	e8 00 00 00 00	 call	 ?__GlobalPositionToAtlasPosition@CPythonMiniMap@@IAEXJJPAM0@Z ; CPythonMiniMap::__GlobalPositionToAtlasPosition

; 953  : 			__GlobalPositionToAtlasPosition(rInfo.lx+rInfo.lwidth, rInfo.ly+rInfo.lheight, &rInfo.fexRender, &rInfo.feyRender);

  0020f	8b 45 e8	 mov	 eax, DWORD PTR _rInfo$13[ebp]
  00212	83 c0 20	 add	 eax, 32			; 00000020H
  00215	50		 push	 eax
  00216	8b 45 e8	 mov	 eax, DWORD PTR _rInfo$13[ebp]
  00219	83 c0 1c	 add	 eax, 28			; 0000001cH
  0021c	50		 push	 eax
  0021d	8b 45 e8	 mov	 eax, DWORD PTR _rInfo$13[ebp]
  00220	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00223	8b 4d e8	 mov	 ecx, DWORD PTR _rInfo$13[ebp]
  00226	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  00229	50		 push	 eax
  0022a	8b 45 e8	 mov	 eax, DWORD PTR _rInfo$13[ebp]
  0022d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00230	8b 4d e8	 mov	 ecx, DWORD PTR _rInfo$13[ebp]
  00233	03 41 0c	 add	 eax, DWORD PTR [ecx+12]
  00236	50		 push	 eax
  00237	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0023a	e8 00 00 00 00	 call	 ?__GlobalPositionToAtlasPosition@CPythonMiniMap@@IAEXJJPAM0@Z ; CPythonMiniMap::__GlobalPositionToAtlasPosition

; 954  : 		}

  0023f	e9 2e ff ff ff	 jmp	 $LN6@UpdateAtla
$LN7@UpdateAtla:

; 955  : 	}
; 956  : }

  00244	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00247	33 cd		 xor	 ecx, ebp
  00249	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024e	c9		 leave
  0024f	c3		 ret	 0
?UpdateAtlas@CPythonMiniMap@@QAEXXZ ENDP		; CPythonMiniMap::UpdateAtlas
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\gamelib\MapBase.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\gamelib\MapOutdoor.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?LoadAtlas@CPythonMiniMap@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -128						; size = 4
_playerMarkFileName$ = -124				; size = 4
$T2 = -120						; size = 4
$T3 = -116						; size = 4
$T4 = -112						; size = 4
_rkBG$ = -108						; size = 4
_pkGrpImgAtlas$ = -104					; size = 4
_sTerrainCountY$ = -100					; size = 2
_sTerrainCountX$ = -96					; size = 2
_rkMap$ = -92						; size = 4
_this$ = -88						; size = 4
_atlasFileName$ = -84					; size = 1025
__$ArrayPad$ = 944					; size = 4
?LoadAtlas@CPythonMiniMap@@QAE_NXZ PROC			; CPythonMiniMap::LoadAtlas, COMDAT
; _this$ = ecx

; 870  : {

  00000	55		 push	 ebp
  00001	8d ac 24 4c fc
	ff ff		 lea	 ebp, DWORD PTR [esp-948]
  00008	81 ec 34 04 00
	00		 sub	 esp, 1076		; 00000434H
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 b0 03 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	89 4d a8	 mov	 DWORD PTR _this$[ebp], ecx

; 871  : 	CPythonBackground& rkBG=CPythonBackground::Instance();

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  00023	89 45 94	 mov	 DWORD PTR _rkBG$[ebp], eax

; 872  : 	if (!rkBG.IsMapOutdoor())

  00026	8b 4d 94	 mov	 ecx, DWORD PTR _rkBG$[ebp]
  00029	e8 00 00 00 00	 call	 ?IsMapOutdoor@CMapManager@@QAE_NXZ ; CMapManager::IsMapOutdoor
  0002e	0f b6 c0	 movzx	 eax, al
  00031	85 c0		 test	 eax, eax
  00033	75 07		 jne	 SHORT $LN2@LoadAtlas

; 873  : 		return false;

  00035	32 c0		 xor	 al, al
  00037	e9 c7 01 00 00	 jmp	 $LN1@LoadAtlas
$LN2@LoadAtlas:

; 874  : 
; 875  : 	CMapOutdoor& rkMap=rkBG.GetMapOutdoorRef();

  0003c	8b 4d 94	 mov	 ecx, DWORD PTR _rkBG$[ebp]
  0003f	e8 00 00 00 00	 call	 ?GetMapOutdoorRef@CMapManager@@QAEAAVCMapOutdoor@@XZ ; CMapManager::GetMapOutdoorRef
  00044	89 45 a4	 mov	 DWORD PTR _rkMap$[ebp], eax

; 876  : 
; 877  : 	const char* playerMarkFileName = "d:/ymir work/ui/minimap/playermark.sub";

  00047	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _playerMarkFileName$[ebp], OFFSET ??_C@_0CH@JMBNEHDO@d?3?1ymir?5work?1ui?1minimap?1playerm@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  0004e	8b 4d a4	 mov	 ecx, DWORD PTR _rkMap$[ebp]
  00051	83 c1 08	 add	 ecx, 8
  00054	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00059	89 45 90	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 880  : 	snprintf(atlasFileName, sizeof(atlasFileName), "%s/atlas.sub", rkMap.GetName().c_str());	

  0005c	ff 75 90	 push	 DWORD PTR $T4[ebp]
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KOLJCEFK@?$CFs?1atlas?4sub@
  00064	68 01 04 00 00	 push	 1025			; 00000401H
  00069	8d 45 ac	 lea	 eax, DWORD PTR _atlasFileName$[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 __snprintf
  00072	83 c4 10	 add	 esp, 16			; 00000010H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  0007a	89 45 8c	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 881  : 	if (!CEterPackManager::Instance().isExist(atlasFileName))		

  0007d	8d 45 ac	 lea	 eax, DWORD PTR _atlasFileName$[ebp]
  00080	50		 push	 eax
  00081	8b 4d 8c	 mov	 ecx, DWORD PTR $T3[ebp]
  00084	e8 00 00 00 00	 call	 ?isExist@CEterPackManager@@QAE_NPBD@Z ; CEterPackManager::isExist
  00089	0f b6 c0	 movzx	 eax, al
  0008c	85 c0		 test	 eax, eax
  0008e	75 22		 jne	 SHORT $LN3@LoadAtlas
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\gamelib\MapBase.h

; 50   : 		const std::string & GetName() const { return m_strName; }

  00090	8b 4d a4	 mov	 ecx, DWORD PTR _rkMap$[ebp]
  00093	83 c1 08	 add	 ecx, 8
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 883  : 		snprintf(atlasFileName, sizeof(atlasFileName), "d:/ymir work/ui/atlas/%s/atlas.sub", rkMap.GetName().c_str());

  00096	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0009b	50		 push	 eax
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@LPCJKMM@d?3?1ymir?5work?1ui?1atlas?1?$CFs?1atlas?4@
  000a1	68 01 04 00 00	 push	 1025			; 00000401H
  000a6	8d 45 ac	 lea	 eax, DWORD PTR _atlasFileName$[ebp]
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 __snprintf
  000af	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@LoadAtlas:

; 884  : 	}
; 885  : 	
; 886  : 	m_AtlasImageInstance.Destroy();

  000b2	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	81 c1 6c 02 00
	00		 add	 ecx, 620		; 0000026cH
  000bb	e8 00 00 00 00	 call	 ?Destroy@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Destroy

; 887  : 	m_AtlasPlayerMark.Destroy();

  000c0	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c3	81 c1 cc 02 00
	00		 add	 ecx, 716		; 000002ccH
  000c9	e8 00 00 00 00	 call	 ?Destroy@CGraphicExpandedImageInstance@@QAEXXZ ; CGraphicExpandedImageInstance::Destroy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  000ce	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  000d3	89 45 88	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 888  : 	CGraphicImage* pkGrpImgAtlas = (CGraphicImage *) CResourceManager::Instance().GetResourcePointer(atlasFileName);

  000d6	8d 45 ac	 lea	 eax, DWORD PTR _atlasFileName$[ebp]
  000d9	50		 push	 eax
  000da	8b 4d 88	 mov	 ecx, DWORD PTR $T2[ebp]
  000dd	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  000e2	89 45 98	 mov	 DWORD PTR _pkGrpImgAtlas$[ebp], eax

; 889  : 	if (pkGrpImgAtlas)

  000e5	83 7d 98 00	 cmp	 DWORD PTR _pkGrpImgAtlas$[ebp], 0
  000e9	74 36		 je	 SHORT $LN4@LoadAtlas

; 890  : 	{
; 891  : 		m_AtlasImageInstance.SetImagePointer(pkGrpImgAtlas);

  000eb	ff 75 98	 push	 DWORD PTR _pkGrpImgAtlas$[ebp]
  000ee	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f1	81 c1 6c 02 00
	00		 add	 ecx, 620		; 0000026cH
  000f7	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer

; 892  : 		
; 893  : 		if (pkGrpImgAtlas->IsEmpty())

  000fc	8b 4d 98	 mov	 ecx, DWORD PTR _pkGrpImgAtlas$[ebp]
  000ff	e8 00 00 00 00	 call	 ?IsEmpty@CResource@@QBE_NXZ ; CResource::IsEmpty
  00104	0f b6 c0	 movzx	 eax, al
  00107	85 c0		 test	 eax, eax
  00109	74 0c		 je	 SHORT $LN6@LoadAtlas

; 894  : 			m_bAtlas=false;

  0010b	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  0010e	c6 80 70 01 00
	00 00		 mov	 BYTE PTR [eax+368], 0
  00115	eb 0a		 jmp	 SHORT $LN7@LoadAtlas
$LN6@LoadAtlas:

; 895  : 		else
; 896  : 			m_bAtlas=true;		

  00117	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	c6 80 70 01 00
	00 01		 mov	 BYTE PTR [eax+368], 1
$LN7@LoadAtlas:
$LN4@LoadAtlas:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00121	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  00126	89 45 80	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 901  : 	m_AtlasPlayerMark.SetImagePointer((CGraphicSubImage *) CResourceManager::Instance().GetResourcePointer(playerMarkFileName));

  00129	ff 75 84	 push	 DWORD PTR _playerMarkFileName$[ebp]
  0012c	8b 4d 80	 mov	 ecx, DWORD PTR $T1[ebp]
  0012f	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  00134	50		 push	 eax
  00135	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00138	81 c1 cc 02 00
	00		 add	 ecx, 716		; 000002ccH
  0013e	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer

; 902  : 
; 903  : 	short sTerrainCountX, sTerrainCountY;  
; 904  : 	rkMap.GetBaseXY(&m_dwAtlasBaseX, &m_dwAtlasBaseY);

  00143	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00146	05 24 03 00 00	 add	 eax, 804		; 00000324H
  0014b	50		 push	 eax
  0014c	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  0014f	05 20 03 00 00	 add	 eax, 800		; 00000320H
  00154	50		 push	 eax
  00155	8b 4d a4	 mov	 ecx, DWORD PTR _rkMap$[ebp]
  00158	e8 00 00 00 00	 call	 ?GetBaseXY@CMapOutdoor@@QAEXPAK0@Z ; CMapOutdoor::GetBaseXY
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\gamelib\MapOutdoor.h

; 140  : 			*psTerrainCountX = m_sTerrainCountX;

  0015d	8b 45 a4	 mov	 eax, DWORD PTR _rkMap$[ebp]
  00160	66 8b 40 70	 mov	 ax, WORD PTR [eax+112]
  00164	66 89 45 a0	 mov	 WORD PTR _sTerrainCountX$[ebp], ax

; 141  : 			*psTerrainCountY = m_sTerrainCountY;

  00168	8b 45 a4	 mov	 eax, DWORD PTR _rkMap$[ebp]
  0016b	66 8b 40 72	 mov	 ax, WORD PTR [eax+114]
  0016f	66 89 45 9c	 mov	 WORD PTR _sTerrainCountY$[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 906  : 	m_fAtlasMaxX = (float) sTerrainCountX * CTerrainImpl::TERRAIN_XSIZE;

  00173	0f bf 45 a0	 movsx	 eax, WORD PTR _sTerrainCountX$[ebp]
  00177	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0017b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@46c80000
  00183	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00186	f3 0f 11 80 28
	03 00 00	 movss	 DWORD PTR [eax+808], xmm0

; 907  : 	m_fAtlasMaxY = (float) sTerrainCountY * CTerrainImpl::TERRAIN_YSIZE;

  0018e	0f bf 45 9c	 movsx	 eax, WORD PTR _sTerrainCountY$[ebp]
  00192	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00196	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@46c80000
  0019e	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  001a1	f3 0f 11 80 2c
	03 00 00	 movss	 DWORD PTR [eax+812], xmm0

; 908  : 
; 909  : 	m_fAtlasImageSizeX = (float) m_AtlasImageInstance.GetWidth();

  001a9	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ac	81 c1 6c 02 00
	00		 add	 ecx, 620		; 0000026cH
  001b2	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  001b7	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001bb	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  001be	f3 0f 11 80 30
	03 00 00	 movss	 DWORD PTR [eax+816], xmm0

; 910  : 	m_fAtlasImageSizeY = (float) m_AtlasImageInstance.GetHeight();

  001c6	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c9	81 c1 6c 02 00
	00		 add	 ecx, 620		; 0000026cH
  001cf	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  001d4	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001d8	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  001db	f3 0f 11 80 34
	03 00 00	 movss	 DWORD PTR [eax+820], xmm0

; 911  : 
; 912  : 	__LoadAtlasMarkInfo();

  001e3	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e6	e8 00 00 00 00	 call	 ?__LoadAtlasMarkInfo@CPythonMiniMap@@IAEXXZ ; CPythonMiniMap::__LoadAtlasMarkInfo

; 913  : 
; 914  : 	if (m_bShowAtlas)

  001eb	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  001ee	0f b6 80 68 02
	00 00		 movzx	 eax, BYTE PTR [eax+616]
  001f5	85 c0		 test	 eax, eax
  001f7	74 08		 je	 SHORT $LN8@LoadAtlas

; 915  : 		OpenAtlasWindow();

  001f9	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  001fc	e8 00 00 00 00	 call	 ?OpenAtlasWindow@CPythonMiniMap@@QAEXXZ ; CPythonMiniMap::OpenAtlasWindow
$LN8@LoadAtlas:

; 916  : 
; 917  : 	return true;

  00201	b0 01		 mov	 al, 1
$LN1@LoadAtlas:

; 918  : }

  00203	8b 8d b0 03 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00209	33 cd		 xor	 ecx, ebp
  0020b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00210	81 c5 b4 03 00
	00		 add	 ebp, 948		; 000003b4H
  00216	c9		 leave
  00217	c3		 ret	 0
?LoadAtlas@CPythonMiniMap@@QAE_NXZ ENDP			; CPythonMiniMap::LoadAtlas
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonCharacterManager.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonCharacterManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonCharacterManager.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonCharacterManager.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonCharacterManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?GetPickedInstanceInfo@CPythonMiniMap@@QAE_NMMAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM1PAK@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
$T2 = -208						; size = 4
$T3 = -204						; size = 4
_dwB$4 = -200						; size = 4
_dwA$5 = -196						; size = 4
_dwR$6 = -192						; size = 4
_dwG$7 = -188						; size = 4
$T8 = -184						; size = 4
$T9 = -180						; size = 4
$T10 = -176						; size = 4
__Xx$ = -172						; size = 4
$T11 = -168						; size = 4
__Xx$ = -164						; size = 4
$T12 = -160						; size = 4
$T13 = -156						; size = 4
$T14 = -152						; size = 4
$T15 = -148						; size = 4
$T16 = -144						; size = 4
$T17 = -140						; size = 4
$T18 = -136						; size = 4
$T19 = -132						; size = 4
___param0$20 = -128					; size = 4
__Scary$21 = -124					; size = 4
$T22 = -120						; size = 4
_this$ = -116						; size = 4
$T23 = -112						; size = 4
_it$ = -108						; size = 4
_this$ = -104						; size = 4
_dwB$24 = -100						; size = 4
_dwA$25 = -96						; size = 4
_dwR$26 = -92						; size = 4
_dwG$27 = -88						; size = 4
$T28 = -84						; size = 4
$T29 = -80						; size = 4
$T30 = -76						; size = 4
__Xx$ = -72						; size = 4
$T31 = -68						; size = 4
__Xx$ = -64						; size = 4
tv338 = -60						; size = 4
tv328 = -56						; size = 4
tv538 = -52						; size = 4
tv517 = -48						; size = 4
tv514 = -44						; size = 4
tv515 = -40						; size = 4
tv544 = -36						; size = 4
tv518 = -32						; size = 4
tv534 = -28						; size = 4
tv530 = -24						; size = 4
__Ptr$ = -20						; size = 4
_fRealY$ = -16						; size = 4
_fRealX$ = -12						; size = 4
tv432 = -8						; size = 4
tv445 = -4						; size = 4
_rkChrMgr$ = 0						; size = 4
tv339 = 4						; size = 4
tv327 = 8						; size = 4
tv285 = 12						; size = 4
tv284 = 16						; size = 4
tv274 = 20						; size = 4
tv273 = 24						; size = 4
__Ptr$ = 28						; size = 4
_fDistanceFromMiniMapCenterY$ = 32			; size = 4
_fDistanceFromMiniMapCenterX$ = 36			; size = 4
_i$ = 40						; size = 4
_pkInst$ = 44						; size = 4
_pkInstEach$32 = 48					; size = 4
$T33 = 54						; size = 1
$T34 = 55						; size = 1
_this$ = 56						; size = 4
_this$ = 60						; size = 4
_this$ = 64						; size = 4
_kInstancePosition$35 = 68				; size = 12
_kInstPos$36 = 80					; size = 12
__$ArrayPad$ = 92					; size = 4
_fScreenX$ = 104					; size = 4
_fScreenY$ = 108					; size = 4
_rReturnName$ = 112					; size = 4
_pReturnPosX$ = 116					; size = 4
_pReturnPosY$ = 120					; size = 4
_pdwTextColor$ = 124					; size = 4
?GetPickedInstanceInfo@CPythonMiniMap@@QAE_NMMAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM1PAK@Z PROC ; CPythonMiniMap::GetPickedInstanceInfo, COMDAT
; _this$ = ecx

; 1056 : {

  00000	55		 push	 ebp
  00001	8d 6c 24 a0	 lea	 ebp, DWORD PTR [esp-96]
  00005	81 ec 34 01 00
	00		 sub	 esp, 308		; 00000134H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 5c	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	89 4d 40	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 : 	float fDistanceFromMiniMapCenterX = fScreenX - m_fScreenX - m_fWidth * 0.5f;

  00018	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	f3 0f 10 45 68	 movss	 xmm0, DWORD PTR _fScreenX$[ebp]
  00020	f3 0f 5c 40 24	 subss	 xmm0, DWORD PTR [eax+36]
  00025	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  00028	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  0002d	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  00035	f3 0f 5c c1	 subss	 xmm0, xmm1
  00039	f3 0f 11 45 24	 movss	 DWORD PTR _fDistanceFromMiniMapCenterX$[ebp], xmm0

; 1058 : 	float fDistanceFromMiniMapCenterY = fScreenY - m_fScreenY - m_fHeight * 0.5f;

  0003e	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  00041	f3 0f 10 45 6c	 movss	 xmm0, DWORD PTR _fScreenY$[ebp]
  00046	f3 0f 5c 40 28	 subss	 xmm0, DWORD PTR [eax+40]
  0004b	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [eax+12]
  00053	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  0005b	f3 0f 5c c1	 subss	 xmm0, xmm1
  0005f	f3 0f 11 45 20	 movss	 DWORD PTR _fDistanceFromMiniMapCenterY$[ebp], xmm0

; 1060 : 	if (sqrtf(fDistanceFromMiniMapCenterX * fDistanceFromMiniMapCenterX + fDistanceFromMiniMapCenterY * fDistanceFromMiniMapCenterY) > m_fMiniMapRadius )

  00064	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _fDistanceFromMiniMapCenterY$[ebp]
  00069	f3 0f 59 45 20	 mulss	 xmm0, DWORD PTR _fDistanceFromMiniMapCenterY$[ebp]
  0006e	f3 0f 10 4d 24	 movss	 xmm1, DWORD PTR _fDistanceFromMiniMapCenterX$[ebp]
  00073	f3 0f 59 4d 24	 mulss	 xmm1, DWORD PTR _fDistanceFromMiniMapCenterX$[ebp]
  00078	f3 0f 58 c8	 addss	 xmm1, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  0007c	f3 0f 5a c1	 cvtss2sd xmm0, xmm1
  00080	51		 push	 ecx
  00081	51		 push	 ecx
  00082	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00087	e8 00 00 00 00	 call	 _sqrt
  0008c	59		 pop	 ecx
  0008d	59		 pop	 ecx
  0008e	d9 9d 74 ff ff
	ff		 fstp	 DWORD PTR $T17[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1060 : 	if (sqrtf(fDistanceFromMiniMapCenterX * fDistanceFromMiniMapCenterX + fDistanceFromMiniMapCenterY * fDistanceFromMiniMapCenterY) > m_fMiniMapRadius )

  00094	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  00097	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR $T17[ebp]
  0009f	0f 2f 40 2c	 comiss	 xmm0, DWORD PTR [eax+44]
  000a3	76 07		 jbe	 SHORT $LN5@GetPickedI

; 1061 : 		return false;

  000a5	32 c0		 xor	 al, al
  000a7	e9 c0 06 00 00	 jmp	 $LN1@GetPickedI
$LN5@GetPickedI:

; 1062 : 
; 1063 : 	float fRealX = m_fCenterX + fDistanceFromMiniMapCenterX / m_fScale * ((float) CTerrainImpl::CELLSCALE);

  000ac	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  000af	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fDistanceFromMiniMapCenterX$[ebp]
  000b4	f3 0f 5e 40 10	 divss	 xmm0, DWORD PTR [eax+16]
  000b9	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@43480000
  000c1	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	f3 0f 58 40 14	 addss	 xmm0, DWORD PTR [eax+20]
  000c9	f3 0f 11 45 f4	 movss	 DWORD PTR _fRealX$[ebp], xmm0

; 1064 : 	float fRealY = m_fCenterY + fDistanceFromMiniMapCenterY / m_fScale * ((float) CTerrainImpl::CELLSCALE);

  000ce	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  000d1	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _fDistanceFromMiniMapCenterY$[ebp]
  000d6	f3 0f 5e 40 10	 divss	 xmm0, DWORD PTR [eax+16]
  000db	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@43480000
  000e3	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  000e6	f3 0f 58 40 18	 addss	 xmm0, DWORD PTR [eax+24]
  000eb	f3 0f 11 45 f0	 movss	 DWORD PTR _fRealY$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  000f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  000f5	89 85 34 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1066 : 	CInstanceBase * pkInst = CPythonCharacterManager::Instance().GetMainInstancePtr();

  000fb	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  00101	e8 00 00 00 00	 call	 ?GetMainInstancePtr@CPythonCharacterManager@@QAEPAVCInstanceBase@@XZ ; CPythonCharacterManager::GetMainInstancePtr
  00106	89 45 2c	 mov	 DWORD PTR _pkInst$[ebp], eax

; 1067 : 
; 1068 : 	if (pkInst)

  00109	83 7d 2c 00	 cmp	 DWORD PTR _pkInst$[ebp], 0
  0010d	0f 84 5a 02 00
	00		 je	 $LN7@GetPickedI

; 1069 : 	{
; 1070 : 		TPixelPosition kInstPos;
; 1071 : 		pkInst->NEW_GetPixelPosition(&kInstPos);

  00113	8d 45 50	 lea	 eax, DWORD PTR _kInstPos$36[ebp]
  00116	50		 push	 eax
  00117	8b 4d 2c	 mov	 ecx, DWORD PTR _pkInst$[ebp]
  0011a	e8 00 00 00 00	 call	 ?NEW_GetPixelPosition@CInstanceBase@@QAEXPAUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_GetPixelPosition

; 1073 : 		if (fabs(kInstPos.x - fRealX) < ((float) CTerrainImpl::CELLSCALE) * 6.0f / m_fScale &&

  0011f	f3 0f 10 45 50	 movss	 xmm0, DWORD PTR _kInstPos$36[ebp]
  00124	f3 0f 5c 45 f4	 subss	 xmm0, DWORD PTR _fRealX$[ebp]
  00129	f3 0f 11 45 c0	 movss	 DWORD PTR __Xx$[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  0012e	f3 0f 5a 45 c0	 cvtss2sd xmm0, DWORD PTR __Xx$[ebp]
  00133	51		 push	 ecx
  00134	51		 push	 ecx
  00135	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0013a	e8 00 00 00 00	 call	 _fabs
  0013f	59		 pop	 ecx
  00140	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath

; 95   :     return _CSTD fabsf(_Xx);

  00141	d9 5d bc	 fstp	 DWORD PTR $T31[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1073 : 		if (fabs(kInstPos.x - fRealX) < ((float) CTerrainImpl::CELLSCALE) * 6.0f / m_fScale &&

  00144	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  00147	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@44960000
  0014f	f3 0f 5e 40 10	 divss	 xmm0, DWORD PTR [eax+16]
  00154	0f 2f 45 bc	 comiss	 xmm0, DWORD PTR $T31[ebp]
  00158	0f 86 0f 02 00
	00		 jbe	 $LN7@GetPickedI
  0015e	f3 0f 10 45 54	 movss	 xmm0, DWORD PTR _kInstPos$36[ebp+4]
  00163	f3 0f 5c 45 f0	 subss	 xmm0, DWORD PTR _fRealY$[ebp]
  00168	f3 0f 11 45 b8	 movss	 DWORD PTR __Xx$[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  0016d	f3 0f 5a 45 b8	 cvtss2sd xmm0, DWORD PTR __Xx$[ebp]
  00172	51		 push	 ecx
  00173	51		 push	 ecx
  00174	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00179	e8 00 00 00 00	 call	 _fabs
  0017e	59		 pop	 ecx
  0017f	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath

; 95   :     return _CSTD fabsf(_Xx);

  00180	d9 5d b4	 fstp	 DWORD PTR $T30[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1073 : 		if (fabs(kInstPos.x - fRealX) < ((float) CTerrainImpl::CELLSCALE) * 6.0f / m_fScale &&

  00183	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  00186	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@44960000
  0018e	f3 0f 5e 40 10	 divss	 xmm0, DWORD PTR [eax+16]
  00193	0f 2f 45 b4	 comiss	 xmm0, DWORD PTR $T30[ebp]
  00197	0f 86 d0 01 00
	00		 jbe	 $LN7@GetPickedI

; 1074 : 			fabs(kInstPos.y - fRealY) < ((float) CTerrainImpl::CELLSCALE) * 6.0f / m_fScale)
; 1075 : 		{
; 1076 : 			rReturnName = pkInst->GetNameString();

  0019d	8b 4d 2c	 mov	 ecx, DWORD PTR _pkInst$[ebp]
  001a0	e8 00 00 00 00	 call	 ?GetNameString@CInstanceBase@@QAEPBDXZ ; CInstanceBase::GetNameString
  001a5	89 45 1c	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  001a8	ff 75 1c	 push	 DWORD PTR __Ptr$[ebp]
  001ab	e8 00 00 00 00	 call	 _strlen
  001b0	59		 pop	 ecx
  001b1	89 45 b0	 mov	 DWORD PTR $T29[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  001b4	8b 45 b0	 mov	 eax, DWORD PTR $T29[ebp]
  001b7	89 45 ac	 mov	 DWORD PTR $T28[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  001ba	ff 75 ac	 push	 DWORD PTR $T28[ebp]
  001bd	ff 75 1c	 push	 DWORD PTR __Ptr$[ebp]
  001c0	8b 4d 70	 mov	 ecx, DWORD PTR _rReturnName$[ebp]
  001c3	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1077 : 			*pReturnPosX = kInstPos.x;

  001c8	8b 45 74	 mov	 eax, DWORD PTR _pReturnPosX$[ebp]
  001cb	f3 0f 10 45 50	 movss	 xmm0, DWORD PTR _kInstPos$36[ebp]
  001d0	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1078 : 			*pReturnPosY = kInstPos.y;

  001d4	8b 45 78	 mov	 eax, DWORD PTR _pReturnPosY$[ebp]
  001d7	f3 0f 10 45 54	 movss	 xmm0, DWORD PTR _kInstPos$36[ebp+4]
  001dc	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1079 : 			*pdwTextColor = pkInst->GetNameColor();

  001e0	8b 4d 2c	 mov	 ecx, DWORD PTR _pkInst$[ebp]
  001e3	e8 00 00 00 00	 call	 ?GetNameColor@CInstanceBase@@QAEABUD3DXCOLOR@@XZ ; CInstanceBase::GetNameColor
  001e8	89 45 3c	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  001eb	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  001ee	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001f2	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  001f9	72 09		 jb	 SHORT $LN44@GetPickedI
  001fb	c7 45 14 ff 00
	00 00		 mov	 DWORD PTR tv274[ebp], 255 ; 000000ffH
  00202	eb 36		 jmp	 SHORT $LN45@GetPickedI
$LN44@GetPickedI:
  00204	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  00207	0f 57 c0	 xorps	 xmm0, xmm0
  0020a	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  0020d	72 06		 jb	 SHORT $LN42@GetPickedI
  0020f	83 65 18 00	 and	 DWORD PTR tv273[ebp], 0
  00213	eb 1f		 jmp	 SHORT $LN43@GetPickedI
$LN42@GetPickedI:
  00215	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  00218	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0021c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00224	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0022c	e8 00 00 00 00	 call	 __ftoui3
  00231	89 45 18	 mov	 DWORD PTR tv273[ebp], eax
$LN43@GetPickedI:
  00234	8b 45 18	 mov	 eax, DWORD PTR tv273[ebp]
  00237	89 45 14	 mov	 DWORD PTR tv274[ebp], eax
$LN45@GetPickedI:
  0023a	8b 45 14	 mov	 eax, DWORD PTR tv274[ebp]
  0023d	89 45 a4	 mov	 DWORD PTR _dwR$26[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  00240	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  00243	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00248	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0024f	72 09		 jb	 SHORT $LN48@GetPickedI
  00251	c7 45 0c ff 00
	00 00		 mov	 DWORD PTR tv285[ebp], 255 ; 000000ffH
  00258	eb 38		 jmp	 SHORT $LN49@GetPickedI
$LN48@GetPickedI:
  0025a	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  0025d	0f 57 c0	 xorps	 xmm0, xmm0
  00260	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  00264	72 06		 jb	 SHORT $LN46@GetPickedI
  00266	83 65 10 00	 and	 DWORD PTR tv284[ebp], 0
  0026a	eb 20		 jmp	 SHORT $LN47@GetPickedI
$LN46@GetPickedI:
  0026c	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  0026f	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00274	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0027c	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00284	e8 00 00 00 00	 call	 __ftoui3
  00289	89 45 10	 mov	 DWORD PTR tv284[ebp], eax
$LN47@GetPickedI:
  0028c	8b 45 10	 mov	 eax, DWORD PTR tv284[ebp]
  0028f	89 45 0c	 mov	 DWORD PTR tv285[ebp], eax
$LN49@GetPickedI:
  00292	8b 45 0c	 mov	 eax, DWORD PTR tv285[ebp]
  00295	89 45 a8	 mov	 DWORD PTR _dwG$27[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  00298	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  0029b	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  002a0	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  002a7	72 09		 jb	 SHORT $LN52@GetPickedI
  002a9	c7 45 c8 ff 00
	00 00		 mov	 DWORD PTR tv328[ebp], 255 ; 000000ffH
  002b0	eb 38		 jmp	 SHORT $LN53@GetPickedI
$LN52@GetPickedI:
  002b2	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  002b5	0f 57 c0	 xorps	 xmm0, xmm0
  002b8	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  002bc	72 06		 jb	 SHORT $LN50@GetPickedI
  002be	83 65 08 00	 and	 DWORD PTR tv327[ebp], 0
  002c2	eb 20		 jmp	 SHORT $LN51@GetPickedI
$LN50@GetPickedI:
  002c4	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  002c7	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  002cc	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  002d4	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  002dc	e8 00 00 00 00	 call	 __ftoui3
  002e1	89 45 08	 mov	 DWORD PTR tv327[ebp], eax
$LN51@GetPickedI:
  002e4	8b 45 08	 mov	 eax, DWORD PTR tv327[ebp]
  002e7	89 45 c8	 mov	 DWORD PTR tv328[ebp], eax
$LN53@GetPickedI:
  002ea	8b 45 c8	 mov	 eax, DWORD PTR tv328[ebp]
  002ed	89 45 9c	 mov	 DWORD PTR _dwB$24[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  002f0	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  002f3	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  002f8	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  002ff	72 09		 jb	 SHORT $LN56@GetPickedI
  00301	c7 45 04 ff 00
	00 00		 mov	 DWORD PTR tv339[ebp], 255 ; 000000ffH
  00308	eb 38		 jmp	 SHORT $LN57@GetPickedI
$LN56@GetPickedI:
  0030a	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  0030d	0f 57 c0	 xorps	 xmm0, xmm0
  00310	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  00314	72 06		 jb	 SHORT $LN54@GetPickedI
  00316	83 65 c4 00	 and	 DWORD PTR tv338[ebp], 0
  0031a	eb 20		 jmp	 SHORT $LN55@GetPickedI
$LN54@GetPickedI:
  0031c	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  0031f	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00324	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0032c	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00334	e8 00 00 00 00	 call	 __ftoui3
  00339	89 45 c4	 mov	 DWORD PTR tv338[ebp], eax
$LN55@GetPickedI:
  0033c	8b 45 c4	 mov	 eax, DWORD PTR tv338[ebp]
  0033f	89 45 04	 mov	 DWORD PTR tv339[ebp], eax
$LN57@GetPickedI:
  00342	8b 45 04	 mov	 eax, DWORD PTR tv339[ebp]
  00345	89 45 a0	 mov	 DWORD PTR _dwA$25[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  00348	8b 45 a8	 mov	 eax, DWORD PTR _dwG$27[ebp]
  0034b	c1 e0 08	 shl	 eax, 8
  0034e	8b 4d a4	 mov	 ecx, DWORD PTR _dwR$26[ebp]
  00351	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00354	8b 55 a0	 mov	 edx, DWORD PTR _dwA$25[ebp]
  00357	c1 e2 18	 shl	 edx, 24			; 00000018H
  0035a	0b d1		 or	 edx, ecx
  0035c	0b d0		 or	 edx, eax
  0035e	0b 55 9c	 or	 edx, DWORD PTR _dwB$24[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1079 : 			*pdwTextColor = pkInst->GetNameColor();

  00361	8b 45 7c	 mov	 eax, DWORD PTR _pdwTextColor$[ebp]
  00364	89 10		 mov	 DWORD PTR [eax], edx

; 1080 : 			return true;

  00366	b0 01		 mov	 al, 1
  00368	e9 ff 03 00 00	 jmp	 $LN1@GetPickedI
$LN7@GetPickedI:

; 1081 : 		}
; 1082 : 	}
; 1083 : 
; 1084 : 	if (m_fScale < 1.0f)

  0036d	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  00370	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00378	0f 2f 40 10	 comiss	 xmm0, DWORD PTR [eax+16]
  0037c	76 07		 jbe	 SHORT $LN8@GetPickedI

; 1085 : 		return false;

  0037e	32 c0		 xor	 al, al
  00380	e9 e7 03 00 00	 jmp	 $LN1@GetPickedI
$LN8@GetPickedI:

; 1086 : 
; 1087 : 	CPythonCharacterManager& rkChrMgr=CPythonCharacterManager::Instance();

  00385	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  0038a	89 45 00	 mov	 DWORD PTR _rkChrMgr$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonCharacterManager.h

; 131  : 			CharacterIterator(){}

  0038d	8d 45 28	 lea	 eax, DWORD PTR _i$[ebp]
  00390	89 45 98	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 37   :     _Tree_unchecked_const_iterator() noexcept : _Ptr() {}

  00393	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00396	83 20 00	 and	 DWORD PTR [eax], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonCharacterManager.h

; 77   : 		inline CharacterIterator			CharacterInstanceBegin() { return CharacterIterator(m_kAliveInstMap.begin());}

  00399	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0039f	50		 push	 eax
  003a0	8b 4d 00	 mov	 ecx, DWORD PTR _rkChrMgr$[ebp]
  003a3	83 c1 20	 add	 ecx, 32			; 00000020H
  003a6	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@KPAVCInstanceBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCInstanceBase@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCInstanceBase@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CInstanceBase *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CInstanceBase *> >,0> >::begin
  003ab	89 45 94	 mov	 DWORD PTR _it$[ebp], eax

; 132  : 			CharacterIterator(const TCharacterInstanceMap::iterator & it) : m_it(it) {}

  003ae	8b 45 94	 mov	 eax, DWORD PTR _it$[ebp]
  003b1	8b 00		 mov	 eax, DWORD PTR [eax]
  003b3	89 45 90	 mov	 DWORD PTR $T23[ebp], eax

; 151  : 				m_it = rhs.m_it;

  003b6	8b 45 90	 mov	 eax, DWORD PTR $T23[ebp]
  003b9	89 45 28	 mov	 DWORD PTR _i$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1089 : 	for(i = rkChrMgr.CharacterInstanceBegin(); i!=rkChrMgr.CharacterInstanceEnd(); ++i)

  003bc	eb 0e		 jmp	 SHORT $LN92@GetPickedI
$LN2@GetPickedI:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonCharacterManager.h

; 138  : 				++m_it;

  003be	8d 45 28	 lea	 eax, DWORD PTR _i$[ebp]
  003c1	89 45 8c	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 198  :         _Mybase::operator++();

  003c4	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  003c7	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCInstanceBase@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CInstanceBase *> > >,std::_Iterator_base0>::operator++
$LN92@GetPickedI:

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  003cc	8b 45 00	 mov	 eax, DWORD PTR _rkChrMgr$[ebp]
  003cf	83 c0 20	 add	 eax, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  003d2	89 45 88	 mov	 DWORD PTR $T22[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  003d5	8b 45 88	 mov	 eax, DWORD PTR $T22[ebp]
  003d8	89 45 84	 mov	 DWORD PTR __Scary$21[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  003db	8b 45 84	 mov	 eax, DWORD PTR __Scary$21[ebp]
  003de	8b 00		 mov	 eax, DWORD PTR [eax]
  003e0	89 45 80	 mov	 DWORD PTR ___param0$20[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  003e3	8b 45 80	 mov	 eax, DWORD PTR ___param0$20[ebp]
  003e6	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T19[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  003ec	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T19[ebp]
  003f2	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T18[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonCharacterManager.h

; 132  : 			CharacterIterator(const TCharacterInstanceMap::iterator & it) : m_it(it) {}

  003f8	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR $T18[ebp]
  003fe	8b 00		 mov	 eax, DWORD PTR [eax]
  00400	89 85 50 ff ff
	ff		 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 232  :         return this->_Ptr == _Right._Ptr;

  00406	8b 45 28	 mov	 eax, DWORD PTR _i$[ebp]
  00409	3b 85 50 ff ff
	ff		 cmp	 eax, DWORD PTR $T10[ebp]
  0040f	75 09		 jne	 SHORT $LN146@GetPickedI
  00411	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv445[ebp], 1
  00418	eb 04		 jmp	 SHORT $LN147@GetPickedI
$LN146@GetPickedI:
  0041a	83 65 fc 00	 and	 DWORD PTR tv445[ebp], 0
$LN147@GetPickedI:
  0041e	8a 45 fc	 mov	 al, BYTE PTR tv445[ebp]
  00421	88 45 36	 mov	 BYTE PTR $T33[ebp], al

; 236  :         return !(*this == _Right);

  00424	0f b6 45 36	 movzx	 eax, BYTE PTR $T33[ebp]
  00428	85 c0		 test	 eax, eax
  0042a	75 09		 jne	 SHORT $LN141@GetPickedI
  0042c	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv432[ebp], 1
  00433	eb 04		 jmp	 SHORT $LN142@GetPickedI
$LN141@GetPickedI:
  00435	83 65 f8 00	 and	 DWORD PTR tv432[ebp], 0
$LN142@GetPickedI:
  00439	8a 45 f8	 mov	 al, BYTE PTR tv432[ebp]
  0043c	88 45 37	 mov	 BYTE PTR $T34[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1089 : 	for(i = rkChrMgr.CharacterInstanceBegin(); i!=rkChrMgr.CharacterInstanceEnd(); ++i)

  0043f	0f b6 45 37	 movzx	 eax, BYTE PTR $T34[ebp]
  00443	85 c0		 test	 eax, eax
  00445	0f 84 1f 03 00
	00		 je	 $LN3@GetPickedI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 185  :         return this->_Ptr->_Myval;

  0044b	8b 45 28	 mov	 eax, DWORD PTR _i$[ebp]
  0044e	83 c0 10	 add	 eax, 16			; 00000010H
  00451	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T16[ebp], eax

; 273  :         return const_cast<reference>(_Mybase::operator*());

  00457	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T16[ebp]
  0045d	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00463	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR $T15[ebp]
  00469	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  0046f	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR $T14[ebp]
  00475	89 85 64 ff ff
	ff		 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 277  :         return pointer_traits<pointer>::pointer_to(**this);

  0047b	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR $T13[ebp]
  00481	89 85 60 ff ff
	ff		 mov	 DWORD PTR $T12[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonCharacterManager.h

; 134  : 			inline CInstanceBase * operator * () {	return m_it->second; }

  00487	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR $T12[ebp]
  0048d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00490	89 45 30	 mov	 DWORD PTR _pkInstEach$32[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1092 : 		if (pkInstEach->IsInvisibility())

  00493	8b 4d 30	 mov	 ecx, DWORD PTR _pkInstEach$32[ebp]
  00496	e8 00 00 00 00	 call	 ?IsInvisibility@CInstanceBase@@QAEHXZ ; CInstanceBase::IsInvisibility
  0049b	85 c0		 test	 eax, eax
  0049d	74 05		 je	 SHORT $LN9@GetPickedI

; 1093 : 			continue;

  0049f	e9 1a ff ff ff	 jmp	 $LN2@GetPickedI
$LN9@GetPickedI:

; 1094 : 		if (m_fScale < 2.0f && (pkInstEach->IsEnemy() || pkInstEach->IsPC()))

  004a4	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  004a7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  004af	0f 2f 40 10	 comiss	 xmm0, DWORD PTR [eax+16]
  004b3	76 1d		 jbe	 SHORT $LN10@GetPickedI
  004b5	8b 4d 30	 mov	 ecx, DWORD PTR _pkInstEach$32[ebp]
  004b8	e8 00 00 00 00	 call	 ?IsEnemy@CInstanceBase@@QAEHXZ ; CInstanceBase::IsEnemy
  004bd	85 c0		 test	 eax, eax
  004bf	75 0c		 jne	 SHORT $LN11@GetPickedI
  004c1	8b 4d 30	 mov	 ecx, DWORD PTR _pkInstEach$32[ebp]
  004c4	e8 00 00 00 00	 call	 ?IsPC@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPC
  004c9	85 c0		 test	 eax, eax
  004cb	74 05		 je	 SHORT $LN10@GetPickedI
$LN11@GetPickedI:

; 1095 : 			continue;

  004cd	e9 ec fe ff ff	 jmp	 $LN2@GetPickedI
$LN10@GetPickedI:

; 1096 : 		TPixelPosition kInstancePosition;
; 1097 : 		pkInstEach->NEW_GetPixelPosition(&kInstancePosition);

  004d2	8d 45 44	 lea	 eax, DWORD PTR _kInstancePosition$35[ebp]
  004d5	50		 push	 eax
  004d6	8b 4d 30	 mov	 ecx, DWORD PTR _pkInstEach$32[ebp]
  004d9	e8 00 00 00 00	 call	 ?NEW_GetPixelPosition@CInstanceBase@@QAEXPAUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_GetPixelPosition

; 1099 : 		if (fabs(kInstancePosition.x - fRealX) < ((float) CTerrainImpl::CELLSCALE) * 3.0f / m_fScale &&

  004de	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR _kInstancePosition$35[ebp]
  004e3	f3 0f 5c 45 f4	 subss	 xmm0, DWORD PTR _fRealX$[ebp]
  004e8	f3 0f 11 85 5c
	ff ff ff	 movss	 DWORD PTR __Xx$[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  004f0	f3 0f 5a 85 5c
	ff ff ff	 cvtss2sd xmm0, DWORD PTR __Xx$[ebp]
  004f8	51		 push	 ecx
  004f9	51		 push	 ecx
  004fa	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  004ff	e8 00 00 00 00	 call	 _fabs
  00504	59		 pop	 ecx
  00505	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath

; 95   :     return _CSTD fabsf(_Xx);

  00506	d9 9d 58 ff ff
	ff		 fstp	 DWORD PTR $T11[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1099 : 		if (fabs(kInstancePosition.x - fRealX) < ((float) CTerrainImpl::CELLSCALE) * 3.0f / m_fScale &&

  0050c	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  0050f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@44160000
  00517	f3 0f 5e 40 10	 divss	 xmm0, DWORD PTR [eax+16]
  0051c	0f 2f 85 58 ff
	ff ff		 comiss	 xmm0, DWORD PTR $T11[ebp]
  00523	0f 86 3c 02 00
	00		 jbe	 $LN12@GetPickedI
  00529	f3 0f 10 45 48	 movss	 xmm0, DWORD PTR _kInstancePosition$35[ebp+4]
  0052e	f3 0f 5c 45 f0	 subss	 xmm0, DWORD PTR _fRealY$[ebp]
  00533	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR __Xx$[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  0053b	f3 0f 5a 85 54
	ff ff ff	 cvtss2sd xmm0, DWORD PTR __Xx$[ebp]
  00543	51		 push	 ecx
  00544	51		 push	 ecx
  00545	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0054a	e8 00 00 00 00	 call	 _fabs
  0054f	59		 pop	 ecx
  00550	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath

; 95   :     return _CSTD fabsf(_Xx);

  00551	d9 9d 30 ff ff
	ff		 fstp	 DWORD PTR $T2[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1099 : 		if (fabs(kInstancePosition.x - fRealX) < ((float) CTerrainImpl::CELLSCALE) * 3.0f / m_fScale &&

  00557	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  0055a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@44160000
  00562	f3 0f 5e 40 10	 divss	 xmm0, DWORD PTR [eax+16]
  00567	0f 2f 85 30 ff
	ff ff		 comiss	 xmm0, DWORD PTR $T2[ebp]
  0056e	0f 86 f1 01 00
	00		 jbe	 $LN12@GetPickedI

; 1100 : 			fabs(kInstancePosition.y - fRealY) < ((float) CTerrainImpl::CELLSCALE) * 3.0f / m_fScale)
; 1101 : 		{
; 1102 : 			rReturnName = pkInstEach->GetNameString();

  00574	8b 4d 30	 mov	 ecx, DWORD PTR _pkInstEach$32[ebp]
  00577	e8 00 00 00 00	 call	 ?GetNameString@CInstanceBase@@QAEPBDXZ ; CInstanceBase::GetNameString
  0057c	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0057f	ff 75 ec	 push	 DWORD PTR __Ptr$[ebp]
  00582	e8 00 00 00 00	 call	 _strlen
  00587	59		 pop	 ecx
  00588	89 85 4c ff ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  0058e	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  00594	89 85 48 ff ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0059a	ff b5 48 ff ff
	ff		 push	 DWORD PTR $T8[ebp]
  005a0	ff 75 ec	 push	 DWORD PTR __Ptr$[ebp]
  005a3	8b 4d 70	 mov	 ecx, DWORD PTR _rReturnName$[ebp]
  005a6	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1103 : 			*pReturnPosX = kInstancePosition.x;

  005ab	8b 45 74	 mov	 eax, DWORD PTR _pReturnPosX$[ebp]
  005ae	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR _kInstancePosition$35[ebp]
  005b3	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1104 : 			*pReturnPosY = kInstancePosition.y;

  005b7	8b 45 78	 mov	 eax, DWORD PTR _pReturnPosY$[ebp]
  005ba	f3 0f 10 45 48	 movss	 xmm0, DWORD PTR _kInstancePosition$35[ebp+4]
  005bf	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1105 : 			*pdwTextColor = pkInstEach->GetNameColor();

  005c3	8b 4d 30	 mov	 ecx, DWORD PTR _pkInstEach$32[ebp]
  005c6	e8 00 00 00 00	 call	 ?GetNameColor@CInstanceBase@@QAEABUD3DXCOLOR@@XZ ; CInstanceBase::GetNameColor
  005cb	89 45 38	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  005ce	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  005d1	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  005d5	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  005dc	72 09		 jb	 SHORT $LN213@GetPickedI
  005de	c7 45 e4 ff 00
	00 00		 mov	 DWORD PTR tv534[ebp], 255 ; 000000ffH
  005e5	eb 36		 jmp	 SHORT $LN214@GetPickedI
$LN213@GetPickedI:
  005e7	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  005ea	0f 57 c0	 xorps	 xmm0, xmm0
  005ed	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  005f0	72 06		 jb	 SHORT $LN211@GetPickedI
  005f2	83 65 e8 00	 and	 DWORD PTR tv530[ebp], 0
  005f6	eb 1f		 jmp	 SHORT $LN212@GetPickedI
$LN211@GetPickedI:
  005f8	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  005fb	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  005ff	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00607	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0060f	e8 00 00 00 00	 call	 __ftoui3
  00614	89 45 e8	 mov	 DWORD PTR tv530[ebp], eax
$LN212@GetPickedI:
  00617	8b 45 e8	 mov	 eax, DWORD PTR tv530[ebp]
  0061a	89 45 e4	 mov	 DWORD PTR tv534[ebp], eax
$LN214@GetPickedI:
  0061d	8b 45 e4	 mov	 eax, DWORD PTR tv534[ebp]
  00620	89 85 40 ff ff
	ff		 mov	 DWORD PTR _dwR$6[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  00626	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  00629	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0062e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00635	72 09		 jb	 SHORT $LN217@GetPickedI
  00637	c7 45 dc ff 00
	00 00		 mov	 DWORD PTR tv544[ebp], 255 ; 000000ffH
  0063e	eb 38		 jmp	 SHORT $LN218@GetPickedI
$LN217@GetPickedI:
  00640	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  00643	0f 57 c0	 xorps	 xmm0, xmm0
  00646	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  0064a	72 06		 jb	 SHORT $LN215@GetPickedI
  0064c	83 65 e0 00	 and	 DWORD PTR tv518[ebp], 0
  00650	eb 20		 jmp	 SHORT $LN216@GetPickedI
$LN215@GetPickedI:
  00652	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  00655	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0065a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00662	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0066a	e8 00 00 00 00	 call	 __ftoui3
  0066f	89 45 e0	 mov	 DWORD PTR tv518[ebp], eax
$LN216@GetPickedI:
  00672	8b 45 e0	 mov	 eax, DWORD PTR tv518[ebp]
  00675	89 45 dc	 mov	 DWORD PTR tv544[ebp], eax
$LN218@GetPickedI:
  00678	8b 45 dc	 mov	 eax, DWORD PTR tv544[ebp]
  0067b	89 85 44 ff ff
	ff		 mov	 DWORD PTR _dwG$7[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  00681	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  00684	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00689	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00690	72 09		 jb	 SHORT $LN221@GetPickedI
  00692	c7 45 d4 ff 00
	00 00		 mov	 DWORD PTR tv514[ebp], 255 ; 000000ffH
  00699	eb 38		 jmp	 SHORT $LN222@GetPickedI
$LN221@GetPickedI:
  0069b	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  0069e	0f 57 c0	 xorps	 xmm0, xmm0
  006a1	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  006a5	72 06		 jb	 SHORT $LN219@GetPickedI
  006a7	83 65 d8 00	 and	 DWORD PTR tv515[ebp], 0
  006ab	eb 20		 jmp	 SHORT $LN220@GetPickedI
$LN219@GetPickedI:
  006ad	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  006b0	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  006b5	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  006bd	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  006c5	e8 00 00 00 00	 call	 __ftoui3
  006ca	89 45 d8	 mov	 DWORD PTR tv515[ebp], eax
$LN220@GetPickedI:
  006cd	8b 45 d8	 mov	 eax, DWORD PTR tv515[ebp]
  006d0	89 45 d4	 mov	 DWORD PTR tv514[ebp], eax
$LN222@GetPickedI:
  006d3	8b 45 d4	 mov	 eax, DWORD PTR tv514[ebp]
  006d6	89 85 38 ff ff
	ff		 mov	 DWORD PTR _dwB$4[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  006dc	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  006df	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  006e4	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  006eb	72 09		 jb	 SHORT $LN225@GetPickedI
  006ed	c7 45 cc ff 00
	00 00		 mov	 DWORD PTR tv538[ebp], 255 ; 000000ffH
  006f4	eb 38		 jmp	 SHORT $LN226@GetPickedI
$LN225@GetPickedI:
  006f6	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  006f9	0f 57 c0	 xorps	 xmm0, xmm0
  006fc	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  00700	72 06		 jb	 SHORT $LN223@GetPickedI
  00702	83 65 d0 00	 and	 DWORD PTR tv517[ebp], 0
  00706	eb 20		 jmp	 SHORT $LN224@GetPickedI
$LN223@GetPickedI:
  00708	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  0070b	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00710	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00718	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00720	e8 00 00 00 00	 call	 __ftoui3
  00725	89 45 d0	 mov	 DWORD PTR tv517[ebp], eax
$LN224@GetPickedI:
  00728	8b 45 d0	 mov	 eax, DWORD PTR tv517[ebp]
  0072b	89 45 cc	 mov	 DWORD PTR tv538[ebp], eax
$LN226@GetPickedI:
  0072e	8b 45 cc	 mov	 eax, DWORD PTR tv538[ebp]
  00731	89 85 3c ff ff
	ff		 mov	 DWORD PTR _dwA$5[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  00737	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _dwG$7[ebp]
  0073d	c1 e0 08	 shl	 eax, 8
  00740	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _dwR$6[ebp]
  00746	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00749	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _dwA$5[ebp]
  0074f	c1 e2 18	 shl	 edx, 24			; 00000018H
  00752	0b d1		 or	 edx, ecx
  00754	0b d0		 or	 edx, eax
  00756	0b 95 38 ff ff
	ff		 or	 edx, DWORD PTR _dwB$4[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1105 : 			*pdwTextColor = pkInstEach->GetNameColor();

  0075c	8b 45 7c	 mov	 eax, DWORD PTR _pdwTextColor$[ebp]
  0075f	89 10		 mov	 DWORD PTR [eax], edx

; 1106 : 			return true;

  00761	b0 01		 mov	 al, 1
  00763	eb 07		 jmp	 SHORT $LN1@GetPickedI
$LN12@GetPickedI:

; 1107 : 		}
; 1108 : 	}

  00765	e9 54 fc ff ff	 jmp	 $LN2@GetPickedI
$LN3@GetPickedI:

; 1109 : 	return false;

  0076a	32 c0		 xor	 al, al
$LN1@GetPickedI:

; 1110 : }

  0076c	8b 4d 5c	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0076f	33 cd		 xor	 ecx, ebp
  00771	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00776	83 c5 60	 add	 ebp, 96			; 00000060H
  00779	c9		 leave
  0077a	c2 18 00	 ret	 24			; 00000018H
?GetPickedInstanceInfo@CPythonMiniMap@@QAE_NMMAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM1PAK@Z ENDP ; CPythonMiniMap::GetPickedInstanceInfo
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?Hide@CPythonMiniMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Hide@CPythonMiniMap@@QAEXXZ PROC			; CPythonMiniMap::Hide, COMDAT
; _this$ = ecx

; 1418 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1419 : 	m_bShow=false;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 80 71 01 00
	00 00		 mov	 BYTE PTR [eax+369], 0

; 1420 : }

  00011	c9		 leave
  00012	c3		 ret	 0
?Hide@CPythonMiniMap@@QAEXXZ ENDP			; CPythonMiniMap::Hide
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?Show@CPythonMiniMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Show@CPythonMiniMap@@QAEXXZ PROC			; CPythonMiniMap::Show, COMDAT
; _this$ = ecx

; 1413 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1414 : 	m_bShow=true;	

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 80 71 01 00
	00 01		 mov	 BYTE PTR [eax+369], 1

; 1415 : }

  00011	c9		 leave
  00012	c3		 ret	 0
?Show@CPythonMiniMap@@QAEXXZ ENDP			; CPythonMiniMap::Show
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\GrpVertexBuffer.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\Camera.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?Render@CPythonMiniMap@@QAEXMM@Z
_TEXT	SEGMENT
$T1 = -620						; size = 4
$T2 = -616						; size = 4
$T3 = -612						; size = 4
$T4 = -608						; size = 4
$T5 = -604						; size = 4
$T6 = -600						; size = 4
$T7 = -596						; size = 4
$T8 = -592						; size = 4
$T9 = -588						; size = 4
$T10 = -584						; size = 4
$T11 = -580						; size = 4
$T12 = -576						; size = 4
$T13 = -572						; size = 4
_d$14 = -568						; size = 16
$T15 = -552						; size = 4
$T16 = -548						; size = 4
$T17 = -544						; size = 4
$T18 = -540						; size = 4
$T19 = -536						; size = 4
___param0$ = -532					; size = 4
___param0$ = -528					; size = 4
tv1998 = -524						; size = 4
$T20 = -520						; size = 4
$T21 = -516						; size = 4
$T22 = -512						; size = 4
$T23 = -508						; size = 4
___param0$ = -504					; size = 4
$T24 = -500						; size = 4
$T25 = -496						; size = 4
___param0$ = -492					; size = 4
_dwB$26 = -488						; size = 4
_dwA$27 = -484						; size = 4
_dwR$28 = -480						; size = 4
_dwG$29 = -476						; size = 4
$T30 = -472						; size = 4
$T31 = -468						; size = 4
$T32 = -464						; size = 4
___param0$ = -460					; size = 4
$T33 = -456						; size = 4
$T34 = -452						; size = 4
___param0$ = -448					; size = 4
_dwB$35 = -444						; size = 4
_dwA$36 = -440						; size = 4
_dwR$37 = -436						; size = 4
_dwG$38 = -432						; size = 4
$T39 = -428						; size = 4
$T40 = -424						; size = 4
$T41 = -420						; size = 4
___param0$ = -416					; size = 4
$T42 = -412						; size = 4
$T43 = -408						; size = 4
___param0$ = -404					; size = 4
_dwB$44 = -400						; size = 4
_dwA$45 = -396						; size = 4
_dwR$46 = -392						; size = 4
_dwG$47 = -388						; size = 4
tv1761 = -384						; size = 4
tv1760 = -380						; size = 4
__X$ = -376						; size = 4
tv1755 = -372						; size = 4
$T48 = -368						; size = 4
_dwB$49 = -364						; size = 4
_dwA$50 = -360						; size = 4
_dwR$51 = -356						; size = 4
_dwG$52 = -352						; size = 4
$T53 = -348						; size = 4
$T54 = -344						; size = 4
$T55 = -340						; size = 4
___param0$ = -336					; size = 4
$T56 = -332						; size = 4
$T57 = -328						; size = 4
___param0$ = -324					; size = 4
$T58 = -320						; size = 4
$T59 = -316						; size = 4
$T60 = -312						; size = 4
___param0$ = -308					; size = 4
$T61 = -304						; size = 4
$T62 = -300						; size = 4
___param0$ = -296					; size = 4
_dwB$63 = -292						; size = 4
_dwA$64 = -288						; size = 4
_dwR$65 = -284						; size = 4
_dwG$66 = -280						; size = 4
_rkSttMgr$67 = -276					; size = 4
$T68 = -272						; size = 4
$T69 = -268						; size = 4
_rkBG$ = -264						; size = 4
_pkCmrCur$ = -260					; size = 4
tv1539 = -256						; size = 4
tv1553 = -252						; size = 4
__My_data$70 = -248					; size = 4
__My_data$71 = -244					; size = 4
_pkInst$ = -240						; size = 4
_rPosition$72 = -236					; size = 4
tv1445 = -232						; size = 4
tv1459 = -228						; size = 4
__My_data$73 = -224					; size = 4
__My_data$74 = -220					; size = 4
tv1403 = -216						; size = 4
tv1402 = -212						; size = 4
tv1392 = -208						; size = 4
tv1391 = -204						; size = 4
tv1381 = -200						; size = 4
tv1380 = -196						; size = 4
tv1370 = -192						; size = 4
tv1369 = -188						; size = 4
_rPosition$75 = -184					; size = 4
tv1308 = -180						; size = 4
tv1354 = -176						; size = 4
__My_data$76 = -172					; size = 4
__My_data$77 = -168					; size = 4
tv1266 = -164						; size = 4
tv1265 = -160						; size = 4
tv1255 = -156						; size = 4
tv1254 = -152						; size = 4
tv1244 = -148						; size = 4
tv1243 = -144						; size = 4
tv1233 = -140						; size = 4
tv1232 = -136						; size = 4
_rPosition$78 = -132					; size = 4
tv1203 = -128						; size = 4
tv1217 = -124						; size = 4
__My_data$79 = -120					; size = 4
__My_data$80 = -116					; size = 4
tv1161 = -112						; size = 4
tv1160 = -108						; size = 4
tv1150 = -104						; size = 4
tv1149 = -100						; size = 4
tv1139 = -96						; size = 4
tv1138 = -92						; size = 4
tv1128 = -88						; size = 4
tv1127 = -84						; size = 4
tv1102 = -80						; size = 4
__My_data$81 = -76					; size = 4
tv1085 = -72						; size = 4
tv1084 = -68						; size = 4
tv1074 = -64						; size = 4
tv1073 = -60						; size = 4
tv1063 = -56						; size = 4
tv1062 = -52						; size = 4
tv1020 = -48						; size = 4
tv1019 = -44						; size = 4
tv996 = -40						; size = 4
tv1010 = -36						; size = 4
__My_data$82 = -32					; size = 4
__My_data$83 = -28					; size = 4
_rPosition$84 = -24					; size = 4
tv940 = -20						; size = 4
tv954 = -16						; size = 4
__My_data$85 = -12					; size = 4
__My_data$86 = -8					; size = 4
tv898 = -4						; size = 4
tv897 = 0						; size = 4
tv887 = 4						; size = 4
tv886 = 8						; size = 4
tv876 = 12						; size = 4
tv875 = 16						; size = 4
tv865 = 20						; size = 4
tv864 = 24						; size = 4
_pMiniMapTexture$87 = 28				; size = 4
_v$88 = 32						; size = 4
_rPosition$89 = 36					; size = 4
_itor$90 = 40						; size = 4
_c$91 = 44						; size = 16
_rAtlasMarkInfo$92 = 60					; size = 4
_fRotation$93 = 64					; size = 4
$T94 = 71						; size = 1
$T95 = 72						; size = 1
$T96 = 73						; size = 1
$T97 = 74						; size = 1
$T98 = 75						; size = 1
$T99 = 76						; size = 1
$T100 = 77						; size = 1
$T101 = 78						; size = 1
$T102 = 79						; size = 1
$T103 = 80						; size = 1
$T104 = 81						; size = 1
$T105 = 82						; size = 1
$T106 = 83						; size = 1
_this$ = 84						; size = 4
_this$ = 88						; size = 4
_this$ = 92						; size = 4
_this$ = 96						; size = 4
_aIterator$ = 100					; size = 4
_byTerrainNum$107 = 107					; size = 1
_this$ = 108						; size = 4
_fScreenX$ = 120					; size = 4
_fScreenY$ = 124					; size = 4
?Render@CPythonMiniMap@@QAEXMM@Z PROC			; CPythonMiniMap::Render, COMDAT
; _this$ = ecx

; 249  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	81 ec dc 02 00
	00		 sub	 esp, 732		; 000002dcH
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	89 4d 6c	 mov	 DWORD PTR _this$[ebp], ecx

; 250  : 	CPythonBackground& rkBG=CPythonBackground::Instance();

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  00015	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _rkBG$[ebp], eax

; 251  : 	if (!rkBG.IsMapOutdoor())

  0001b	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _rkBG$[ebp]
  00021	e8 00 00 00 00	 call	 ?IsMapOutdoor@CMapManager@@QAE_NXZ ; CMapManager::IsMapOutdoor
  00026	0f b6 c0	 movzx	 eax, al
  00029	85 c0		 test	 eax, eax
  0002b	75 05		 jne	 SHORT $LN22@Render

; 252  : 		return;

  0002d	e9 01 18 00 00	 jmp	 $LN1@Render
$LN22@Render:

; 253  : 
; 254  : 	if (!m_bShow)

  00032	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00035	0f b6 80 71 01
	00 00		 movzx	 eax, BYTE PTR [eax+369]
  0003c	85 c0		 test	 eax, eax
  0003e	75 05		 jne	 SHORT $LN23@Render

; 255  : 		return;

  00040	e9 ee 17 00 00	 jmp	 $LN1@Render
$LN23@Render:

; 256  : 
; 257  : 	if (!rkBG.IsMapReady())

  00045	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _rkBG$[ebp]
  0004b	e8 00 00 00 00	 call	 ?IsMapReady@CMapManager@@QAE_NXZ ; CMapManager::IsMapReady
  00050	0f b6 c0	 movzx	 eax, al
  00053	85 c0		 test	 eax, eax
  00055	75 05		 jne	 SHORT $LN24@Render

; 258  : 		return;

  00057	e9 d7 17 00 00	 jmp	 $LN1@Render
$LN24@Render:

; 259  : 
; 260  : 	if (m_fScreenX != fScreenX || m_fScreenY != fScreenY)

  0005c	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00064	0f 2e 45 78	 ucomiss xmm0, DWORD PTR _fScreenX$[ebp]
  00068	9f		 lahf
  00069	f6 c4 44	 test	 ah, 68			; 00000044H
  0006c	7a 12		 jp	 SHORT $LN26@Render
  0006e	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00071	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [eax+40]
  00076	0f 2e 45 7c	 ucomiss xmm0, DWORD PTR _fScreenY$[ebp]
  0007a	9f		 lahf
  0007b	f6 c4 44	 test	 ah, 68			; 00000044H
  0007e	7b 22		 jnp	 SHORT $LN25@Render
$LN26@Render:

; 261  : 	{
; 262  : 		m_fScreenX = fScreenX;

  00080	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00083	f3 0f 10 45 78	 movss	 xmm0, DWORD PTR _fScreenX$[ebp]
  00088	f3 0f 11 40 24	 movss	 DWORD PTR [eax+36], xmm0

; 263  : 		m_fScreenY = fScreenY;

  0008d	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00090	f3 0f 10 45 7c	 movss	 xmm0, DWORD PTR _fScreenY$[ebp]
  00095	f3 0f 11 40 28	 movss	 DWORD PTR [eax+40], xmm0

; 264  : 		__SetPosition();

  0009a	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	e8 00 00 00 00	 call	 ?__SetPosition@CPythonMiniMap@@IAEXXZ ; CPythonMiniMap::__SetPosition
$LN25@Render:

; 265  : 	}
; 266  : 
; 267  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_MIPFILTER, D3DTEXF_POINT);

  000a2	6a 01		 push	 1
  000a4	6a 12		 push	 18			; 00000012H
  000a6	6a 00		 push	 0
  000a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000ae	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 268  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_POINT);

  000b3	6a 01		 push	 1
  000b5	6a 11		 push	 17			; 00000011H
  000b7	6a 00		 push	 0
  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000bf	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 269  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_POINT);

  000c4	6a 01		 push	 1
  000c6	6a 10		 push	 16			; 00000010H
  000c8	6a 00		 push	 0
  000ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000d0	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 270  : 
; 271  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);

  000d5	6a 03		 push	 3
  000d7	6a 0d		 push	 13			; 0000000dH
  000d9	6a 00		 push	 0
  000db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000e1	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 272  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);

  000e6	6a 03		 push	 3
  000e8	6a 0e		 push	 14			; 0000000eH
  000ea	6a 00		 push	 0
  000ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000f2	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 273  : 
; 274  : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION);

  000f7	68 00 00 02 00	 push	 131072			; 00020000H
  000fc	6a 0b		 push	 11			; 0000000bH
  000fe	6a 01		 push	 1
  00100	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00106	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 275  : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2);

  0010b	6a 02		 push	 2
  0010d	6a 18		 push	 24			; 00000018H
  0010f	6a 01		 push	 1
  00111	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00117	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 276  : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);

  0011c	6a 03		 push	 3
  0011e	6a 0d		 push	 13			; 0000000dH
  00120	6a 01		 push	 1
  00122	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00128	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 277  : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);

  0012d	6a 03		 push	 3
  0012f	6a 0e		 push	 14			; 0000000eH
  00131	6a 01		 push	 1
  00133	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00139	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 278  : 
; 279  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  0013e	6a 02		 push	 2
  00140	6a 02		 push	 2
  00142	6a 00		 push	 0
  00144	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0014a	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 280  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);

  0014f	6a 00		 push	 0
  00151	6a 03		 push	 3
  00153	6a 00		 push	 0
  00155	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0015b	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 281  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);

  00160	6a 02		 push	 2
  00162	6a 01		 push	 1
  00164	6a 00		 push	 0
  00166	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0016c	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 282  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  00171	6a 02		 push	 2
  00173	6a 05		 push	 5
  00175	6a 00		 push	 0
  00177	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0017d	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 283  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);

  00182	6a 00		 push	 0
  00184	6a 06		 push	 6
  00186	6a 00		 push	 0
  00188	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0018e	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 284  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);

  00193	6a 02		 push	 2
  00195	6a 04		 push	 4
  00197	6a 00		 push	 0
  00199	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0019f	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 285  : 
; 286  : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  001a4	6a 02		 push	 2
  001a6	6a 02		 push	 2
  001a8	6a 01		 push	 1
  001aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001b0	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 287  : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_COLORARG2, D3DTA_CURRENT);

  001b5	6a 01		 push	 1
  001b7	6a 03		 push	 3
  001b9	6a 01		 push	 1
  001bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001c1	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 288  : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_COLOROP, D3DTOP_MODULATE);

  001c6	6a 04		 push	 4
  001c8	6a 01		 push	 1
  001ca	6a 01		 push	 1
  001cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001d2	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 289  : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  001d7	6a 02		 push	 2
  001d9	6a 05		 push	 5
  001db	6a 01		 push	 1
  001dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001e3	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 290  : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_ALPHAARG2, D3DTA_CURRENT);

  001e8	6a 01		 push	 1
  001ea	6a 06		 push	 6
  001ec	6a 01		 push	 1
  001ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001f4	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 291  : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);

  001f9	6a 02		 push	 2
  001fb	6a 04		 push	 4
  001fd	6a 01		 push	 1
  001ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00205	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 292  : 
; 293  : 	STATEMANAGER.SaveRenderState(D3DRS_TEXTUREFACTOR, 0xFF000000);

  0020a	68 00 00 00 ff	 push	 -16777216		; ff000000H
  0020f	6a 3c		 push	 60			; 0000003cH
  00211	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00217	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0021c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00221	89 85 c4 fd ff
	ff		 mov	 DWORD PTR $T13[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 295  : 	STATEMANAGER.SetTexture(1, m_MiniMapFilterGraphicImageInstance.GetTexturePointer()->GetD3DTexture());

  00227	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  0022a	83 c1 54	 add	 ecx, 84			; 00000054H
  0022d	e8 00 00 00 00	 call	 ?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTexturePointer
  00232	8b c8		 mov	 ecx, eax
  00234	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  00239	50		 push	 eax
  0023a	6a 01		 push	 1
  0023c	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR $T13[ebp]
  00242	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 296  : 	STATEMANAGER.SetTransform(D3DTS_TEXTURE1, &m_matMiniMapCover);

  00247	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  0024a	05 28 02 00 00	 add	 eax, 552		; 00000228H
  0024f	50		 push	 eax
  00250	6a 11		 push	 17			; 00000011H
  00252	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00258	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 297  : 
; 298  : 	STATEMANAGER.SetVertexShader(D3DFVF_XYZ | D3DFVF_TEX1);

  0025d	68 02 01 00 00	 push	 258			; 00000102H
  00262	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00268	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\GrpVertexBuffer.h

; 33   : 		inline	LPDIRECT3DVERTEXBUFFER8 GetD3DVertexBuffer() const	{ return m_lpd3dVB; }

  0026d	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00270	8b 80 78 01 00
	00		 mov	 eax, DWORD PTR [eax+376]
  00276	89 85 f4 fe ff
	ff		 mov	 DWORD PTR $T69[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 299  : 	STATEMANAGER.SetStreamSource(0, m_VertexBuffer.GetD3DVertexBuffer(), 20);

  0027c	6a 14		 push	 20			; 00000014H
  0027e	ff b5 f4 fe ff
	ff		 push	 DWORD PTR $T69[ebp]
  00284	6a 00		 push	 0
  00286	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0028c	e8 00 00 00 00	 call	 ?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z ; CStateManager::SetStreamSource
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00291	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00296	89 85 f0 fe ff
	ff		 mov	 DWORD PTR $T68[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 300  : 	STATEMANAGER.SetIndices(m_IndexBuffer.GetD3DIndexBuffer(), 0);

  0029c	6a 00		 push	 0
  0029e	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  002a1	81 c1 94 01 00
	00		 add	 ecx, 404		; 00000194H
  002a7	e8 00 00 00 00	 call	 ?GetD3DIndexBuffer@CGraphicIndexBuffer@@QBEPAUIDirect3DIndexBuffer8@@XZ ; CGraphicIndexBuffer::GetD3DIndexBuffer
  002ac	50		 push	 eax
  002ad	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR $T68[ebp]
  002b3	e8 00 00 00 00	 call	 ?SetIndices@CStateManager@@QAEXPAUIDirect3DIndexBuffer8@@I@Z ; CStateManager::SetIndices

; 301  : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &m_matWorld);

  002b8	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  002bb	05 e8 01 00 00	 add	 eax, 488		; 000001e8H
  002c0	50		 push	 eax
  002c1	68 00 01 00 00	 push	 256			; 00000100H
  002c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002cc	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 302  : 
; 303  : 	for (BYTE byTerrainNum = 0; byTerrainNum < AROUND_AREA_NUM; ++byTerrainNum)

  002d1	c6 45 6b 00	 mov	 BYTE PTR _byTerrainNum$107[ebp], 0
  002d5	eb 08		 jmp	 SHORT $LN4@Render
$LN2@Render:
  002d7	8a 45 6b	 mov	 al, BYTE PTR _byTerrainNum$107[ebp]
  002da	04 01		 add	 al, 1
  002dc	88 45 6b	 mov	 BYTE PTR _byTerrainNum$107[ebp], al
$LN4@Render:
  002df	0f b6 45 6b	 movzx	 eax, BYTE PTR _byTerrainNum$107[ebp]
  002e3	83 f8 09	 cmp	 eax, 9
  002e6	0f 8d 9a 00 00
	00		 jge	 $LN3@Render

; 304  : 	{
; 305  : 		LPDIRECT3DTEXTURE8 pMiniMapTexture = m_lpMiniMapTexture[byTerrainNum];

  002ec	0f b6 45 6b	 movzx	 eax, BYTE PTR _byTerrainNum$107[ebp]
  002f0	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  002f3	8b 44 81 30	 mov	 eax, DWORD PTR [ecx+eax*4+48]
  002f7	89 45 1c	 mov	 DWORD PTR _pMiniMapTexture$87[ebp], eax

; 306  : 		STATEMANAGER.SetTexture(0, pMiniMapTexture);

  002fa	ff 75 1c	 push	 DWORD PTR _pMiniMapTexture$87[ebp]
  002fd	6a 00		 push	 0
  002ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00305	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 307  : 		if (pMiniMapTexture)

  0030a	83 7d 1c 00	 cmp	 DWORD PTR _pMiniMapTexture$87[ebp], 0
  0030e	74 2e		 je	 SHORT $LN27@Render

; 308  : 		{
; 309  : 			CStateManager& rkSttMgr=CStateManager::Instance();

  00310	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00315	89 85 ec fe ff
	ff		 mov	 DWORD PTR _rkSttMgr$67[ebp], eax

; 310  : 			rkSttMgr.DrawIndexedPrimitive(D3DPT_TRIANGLELIST, byTerrainNum * 4, 4, byTerrainNum * 6, 2);

  0031b	6a 02		 push	 2
  0031d	0f b6 45 6b	 movzx	 eax, BYTE PTR _byTerrainNum$107[ebp]
  00321	6b c0 06	 imul	 eax, eax, 6
  00324	50		 push	 eax
  00325	6a 04		 push	 4
  00327	0f b6 45 6b	 movzx	 eax, BYTE PTR _byTerrainNum$107[ebp]
  0032b	c1 e0 02	 shl	 eax, 2
  0032e	50		 push	 eax
  0032f	6a 04		 push	 4
  00331	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _rkSttMgr$67[ebp]
  00337	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive

; 311  : 		}

  0033c	eb 43		 jmp	 SHORT $LN28@Render
$LN27@Render:

; 312  : 		else
; 313  : 		{
; 314  : 			STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);

  0033e	6a 03		 push	 3
  00340	6a 02		 push	 2
  00342	6a 00		 push	 0
  00344	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0034a	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 315  : 			STATEMANAGER.DrawIndexedPrimitive(D3DPT_TRIANGLELIST, byTerrainNum * 4, 4, byTerrainNum * 6, 2);

  0034f	6a 02		 push	 2
  00351	0f b6 45 6b	 movzx	 eax, BYTE PTR _byTerrainNum$107[ebp]
  00355	6b c0 06	 imul	 eax, eax, 6
  00358	50		 push	 eax
  00359	6a 04		 push	 4
  0035b	0f b6 45 6b	 movzx	 eax, BYTE PTR _byTerrainNum$107[ebp]
  0035f	c1 e0 02	 shl	 eax, 2
  00362	50		 push	 eax
  00363	6a 04		 push	 4
  00365	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0036b	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive

; 316  : 			STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00370	6a 02		 push	 2
  00372	6a 02		 push	 2
  00374	6a 00		 push	 0
  00376	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0037c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState
$LN28@Render:

; 317  : 		}
; 318  : 	}

  00381	e9 51 ff ff ff	 jmp	 $LN2@Render
$LN3@Render:

; 319  : 
; 320  : 	STATEMANAGER.RestoreRenderState(D3DRS_TEXTUREFACTOR);

  00386	6a 3c		 push	 60			; 0000003cH
  00388	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0038e	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 321  : 
; 322  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_ALPHAARG2);

  00393	6a 06		 push	 6
  00395	6a 01		 push	 1
  00397	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0039d	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 323  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_ALPHAARG1);

  003a2	6a 05		 push	 5
  003a4	6a 01		 push	 1
  003a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003ac	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 324  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_ALPHAOP);

  003b1	6a 04		 push	 4
  003b3	6a 01		 push	 1
  003b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003bb	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 325  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_COLORARG1);

  003c0	6a 02		 push	 2
  003c2	6a 01		 push	 1
  003c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003ca	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 326  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_COLORARG2);

  003cf	6a 03		 push	 3
  003d1	6a 01		 push	 1
  003d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003d9	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 327  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_COLOROP);

  003de	6a 01		 push	 1
  003e0	6a 01		 push	 1
  003e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003e8	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 328  : 
; 329  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_ALPHAARG2);

  003ed	6a 06		 push	 6
  003ef	6a 00		 push	 0
  003f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003f7	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 330  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_ALPHAARG1);

  003fc	6a 05		 push	 5
  003fe	6a 00		 push	 0
  00400	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00406	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 331  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_ALPHAOP);

  0040b	6a 04		 push	 4
  0040d	6a 00		 push	 0
  0040f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00415	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 332  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLORARG1);

  0041a	6a 02		 push	 2
  0041c	6a 00		 push	 0
  0041e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00424	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 333  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLORARG2);

  00429	6a 03		 push	 3
  0042b	6a 00		 push	 0
  0042d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00433	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 334  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLOROP);

  00438	6a 01		 push	 1
  0043a	6a 00		 push	 0
  0043c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00442	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 335  : 
; 336  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_ADDRESSU);

  00447	6a 0d		 push	 13			; 0000000dH
  00449	6a 00		 push	 0
  0044b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00451	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 337  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_ADDRESSV);

  00456	6a 0e		 push	 14			; 0000000eH
  00458	6a 00		 push	 0
  0045a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00460	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 338  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_TEXCOORDINDEX);

  00465	6a 0b		 push	 11			; 0000000bH
  00467	6a 01		 push	 1
  00469	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0046f	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 339  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS);

  00474	6a 18		 push	 24			; 00000018H
  00476	6a 01		 push	 1
  00478	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0047e	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 340  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_ADDRESSU);

  00483	6a 0d		 push	 13			; 0000000dH
  00485	6a 01		 push	 1
  00487	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0048d	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 341  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_ADDRESSV);

  00492	6a 0e		 push	 14			; 0000000eH
  00494	6a 01		 push	 1
  00496	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0049c	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 342  : 
; 343  : 	SetDiffuseOperation();

  004a1	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  004a4	e8 00 00 00 00	 call	 ?SetDiffuseOperation@CScreen@@QAEXXZ ; CScreen::SetDiffuseOperation

; 344  : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &m_matIdentity);

  004a9	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  004ac	05 a8 01 00 00	 add	 eax, 424		; 000001a8H
  004b1	50		 push	 eax
  004b2	68 00 01 00 00	 push	 256			; 00000100H
  004b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004bd	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 345  : 
; 346  : 	STATEMANAGER.SaveRenderState(D3DRS_TEXTUREFACTOR, 0xFFFFFFFF);

  004c2	6a ff		 push	 -1
  004c4	6a 3c		 push	 60			; 0000003cH
  004c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004cc	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 347  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);

  004d1	6a 03		 push	 3
  004d3	6a 02		 push	 2
  004d5	6a 00		 push	 0
  004d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004dd	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 348  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLORARG2, D3DTA_TEXTURE);

  004e2	6a 02		 push	 2
  004e4	6a 03		 push	 3
  004e6	6a 00		 push	 0
  004e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004ee	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 349  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);

  004f3	6a 04		 push	 4
  004f5	6a 01		 push	 1
  004f7	6a 00		 push	 0
  004f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004ff	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 350  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR);

  00504	6a 03		 push	 3
  00506	6a 05		 push	 5
  00508	6a 00		 push	 0
  0050a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00510	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 351  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TEXTURE);

  00515	6a 02		 push	 2
  00517	6a 06		 push	 6
  00519	6a 00		 push	 0
  0051b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00521	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 352  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG2);

  00526	6a 03		 push	 3
  00528	6a 04		 push	 4
  0052a	6a 00		 push	 0
  0052c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00532	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  00537	83 65 64 00	 and	 DWORD PTR _aIterator$[ebp], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 356  : 	if (m_fScale >= 2.0f)

  0053b	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  0053e	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00543	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@40000000
  0054a	0f 82 66 09 00
	00		 jb	 $LN10@Render

; 359  : 		STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_MOB));//m_MarkTypeToColorMap[TYPE_MONSTER]);

  00550	6a 00		 push	 0
  00552	e8 00 00 00 00	 call	 ?GetIndexedNameColor@CInstanceBase@@SAABUD3DXCOLOR@@I@Z ; CInstanceBase::GetIndexedNameColor
  00557	59		 pop	 ecx
  00558	89 45 60	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  0055b	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  0055e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00562	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00569	72 09		 jb	 SHORT $LN171@Render
  0056b	c7 45 14 ff 00
	00 00		 mov	 DWORD PTR tv865[ebp], 255 ; 000000ffH
  00572	eb 36		 jmp	 SHORT $LN172@Render
$LN171@Render:
  00574	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  00577	0f 57 c0	 xorps	 xmm0, xmm0
  0057a	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  0057d	72 06		 jb	 SHORT $LN169@Render
  0057f	83 65 18 00	 and	 DWORD PTR tv864[ebp], 0
  00583	eb 1f		 jmp	 SHORT $LN170@Render
$LN169@Render:
  00585	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  00588	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0058c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00594	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0059c	e8 00 00 00 00	 call	 __ftoui3
  005a1	89 45 18	 mov	 DWORD PTR tv864[ebp], eax
$LN170@Render:
  005a4	8b 45 18	 mov	 eax, DWORD PTR tv864[ebp]
  005a7	89 45 14	 mov	 DWORD PTR tv865[ebp], eax
$LN172@Render:
  005aa	8b 45 14	 mov	 eax, DWORD PTR tv865[ebp]
  005ad	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _dwR$65[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  005b3	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  005b6	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  005bb	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  005c2	72 09		 jb	 SHORT $LN175@Render
  005c4	c7 45 0c ff 00
	00 00		 mov	 DWORD PTR tv876[ebp], 255 ; 000000ffH
  005cb	eb 38		 jmp	 SHORT $LN176@Render
$LN175@Render:
  005cd	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  005d0	0f 57 c0	 xorps	 xmm0, xmm0
  005d3	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  005d7	72 06		 jb	 SHORT $LN173@Render
  005d9	83 65 10 00	 and	 DWORD PTR tv875[ebp], 0
  005dd	eb 20		 jmp	 SHORT $LN174@Render
$LN173@Render:
  005df	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  005e2	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  005e7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  005ef	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  005f7	e8 00 00 00 00	 call	 __ftoui3
  005fc	89 45 10	 mov	 DWORD PTR tv875[ebp], eax
$LN174@Render:
  005ff	8b 45 10	 mov	 eax, DWORD PTR tv875[ebp]
  00602	89 45 0c	 mov	 DWORD PTR tv876[ebp], eax
$LN176@Render:
  00605	8b 45 0c	 mov	 eax, DWORD PTR tv876[ebp]
  00608	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _dwG$66[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  0060e	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  00611	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00616	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0061d	72 09		 jb	 SHORT $LN179@Render
  0061f	c7 45 04 ff 00
	00 00		 mov	 DWORD PTR tv887[ebp], 255 ; 000000ffH
  00626	eb 38		 jmp	 SHORT $LN180@Render
$LN179@Render:
  00628	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  0062b	0f 57 c0	 xorps	 xmm0, xmm0
  0062e	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  00632	72 06		 jb	 SHORT $LN177@Render
  00634	83 65 08 00	 and	 DWORD PTR tv886[ebp], 0
  00638	eb 20		 jmp	 SHORT $LN178@Render
$LN177@Render:
  0063a	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  0063d	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00642	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0064a	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00652	e8 00 00 00 00	 call	 __ftoui3
  00657	89 45 08	 mov	 DWORD PTR tv886[ebp], eax
$LN178@Render:
  0065a	8b 45 08	 mov	 eax, DWORD PTR tv886[ebp]
  0065d	89 45 04	 mov	 DWORD PTR tv887[ebp], eax
$LN180@Render:
  00660	8b 45 04	 mov	 eax, DWORD PTR tv887[ebp]
  00663	89 85 dc fe ff
	ff		 mov	 DWORD PTR _dwB$63[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  00669	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  0066c	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00671	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00678	72 09		 jb	 SHORT $LN183@Render
  0067a	c7 45 fc ff 00
	00 00		 mov	 DWORD PTR tv898[ebp], 255 ; 000000ffH
  00681	eb 38		 jmp	 SHORT $LN184@Render
$LN183@Render:
  00683	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  00686	0f 57 c0	 xorps	 xmm0, xmm0
  00689	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  0068d	72 06		 jb	 SHORT $LN181@Render
  0068f	83 65 00 00	 and	 DWORD PTR tv897[ebp], 0
  00693	eb 20		 jmp	 SHORT $LN182@Render
$LN181@Render:
  00695	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  00698	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0069d	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  006a5	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  006ad	e8 00 00 00 00	 call	 __ftoui3
  006b2	89 45 00	 mov	 DWORD PTR tv897[ebp], eax
$LN182@Render:
  006b5	8b 45 00	 mov	 eax, DWORD PTR tv897[ebp]
  006b8	89 45 fc	 mov	 DWORD PTR tv898[ebp], eax
$LN184@Render:
  006bb	8b 45 fc	 mov	 eax, DWORD PTR tv898[ebp]
  006be	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _dwA$64[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  006c4	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _dwG$66[ebp]
  006ca	c1 e0 08	 shl	 eax, 8
  006cd	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _dwR$65[ebp]
  006d3	c1 e1 10	 shl	 ecx, 16			; 00000010H
  006d6	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _dwA$64[ebp]
  006dc	c1 e2 18	 shl	 edx, 24			; 00000018H
  006df	0b d1		 or	 edx, ecx
  006e1	0b d0		 or	 edx, eax
  006e3	0b 95 dc fe ff
	ff		 or	 edx, DWORD PTR _dwB$63[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 359  : 		STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_MOB));//m_MarkTypeToColorMap[TYPE_MONSTER]);

  006e9	52		 push	 edx
  006ea	6a 3c		 push	 60			; 0000003cH
  006ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  006f2	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  006f7	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  006fa	05 50 01 00 00	 add	 eax, 336		; 00000150H
  006ff	89 45 f8	 mov	 DWORD PTR __My_data$86[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00702	8b 45 f8	 mov	 eax, DWORD PTR __My_data$86[ebp]
  00705	89 85 bc fd ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0070b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$86[ebp]
  0070e	8b 00		 mov	 eax, DWORD PTR [eax]
  00710	89 85 d8 fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00716	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  0071c	89 85 d4 fe ff
	ff		 mov	 DWORD PTR $T62[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00722	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR $T62[ebp]
  00728	89 85 d0 fe ff
	ff		 mov	 DWORD PTR $T61[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 360  : 		aIterator = m_MonsterPositionVector.begin();

  0072e	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR $T61[ebp]
  00734	8b 00		 mov	 eax, DWORD PTR [eax]
  00736	89 45 64	 mov	 DWORD PTR _aIterator$[ebp], eax
$LN5@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00739	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  0073c	05 50 01 00 00	 add	 eax, 336		; 00000150H
  00741	89 45 f4	 mov	 DWORD PTR __My_data$85[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00744	8b 45 f4	 mov	 eax, DWORD PTR __My_data$85[ebp]
  00747	89 85 98 fd ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0074d	8b 45 f4	 mov	 eax, DWORD PTR __My_data$85[ebp]
  00750	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00753	89 85 cc fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00759	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  0075f	89 85 c8 fe ff
	ff		 mov	 DWORD PTR $T60[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00765	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR $T60[ebp]
  0076b	89 85 c4 fe ff
	ff		 mov	 DWORD PTR $T59[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00771	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR $T59[ebp]
  00777	8b 4d 64	 mov	 ecx, DWORD PTR _aIterator$[ebp]
  0077a	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0077c	75 09		 jne	 SHORT $LN224@Render
  0077e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv954[ebp], 1
  00785	eb 04		 jmp	 SHORT $LN225@Render
$LN224@Render:
  00787	83 65 f0 00	 and	 DWORD PTR tv954[ebp], 0
$LN225@Render:
  0078b	8a 45 f0	 mov	 al, BYTE PTR tv954[ebp]
  0078e	88 45 53	 mov	 BYTE PTR $T106[ebp], al

; 153  :         return !(*this == _Right);

  00791	0f b6 45 53	 movzx	 eax, BYTE PTR $T106[ebp]
  00795	85 c0		 test	 eax, eax
  00797	75 09		 jne	 SHORT $LN219@Render
  00799	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv940[ebp], 1
  007a0	eb 04		 jmp	 SHORT $LN220@Render
$LN219@Render:
  007a2	83 65 ec 00	 and	 DWORD PTR tv940[ebp], 0
$LN220@Render:
  007a6	8a 45 ec	 mov	 al, BYTE PTR tv940[ebp]
  007a9	88 45 52	 mov	 BYTE PTR $T105[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 361  : 		while (aIterator != m_MonsterPositionVector.end())

  007ac	0f b6 45 52	 movzx	 eax, BYTE PTR $T105[ebp]
  007b0	85 c0		 test	 eax, eax
  007b2	74 57		 je	 SHORT $LN6@Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  007b4	8b 45 64	 mov	 eax, DWORD PTR _aIterator$[ebp]
  007b7	89 85 c0 fe ff
	ff		 mov	 DWORD PTR $T58[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  007bd	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR $T58[ebp]
  007c3	89 45 e8	 mov	 DWORD PTR _rPosition$84[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 364  : 			m_WhiteMark.SetPosition(rPosition.m_fX, rPosition.m_fY);

  007c6	8b 45 e8	 mov	 eax, DWORD PTR _rPosition$84[ebp]
  007c9	51		 push	 ecx
  007ca	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  007cf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007d4	8b 45 e8	 mov	 eax, DWORD PTR _rPosition$84[ebp]
  007d7	51		 push	 ecx
  007d8	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  007dc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007e1	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  007e4	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  007ea	e8 00 00 00 00	 call	 ?SetPosition@CGraphicImageInstance@@QAEXMM@Z ; CGraphicImageInstance::SetPosition

; 365  : 			m_WhiteMark.Render();

  007ef	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  007f2	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  007f8	e8 00 00 00 00	 call	 ?Render@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  007fd	8b 45 64	 mov	 eax, DWORD PTR _aIterator$[ebp]
  00800	83 c0 0c	 add	 eax, 12			; 0000000cH
  00803	89 45 64	 mov	 DWORD PTR _aIterator$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 367  : 		}

  00806	e9 2e ff ff ff	 jmp	 $LN5@Render
$LN6@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0080b	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  0080e	05 38 01 00 00	 add	 eax, 312		; 00000138H
  00813	89 45 e4	 mov	 DWORD PTR __My_data$83[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00816	8b 45 e4	 mov	 eax, DWORD PTR __My_data$83[ebp]
  00819	89 85 c0 fd ff
	ff		 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0081f	8b 45 e4	 mov	 eax, DWORD PTR __My_data$83[ebp]
  00822	8b 00		 mov	 eax, DWORD PTR [eax]
  00824	89 85 bc fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0082a	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  00830	89 85 b8 fe ff
	ff		 mov	 DWORD PTR $T57[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00836	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR $T57[ebp]
  0083c	89 85 b4 fe ff
	ff		 mov	 DWORD PTR $T56[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 370  : 		aIterator = m_OtherPCPositionVector.begin();

  00842	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR $T56[ebp]
  00848	8b 00		 mov	 eax, DWORD PTR [eax]
  0084a	89 45 64	 mov	 DWORD PTR _aIterator$[ebp], eax
$LN7@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  0084d	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00850	05 38 01 00 00	 add	 eax, 312		; 00000138H
  00855	89 45 e0	 mov	 DWORD PTR __My_data$82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00858	8b 45 e0	 mov	 eax, DWORD PTR __My_data$82[ebp]
  0085b	89 85 94 fd ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00861	8b 45 e0	 mov	 eax, DWORD PTR __My_data$82[ebp]
  00864	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00867	89 85 b0 fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0086d	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  00873	89 85 ac fe ff
	ff		 mov	 DWORD PTR $T55[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00879	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR $T55[ebp]
  0087f	89 85 a8 fe ff
	ff		 mov	 DWORD PTR $T54[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00885	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR $T54[ebp]
  0088b	8b 4d 64	 mov	 ecx, DWORD PTR _aIterator$[ebp]
  0088e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00890	75 09		 jne	 SHORT $LN279@Render
  00892	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv1010[ebp], 1
  00899	eb 04		 jmp	 SHORT $LN280@Render
$LN279@Render:
  0089b	83 65 dc 00	 and	 DWORD PTR tv1010[ebp], 0
$LN280@Render:
  0089f	8a 45 dc	 mov	 al, BYTE PTR tv1010[ebp]
  008a2	88 45 51	 mov	 BYTE PTR $T104[ebp], al

; 153  :         return !(*this == _Right);

  008a5	0f b6 45 51	 movzx	 eax, BYTE PTR $T104[ebp]
  008a9	85 c0		 test	 eax, eax
  008ab	75 09		 jne	 SHORT $LN274@Render
  008ad	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv996[ebp], 1
  008b4	eb 04		 jmp	 SHORT $LN275@Render
$LN274@Render:
  008b6	83 65 d8 00	 and	 DWORD PTR tv996[ebp], 0
$LN275@Render:
  008ba	8a 45 d8	 mov	 al, BYTE PTR tv996[ebp]
  008bd	88 45 50	 mov	 BYTE PTR $T103[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 371  : 		while (aIterator != m_OtherPCPositionVector.end())

  008c0	0f b6 45 50	 movzx	 eax, BYTE PTR $T103[ebp]
  008c4	85 c0		 test	 eax, eax
  008c6	0f 84 02 02 00
	00		 je	 $LN8@Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  008cc	8b 45 64	 mov	 eax, DWORD PTR _aIterator$[ebp]
  008cf	89 85 a4 fe ff
	ff		 mov	 DWORD PTR $T53[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  008d5	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR $T53[ebp]
  008db	89 45 24	 mov	 DWORD PTR _rPosition$89[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 374  : 			STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, CInstanceBase::GetIndexedNameColor(rPosition.m_eNameColor));

  008de	8b 45 24	 mov	 eax, DWORD PTR _rPosition$89[ebp]
  008e1	ff 70 08	 push	 DWORD PTR [eax+8]
  008e4	e8 00 00 00 00	 call	 ?GetIndexedNameColor@CInstanceBase@@SAABUD3DXCOLOR@@I@Z ; CInstanceBase::GetIndexedNameColor
  008e9	59		 pop	 ecx
  008ea	89 45 5c	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  008ed	8b 45 5c	 mov	 eax, DWORD PTR _this$[ebp]
  008f0	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  008f4	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  008fb	72 09		 jb	 SHORT $LN295@Render
  008fd	c7 45 d0 ff 00
	00 00		 mov	 DWORD PTR tv1020[ebp], 255 ; 000000ffH
  00904	eb 36		 jmp	 SHORT $LN296@Render
$LN295@Render:
  00906	8b 45 5c	 mov	 eax, DWORD PTR _this$[ebp]
  00909	0f 57 c0	 xorps	 xmm0, xmm0
  0090c	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  0090f	72 06		 jb	 SHORT $LN293@Render
  00911	83 65 d4 00	 and	 DWORD PTR tv1019[ebp], 0
  00915	eb 1f		 jmp	 SHORT $LN294@Render
$LN293@Render:
  00917	8b 45 5c	 mov	 eax, DWORD PTR _this$[ebp]
  0091a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0091e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00926	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0092e	e8 00 00 00 00	 call	 __ftoui3
  00933	89 45 d4	 mov	 DWORD PTR tv1019[ebp], eax
$LN294@Render:
  00936	8b 45 d4	 mov	 eax, DWORD PTR tv1019[ebp]
  00939	89 45 d0	 mov	 DWORD PTR tv1020[ebp], eax
$LN296@Render:
  0093c	8b 45 d0	 mov	 eax, DWORD PTR tv1020[ebp]
  0093f	89 85 9c fe ff
	ff		 mov	 DWORD PTR _dwR$51[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  00945	8b 45 5c	 mov	 eax, DWORD PTR _this$[ebp]
  00948	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0094d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00954	72 09		 jb	 SHORT $LN299@Render
  00956	c7 45 c8 ff 00
	00 00		 mov	 DWORD PTR tv1063[ebp], 255 ; 000000ffH
  0095d	eb 38		 jmp	 SHORT $LN300@Render
$LN299@Render:
  0095f	8b 45 5c	 mov	 eax, DWORD PTR _this$[ebp]
  00962	0f 57 c0	 xorps	 xmm0, xmm0
  00965	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  00969	72 06		 jb	 SHORT $LN297@Render
  0096b	83 65 cc 00	 and	 DWORD PTR tv1062[ebp], 0
  0096f	eb 20		 jmp	 SHORT $LN298@Render
$LN297@Render:
  00971	8b 45 5c	 mov	 eax, DWORD PTR _this$[ebp]
  00974	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00979	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00981	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00989	e8 00 00 00 00	 call	 __ftoui3
  0098e	89 45 cc	 mov	 DWORD PTR tv1062[ebp], eax
$LN298@Render:
  00991	8b 45 cc	 mov	 eax, DWORD PTR tv1062[ebp]
  00994	89 45 c8	 mov	 DWORD PTR tv1063[ebp], eax
$LN300@Render:
  00997	8b 45 c8	 mov	 eax, DWORD PTR tv1063[ebp]
  0099a	89 85 a0 fe ff
	ff		 mov	 DWORD PTR _dwG$52[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  009a0	8b 45 5c	 mov	 eax, DWORD PTR _this$[ebp]
  009a3	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  009a8	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  009af	72 09		 jb	 SHORT $LN303@Render
  009b1	c7 45 c0 ff 00
	00 00		 mov	 DWORD PTR tv1074[ebp], 255 ; 000000ffH
  009b8	eb 38		 jmp	 SHORT $LN304@Render
$LN303@Render:
  009ba	8b 45 5c	 mov	 eax, DWORD PTR _this$[ebp]
  009bd	0f 57 c0	 xorps	 xmm0, xmm0
  009c0	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  009c4	72 06		 jb	 SHORT $LN301@Render
  009c6	83 65 c4 00	 and	 DWORD PTR tv1073[ebp], 0
  009ca	eb 20		 jmp	 SHORT $LN302@Render
$LN301@Render:
  009cc	8b 45 5c	 mov	 eax, DWORD PTR _this$[ebp]
  009cf	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  009d4	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  009dc	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  009e4	e8 00 00 00 00	 call	 __ftoui3
  009e9	89 45 c4	 mov	 DWORD PTR tv1073[ebp], eax
$LN302@Render:
  009ec	8b 45 c4	 mov	 eax, DWORD PTR tv1073[ebp]
  009ef	89 45 c0	 mov	 DWORD PTR tv1074[ebp], eax
$LN304@Render:
  009f2	8b 45 c0	 mov	 eax, DWORD PTR tv1074[ebp]
  009f5	89 85 94 fe ff
	ff		 mov	 DWORD PTR _dwB$49[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  009fb	8b 45 5c	 mov	 eax, DWORD PTR _this$[ebp]
  009fe	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00a03	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00a0a	72 09		 jb	 SHORT $LN307@Render
  00a0c	c7 45 b8 ff 00
	00 00		 mov	 DWORD PTR tv1085[ebp], 255 ; 000000ffH
  00a13	eb 38		 jmp	 SHORT $LN308@Render
$LN307@Render:
  00a15	8b 45 5c	 mov	 eax, DWORD PTR _this$[ebp]
  00a18	0f 57 c0	 xorps	 xmm0, xmm0
  00a1b	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  00a1f	72 06		 jb	 SHORT $LN305@Render
  00a21	83 65 bc 00	 and	 DWORD PTR tv1084[ebp], 0
  00a25	eb 20		 jmp	 SHORT $LN306@Render
$LN305@Render:
  00a27	8b 45 5c	 mov	 eax, DWORD PTR _this$[ebp]
  00a2a	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00a2f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00a37	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00a3f	e8 00 00 00 00	 call	 __ftoui3
  00a44	89 45 bc	 mov	 DWORD PTR tv1084[ebp], eax
$LN306@Render:
  00a47	8b 45 bc	 mov	 eax, DWORD PTR tv1084[ebp]
  00a4a	89 45 b8	 mov	 DWORD PTR tv1085[ebp], eax
$LN308@Render:
  00a4d	8b 45 b8	 mov	 eax, DWORD PTR tv1085[ebp]
  00a50	89 85 98 fe ff
	ff		 mov	 DWORD PTR _dwA$50[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  00a56	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _dwG$52[ebp]
  00a5c	c1 e0 08	 shl	 eax, 8
  00a5f	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR _dwR$51[ebp]
  00a65	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00a68	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _dwA$50[ebp]
  00a6e	c1 e2 18	 shl	 edx, 24			; 00000018H
  00a71	0b d1		 or	 edx, ecx
  00a73	0b d0		 or	 edx, eax
  00a75	0b 95 94 fe ff
	ff		 or	 edx, DWORD PTR _dwB$49[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 374  : 			STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, CInstanceBase::GetIndexedNameColor(rPosition.m_eNameColor));

  00a7b	52		 push	 edx
  00a7c	6a 3c		 push	 60			; 0000003cH
  00a7e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00a84	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 375  : 			m_WhiteMark.SetPosition(rPosition.m_fX, rPosition.m_fY);

  00a89	8b 45 24	 mov	 eax, DWORD PTR _rPosition$89[ebp]
  00a8c	51		 push	 ecx
  00a8d	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00a92	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a97	8b 45 24	 mov	 eax, DWORD PTR _rPosition$89[ebp]
  00a9a	51		 push	 ecx
  00a9b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00a9f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00aa4	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  00aa7	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00aad	e8 00 00 00 00	 call	 ?SetPosition@CGraphicImageInstance@@QAEXMM@Z ; CGraphicImageInstance::SetPosition

; 376  : 			m_WhiteMark.Render();

  00ab2	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  00ab5	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00abb	e8 00 00 00 00	 call	 ?Render@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00ac0	8b 45 64	 mov	 eax, DWORD PTR _aIterator$[ebp]
  00ac3	83 c0 0c	 add	 eax, 12			; 0000000cH
  00ac6	89 45 64	 mov	 DWORD PTR _aIterator$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 378  : 		}

  00ac9	e9 7f fd ff ff	 jmp	 $LN7@Render
$LN8@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00ace	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00ad1	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00ad6	89 45 b4	 mov	 DWORD PTR __My_data$81[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00ad9	8b 45 b4	 mov	 eax, DWORD PTR __My_data$81[ebp]
  00adc	8b 4d b4	 mov	 ecx, DWORD PTR __My_data$81[ebp]
  00adf	8b 00		 mov	 eax, DWORD PTR [eax]
  00ae1	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00ae4	75 09		 jne	 SHORT $LN319@Render
  00ae6	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv1102[ebp], 1
  00aed	eb 04		 jmp	 SHORT $LN320@Render
$LN319@Render:
  00aef	83 65 b0 00	 and	 DWORD PTR tv1102[ebp], 0
$LN320@Render:
  00af3	8a 45 b0	 mov	 al, BYTE PTR tv1102[ebp]
  00af6	88 45 4f	 mov	 BYTE PTR $T102[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 381  : 		if (!m_PartyPCPositionVector.empty())

  00af9	0f b6 45 4f	 movzx	 eax, BYTE PTR $T102[ebp]
  00afd	85 c0		 test	 eax, eax
  00aff	0f 85 b1 03 00
	00		 jne	 $LN10@Render
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00b05	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  00b0a	89 85 90 fe ff
	ff		 mov	 DWORD PTR $T48[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 383  : 			float v = (1+sinf(CTimer::Instance().GetCurrentSecond()*6))/5+0.6;

  00b10	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR $T48[ebp]
  00b16	e8 00 00 00 00	 call	 ?GetCurrentSecond@CTimer@@QAEMXZ ; CTimer::GetCurrentSecond
  00b1b	d9 9d 8c fe ff
	ff		 fstp	 DWORD PTR tv1755[ebp]
  00b21	f3 0f 10 85 8c
	fe ff ff	 movss	 xmm0, DWORD PTR tv1755[ebp]
  00b29	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40c00000
  00b31	f3 0f 11 85 88
	fe ff ff	 movss	 DWORD PTR __X$[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 750  :             return (float)sin(_X);

  00b39	f3 0f 5a 85 88
	fe ff ff	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00b41	51		 push	 ecx
  00b42	51		 push	 ecx
  00b43	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00b48	e8 00 00 00 00	 call	 _sin
  00b4d	59		 pop	 ecx
  00b4e	59		 pop	 ecx
  00b4f	d9 9d 84 fe ff
	ff		 fstp	 DWORD PTR tv1760[ebp]
  00b55	d9 85 84 fe ff
	ff		 fld	 DWORD PTR tv1760[ebp]
  00b5b	d9 9d 80 fe ff
	ff		 fstp	 DWORD PTR tv1761[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 383  : 			float v = (1+sinf(CTimer::Instance().GetCurrentSecond()*6))/5+0.6;

  00b61	f3 0f 10 85 80
	fe ff ff	 movss	 xmm0, DWORD PTR tv1761[ebp]
  00b69	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00b71	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40a00000
  00b79	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00b7d	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe3333333333333
  00b85	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00b89	f3 0f 11 45 20	 movss	 DWORD PTR _v$88[ebp], xmm0

; 384  : 			D3DXCOLOR c(CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_PARTY));//(m_MarkTypeToColorMap[TYPE_PARTY]);

  00b8e	6a 18		 push	 24			; 00000018H
  00b90	e8 00 00 00 00	 call	 ?GetIndexedNameColor@CInstanceBase@@SAABUD3DXCOLOR@@I@Z ; CInstanceBase::GetIndexedNameColor
  00b95	59		 pop	 ecx
  00b96	8b f0		 mov	 esi, eax
  00b98	8d 7d 2c	 lea	 edi, DWORD PTR _c$91[ebp]
  00b9b	a5		 movsd
  00b9c	a5		 movsd
  00b9d	a5		 movsd
  00b9e	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 920  :     r = fr;

  00b9f	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _v$88[ebp]
  00ba4	f3 0f 11 85 c8
	fd ff ff	 movss	 DWORD PTR _d$14[ebp], xmm0

; 921  :     g = fg;

  00bac	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _v$88[ebp]
  00bb1	f3 0f 11 85 cc
	fd ff ff	 movss	 DWORD PTR _d$14[ebp+4], xmm0

; 922  :     b = fb;

  00bb9	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _v$88[ebp]
  00bbe	f3 0f 11 85 d0
	fd ff ff	 movss	 DWORD PTR _d$14[ebp+8], xmm0

; 923  :     a = fa;

  00bc6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00bce	f3 0f 11 85 d4
	fd ff ff	 movss	 DWORD PTR _d$14[ebp+12], xmm0

; 1734 :     pOut->r = pC1->r * pC2->r;

  00bd6	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _c$91[ebp]
  00bdb	f3 0f 59 85 c8
	fd ff ff	 mulss	 xmm0, DWORD PTR _d$14[ebp]
  00be3	f3 0f 11 45 2c	 movss	 DWORD PTR _c$91[ebp], xmm0

; 1735 :     pOut->g = pC1->g * pC2->g;

  00be8	f3 0f 10 45 30	 movss	 xmm0, DWORD PTR _c$91[ebp+4]
  00bed	f3 0f 59 85 cc
	fd ff ff	 mulss	 xmm0, DWORD PTR _d$14[ebp+4]
  00bf5	f3 0f 11 45 30	 movss	 DWORD PTR _c$91[ebp+4], xmm0

; 1736 :     pOut->b = pC1->b * pC2->b;

  00bfa	f3 0f 10 45 34	 movss	 xmm0, DWORD PTR _c$91[ebp+8]
  00bff	f3 0f 59 85 d0
	fd ff ff	 mulss	 xmm0, DWORD PTR _d$14[ebp+8]
  00c07	f3 0f 11 45 34	 movss	 DWORD PTR _c$91[ebp+8], xmm0

; 1737 :     pOut->a = pC1->a * pC2->a;

  00c0c	f3 0f 10 45 38	 movss	 xmm0, DWORD PTR _c$91[ebp+12]
  00c11	f3 0f 59 85 d4
	fd ff ff	 mulss	 xmm0, DWORD PTR _d$14[ebp+12]
  00c19	f3 0f 11 45 38	 movss	 DWORD PTR _c$91[ebp+12], xmm0

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00c1e	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _c$91[ebp]
  00c23	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00c2a	72 09		 jb	 SHORT $LN334@Render
  00c2c	c7 45 a8 ff 00
	00 00		 mov	 DWORD PTR tv1128[ebp], 255 ; 000000ffH
  00c33	eb 32		 jmp	 SHORT $LN335@Render
$LN334@Render:
  00c35	0f 57 c0	 xorps	 xmm0, xmm0
  00c38	0f 2f 45 2c	 comiss	 xmm0, DWORD PTR _c$91[ebp]
  00c3c	72 06		 jb	 SHORT $LN332@Render
  00c3e	83 65 ac 00	 and	 DWORD PTR tv1127[ebp], 0
  00c42	eb 1d		 jmp	 SHORT $LN333@Render
$LN332@Render:
  00c44	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _c$91[ebp]
  00c49	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00c51	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00c59	e8 00 00 00 00	 call	 __ftoui3
  00c5e	89 45 ac	 mov	 DWORD PTR tv1127[ebp], eax
$LN333@Render:
  00c61	8b 45 ac	 mov	 eax, DWORD PTR tv1127[ebp]
  00c64	89 45 a8	 mov	 DWORD PTR tv1128[ebp], eax
$LN335@Render:
  00c67	8b 45 a8	 mov	 eax, DWORD PTR tv1128[ebp]
  00c6a	89 85 78 fe ff
	ff		 mov	 DWORD PTR _dwR$46[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  00c70	f3 0f 10 45 30	 movss	 xmm0, DWORD PTR _c$91[ebp+4]
  00c75	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00c7c	72 09		 jb	 SHORT $LN338@Render
  00c7e	c7 45 a0 ff 00
	00 00		 mov	 DWORD PTR tv1139[ebp], 255 ; 000000ffH
  00c85	eb 32		 jmp	 SHORT $LN339@Render
$LN338@Render:
  00c87	0f 57 c0	 xorps	 xmm0, xmm0
  00c8a	0f 2f 45 30	 comiss	 xmm0, DWORD PTR _c$91[ebp+4]
  00c8e	72 06		 jb	 SHORT $LN336@Render
  00c90	83 65 a4 00	 and	 DWORD PTR tv1138[ebp], 0
  00c94	eb 1d		 jmp	 SHORT $LN337@Render
$LN336@Render:
  00c96	f3 0f 10 45 30	 movss	 xmm0, DWORD PTR _c$91[ebp+4]
  00c9b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00ca3	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00cab	e8 00 00 00 00	 call	 __ftoui3
  00cb0	89 45 a4	 mov	 DWORD PTR tv1138[ebp], eax
$LN337@Render:
  00cb3	8b 45 a4	 mov	 eax, DWORD PTR tv1138[ebp]
  00cb6	89 45 a0	 mov	 DWORD PTR tv1139[ebp], eax
$LN339@Render:
  00cb9	8b 45 a0	 mov	 eax, DWORD PTR tv1139[ebp]
  00cbc	89 85 7c fe ff
	ff		 mov	 DWORD PTR _dwG$47[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  00cc2	f3 0f 10 45 34	 movss	 xmm0, DWORD PTR _c$91[ebp+8]
  00cc7	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00cce	72 09		 jb	 SHORT $LN342@Render
  00cd0	c7 45 98 ff 00
	00 00		 mov	 DWORD PTR tv1150[ebp], 255 ; 000000ffH
  00cd7	eb 32		 jmp	 SHORT $LN343@Render
$LN342@Render:
  00cd9	0f 57 c0	 xorps	 xmm0, xmm0
  00cdc	0f 2f 45 34	 comiss	 xmm0, DWORD PTR _c$91[ebp+8]
  00ce0	72 06		 jb	 SHORT $LN340@Render
  00ce2	83 65 9c 00	 and	 DWORD PTR tv1149[ebp], 0
  00ce6	eb 1d		 jmp	 SHORT $LN341@Render
$LN340@Render:
  00ce8	f3 0f 10 45 34	 movss	 xmm0, DWORD PTR _c$91[ebp+8]
  00ced	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00cf5	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00cfd	e8 00 00 00 00	 call	 __ftoui3
  00d02	89 45 9c	 mov	 DWORD PTR tv1149[ebp], eax
$LN341@Render:
  00d05	8b 45 9c	 mov	 eax, DWORD PTR tv1149[ebp]
  00d08	89 45 98	 mov	 DWORD PTR tv1150[ebp], eax
$LN343@Render:
  00d0b	8b 45 98	 mov	 eax, DWORD PTR tv1150[ebp]
  00d0e	89 85 70 fe ff
	ff		 mov	 DWORD PTR _dwB$44[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  00d14	f3 0f 10 45 38	 movss	 xmm0, DWORD PTR _c$91[ebp+12]
  00d19	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00d20	72 09		 jb	 SHORT $LN346@Render
  00d22	c7 45 90 ff 00
	00 00		 mov	 DWORD PTR tv1161[ebp], 255 ; 000000ffH
  00d29	eb 32		 jmp	 SHORT $LN347@Render
$LN346@Render:
  00d2b	0f 57 c0	 xorps	 xmm0, xmm0
  00d2e	0f 2f 45 38	 comiss	 xmm0, DWORD PTR _c$91[ebp+12]
  00d32	72 06		 jb	 SHORT $LN344@Render
  00d34	83 65 94 00	 and	 DWORD PTR tv1160[ebp], 0
  00d38	eb 1d		 jmp	 SHORT $LN345@Render
$LN344@Render:
  00d3a	f3 0f 10 45 38	 movss	 xmm0, DWORD PTR _c$91[ebp+12]
  00d3f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00d47	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00d4f	e8 00 00 00 00	 call	 __ftoui3
  00d54	89 45 94	 mov	 DWORD PTR tv1160[ebp], eax
$LN345@Render:
  00d57	8b 45 94	 mov	 eax, DWORD PTR tv1160[ebp]
  00d5a	89 45 90	 mov	 DWORD PTR tv1161[ebp], eax
$LN347@Render:
  00d5d	8b 45 90	 mov	 eax, DWORD PTR tv1161[ebp]
  00d60	89 85 74 fe ff
	ff		 mov	 DWORD PTR _dwA$45[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  00d66	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _dwG$47[ebp]
  00d6c	c1 e0 08	 shl	 eax, 8
  00d6f	8b 8d 78 fe ff
	ff		 mov	 ecx, DWORD PTR _dwR$46[ebp]
  00d75	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00d78	8b 95 74 fe ff
	ff		 mov	 edx, DWORD PTR _dwA$45[ebp]
  00d7e	c1 e2 18	 shl	 edx, 24			; 00000018H
  00d81	0b d1		 or	 edx, ecx
  00d83	0b d0		 or	 edx, eax
  00d85	0b 95 70 fe ff
	ff		 or	 edx, DWORD PTR _dwB$44[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 387  : 			STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, (DWORD)c);

  00d8b	52		 push	 edx
  00d8c	6a 3c		 push	 60			; 0000003cH
  00d8e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00d94	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00d99	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00d9c	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00da1	89 45 8c	 mov	 DWORD PTR __My_data$80[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00da4	8b 45 8c	 mov	 eax, DWORD PTR __My_data$80[ebp]
  00da7	89 85 b8 fd ff
	ff		 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00dad	8b 45 8c	 mov	 eax, DWORD PTR __My_data$80[ebp]
  00db0	8b 00		 mov	 eax, DWORD PTR [eax]
  00db2	89 85 6c fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00db8	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  00dbe	89 85 68 fe ff
	ff		 mov	 DWORD PTR $T43[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00dc4	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR $T43[ebp]
  00dca	89 85 64 fe ff
	ff		 mov	 DWORD PTR $T42[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 388  : 			aIterator = m_PartyPCPositionVector.begin();

  00dd0	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR $T42[ebp]
  00dd6	8b 00		 mov	 eax, DWORD PTR [eax]
  00dd8	89 45 64	 mov	 DWORD PTR _aIterator$[ebp], eax
$LN9@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00ddb	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00dde	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00de3	89 45 88	 mov	 DWORD PTR __My_data$79[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00de6	8b 45 88	 mov	 eax, DWORD PTR __My_data$79[ebp]
  00de9	89 85 b4 fd ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00def	8b 45 88	 mov	 eax, DWORD PTR __My_data$79[ebp]
  00df2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00df5	89 85 60 fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00dfb	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  00e01	89 85 5c fe ff
	ff		 mov	 DWORD PTR $T41[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00e07	8d 85 5c fe ff
	ff		 lea	 eax, DWORD PTR $T41[ebp]
  00e0d	89 85 58 fe ff
	ff		 mov	 DWORD PTR $T40[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00e13	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR $T40[ebp]
  00e19	8b 4d 64	 mov	 ecx, DWORD PTR _aIterator$[ebp]
  00e1c	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00e1e	75 09		 jne	 SHORT $LN387@Render
  00e20	c7 45 84 01 00
	00 00		 mov	 DWORD PTR tv1217[ebp], 1
  00e27	eb 04		 jmp	 SHORT $LN388@Render
$LN387@Render:
  00e29	83 65 84 00	 and	 DWORD PTR tv1217[ebp], 0
$LN388@Render:
  00e2d	8a 45 84	 mov	 al, BYTE PTR tv1217[ebp]
  00e30	88 45 4e	 mov	 BYTE PTR $T101[ebp], al

; 153  :         return !(*this == _Right);

  00e33	0f b6 45 4e	 movzx	 eax, BYTE PTR $T101[ebp]
  00e37	85 c0		 test	 eax, eax
  00e39	75 09		 jne	 SHORT $LN382@Render
  00e3b	c7 45 80 01 00
	00 00		 mov	 DWORD PTR tv1203[ebp], 1
  00e42	eb 04		 jmp	 SHORT $LN383@Render
$LN382@Render:
  00e44	83 65 80 00	 and	 DWORD PTR tv1203[ebp], 0
$LN383@Render:
  00e48	8a 45 80	 mov	 al, BYTE PTR tv1203[ebp]
  00e4b	88 45 4d	 mov	 BYTE PTR $T100[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 389  : 			while (aIterator != m_PartyPCPositionVector.end())

  00e4e	0f b6 45 4d	 movzx	 eax, BYTE PTR $T100[ebp]
  00e52	85 c0		 test	 eax, eax
  00e54	74 60		 je	 SHORT $LN10@Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  00e56	8b 45 64	 mov	 eax, DWORD PTR _aIterator$[ebp]
  00e59	89 85 54 fe ff
	ff		 mov	 DWORD PTR $T39[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  00e5f	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR $T39[ebp]
  00e65	89 85 7c ff ff
	ff		 mov	 DWORD PTR _rPosition$78[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 392  : 				m_WhiteMark.SetPosition(rPosition.m_fX, rPosition.m_fY);

  00e6b	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _rPosition$78[ebp]
  00e71	51		 push	 ecx
  00e72	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00e77	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e7c	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _rPosition$78[ebp]
  00e82	51		 push	 ecx
  00e83	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00e87	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e8c	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  00e8f	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00e95	e8 00 00 00 00	 call	 ?SetPosition@CGraphicImageInstance@@QAEXMM@Z ; CGraphicImageInstance::SetPosition

; 393  : 				m_WhiteMark.Render();

  00e9a	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  00e9d	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00ea3	e8 00 00 00 00	 call	 ?Render@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00ea8	8b 45 64	 mov	 eax, DWORD PTR _aIterator$[ebp]
  00eab	83 c0 0c	 add	 eax, 12			; 0000000cH
  00eae	89 45 64	 mov	 DWORD PTR _aIterator$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 395  : 			}

  00eb1	e9 25 ff ff ff	 jmp	 $LN9@Render
$LN10@Render:

; 400  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_NPC));

  00eb6	6a 01		 push	 1
  00eb8	e8 00 00 00 00	 call	 ?GetIndexedNameColor@CInstanceBase@@SAABUD3DXCOLOR@@I@Z ; CInstanceBase::GetIndexedNameColor
  00ebd	59		 pop	 ecx
  00ebe	89 45 58	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00ec1	8b 45 58	 mov	 eax, DWORD PTR _this$[ebp]
  00ec4	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00ec8	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00ecf	72 0c		 jb	 SHORT $LN409@Render
  00ed1	c7 85 74 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1233[ebp], 255 ; 000000ffH
  00edb	eb 42		 jmp	 SHORT $LN410@Render
$LN409@Render:
  00edd	8b 45 58	 mov	 eax, DWORD PTR _this$[ebp]
  00ee0	0f 57 c0	 xorps	 xmm0, xmm0
  00ee3	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  00ee6	72 09		 jb	 SHORT $LN407@Render
  00ee8	83 a5 78 ff ff
	ff 00		 and	 DWORD PTR tv1232[ebp], 0
  00eef	eb 22		 jmp	 SHORT $LN408@Render
$LN407@Render:
  00ef1	8b 45 58	 mov	 eax, DWORD PTR _this$[ebp]
  00ef4	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00ef8	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00f00	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00f08	e8 00 00 00 00	 call	 __ftoui3
  00f0d	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv1232[ebp], eax
$LN408@Render:
  00f13	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv1232[ebp]
  00f19	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv1233[ebp], eax
$LN410@Render:
  00f1f	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv1233[ebp]
  00f25	89 85 4c fe ff
	ff		 mov	 DWORD PTR _dwR$37[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  00f2b	8b 45 58	 mov	 eax, DWORD PTR _this$[ebp]
  00f2e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00f33	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00f3a	72 0c		 jb	 SHORT $LN413@Render
  00f3c	c7 85 6c ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1244[ebp], 255 ; 000000ffH
  00f46	eb 44		 jmp	 SHORT $LN414@Render
$LN413@Render:
  00f48	8b 45 58	 mov	 eax, DWORD PTR _this$[ebp]
  00f4b	0f 57 c0	 xorps	 xmm0, xmm0
  00f4e	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  00f52	72 09		 jb	 SHORT $LN411@Render
  00f54	83 a5 70 ff ff
	ff 00		 and	 DWORD PTR tv1243[ebp], 0
  00f5b	eb 23		 jmp	 SHORT $LN412@Render
$LN411@Render:
  00f5d	8b 45 58	 mov	 eax, DWORD PTR _this$[ebp]
  00f60	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00f65	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00f6d	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00f75	e8 00 00 00 00	 call	 __ftoui3
  00f7a	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv1243[ebp], eax
$LN412@Render:
  00f80	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv1243[ebp]
  00f86	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv1244[ebp], eax
$LN414@Render:
  00f8c	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv1244[ebp]
  00f92	89 85 50 fe ff
	ff		 mov	 DWORD PTR _dwG$38[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  00f98	8b 45 58	 mov	 eax, DWORD PTR _this$[ebp]
  00f9b	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00fa0	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00fa7	72 0c		 jb	 SHORT $LN417@Render
  00fa9	c7 85 64 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1255[ebp], 255 ; 000000ffH
  00fb3	eb 44		 jmp	 SHORT $LN418@Render
$LN417@Render:
  00fb5	8b 45 58	 mov	 eax, DWORD PTR _this$[ebp]
  00fb8	0f 57 c0	 xorps	 xmm0, xmm0
  00fbb	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  00fbf	72 09		 jb	 SHORT $LN415@Render
  00fc1	83 a5 68 ff ff
	ff 00		 and	 DWORD PTR tv1254[ebp], 0
  00fc8	eb 23		 jmp	 SHORT $LN416@Render
$LN415@Render:
  00fca	8b 45 58	 mov	 eax, DWORD PTR _this$[ebp]
  00fcd	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00fd2	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00fda	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00fe2	e8 00 00 00 00	 call	 __ftoui3
  00fe7	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv1254[ebp], eax
$LN416@Render:
  00fed	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv1254[ebp]
  00ff3	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv1255[ebp], eax
$LN418@Render:
  00ff9	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv1255[ebp]
  00fff	89 85 44 fe ff
	ff		 mov	 DWORD PTR _dwB$35[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  01005	8b 45 58	 mov	 eax, DWORD PTR _this$[ebp]
  01008	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0100d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  01014	72 0c		 jb	 SHORT $LN421@Render
  01016	c7 85 5c ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1266[ebp], 255 ; 000000ffH
  01020	eb 44		 jmp	 SHORT $LN422@Render
$LN421@Render:
  01022	8b 45 58	 mov	 eax, DWORD PTR _this$[ebp]
  01025	0f 57 c0	 xorps	 xmm0, xmm0
  01028	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  0102c	72 09		 jb	 SHORT $LN419@Render
  0102e	83 a5 60 ff ff
	ff 00		 and	 DWORD PTR tv1265[ebp], 0
  01035	eb 23		 jmp	 SHORT $LN420@Render
$LN419@Render:
  01037	8b 45 58	 mov	 eax, DWORD PTR _this$[ebp]
  0103a	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0103f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  01047	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0104f	e8 00 00 00 00	 call	 __ftoui3
  01054	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv1265[ebp], eax
$LN420@Render:
  0105a	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR tv1265[ebp]
  01060	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv1266[ebp], eax
$LN422@Render:
  01066	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR tv1266[ebp]
  0106c	89 85 48 fe ff
	ff		 mov	 DWORD PTR _dwA$36[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  01072	8b 85 50 fe ff
	ff		 mov	 eax, DWORD PTR _dwG$38[ebp]
  01078	c1 e0 08	 shl	 eax, 8
  0107b	8b 8d 4c fe ff
	ff		 mov	 ecx, DWORD PTR _dwR$37[ebp]
  01081	c1 e1 10	 shl	 ecx, 16			; 00000010H
  01084	8b 95 48 fe ff
	ff		 mov	 edx, DWORD PTR _dwA$36[ebp]
  0108a	c1 e2 18	 shl	 edx, 24			; 00000018H
  0108d	0b d1		 or	 edx, ecx
  0108f	0b d0		 or	 edx, eax
  01091	0b 95 44 fe ff
	ff		 or	 edx, DWORD PTR _dwB$35[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 400  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_NPC));

  01097	52		 push	 edx
  01098	6a 3c		 push	 60			; 0000003cH
  0109a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  010a0	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  010a5	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  010a8	05 44 01 00 00	 add	 eax, 324		; 00000144H
  010ad	89 85 58 ff ff
	ff		 mov	 DWORD PTR __My_data$77[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  010b3	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$77[ebp]
  010b9	89 85 b0 fd ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  010bf	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$77[ebp]
  010c5	8b 00		 mov	 eax, DWORD PTR [eax]
  010c7	89 85 40 fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  010cd	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  010d3	89 85 3c fe ff
	ff		 mov	 DWORD PTR $T34[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  010d9	8d 85 3c fe ff
	ff		 lea	 eax, DWORD PTR $T34[ebp]
  010df	89 85 38 fe ff
	ff		 mov	 DWORD PTR $T33[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 401  : 	aIterator = m_NPCPositionVector.begin();

  010e5	8b 85 38 fe ff
	ff		 mov	 eax, DWORD PTR $T33[ebp]
  010eb	8b 00		 mov	 eax, DWORD PTR [eax]
  010ed	89 45 64	 mov	 DWORD PTR _aIterator$[ebp], eax
$LN11@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  010f0	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  010f3	05 44 01 00 00	 add	 eax, 324		; 00000144H
  010f8	89 85 54 ff ff
	ff		 mov	 DWORD PTR __My_data$76[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  010fe	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$76[ebp]
  01104	89 85 ac fd ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0110a	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$76[ebp]
  01110	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  01113	89 85 34 fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  01119	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  0111f	89 85 30 fe ff
	ff		 mov	 DWORD PTR $T32[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  01125	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR $T32[ebp]
  0112b	89 85 2c fe ff
	ff		 mov	 DWORD PTR $T31[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  01131	8b 85 2c fe ff
	ff		 mov	 eax, DWORD PTR $T31[ebp]
  01137	8b 4d 64	 mov	 ecx, DWORD PTR _aIterator$[ebp]
  0113a	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0113c	75 0c		 jne	 SHORT $LN462@Render
  0113e	c7 85 50 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv1354[ebp], 1
  01148	eb 07		 jmp	 SHORT $LN463@Render
$LN462@Render:
  0114a	83 a5 50 ff ff
	ff 00		 and	 DWORD PTR tv1354[ebp], 0
$LN463@Render:
  01151	8a 85 50 ff ff
	ff		 mov	 al, BYTE PTR tv1354[ebp]
  01157	88 45 4c	 mov	 BYTE PTR $T99[ebp], al

; 153  :         return !(*this == _Right);

  0115a	0f b6 45 4c	 movzx	 eax, BYTE PTR $T99[ebp]
  0115e	85 c0		 test	 eax, eax
  01160	75 0c		 jne	 SHORT $LN457@Render
  01162	c7 85 4c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv1308[ebp], 1
  0116c	eb 07		 jmp	 SHORT $LN458@Render
$LN457@Render:
  0116e	83 a5 4c ff ff
	ff 00		 and	 DWORD PTR tv1308[ebp], 0
$LN458@Render:
  01175	8a 85 4c ff ff
	ff		 mov	 al, BYTE PTR tv1308[ebp]
  0117b	88 45 4b	 mov	 BYTE PTR $T98[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 402  : 	while (aIterator != m_NPCPositionVector.end())

  0117e	0f b6 45 4b	 movzx	 eax, BYTE PTR $T98[ebp]
  01182	85 c0		 test	 eax, eax
  01184	74 60		 je	 SHORT $LN12@Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  01186	8b 45 64	 mov	 eax, DWORD PTR _aIterator$[ebp]
  01189	89 85 28 fe ff
	ff		 mov	 DWORD PTR $T30[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  0118f	8b 85 28 fe ff
	ff		 mov	 eax, DWORD PTR $T30[ebp]
  01195	89 85 48 ff ff
	ff		 mov	 DWORD PTR _rPosition$75[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 405  : 		m_WhiteMark.SetPosition(rPosition.m_fX, rPosition.m_fY);

  0119b	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _rPosition$75[ebp]
  011a1	51		 push	 ecx
  011a2	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  011a7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011ac	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _rPosition$75[ebp]
  011b2	51		 push	 ecx
  011b3	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  011b7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011bc	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  011bf	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  011c5	e8 00 00 00 00	 call	 ?SetPosition@CGraphicImageInstance@@QAEXMM@Z ; CGraphicImageInstance::SetPosition

; 406  : 		m_WhiteMark.Render();

  011ca	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  011cd	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  011d3	e8 00 00 00 00	 call	 ?Render@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  011d8	8b 45 64	 mov	 eax, DWORD PTR _aIterator$[ebp]
  011db	83 c0 0c	 add	 eax, 12			; 0000000cH
  011de	89 45 64	 mov	 DWORD PTR _aIterator$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 408  : 	}

  011e1	e9 0a ff ff ff	 jmp	 $LN11@Render
$LN12@Render:

; 411  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_WARP));

  011e6	6a 19		 push	 25			; 00000019H
  011e8	e8 00 00 00 00	 call	 ?GetIndexedNameColor@CInstanceBase@@SAABUD3DXCOLOR@@I@Z ; CInstanceBase::GetIndexedNameColor
  011ed	59		 pop	 ecx
  011ee	89 45 54	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  011f1	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
  011f4	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  011f8	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  011ff	72 0c		 jb	 SHORT $LN484@Render
  01201	c7 85 40 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1370[ebp], 255 ; 000000ffH
  0120b	eb 42		 jmp	 SHORT $LN485@Render
$LN484@Render:
  0120d	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
  01210	0f 57 c0	 xorps	 xmm0, xmm0
  01213	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  01216	72 09		 jb	 SHORT $LN482@Render
  01218	83 a5 44 ff ff
	ff 00		 and	 DWORD PTR tv1369[ebp], 0
  0121f	eb 22		 jmp	 SHORT $LN483@Render
$LN482@Render:
  01221	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
  01224	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  01228	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  01230	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  01238	e8 00 00 00 00	 call	 __ftoui3
  0123d	89 85 44 ff ff
	ff		 mov	 DWORD PTR tv1369[ebp], eax
$LN483@Render:
  01243	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR tv1369[ebp]
  01249	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv1370[ebp], eax
$LN485@Render:
  0124f	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv1370[ebp]
  01255	89 85 20 fe ff
	ff		 mov	 DWORD PTR _dwR$28[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  0125b	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
  0125e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  01263	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0126a	72 0c		 jb	 SHORT $LN488@Render
  0126c	c7 85 38 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1381[ebp], 255 ; 000000ffH
  01276	eb 44		 jmp	 SHORT $LN489@Render
$LN488@Render:
  01278	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
  0127b	0f 57 c0	 xorps	 xmm0, xmm0
  0127e	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  01282	72 09		 jb	 SHORT $LN486@Render
  01284	83 a5 3c ff ff
	ff 00		 and	 DWORD PTR tv1380[ebp], 0
  0128b	eb 23		 jmp	 SHORT $LN487@Render
$LN486@Render:
  0128d	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
  01290	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  01295	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0129d	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  012a5	e8 00 00 00 00	 call	 __ftoui3
  012aa	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv1380[ebp], eax
$LN487@Render:
  012b0	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv1380[ebp]
  012b6	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv1381[ebp], eax
$LN489@Render:
  012bc	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv1381[ebp]
  012c2	89 85 24 fe ff
	ff		 mov	 DWORD PTR _dwG$29[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  012c8	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
  012cb	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  012d0	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  012d7	72 0c		 jb	 SHORT $LN492@Render
  012d9	c7 85 30 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1392[ebp], 255 ; 000000ffH
  012e3	eb 44		 jmp	 SHORT $LN493@Render
$LN492@Render:
  012e5	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
  012e8	0f 57 c0	 xorps	 xmm0, xmm0
  012eb	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  012ef	72 09		 jb	 SHORT $LN490@Render
  012f1	83 a5 34 ff ff
	ff 00		 and	 DWORD PTR tv1391[ebp], 0
  012f8	eb 23		 jmp	 SHORT $LN491@Render
$LN490@Render:
  012fa	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
  012fd	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  01302	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0130a	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  01312	e8 00 00 00 00	 call	 __ftoui3
  01317	89 85 34 ff ff
	ff		 mov	 DWORD PTR tv1391[ebp], eax
$LN491@Render:
  0131d	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR tv1391[ebp]
  01323	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv1392[ebp], eax
$LN493@Render:
  01329	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv1392[ebp]
  0132f	89 85 18 fe ff
	ff		 mov	 DWORD PTR _dwB$26[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  01335	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
  01338	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0133d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  01344	72 0c		 jb	 SHORT $LN496@Render
  01346	c7 85 28 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1403[ebp], 255 ; 000000ffH
  01350	eb 44		 jmp	 SHORT $LN497@Render
$LN496@Render:
  01352	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
  01355	0f 57 c0	 xorps	 xmm0, xmm0
  01358	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  0135c	72 09		 jb	 SHORT $LN494@Render
  0135e	83 a5 2c ff ff
	ff 00		 and	 DWORD PTR tv1402[ebp], 0
  01365	eb 23		 jmp	 SHORT $LN495@Render
$LN494@Render:
  01367	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
  0136a	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0136f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  01377	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0137f	e8 00 00 00 00	 call	 __ftoui3
  01384	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv1402[ebp], eax
$LN495@Render:
  0138a	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR tv1402[ebp]
  01390	89 85 28 ff ff
	ff		 mov	 DWORD PTR tv1403[ebp], eax
$LN497@Render:
  01396	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR tv1403[ebp]
  0139c	89 85 1c fe ff
	ff		 mov	 DWORD PTR _dwA$27[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  013a2	8b 85 24 fe ff
	ff		 mov	 eax, DWORD PTR _dwG$29[ebp]
  013a8	c1 e0 08	 shl	 eax, 8
  013ab	8b 8d 20 fe ff
	ff		 mov	 ecx, DWORD PTR _dwR$28[ebp]
  013b1	c1 e1 10	 shl	 ecx, 16			; 00000010H
  013b4	8b 95 1c fe ff
	ff		 mov	 edx, DWORD PTR _dwA$27[ebp]
  013ba	c1 e2 18	 shl	 edx, 24			; 00000018H
  013bd	0b d1		 or	 edx, ecx
  013bf	0b d0		 or	 edx, eax
  013c1	0b 95 18 fe ff
	ff		 or	 edx, DWORD PTR _dwB$26[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 411  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, CInstanceBase::GetIndexedNameColor(CInstanceBase::NAMECOLOR_WARP));

  013c7	52		 push	 edx
  013c8	6a 3c		 push	 60			; 0000003cH
  013ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  013d0	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  013d5	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  013d8	05 5c 01 00 00	 add	 eax, 348		; 0000015cH
  013dd	89 85 24 ff ff
	ff		 mov	 DWORD PTR __My_data$74[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  013e3	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$74[ebp]
  013e9	89 85 a8 fd ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  013ef	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$74[ebp]
  013f5	8b 00		 mov	 eax, DWORD PTR [eax]
  013f7	89 85 14 fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  013fd	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  01403	89 85 10 fe ff
	ff		 mov	 DWORD PTR $T25[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  01409	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR $T25[ebp]
  0140f	89 85 0c fe ff
	ff		 mov	 DWORD PTR $T24[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 412  : 	aIterator = m_WarpPositionVector.begin();

  01415	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR $T24[ebp]
  0141b	8b 00		 mov	 eax, DWORD PTR [eax]
  0141d	89 45 64	 mov	 DWORD PTR _aIterator$[ebp], eax
$LN13@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  01420	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  01423	05 5c 01 00 00	 add	 eax, 348		; 0000015cH
  01428	89 85 20 ff ff
	ff		 mov	 DWORD PTR __My_data$73[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0142e	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$73[ebp]
  01434	89 85 a4 fd ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0143a	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$73[ebp]
  01440	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  01443	89 85 08 fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  01449	8b 85 08 fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  0144f	89 85 04 fe ff
	ff		 mov	 DWORD PTR $T23[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  01455	8d 85 04 fe ff
	ff		 lea	 eax, DWORD PTR $T23[ebp]
  0145b	89 85 00 fe ff
	ff		 mov	 DWORD PTR $T22[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  01461	8b 85 00 fe ff
	ff		 mov	 eax, DWORD PTR $T22[ebp]
  01467	8b 4d 64	 mov	 ecx, DWORD PTR _aIterator$[ebp]
  0146a	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0146c	75 0c		 jne	 SHORT $LN537@Render
  0146e	c7 85 1c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv1459[ebp], 1
  01478	eb 07		 jmp	 SHORT $LN538@Render
$LN537@Render:
  0147a	83 a5 1c ff ff
	ff 00		 and	 DWORD PTR tv1459[ebp], 0
$LN538@Render:
  01481	8a 85 1c ff ff
	ff		 mov	 al, BYTE PTR tv1459[ebp]
  01487	88 45 4a	 mov	 BYTE PTR $T97[ebp], al

; 153  :         return !(*this == _Right);

  0148a	0f b6 45 4a	 movzx	 eax, BYTE PTR $T97[ebp]
  0148e	85 c0		 test	 eax, eax
  01490	75 0c		 jne	 SHORT $LN532@Render
  01492	c7 85 18 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv1445[ebp], 1
  0149c	eb 07		 jmp	 SHORT $LN533@Render
$LN532@Render:
  0149e	83 a5 18 ff ff
	ff 00		 and	 DWORD PTR tv1445[ebp], 0
$LN533@Render:
  014a5	8a 85 18 ff ff
	ff		 mov	 al, BYTE PTR tv1445[ebp]
  014ab	88 45 49	 mov	 BYTE PTR $T96[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 413  : 	while (aIterator != m_WarpPositionVector.end())

  014ae	0f b6 45 49	 movzx	 eax, BYTE PTR $T96[ebp]
  014b2	85 c0		 test	 eax, eax
  014b4	74 60		 je	 SHORT $LN14@Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  014b6	8b 45 64	 mov	 eax, DWORD PTR _aIterator$[ebp]
  014b9	89 85 fc fd ff
	ff		 mov	 DWORD PTR $T21[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  014bf	8b 85 fc fd ff
	ff		 mov	 eax, DWORD PTR $T21[ebp]
  014c5	89 85 14 ff ff
	ff		 mov	 DWORD PTR _rPosition$72[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 416  : 		m_WhiteMark.SetPosition(rPosition.m_fX, rPosition.m_fY);

  014cb	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _rPosition$72[ebp]
  014d1	51		 push	 ecx
  014d2	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  014d7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  014dc	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _rPosition$72[ebp]
  014e2	51		 push	 ecx
  014e3	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  014e7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  014ec	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  014ef	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  014f5	e8 00 00 00 00	 call	 ?SetPosition@CGraphicImageInstance@@QAEXMM@Z ; CGraphicImageInstance::SetPosition

; 417  : 		m_WhiteMark.Render();

  014fa	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  014fd	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  01503	e8 00 00 00 00	 call	 ?Render@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  01508	8b 45 64	 mov	 eax, DWORD PTR _aIterator$[ebp]
  0150b	83 c0 0c	 add	 eax, 12			; 0000000cH
  0150e	89 45 64	 mov	 DWORD PTR _aIterator$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 419  : 	}

  01511	e9 0a ff ff ff	 jmp	 $LN13@Render
$LN14@Render:

; 420  : 
; 421  : 	STATEMANAGER.RestoreRenderState(D3DRS_TEXTUREFACTOR);

  01516	6a 3c		 push	 60			; 0000003cH
  01518	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0151e	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 422  : 
; 423  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_ALPHAARG2);

  01523	6a 06		 push	 6
  01525	6a 00		 push	 0
  01527	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0152d	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 424  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_ALPHAARG1);

  01532	6a 05		 push	 5
  01534	6a 00		 push	 0
  01536	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0153c	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 425  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_ALPHAOP);

  01541	6a 04		 push	 4
  01543	6a 00		 push	 0
  01545	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0154b	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 426  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLORARG1);

  01550	6a 02		 push	 2
  01552	6a 00		 push	 0
  01554	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0155a	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 427  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLORARG2);

  0155f	6a 03		 push	 3
  01561	6a 00		 push	 0
  01563	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  01569	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 428  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLOROP);

  0156e	6a 01		 push	 1
  01570	6a 00		 push	 0
  01572	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  01578	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 429  : 
; 430  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_MIPFILTER);

  0157d	6a 12		 push	 18			; 00000012H
  0157f	6a 00		 push	 0
  01581	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  01587	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 431  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_MINFILTER);

  0158c	6a 11		 push	 17			; 00000011H
  0158e	6a 00		 push	 0
  01590	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  01596	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 432  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_MAGFILTER);

  0159b	6a 10		 push	 16			; 00000010H
  0159d	6a 00		 push	 0
  0159f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  015a5	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 433  : 
; 434  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_LINEAR);

  015aa	6a 02		 push	 2
  015ac	6a 11		 push	 17			; 00000011H
  015ae	6a 00		 push	 0
  015b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  015b6	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 435  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);

  015bb	6a 02		 push	 2
  015bd	6a 10		 push	 16			; 00000010H
  015bf	6a 00		 push	 0
  015c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  015c7	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  015cc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  015d1	89 85 f8 fd ff
	ff		 mov	 DWORD PTR $T20[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 438  : 	CInstanceBase * pkInst = CPythonCharacterManager::Instance().GetMainInstancePtr();

  015d7	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR $T20[ebp]
  015dd	e8 00 00 00 00	 call	 ?GetMainInstancePtr@CPythonCharacterManager@@QAEPAVCInstanceBase@@XZ ; CPythonCharacterManager::GetMainInstancePtr
  015e2	89 85 10 ff ff
	ff		 mov	 DWORD PTR _pkInst$[ebp], eax

; 439  : 
; 440  : 	if (pkInst)

  015e8	83 bd 10 ff ff
	ff 00		 cmp	 DWORD PTR _pkInst$[ebp], 0
  015ef	0f 84 8c 00 00
	00		 je	 $LN31@Render

; 441  : 	{
; 442  : 		float fRotation;
; 443  : 		fRotation = (540.0f - pkInst->GetRotation());

  015f5	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _pkInst$[ebp]
  015fb	e8 00 00 00 00	 call	 ?GetRotation@CInstanceBase@@QAEMXZ ; CInstanceBase::GetRotation
  01600	d9 9d f4 fd ff
	ff		 fstp	 DWORD PTR tv1998[ebp]
  01606	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@44070000
  0160e	f3 0f 5c 85 f4
	fd ff ff	 subss	 xmm0, DWORD PTR tv1998[ebp]
  01616	f3 0f 11 45 40	 movss	 DWORD PTR _fRotation$93[ebp], xmm0
$LN15@Render:

; 444  : 		while(fRotation > 360.0f)

  0161b	f3 0f 10 45 40	 movss	 xmm0, DWORD PTR _fRotation$93[ebp]
  01620	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@43b40000
  01627	76 14		 jbe	 SHORT $LN16@Render

; 445  : 			fRotation -= 360.0f;

  01629	f3 0f 10 45 40	 movss	 xmm0, DWORD PTR _fRotation$93[ebp]
  0162e	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@43b40000
  01636	f3 0f 11 45 40	 movss	 DWORD PTR _fRotation$93[ebp], xmm0
  0163b	eb de		 jmp	 SHORT $LN15@Render
$LN16@Render:

; 446  : 		while(fRotation < 0.0f)

  0163d	0f 57 c0	 xorps	 xmm0, xmm0
  01640	0f 2f 45 40	 comiss	 xmm0, DWORD PTR _fRotation$93[ebp]
  01644	76 14		 jbe	 SHORT $LN18@Render

; 447  : 			fRotation += 360.0f;

  01646	f3 0f 10 45 40	 movss	 xmm0, DWORD PTR _fRotation$93[ebp]
  0164b	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@43b40000
  01653	f3 0f 11 45 40	 movss	 DWORD PTR _fRotation$93[ebp], xmm0
  01658	eb e3		 jmp	 SHORT $LN16@Render
$LN18@Render:

; 448  : 
; 449  : 		m_PlayerMark.SetRotation(fRotation);

  0165a	51		 push	 ecx
  0165b	f3 0f 10 45 40	 movss	 xmm0, DWORD PTR _fRotation$93[ebp]
  01660	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01665	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  01668	81 c1 c0 00 00
	00		 add	 ecx, 192		; 000000c0H
  0166e	e8 00 00 00 00	 call	 ?SetRotation@CGraphicExpandedImageInstance@@QAEXM@Z ; CGraphicExpandedImageInstance::SetRotation

; 450  : 		m_PlayerMark.Render();

  01673	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  01676	81 c1 c0 00 00
	00		 add	 ecx, 192		; 000000c0H
  0167c	e8 00 00 00 00	 call	 ?Render@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Render
$LN31@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  01681	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  01684	05 10 0c 00 00	 add	 eax, 3088		; 00000c10H
  01689	89 85 0c ff ff
	ff		 mov	 DWORD PTR __My_data$71[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0168f	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR __My_data$71[ebp]
  01695	89 85 a0 fd ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0169b	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR __My_data$71[ebp]
  016a1	8b 00		 mov	 eax, DWORD PTR [eax]
  016a3	89 85 f0 fd ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  016a9	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  016af	89 45 28	 mov	 DWORD PTR _itor$90[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 456  : 		for (; itor != m_AtlasWayPointInfoVector.end(); ++itor)

  016b2	eb 09		 jmp	 SHORT $LN596@Render
$LN19@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  016b4	8b 45 28	 mov	 eax, DWORD PTR _itor$90[ebp]
  016b7	83 c0 3c	 add	 eax, 60			; 0000003cH
  016ba	89 45 28	 mov	 DWORD PTR _itor$90[ebp], eax
$LN596@Render:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  016bd	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  016c0	05 10 0c 00 00	 add	 eax, 3088		; 00000c10H
  016c5	89 85 08 ff ff
	ff		 mov	 DWORD PTR __My_data$70[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  016cb	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$70[ebp]
  016d1	89 85 9c fd ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  016d7	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$70[ebp]
  016dd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  016e0	89 85 ec fd ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  016e6	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  016ec	89 85 e8 fd ff
	ff		 mov	 DWORD PTR $T19[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  016f2	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR $T19[ebp]
  016f8	89 85 e4 fd ff
	ff		 mov	 DWORD PTR $T18[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  016fe	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR $T18[ebp]
  01704	8b 4d 28	 mov	 ecx, DWORD PTR _itor$90[ebp]
  01707	3b 08		 cmp	 ecx, DWORD PTR [eax]
  01709	75 0c		 jne	 SHORT $LN624@Render
  0170b	c7 85 04 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv1553[ebp], 1
  01715	eb 07		 jmp	 SHORT $LN625@Render
$LN624@Render:
  01717	83 a5 04 ff ff
	ff 00		 and	 DWORD PTR tv1553[ebp], 0
$LN625@Render:
  0171e	8a 85 04 ff ff
	ff		 mov	 al, BYTE PTR tv1553[ebp]
  01724	88 45 48	 mov	 BYTE PTR $T95[ebp], al

; 153  :         return !(*this == _Right);

  01727	0f b6 45 48	 movzx	 eax, BYTE PTR $T95[ebp]
  0172b	85 c0		 test	 eax, eax
  0172d	75 0c		 jne	 SHORT $LN619@Render
  0172f	c7 85 00 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv1539[ebp], 1
  01739	eb 07		 jmp	 SHORT $LN620@Render
$LN619@Render:
  0173b	83 a5 00 ff ff
	ff 00		 and	 DWORD PTR tv1539[ebp], 0
$LN620@Render:
  01742	8a 85 00 ff ff
	ff		 mov	 al, BYTE PTR tv1539[ebp]
  01748	88 45 47	 mov	 BYTE PTR $T94[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 456  : 		for (; itor != m_AtlasWayPointInfoVector.end(); ++itor)

  0174b	0f b6 45 47	 movzx	 eax, BYTE PTR $T94[ebp]
  0174f	85 c0		 test	 eax, eax
  01751	74 63		 je	 SHORT $LN20@Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  01753	8b 45 28	 mov	 eax, DWORD PTR _itor$90[ebp]
  01756	89 85 e0 fd ff
	ff		 mov	 DWORD PTR $T17[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  0175c	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR $T17[ebp]
  01762	89 45 3c	 mov	 DWORD PTR _rAtlasMarkInfo$92[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 460  : 			if (TYPE_TARGET != rAtlasMarkInfo.m_byType)

  01765	8b 45 3c	 mov	 eax, DWORD PTR _rAtlasMarkInfo$92[ebp]
  01768	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0176b	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  0176e	74 05		 je	 SHORT $LN32@Render

; 461  : 				continue;

  01770	e9 3f ff ff ff	 jmp	 $LN19@Render
$LN32@Render:

; 462  : 			if (rAtlasMarkInfo.m_fMiniMapX <= 0.0f)

  01775	8b 45 3c	 mov	 eax, DWORD PTR _rAtlasMarkInfo$92[ebp]
  01778	0f 57 c0	 xorps	 xmm0, xmm0
  0177b	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [eax+24]
  0177f	72 05		 jb	 SHORT $LN33@Render

; 463  : 				continue;

  01781	e9 2e ff ff ff	 jmp	 $LN19@Render
$LN33@Render:

; 464  : 			if (rAtlasMarkInfo.m_fMiniMapY <= 0.0f)

  01786	8b 45 3c	 mov	 eax, DWORD PTR _rAtlasMarkInfo$92[ebp]
  01789	0f 57 c0	 xorps	 xmm0, xmm0
  0178c	0f 2f 40 1c	 comiss	 xmm0, DWORD PTR [eax+28]
  01790	72 05		 jb	 SHORT $LN34@Render

; 465  : 				continue;

  01792	e9 1d ff ff ff	 jmp	 $LN19@Render
$LN34@Render:

; 466  : 
; 467  : 			__RenderTargetMark(rAtlasMarkInfo.m_fMiniMapX, rAtlasMarkInfo.m_fMiniMapY);

  01797	8b 45 3c	 mov	 eax, DWORD PTR _rAtlasMarkInfo$92[ebp]
  0179a	f3 0f 2c 40 1c	 cvttss2si eax, DWORD PTR [eax+28]
  0179f	50		 push	 eax
  017a0	8b 45 3c	 mov	 eax, DWORD PTR _rAtlasMarkInfo$92[ebp]
  017a3	f3 0f 2c 40 18	 cvttss2si eax, DWORD PTR [eax+24]
  017a8	50		 push	 eax
  017a9	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  017ac	e8 00 00 00 00	 call	 ?__RenderTargetMark@CPythonMiniMap@@IAEXHH@Z ; CPythonMiniMap::__RenderTargetMark

; 468  : 		}

  017b1	e9 fe fe ff ff	 jmp	 $LN19@Render
$LN20@Render:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  017b6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  017bb	89 85 dc fd ff
	ff		 mov	 DWORD PTR $T16[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 471  : 	CCamera* pkCmrCur=CCameraManager::Instance().GetCurrentCamera();

  017c1	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR $T16[ebp]
  017c7	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera
  017cc	89 85 fc fe ff
	ff		 mov	 DWORD PTR _pkCmrCur$[ebp], eax

; 472  : 
; 473  : 	//  
; 474  : 	if (pkCmrCur)

  017d2	83 bd fc fe ff
	ff 00		 cmp	 DWORD PTR _pkCmrCur$[ebp], 0
  017d9	74 3a		 je	 SHORT $LN35@Render
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\Camera.h

; 185  : 		float GetRoll() const { return m_fRoll; }

  017db	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _pkCmrCur$[ebp]
  017e1	f3 0f 10 80 30
	01 00 00	 movss	 xmm0, DWORD PTR [eax+304]
  017e9	f3 0f 11 85 d8
	fd ff ff	 movss	 DWORD PTR $T15[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 476  : 		m_MiniMapCameraraphicImageInstance.SetRotation(pkCmrCur->GetRoll());

  017f1	51		 push	 ecx
  017f2	f3 0f 10 85 d8
	fd ff ff	 movss	 xmm0, DWORD PTR $T15[ebp]
  017fa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  017ff	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  01802	83 c1 74	 add	 ecx, 116		; 00000074H
  01805	e8 00 00 00 00	 call	 ?SetRotation@CGraphicExpandedImageInstance@@QAEXM@Z ; CGraphicExpandedImageInstance::SetRotation

; 477  : 		m_MiniMapCameraraphicImageInstance.Render();

  0180a	8b 4d 6c	 mov	 ecx, DWORD PTR _this$[ebp]
  0180d	83 c1 74	 add	 ecx, 116		; 00000074H
  01810	e8 00 00 00 00	 call	 ?Render@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Render
$LN35@Render:

; 478  : 	}
; 479  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_MINFILTER);

  01815	6a 11		 push	 17			; 00000011H
  01817	6a 00		 push	 0
  01819	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0181f	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 480  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_MAGFILTER);

  01824	6a 10		 push	 16			; 00000010H
  01826	6a 00		 push	 0
  01828	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0182e	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState
$LN1@Render:

; 481  : }

  01833	5f		 pop	 edi
  01834	5e		 pop	 esi
  01835	83 c5 70	 add	 ebp, 112		; 00000070H
  01838	c9		 leave
  01839	c2 08 00	 ret	 8
?Render@CPythonMiniMap@@QAEXMM@Z ENDP			; CPythonMiniMap::Render
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonCharacterManager.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonCharacterManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonCharacterManager.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonCharacterManager.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonCharacterManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?Update@CPythonMiniMap@@QAEXMM@Z
_TEXT	SEGMENT
_c_fMiniMapWindowRadius$1 = -312			; size = 4
$T2 = -308						; size = 4
$T3 = -304						; size = 4
$T4 = -300						; size = 4
$T5 = -296						; size = 4
tv1235 = -292						; size = 8
tv1224 = -284						; size = 8
tv1358 = -276						; size = 4
$T6 = -272						; size = 4
_it$ = -268						; size = 4
_this$ = -264						; size = 4
_pkInstMain$ = -260					; size = 4
___param0$ = -256					; size = 4
tv1357 = -252						; size = 4
_fRadianY$7 = -248					; size = 4
tv1351 = -244						; size = 4
tv1350 = -240						; size = 4
_fRadianX$8 = -236					; size = 4
__X$ = -232						; size = 4
__X$ = -228						; size = 4
$T9 = -224						; size = 4
$T10 = -220						; size = 4
$T11 = -216						; size = 4
___param0$ = -212					; size = 4
_rkBG$ = -208						; size = 4
_fDistanceFromCenter$12 = -204				; size = 4
$T13 = -200						; size = 4
$T14 = -196						; size = 4
_dwCurTime$15 = -192					; size = 4
$T16 = -188						; size = 4
$T17 = -184						; size = 4
$T18 = -180						; size = 4
$T19 = -176						; size = 4
$T20 = -172						; size = 4
$T21 = -168						; size = 4
$T22 = -164						; size = 4
___param0$ = -160					; size = 4
__Scary$23 = -156					; size = 4
$T24 = -152						; size = 4
$T25 = -148						; size = 4
$T26 = -144						; size = 4
___param0$ = -140					; size = 4
__Scary$27 = -136					; size = 4
$T28 = -132						; size = 4
$T29 = -128						; size = 4
_fDistanceFromCenter$30 = -124				; size = 4
$T31 = -120						; size = 4
$T32 = -116						; size = 4
$T33 = -112						; size = 4
$T34 = -108						; size = 4
$T35 = -104						; size = 4
$T36 = -100						; size = 4
$T37 = -96						; size = 4
$T38 = -92						; size = 4
_it$ = -88						; size = 4
_this$ = -84						; size = 4
_pInstance$39 = -80					; size = 4
tv500 = -76						; size = 4
tv1000 = -72						; size = 4
tv1014 = -68						; size = 4
__My_data$40 = -64					; size = 4
__My_data$41 = -60					; size = 4
tv1232 = -56						; size = 4
tv1221 = -52						; size = 4
tv860 = -48						; size = 4
tv887 = -44						; size = 4
tv759 = -40						; size = 4
tv772 = -36						; size = 4
_fDistanceFromCenter$42 = -32				; size = 4
_rkChrMgr$ = -28					; size = 4
_itor$43 = -24						; size = 4
_i$ = -20						; size = 4
_i$44 = -16						; size = 4
_fDistanceFromCenterX$45 = -12				; size = 4
_fDistanceFromCenterY$46 = -8				; size = 4
_fDistanceFromCenterY$47 = -4				; size = 4
_fDistanceFromCenterX$48 = 0				; size = 4
_fooCellScale$ = 4					; size = 4
_fPos$49 = 8						; size = 4
$T50 = 15						; size = 1
_fDistanceFromCenterY$51 = 16				; size = 4
_fDistanceFromCenterX$52 = 20				; size = 4
$T53 = 27						; size = 1
$T54 = 28						; size = 1
$T55 = 29						; size = 1
$T56 = 30						; size = 1
$T57 = 31						; size = 1
_pkInstEach$58 = 32					; size = 4
_rAtlasMarkInfo$59 = 36					; size = 4
_rkObserver$60 = 40					; size = 4
_this$ = 44						; size = 4
_kPixelPosition$61 = 48					; size = 12
_kInstancePosition$62 = 60				; size = 12
_aMarkPosition$63 = 72					; size = 12
_kInstancePosition$64 = 84				; size = 12
_aMarkPosition$65 = 96					; size = 12
__$ArrayPad$ = 108					; size = 4
_fCenterX$ = 120					; size = 4
_fCenterY$ = 124					; size = 4
?Update@CPythonMiniMap@@QAEXMM@Z PROC			; CPythonMiniMap::Update, COMDAT
; _this$ = ecx

; 89   : {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	81 ec a8 01 00
	00		 sub	 esp, 424		; 000001a8H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 6c	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	89 4d 2c	 mov	 DWORD PTR _this$[ebp], ecx

; 90   : 	CPythonBackground& rkBG=CPythonBackground::Instance();

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  0001d	89 85 30 ff ff
	ff		 mov	 DWORD PTR _rkBG$[ebp], eax

; 91   : 	if (!rkBG.IsMapOutdoor())

  00023	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _rkBG$[ebp]
  00029	e8 00 00 00 00	 call	 ?IsMapOutdoor@CMapManager@@QAE_NXZ ; CMapManager::IsMapOutdoor
  0002e	0f b6 c0	 movzx	 eax, al
  00031	85 c0		 test	 eax, eax
  00033	75 05		 jne	 SHORT $LN11@Update

; 92   : 		return;

  00035	e9 4d 0c 00 00	 jmp	 $LN1@Update
$LN11@Update:

; 93   : 	
; 94   : 	//   
; 95   : 	if (m_fCenterX != fCenterX || m_fCenterY != fCenterY )

  0003a	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00042	0f 2e 45 78	 ucomiss xmm0, DWORD PTR _fCenterX$[ebp]
  00046	9f		 lahf
  00047	f6 c4 44	 test	 ah, 68			; 00000044H
  0004a	7a 12		 jp	 SHORT $LN13@Update
  0004c	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00054	0f 2e 45 7c	 ucomiss xmm0, DWORD PTR _fCenterY$[ebp]
  00058	9f		 lahf
  00059	f6 c4 44	 test	 ah, 68			; 00000044H
  0005c	7b 1e		 jnp	 SHORT $LN12@Update
$LN13@Update:

; 96   : 		SetCenterPosition(fCenterX, fCenterY);

  0005e	51		 push	 ecx
  0005f	f3 0f 10 45 7c	 movss	 xmm0, DWORD PTR _fCenterY$[ebp]
  00064	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00069	51		 push	 ecx
  0006a	f3 0f 10 45 78	 movss	 xmm0, DWORD PTR _fCenterX$[ebp]
  0006f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00074	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ?SetCenterPosition@CPythonMiniMap@@QAEXMM@Z ; CPythonMiniMap::SetCenterPosition
$LN12@Update:

; 97   : 
; 98   : 	//   
; 99   : 	m_OtherPCPositionVector.clear();

  0007c	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	81 c1 38 01 00
	00		 add	 ecx, 312		; 00000138H
  00085	e8 00 00 00 00	 call	 ?clear@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEXXZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::clear

; 100  : 	m_PartyPCPositionVector.clear();

  0008a	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	81 c1 2c 01 00
	00		 add	 ecx, 300		; 0000012cH
  00093	e8 00 00 00 00	 call	 ?clear@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEXXZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::clear

; 101  : 	m_NPCPositionVector.clear();

  00098	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  000a1	e8 00 00 00 00	 call	 ?clear@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEXXZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::clear

; 102  : 	m_MonsterPositionVector.clear();

  000a6	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
  000af	e8 00 00 00 00	 call	 ?clear@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEXXZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::clear

; 103  : 	m_WarpPositionVector.clear();

  000b4	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	81 c1 5c 01 00
	00		 add	 ecx, 348		; 0000015cH
  000bd	e8 00 00 00 00	 call	 ?clear@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEXXZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::clear

; 104  : 
; 105  : 	float fooCellScale = 1.0f / ((float) CTerrainImpl::CELLSCALE);

  000c2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ba3d70a
  000ca	f3 0f 11 45 04	 movss	 DWORD PTR _fooCellScale$[ebp], xmm0

; 106  : 
; 107  : 	CPythonCharacterManager& rkChrMgr=CPythonCharacterManager::Instance();

  000cf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  000d4	89 45 e4	 mov	 DWORD PTR _rkChrMgr$[ebp], eax

; 108  : 
; 109  : 	CInstanceBase* pkInstMain=rkChrMgr.GetMainInstancePtr();

  000d7	8b 4d e4	 mov	 ecx, DWORD PTR _rkChrMgr$[ebp]
  000da	e8 00 00 00 00	 call	 ?GetMainInstancePtr@CPythonCharacterManager@@QAEPAVCInstanceBase@@XZ ; CPythonCharacterManager::GetMainInstancePtr
  000df	89 85 fc fe ff
	ff		 mov	 DWORD PTR _pkInstMain$[ebp], eax

; 110  : 	if (!pkInstMain)

  000e5	83 bd fc fe ff
	ff 00		 cmp	 DWORD PTR _pkInstMain$[ebp], 0
  000ec	75 05		 jne	 SHORT $LN14@Update

; 111  : 		return;

  000ee	e9 94 0b 00 00	 jmp	 $LN1@Update
$LN14@Update:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonCharacterManager.h

; 131  : 			CharacterIterator(){}

  000f3	8d 45 ec	 lea	 eax, DWORD PTR _i$[ebp]
  000f6	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 37   :     _Tree_unchecked_const_iterator() noexcept : _Ptr() {}

  000fc	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00102	83 20 00	 and	 DWORD PTR [eax], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonCharacterManager.h

; 77   : 		inline CharacterIterator			CharacterInstanceBegin() { return CharacterIterator(m_kAliveInstMap.begin());}

  00105	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  0010b	50		 push	 eax
  0010c	8b 4d e4	 mov	 ecx, DWORD PTR _rkChrMgr$[ebp]
  0010f	83 c1 20	 add	 ecx, 32			; 00000020H
  00112	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@KPAVCInstanceBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCInstanceBase@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCInstanceBase@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CInstanceBase *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CInstanceBase *> >,0> >::begin
  00117	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _it$[ebp], eax

; 132  : 			CharacterIterator(const TCharacterInstanceMap::iterator & it) : m_it(it) {}

  0011d	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _it$[ebp]
  00123	8b 00		 mov	 eax, DWORD PTR [eax]
  00125	89 85 f0 fe ff
	ff		 mov	 DWORD PTR $T6[ebp], eax

; 151  : 				m_it = rhs.m_it;

  0012b	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR $T6[ebp]
  00131	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 114  : 	for(i = rkChrMgr.CharacterInstanceBegin(); i!=rkChrMgr.CharacterInstanceEnd(); ++i)

  00134	eb 0e		 jmp	 SHORT $LN146@Update
$LN2@Update:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonCharacterManager.h

; 138  : 				++m_it;

  00136	8d 45 ec	 lea	 eax, DWORD PTR _i$[ebp]
  00139	89 45 ac	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 198  :         _Mybase::operator++();

  0013c	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0013f	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCInstanceBase@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CInstanceBase *> > >,std::_Iterator_base0>::operator++
$LN146@Update:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonCharacterManager.h

; 78   : 		inline CharacterIterator			CharacterInstanceEnd() { return CharacterIterator(m_kAliveInstMap.end());}

  00144	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  0014a	50		 push	 eax
  0014b	8b 4d e4	 mov	 ecx, DWORD PTR _rkChrMgr$[ebp]
  0014e	83 c1 20	 add	 ecx, 32			; 00000020H
  00151	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@KPAVCInstanceBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCInstanceBase@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCInstanceBase@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CInstanceBase *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CInstanceBase *> >,0> >::end
  00156	89 45 a8	 mov	 DWORD PTR _it$[ebp], eax

; 132  : 			CharacterIterator(const TCharacterInstanceMap::iterator & it) : m_it(it) {}

  00159	8b 45 a8	 mov	 eax, DWORD PTR _it$[ebp]
  0015c	8b 00		 mov	 eax, DWORD PTR [eax]
  0015e	89 45 a4	 mov	 DWORD PTR $T38[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 232  :         return this->_Ptr == _Right._Ptr;

  00161	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00164	3b 45 a4	 cmp	 eax, DWORD PTR $T38[ebp]
  00167	75 09		 jne	 SHORT $LN182@Update
  00169	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv772[ebp], 1
  00170	eb 04		 jmp	 SHORT $LN183@Update
$LN182@Update:
  00172	83 65 dc 00	 and	 DWORD PTR tv772[ebp], 0
$LN183@Update:
  00176	8a 45 dc	 mov	 al, BYTE PTR tv772[ebp]
  00179	88 45 0f	 mov	 BYTE PTR $T50[ebp], al

; 236  :         return !(*this == _Right);

  0017c	0f b6 45 0f	 movzx	 eax, BYTE PTR $T50[ebp]
  00180	85 c0		 test	 eax, eax
  00182	75 09		 jne	 SHORT $LN177@Update
  00184	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv759[ebp], 1
  0018b	eb 04		 jmp	 SHORT $LN178@Update
$LN177@Update:
  0018d	83 65 d8 00	 and	 DWORD PTR tv759[ebp], 0
$LN178@Update:
  00191	8a 45 d8	 mov	 al, BYTE PTR tv759[ebp]
  00194	88 45 1f	 mov	 BYTE PTR $T57[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 114  : 	for(i = rkChrMgr.CharacterInstanceBegin(); i!=rkChrMgr.CharacterInstanceEnd(); ++i)

  00197	0f b6 45 1f	 movzx	 eax, BYTE PTR $T57[ebp]
  0019b	85 c0		 test	 eax, eax
  0019d	0f 84 ac 03 00
	00		 je	 $LN3@Update
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 185  :         return this->_Ptr->_Myval;

  001a3	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  001a6	83 c0 10	 add	 eax, 16			; 00000010H
  001a9	89 45 a0	 mov	 DWORD PTR $T37[ebp], eax

; 273  :         return const_cast<reference>(_Mybase::operator*());

  001ac	8b 45 a0	 mov	 eax, DWORD PTR $T37[ebp]
  001af	89 45 9c	 mov	 DWORD PTR $T36[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  001b2	8b 45 9c	 mov	 eax, DWORD PTR $T36[ebp]
  001b5	89 45 98	 mov	 DWORD PTR $T35[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  001b8	8b 45 98	 mov	 eax, DWORD PTR $T35[ebp]
  001bb	89 45 94	 mov	 DWORD PTR $T34[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 277  :         return pointer_traits<pointer>::pointer_to(**this);

  001be	8b 45 94	 mov	 eax, DWORD PTR $T34[ebp]
  001c1	89 45 90	 mov	 DWORD PTR $T33[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonCharacterManager.h

; 134  : 			inline CInstanceBase * operator * () {	return m_it->second; }

  001c4	8b 45 90	 mov	 eax, DWORD PTR $T33[ebp]
  001c7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001ca	89 45 20	 mov	 DWORD PTR _pkInstEach$58[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 119  : 		pkInstEach->NEW_GetPixelPosition(&kInstancePosition);

  001cd	8d 45 3c	 lea	 eax, DWORD PTR _kInstancePosition$62[ebp]
  001d0	50		 push	 eax
  001d1	8b 4d 20	 mov	 ecx, DWORD PTR _pkInstEach$58[ebp]
  001d4	e8 00 00 00 00	 call	 ?NEW_GetPixelPosition@CInstanceBase@@QAEXPAUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_GetPixelPosition

; 120  : 		float fDistanceFromCenterX = (kInstancePosition.x - m_fCenterX) * fooCellScale * m_fScale;

  001d9	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  001dc	f3 0f 10 45 3c	 movss	 xmm0, DWORD PTR _kInstancePosition$62[ebp]
  001e1	f3 0f 5c 40 14	 subss	 xmm0, DWORD PTR [eax+20]
  001e6	f3 0f 59 45 04	 mulss	 xmm0, DWORD PTR _fooCellScale$[ebp]
  001eb	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  001ee	f3 0f 59 40 10	 mulss	 xmm0, DWORD PTR [eax+16]
  001f3	f3 0f 11 45 14	 movss	 DWORD PTR _fDistanceFromCenterX$52[ebp], xmm0

; 121  : 		float fDistanceFromCenterY = (kInstancePosition.y - m_fCenterY) * fooCellScale * m_fScale;

  001f8	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  001fb	f3 0f 10 45 40	 movss	 xmm0, DWORD PTR _kInstancePosition$62[ebp+4]
  00200	f3 0f 5c 40 18	 subss	 xmm0, DWORD PTR [eax+24]
  00205	f3 0f 59 45 04	 mulss	 xmm0, DWORD PTR _fooCellScale$[ebp]
  0020a	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  0020d	f3 0f 59 40 10	 mulss	 xmm0, DWORD PTR [eax+16]
  00212	f3 0f 11 45 10	 movss	 DWORD PTR _fDistanceFromCenterY$51[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  00217	f3 0f 5a 45 14	 cvtss2sd xmm0, DWORD PTR _fDistanceFromCenterX$52[ebp]
  0021c	51		 push	 ecx
  0021d	51		 push	 ecx
  0021e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00223	e8 00 00 00 00	 call	 _fabs
  00228	59		 pop	 ecx
  00229	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath

; 95   :     return _CSTD fabsf(_Xx);

  0022a	d9 5d 8c	 fstp	 DWORD PTR $T32[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 122  : 		if (fabs(fDistanceFromCenterX) >= m_fMiniMapRadius || fabs(fDistanceFromCenterY) >= m_fMiniMapRadius)

  0022d	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00230	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR $T32[ebp]
  00235	0f 2f 40 2c	 comiss	 xmm0, DWORD PTR [eax+44]
  00239	73 24		 jae	 SHORT $LN16@Update
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  0023b	f3 0f 5a 45 10	 cvtss2sd xmm0, DWORD PTR _fDistanceFromCenterY$51[ebp]
  00240	51		 push	 ecx
  00241	51		 push	 ecx
  00242	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00247	e8 00 00 00 00	 call	 _fabs
  0024c	59		 pop	 ecx
  0024d	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath

; 95   :     return _CSTD fabsf(_Xx);

  0024e	d9 5d 88	 fstp	 DWORD PTR $T31[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 122  : 		if (fabs(fDistanceFromCenterX) >= m_fMiniMapRadius || fabs(fDistanceFromCenterY) >= m_fMiniMapRadius)

  00251	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00254	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR $T31[ebp]
  00259	0f 2f 40 2c	 comiss	 xmm0, DWORD PTR [eax+44]
  0025d	72 05		 jb	 SHORT $LN15@Update
$LN16@Update:

; 123  : 			continue;

  0025f	e9 d2 fe ff ff	 jmp	 $LN2@Update
$LN15@Update:

; 125  : 		float fDistanceFromCenter = sqrtf(fDistanceFromCenterX * fDistanceFromCenterX + fDistanceFromCenterY * fDistanceFromCenterY );

  00264	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fDistanceFromCenterY$51[ebp]
  00269	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _fDistanceFromCenterY$51[ebp]
  0026e	f3 0f 10 4d 14	 movss	 xmm1, DWORD PTR _fDistanceFromCenterX$52[ebp]
  00273	f3 0f 59 4d 14	 mulss	 xmm1, DWORD PTR _fDistanceFromCenterX$52[ebp]
  00278	f3 0f 58 c8	 addss	 xmm1, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  0027c	f3 0f 5a c1	 cvtss2sd xmm0, xmm1
  00280	51		 push	 ecx
  00281	51		 push	 ecx
  00282	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00287	e8 00 00 00 00	 call	 _sqrt
  0028c	59		 pop	 ecx
  0028d	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 125  : 		float fDistanceFromCenter = sqrtf(fDistanceFromCenterX * fDistanceFromCenterX + fDistanceFromCenterY * fDistanceFromCenterY );

  0028e	d9 5d 84	 fstp	 DWORD PTR _fDistanceFromCenter$30[ebp]

; 126  : 		if ( fDistanceFromCenter >= m_fMiniMapRadius )

  00291	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00294	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _fDistanceFromCenter$30[ebp]
  00299	0f 2f 40 2c	 comiss	 xmm0, DWORD PTR [eax+44]
  0029d	72 05		 jb	 SHORT $LN17@Update

; 127  : 			continue;

  0029f	e9 92 fe ff ff	 jmp	 $LN2@Update
$LN17@Update:

; 128  : 
; 129  : 		TMarkPosition aMarkPosition;
; 130  : 
; 131  : 		if (pkInstEach->IsPC() && !pkInstEach->IsInvisibility())

  002a4	8b 4d 20	 mov	 ecx, DWORD PTR _pkInstEach$58[ebp]
  002a7	e8 00 00 00 00	 call	 ?IsPC@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPC
  002ac	85 c0		 test	 eax, eax
  002ae	0f 84 d6 00 00
	00		 je	 $LN18@Update
  002b4	8b 4d 20	 mov	 ecx, DWORD PTR _pkInstEach$58[ebp]
  002b7	e8 00 00 00 00	 call	 ?IsInvisibility@CInstanceBase@@QAEHXZ ; CInstanceBase::IsInvisibility
  002bc	85 c0		 test	 eax, eax
  002be	0f 85 c6 00 00
	00		 jne	 $LN18@Update
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  002c4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  002c9	89 45 80	 mov	 DWORD PTR $T29[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 133  : 			if (pkInstEach == CPythonCharacterManager::Instance().GetMainInstancePtr())

  002cc	8b 4d 80	 mov	 ecx, DWORD PTR $T29[ebp]
  002cf	e8 00 00 00 00	 call	 ?GetMainInstancePtr@CPythonCharacterManager@@QAEPAVCInstanceBase@@XZ ; CPythonCharacterManager::GetMainInstancePtr
  002d4	39 45 20	 cmp	 DWORD PTR _pkInstEach$58[ebp], eax
  002d7	75 05		 jne	 SHORT $LN20@Update

; 134  : 				continue;

  002d9	e9 58 fe ff ff	 jmp	 $LN2@Update
$LN20@Update:

; 135  : 
; 136  : 			aMarkPosition.m_fX = ( m_fWidth - (float)m_WhiteMark.GetWidth() ) / 2.0f + fDistanceFromCenterX + m_fScreenX;

  002de	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  002e1	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  002e7	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  002ec	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  002f0	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  002f3	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  002f8	f3 0f 5c c8	 subss	 xmm1, xmm0
  002fc	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  00304	f3 0f 58 4d 14	 addss	 xmm1, DWORD PTR _fDistanceFromCenterX$52[ebp]
  00309	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  0030c	f3 0f 58 48 24	 addss	 xmm1, DWORD PTR [eax+36]
  00311	f3 0f 11 4d 60	 movss	 DWORD PTR _aMarkPosition$65[ebp], xmm1

; 137  : 			aMarkPosition.m_fY = ( m_fHeight - (float)m_WhiteMark.GetHeight() ) / 2.0f + fDistanceFromCenterY + m_fScreenY;

  00316	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  00319	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  0031f	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  00324	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00328	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  0032b	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [eax+12]
  00330	f3 0f 5c c8	 subss	 xmm1, xmm0
  00334	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  0033c	f3 0f 58 4d 10	 addss	 xmm1, DWORD PTR _fDistanceFromCenterY$51[ebp]
  00341	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00344	f3 0f 58 48 28	 addss	 xmm1, DWORD PTR [eax+40]
  00349	f3 0f 11 4d 64	 movss	 DWORD PTR _aMarkPosition$65[ebp+4], xmm1

; 138  : 			aMarkPosition.m_eNameColor=pkInstEach->GetNameColorIndex();

  0034e	8b 4d 20	 mov	 ecx, DWORD PTR _pkInstEach$58[ebp]
  00351	e8 00 00 00 00	 call	 ?GetNameColorIndex@CInstanceBase@@QAEIXZ ; CInstanceBase::GetNameColorIndex
  00356	89 45 68	 mov	 DWORD PTR _aMarkPosition$65[ebp+8], eax

; 139  : 			if (aMarkPosition.m_eNameColor==CInstanceBase::NAMECOLOR_PARTY)

  00359	83 7d 68 18	 cmp	 DWORD PTR _aMarkPosition$65[ebp+8], 24 ; 00000018H
  0035d	75 14		 jne	 SHORT $LN21@Update
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0035f	8d 45 60	 lea	 eax, DWORD PTR _aMarkPosition$65[ebp]
  00362	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 140  : 				m_PartyPCPositionVector.push_back(aMarkPosition);

  00363	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  00366	81 c1 2c 01 00
	00		 add	 ecx, 300		; 0000012cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0036c	e8 00 00 00 00	 call	 ??$emplace_back@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEXABUTMarkPosition@CPythonMiniMap@@@Z ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::emplace_back<CPythonMiniMap::TMarkPosition const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 140  : 				m_PartyPCPositionVector.push_back(aMarkPosition);

  00371	eb 12		 jmp	 SHORT $LN229@Update
$LN21@Update:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00373	8d 45 60	 lea	 eax, DWORD PTR _aMarkPosition$65[ebp]
  00376	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 142  : 				m_OtherPCPositionVector.push_back(aMarkPosition);

  00377	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  0037a	81 c1 38 01 00
	00		 add	 ecx, 312		; 00000138H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00380	e8 00 00 00 00	 call	 ??$emplace_back@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEXABUTMarkPosition@CPythonMiniMap@@@Z ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::emplace_back<CPythonMiniMap::TMarkPosition const &>
$LN229@Update:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 143  : 		}

  00385	e9 c0 01 00 00	 jmp	 $LN262@Update
$LN18@Update:

; 144  : 		else if (pkInstEach->IsNPC())

  0038a	8b 4d 20	 mov	 ecx, DWORD PTR _pkInstEach$58[ebp]
  0038d	e8 00 00 00 00	 call	 ?IsNPC@CInstanceBase@@QAEHXZ ; CInstanceBase::IsNPC
  00392	85 c0		 test	 eax, eax
  00394	0f 84 87 00 00
	00		 je	 $LN23@Update

; 145  : 		{
; 146  : 			aMarkPosition.m_fX = ( m_fWidth - (float)m_WhiteMark.GetWidth() ) / 2.0f + fDistanceFromCenterX + m_fScreenX;

  0039a	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  0039d	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  003a3	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  003a8	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  003ac	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  003af	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  003b4	f3 0f 5c c8	 subss	 xmm1, xmm0
  003b8	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  003c0	f3 0f 58 4d 14	 addss	 xmm1, DWORD PTR _fDistanceFromCenterX$52[ebp]
  003c5	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  003c8	f3 0f 58 48 24	 addss	 xmm1, DWORD PTR [eax+36]
  003cd	f3 0f 11 4d 60	 movss	 DWORD PTR _aMarkPosition$65[ebp], xmm1

; 147  : 			aMarkPosition.m_fY = ( m_fHeight - (float)m_WhiteMark.GetHeight() ) / 2.0f + fDistanceFromCenterY + m_fScreenY;

  003d2	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  003d5	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  003db	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  003e0	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  003e4	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  003e7	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [eax+12]
  003ec	f3 0f 5c c8	 subss	 xmm1, xmm0
  003f0	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  003f8	f3 0f 58 4d 10	 addss	 xmm1, DWORD PTR _fDistanceFromCenterY$51[ebp]
  003fd	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00400	f3 0f 58 48 28	 addss	 xmm1, DWORD PTR [eax+40]
  00405	f3 0f 11 4d 64	 movss	 DWORD PTR _aMarkPosition$65[ebp+4], xmm1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0040a	8d 45 60	 lea	 eax, DWORD PTR _aMarkPosition$65[ebp]
  0040d	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 149  : 			m_NPCPositionVector.push_back(aMarkPosition);

  0040e	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  00411	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00417	e8 00 00 00 00	 call	 ??$emplace_back@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEXABUTMarkPosition@CPythonMiniMap@@@Z ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::emplace_back<CPythonMiniMap::TMarkPosition const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 150  : 		}

  0041c	e9 29 01 00 00	 jmp	 $LN262@Update
$LN23@Update:

; 151  : 		else if (pkInstEach->IsEnemy())

  00421	8b 4d 20	 mov	 ecx, DWORD PTR _pkInstEach$58[ebp]
  00424	e8 00 00 00 00	 call	 ?IsEnemy@CInstanceBase@@QAEHXZ ; CInstanceBase::IsEnemy
  00429	85 c0		 test	 eax, eax
  0042b	0f 84 87 00 00
	00		 je	 $LN25@Update

; 152  : 		{
; 153  : 			aMarkPosition.m_fX = ( m_fWidth - (float)m_WhiteMark.GetWidth() ) / 2.0f + fDistanceFromCenterX + m_fScreenX;

  00431	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  00434	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  0043a	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  0043f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00443	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00446	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  0044b	f3 0f 5c c8	 subss	 xmm1, xmm0
  0044f	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  00457	f3 0f 58 4d 14	 addss	 xmm1, DWORD PTR _fDistanceFromCenterX$52[ebp]
  0045c	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  0045f	f3 0f 58 48 24	 addss	 xmm1, DWORD PTR [eax+36]
  00464	f3 0f 11 4d 60	 movss	 DWORD PTR _aMarkPosition$65[ebp], xmm1

; 154  : 			aMarkPosition.m_fY = ( m_fHeight - (float)m_WhiteMark.GetHeight() ) / 2.0f + fDistanceFromCenterY + m_fScreenY;

  00469	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  0046c	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00472	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  00477	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0047b	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  0047e	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [eax+12]
  00483	f3 0f 5c c8	 subss	 xmm1, xmm0
  00487	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  0048f	f3 0f 58 4d 10	 addss	 xmm1, DWORD PTR _fDistanceFromCenterY$51[ebp]
  00494	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00497	f3 0f 58 48 28	 addss	 xmm1, DWORD PTR [eax+40]
  0049c	f3 0f 11 4d 64	 movss	 DWORD PTR _aMarkPosition$65[ebp+4], xmm1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  004a1	8d 45 60	 lea	 eax, DWORD PTR _aMarkPosition$65[ebp]
  004a4	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 156  : 			m_MonsterPositionVector.push_back(aMarkPosition);

  004a5	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  004a8	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  004ae	e8 00 00 00 00	 call	 ??$emplace_back@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEXABUTMarkPosition@CPythonMiniMap@@@Z ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::emplace_back<CPythonMiniMap::TMarkPosition const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 157  : 		}

  004b3	e9 92 00 00 00	 jmp	 $LN262@Update
$LN25@Update:

; 158  : 		else if (pkInstEach->IsWarp())

  004b8	8b 4d 20	 mov	 ecx, DWORD PTR _pkInstEach$58[ebp]
  004bb	e8 00 00 00 00	 call	 ?IsWarp@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWarp
  004c0	85 c0		 test	 eax, eax
  004c2	0f 84 82 00 00
	00		 je	 $LN262@Update

; 159  : 		{
; 160  : 			aMarkPosition.m_fX = ( m_fWidth - (float)m_WhiteMark.GetWidth() ) / 2.0f + fDistanceFromCenterX + m_fScreenX;

  004c8	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  004cb	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  004d1	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  004d6	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  004da	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  004dd	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  004e2	f3 0f 5c c8	 subss	 xmm1, xmm0
  004e6	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  004ee	f3 0f 58 4d 14	 addss	 xmm1, DWORD PTR _fDistanceFromCenterX$52[ebp]
  004f3	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  004f6	f3 0f 58 48 24	 addss	 xmm1, DWORD PTR [eax+36]
  004fb	f3 0f 11 4d 60	 movss	 DWORD PTR _aMarkPosition$65[ebp], xmm1

; 161  : 			aMarkPosition.m_fY = ( m_fHeight - (float)m_WhiteMark.GetHeight() ) / 2.0f + fDistanceFromCenterY + m_fScreenY;

  00500	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  00503	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00509	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  0050e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00512	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00515	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [eax+12]
  0051a	f3 0f 5c c8	 subss	 xmm1, xmm0
  0051e	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  00526	f3 0f 58 4d 10	 addss	 xmm1, DWORD PTR _fDistanceFromCenterY$51[ebp]
  0052b	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  0052e	f3 0f 58 48 28	 addss	 xmm1, DWORD PTR [eax+40]
  00533	f3 0f 11 4d 64	 movss	 DWORD PTR _aMarkPosition$65[ebp+4], xmm1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00538	8d 45 60	 lea	 eax, DWORD PTR _aMarkPosition$65[ebp]
  0053b	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 163  : 			m_WarpPositionVector.push_back(aMarkPosition);

  0053c	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  0053f	81 c1 5c 01 00
	00		 add	 ecx, 348		; 0000015cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00545	e8 00 00 00 00	 call	 ??$emplace_back@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEXABUTMarkPosition@CPythonMiniMap@@@Z ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::emplace_back<CPythonMiniMap::TMarkPosition const &>
$LN262@Update:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 165  : 	}

  0054a	e9 e7 fb ff ff	 jmp	 $LN2@Update
$LN3@Update:

; 166  : 
; 167  : 	{
; 168  : 		DWORD dwCurTime=ELTimer_GetMSec();

  0054f	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  00554	89 85 40 ff ff
	ff		 mov	 DWORD PTR _dwCurTime$15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 37   :     _Tree_unchecked_const_iterator() noexcept : _Ptr() {}

  0055a	83 65 f0 00	 and	 DWORD PTR _i$44[ebp], 0

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0055e	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00561	05 68 01 00 00	 add	 eax, 360		; 00000168H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00566	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T28[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0056c	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR $T28[ebp]
  00572	89 85 78 ff ff
	ff		 mov	 DWORD PTR __Scary$27[ebp], eax

; 1240 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00578	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR __Scary$27[ebp]
  0057e	8b 00		 mov	 eax, DWORD PTR [eax]
  00580	8b 00		 mov	 eax, DWORD PTR [eax]
  00582	89 85 74 ff ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00588	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  0058e	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T26[ebp], eax

; 1240 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00594	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR $T26[ebp]
  0059a	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T25[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 171  : 		for (i=m_kMap_dwVID_kObserver.begin(); i!=m_kMap_dwVID_kObserver.end(); ++i)

  005a0	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR $T25[ebp]
  005a6	8b 00		 mov	 eax, DWORD PTR [eax]
  005a8	89 45 f0	 mov	 DWORD PTR _i$44[ebp], eax
  005ab	eb 08		 jmp	 SHORT $LN303@Update
$LN5@Update:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 198  :         _Mybase::operator++();

  005ad	8d 4d f0	 lea	 ecx, DWORD PTR _i$44[ebp]
  005b0	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonMiniMap::SObserver> > >,std::_Iterator_base0>::operator++
$LN303@Update:

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  005b5	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  005b8	05 68 01 00 00	 add	 eax, 360		; 00000168H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  005bd	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T24[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  005c3	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR $T24[ebp]
  005c9	89 85 64 ff ff
	ff		 mov	 DWORD PTR __Scary$23[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  005cf	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR __Scary$23[ebp]
  005d5	8b 00		 mov	 eax, DWORD PTR [eax]
  005d7	89 85 60 ff ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  005dd	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  005e3	89 85 5c ff ff
	ff		 mov	 DWORD PTR $T22[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  005e9	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR $T22[ebp]
  005ef	89 85 58 ff ff
	ff		 mov	 DWORD PTR $T21[ebp], eax

; 232  :         return this->_Ptr == _Right._Ptr;

  005f5	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR $T21[ebp]
  005fb	8b 4d f0	 mov	 ecx, DWORD PTR _i$44[ebp]
  005fe	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00600	75 09		 jne	 SHORT $LN349@Update
  00602	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR tv887[ebp], 1
  00609	eb 04		 jmp	 SHORT $LN350@Update
$LN349@Update:
  0060b	83 65 d4 00	 and	 DWORD PTR tv887[ebp], 0
$LN350@Update:
  0060f	8a 45 d4	 mov	 al, BYTE PTR tv887[ebp]
  00612	88 45 1e	 mov	 BYTE PTR $T56[ebp], al

; 236  :         return !(*this == _Right);

  00615	0f b6 45 1e	 movzx	 eax, BYTE PTR $T56[ebp]
  00619	85 c0		 test	 eax, eax
  0061b	75 09		 jne	 SHORT $LN344@Update
  0061d	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR tv860[ebp], 1
  00624	eb 04		 jmp	 SHORT $LN345@Update
$LN344@Update:
  00626	83 65 d0 00	 and	 DWORD PTR tv860[ebp], 0
$LN345@Update:
  0062a	8a 45 d0	 mov	 al, BYTE PTR tv860[ebp]
  0062d	88 45 1d	 mov	 BYTE PTR $T55[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 171  : 		for (i=m_kMap_dwVID_kObserver.begin(); i!=m_kMap_dwVID_kObserver.end(); ++i)

  00630	0f b6 45 1d	 movzx	 eax, BYTE PTR $T55[ebp]
  00634	85 c0		 test	 eax, eax
  00636	0f 84 ba 02 00
	00		 je	 $LN6@Update
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 185  :         return this->_Ptr->_Myval;

  0063c	8b 45 f0	 mov	 eax, DWORD PTR _i$44[ebp]
  0063f	83 c0 10	 add	 eax, 16			; 00000010H
  00642	89 85 54 ff ff
	ff		 mov	 DWORD PTR $T20[ebp], eax

; 273  :         return const_cast<reference>(_Mybase::operator*());

  00648	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR $T20[ebp]
  0064e	89 85 50 ff ff
	ff		 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00654	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR $T19[ebp]
  0065a	89 85 4c ff ff
	ff		 mov	 DWORD PTR $T18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  00660	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR $T18[ebp]
  00666	89 85 48 ff ff
	ff		 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 277  :         return pointer_traits<pointer>::pointer_to(**this);

  0066c	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR $T17[ebp]
  00672	89 85 44 ff ff
	ff		 mov	 DWORD PTR $T16[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 173  : 			SObserver& rkObserver=i->second;

  00678	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR $T16[ebp]
  0067e	83 c0 04	 add	 eax, 4
  00681	89 45 28	 mov	 DWORD PTR _rkObserver$60[ebp], eax

; 174  : 
; 175  : 			float fPos=float(dwCurTime-rkObserver.dwSrcTime)/float(rkObserver.dwDstTime-rkObserver.dwSrcTime);			

  00684	8b 45 28	 mov	 eax, DWORD PTR _rkObserver$60[ebp]
  00687	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _dwCurTime$15[ebp]
  0068d	2b 48 18	 sub	 ecx, DWORD PTR [eax+24]
  00690	89 4d cc	 mov	 DWORD PTR tv1221[ebp], ecx
  00693	f2 0f 2a 45 cc	 cvtsi2sd xmm0, DWORD PTR tv1221[ebp]
  00698	8b 45 cc	 mov	 eax, DWORD PTR tv1221[ebp]
  0069b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0069e	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  006a7	f2 0f 11 85 e4
	fe ff ff	 movsd	 QWORD PTR tv1224[ebp], xmm0
  006af	f2 0f 5a 85 e4
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv1224[ebp]
  006b7	8b 45 28	 mov	 eax, DWORD PTR _rkObserver$60[ebp]
  006ba	8b 4d 28	 mov	 ecx, DWORD PTR _rkObserver$60[ebp]
  006bd	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  006c0	2b 41 18	 sub	 eax, DWORD PTR [ecx+24]
  006c3	89 45 c8	 mov	 DWORD PTR tv1232[ebp], eax
  006c6	f2 0f 2a 4d c8	 cvtsi2sd xmm1, DWORD PTR tv1232[ebp]
  006cb	8b 45 c8	 mov	 eax, DWORD PTR tv1232[ebp]
  006ce	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  006d1	f2 0f 58 0c c5
	00 00 00 00	 addsd	 xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  006da	f2 0f 11 8d dc
	fe ff ff	 movsd	 QWORD PTR tv1235[ebp], xmm1
  006e2	f2 0f 5a 8d dc
	fe ff ff	 cvtsd2ss xmm1, QWORD PTR tv1235[ebp]
  006ea	f3 0f 5e c1	 divss	 xmm0, xmm1
  006ee	f3 0f 11 45 08	 movss	 DWORD PTR _fPos$49[ebp], xmm0

; 176  : 			if (fPos<0.0f) fPos=0.0f;

  006f3	0f 57 c0	 xorps	 xmm0, xmm0
  006f6	0f 2f 45 08	 comiss	 xmm0, DWORD PTR _fPos$49[ebp]
  006fa	76 0a		 jbe	 SHORT $LN28@Update
  006fc	0f 57 c0	 xorps	 xmm0, xmm0
  006ff	f3 0f 11 45 08	 movss	 DWORD PTR _fPos$49[ebp], xmm0
  00704	eb 1b		 jmp	 SHORT $LN30@Update
$LN28@Update:

; 177  : 			else if (fPos>1.0f) fPos=1.0f;

  00706	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fPos$49[ebp]
  0070b	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00712	76 0d		 jbe	 SHORT $LN30@Update
  00714	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0071c	f3 0f 11 45 08	 movss	 DWORD PTR _fPos$49[ebp], xmm0
$LN30@Update:

; 178  : 
; 179  : 			rkObserver.fCurX=(rkObserver.fDstX-rkObserver.fSrcX)*fPos+rkObserver.fSrcX;

  00721	8b 45 28	 mov	 eax, DWORD PTR _rkObserver$60[ebp]
  00724	8b 4d 28	 mov	 ecx, DWORD PTR _rkObserver$60[ebp]
  00727	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  0072c	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00731	f3 0f 59 45 08	 mulss	 xmm0, DWORD PTR _fPos$49[ebp]
  00736	8b 45 28	 mov	 eax, DWORD PTR _rkObserver$60[ebp]
  00739	f3 0f 58 40 08	 addss	 xmm0, DWORD PTR [eax+8]
  0073e	8b 45 28	 mov	 eax, DWORD PTR _rkObserver$60[ebp]
  00741	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 180  : 			rkObserver.fCurY=(rkObserver.fDstY-rkObserver.fSrcY)*fPos+rkObserver.fSrcY;

  00745	8b 45 28	 mov	 eax, DWORD PTR _rkObserver$60[ebp]
  00748	8b 4d 28	 mov	 ecx, DWORD PTR _rkObserver$60[ebp]
  0074b	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00750	f3 0f 5c 41 0c	 subss	 xmm0, DWORD PTR [ecx+12]
  00755	f3 0f 59 45 08	 mulss	 xmm0, DWORD PTR _fPos$49[ebp]
  0075a	8b 45 28	 mov	 eax, DWORD PTR _rkObserver$60[ebp]
  0075d	f3 0f 58 40 0c	 addss	 xmm0, DWORD PTR [eax+12]
  00762	8b 45 28	 mov	 eax, DWORD PTR _rkObserver$60[ebp]
  00765	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 181  : 
; 182  : 			TPixelPosition kInstancePosition;
; 183  : 			kInstancePosition.x=rkObserver.fCurX;

  0076a	8b 45 28	 mov	 eax, DWORD PTR _rkObserver$60[ebp]
  0076d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00771	f3 0f 11 45 54	 movss	 DWORD PTR _kInstancePosition$64[ebp], xmm0

; 184  : 			kInstancePosition.y=rkObserver.fCurY;

  00776	8b 45 28	 mov	 eax, DWORD PTR _rkObserver$60[ebp]
  00779	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0077e	f3 0f 11 45 58	 movss	 DWORD PTR _kInstancePosition$64[ebp+4], xmm0

; 185  : 			kInstancePosition.z=0.0f;

  00783	0f 57 c0	 xorps	 xmm0, xmm0
  00786	f3 0f 11 45 5c	 movss	 DWORD PTR _kInstancePosition$64[ebp+8], xmm0

; 186  : 
; 187  : 			float fDistanceFromCenterX = (kInstancePosition.x - m_fCenterX) * fooCellScale * m_fScale;

  0078b	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  0078e	f3 0f 10 45 54	 movss	 xmm0, DWORD PTR _kInstancePosition$64[ebp]
  00793	f3 0f 5c 40 14	 subss	 xmm0, DWORD PTR [eax+20]
  00798	f3 0f 59 45 04	 mulss	 xmm0, DWORD PTR _fooCellScale$[ebp]
  0079d	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  007a0	f3 0f 59 40 10	 mulss	 xmm0, DWORD PTR [eax+16]
  007a5	f3 0f 11 45 f4	 movss	 DWORD PTR _fDistanceFromCenterX$45[ebp], xmm0

; 188  : 			float fDistanceFromCenterY = (kInstancePosition.y - m_fCenterY) * fooCellScale * m_fScale;

  007aa	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  007ad	f3 0f 10 45 58	 movss	 xmm0, DWORD PTR _kInstancePosition$64[ebp+4]
  007b2	f3 0f 5c 40 18	 subss	 xmm0, DWORD PTR [eax+24]
  007b7	f3 0f 59 45 04	 mulss	 xmm0, DWORD PTR _fooCellScale$[ebp]
  007bc	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  007bf	f3 0f 59 40 10	 mulss	 xmm0, DWORD PTR [eax+16]
  007c4	f3 0f 11 45 f8	 movss	 DWORD PTR _fDistanceFromCenterY$46[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  007c9	f3 0f 5a 45 f4	 cvtss2sd xmm0, DWORD PTR _fDistanceFromCenterX$45[ebp]
  007ce	51		 push	 ecx
  007cf	51		 push	 ecx
  007d0	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  007d5	e8 00 00 00 00	 call	 _fabs
  007da	59		 pop	 ecx
  007db	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath

; 95   :     return _CSTD fabsf(_Xx);

  007dc	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR $T14[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 189  : 			if (fabs(fDistanceFromCenterX) >= m_fMiniMapRadius || fabs(fDistanceFromCenterY) >= m_fMiniMapRadius)

  007e2	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  007e5	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR $T14[ebp]
  007ed	0f 2f 40 2c	 comiss	 xmm0, DWORD PTR [eax+44]
  007f1	73 2a		 jae	 SHORT $LN32@Update
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  007f3	f3 0f 5a 45 f8	 cvtss2sd xmm0, DWORD PTR _fDistanceFromCenterY$46[ebp]
  007f8	51		 push	 ecx
  007f9	51		 push	 ecx
  007fa	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  007ff	e8 00 00 00 00	 call	 _fabs
  00804	59		 pop	 ecx
  00805	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath

; 95   :     return _CSTD fabsf(_Xx);

  00806	d9 9d 38 ff ff
	ff		 fstp	 DWORD PTR $T13[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 189  : 			if (fabs(fDistanceFromCenterX) >= m_fMiniMapRadius || fabs(fDistanceFromCenterY) >= m_fMiniMapRadius)

  0080c	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  0080f	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR $T13[ebp]
  00817	0f 2f 40 2c	 comiss	 xmm0, DWORD PTR [eax+44]
  0081b	72 05		 jb	 SHORT $LN31@Update
$LN32@Update:

; 190  : 				continue;

  0081d	e9 8b fd ff ff	 jmp	 $LN5@Update
$LN31@Update:

; 192  : 			float fDistanceFromCenter = sqrtf(fDistanceFromCenterX * fDistanceFromCenterX + fDistanceFromCenterY * fDistanceFromCenterY );

  00822	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fDistanceFromCenterY$46[ebp]
  00827	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _fDistanceFromCenterY$46[ebp]
  0082c	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _fDistanceFromCenterX$45[ebp]
  00831	f3 0f 59 4d f4	 mulss	 xmm1, DWORD PTR _fDistanceFromCenterX$45[ebp]
  00836	f3 0f 58 c8	 addss	 xmm1, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  0083a	f3 0f 5a c1	 cvtss2sd xmm0, xmm1
  0083e	51		 push	 ecx
  0083f	51		 push	 ecx
  00840	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00845	e8 00 00 00 00	 call	 _sqrt
  0084a	59		 pop	 ecx
  0084b	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 192  : 			float fDistanceFromCenter = sqrtf(fDistanceFromCenterX * fDistanceFromCenterX + fDistanceFromCenterY * fDistanceFromCenterY );

  0084c	d9 9d 34 ff ff
	ff		 fstp	 DWORD PTR _fDistanceFromCenter$12[ebp]

; 193  : 			if ( fDistanceFromCenter >= m_fMiniMapRadius )

  00852	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00855	f3 0f 10 85 34
	ff ff ff	 movss	 xmm0, DWORD PTR _fDistanceFromCenter$12[ebp]
  0085d	0f 2f 40 2c	 comiss	 xmm0, DWORD PTR [eax+44]
  00861	72 05		 jb	 SHORT $LN33@Update

; 194  : 				continue;

  00863	e9 45 fd ff ff	 jmp	 $LN5@Update
$LN33@Update:

; 195  : 
; 196  : 			TMarkPosition aMarkPosition;
; 197  : 			aMarkPosition.m_fX = ( m_fWidth - (float)m_WhiteMark.GetWidth() ) / 2.0f + fDistanceFromCenterX + m_fScreenX;

  00868	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  0086b	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00871	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  00876	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0087a	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  0087d	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  00882	f3 0f 5c c8	 subss	 xmm1, xmm0
  00886	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  0088e	f3 0f 58 4d f4	 addss	 xmm1, DWORD PTR _fDistanceFromCenterX$45[ebp]
  00893	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00896	f3 0f 58 48 24	 addss	 xmm1, DWORD PTR [eax+36]
  0089b	f3 0f 11 4d 48	 movss	 DWORD PTR _aMarkPosition$63[ebp], xmm1

; 198  : 			aMarkPosition.m_fY = ( m_fHeight - (float)m_WhiteMark.GetHeight() ) / 2.0f + fDistanceFromCenterY + m_fScreenY;

  008a0	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  008a3	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  008a9	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  008ae	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  008b2	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  008b5	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [eax+12]
  008ba	f3 0f 5c c8	 subss	 xmm1, xmm0
  008be	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  008c6	f3 0f 58 4d f8	 addss	 xmm1, DWORD PTR _fDistanceFromCenterY$46[ebp]
  008cb	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  008ce	f3 0f 58 48 28	 addss	 xmm1, DWORD PTR [eax+40]
  008d3	f3 0f 11 4d 4c	 movss	 DWORD PTR _aMarkPosition$63[ebp+4], xmm1

; 199  : 			aMarkPosition.m_eNameColor=CInstanceBase::NAMECOLOR_PARTY;

  008d8	c7 45 50 18 00
	00 00		 mov	 DWORD PTR _aMarkPosition$63[ebp+8], 24 ; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  008df	8d 45 48	 lea	 eax, DWORD PTR _aMarkPosition$63[ebp]
  008e2	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 200  : 			m_PartyPCPositionVector.push_back(aMarkPosition);

  008e3	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  008e6	81 c1 2c 01 00
	00		 add	 ecx, 300		; 0000012cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  008ec	e8 00 00 00 00	 call	 ??$emplace_back@ABUTMarkPosition@CPythonMiniMap@@@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAEXABUTMarkPosition@CPythonMiniMap@@@Z ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::emplace_back<CPythonMiniMap::TMarkPosition const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 201  : 		}

  008f1	e9 b7 fc ff ff	 jmp	 $LN5@Update
$LN6@Update:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  008f6	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  008f9	05 10 0c 00 00	 add	 eax, 3088		; 00000c10H
  008fe	89 45 c4	 mov	 DWORD PTR __My_data$41[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00901	8b 45 c4	 mov	 eax, DWORD PTR __My_data$41[ebp]
  00904	89 85 d0 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0090a	8b 45 c4	 mov	 eax, DWORD PTR __My_data$41[ebp]
  0090d	8b 00		 mov	 eax, DWORD PTR [eax]
  0090f	89 85 00 ff ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00915	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  0091b	89 45 e8	 mov	 DWORD PTR _itor$43[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 206  : 		for (; itor != m_AtlasWayPointInfoVector.end(); ++itor)

  0091e	eb 09		 jmp	 SHORT $LN431@Update
$LN8@Update:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00920	8b 45 e8	 mov	 eax, DWORD PTR _itor$43[ebp]
  00923	83 c0 3c	 add	 eax, 60			; 0000003cH
  00926	89 45 e8	 mov	 DWORD PTR _itor$43[ebp], eax
$LN431@Update:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00929	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  0092c	05 10 0c 00 00	 add	 eax, 3088		; 00000c10H
  00931	89 45 c0	 mov	 DWORD PTR __My_data$40[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00934	8b 45 c0	 mov	 eax, DWORD PTR __My_data$40[ebp]
  00937	89 85 cc fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0093d	8b 45 c0	 mov	 eax, DWORD PTR __My_data$40[ebp]
  00940	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00943	89 85 2c ff ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00949	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  0094f	89 85 28 ff ff
	ff		 mov	 DWORD PTR $T11[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00955	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  0095b	89 85 24 ff ff
	ff		 mov	 DWORD PTR $T10[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00961	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR $T10[ebp]
  00967	8b 4d e8	 mov	 ecx, DWORD PTR _itor$43[ebp]
  0096a	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0096c	75 09		 jne	 SHORT $LN459@Update
  0096e	c7 45 bc 01 00
	00 00		 mov	 DWORD PTR tv1014[ebp], 1
  00975	eb 04		 jmp	 SHORT $LN460@Update
$LN459@Update:
  00977	83 65 bc 00	 and	 DWORD PTR tv1014[ebp], 0
$LN460@Update:
  0097b	8a 45 bc	 mov	 al, BYTE PTR tv1014[ebp]
  0097e	88 45 1c	 mov	 BYTE PTR $T54[ebp], al

; 153  :         return !(*this == _Right);

  00981	0f b6 45 1c	 movzx	 eax, BYTE PTR $T54[ebp]
  00985	85 c0		 test	 eax, eax
  00987	75 09		 jne	 SHORT $LN454@Update
  00989	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv1000[ebp], 1
  00990	eb 04		 jmp	 SHORT $LN455@Update
$LN454@Update:
  00992	83 65 b8 00	 and	 DWORD PTR tv1000[ebp], 0
$LN455@Update:
  00996	8a 45 b8	 mov	 al, BYTE PTR tv1000[ebp]
  00999	88 45 1b	 mov	 BYTE PTR $T53[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 206  : 		for (; itor != m_AtlasWayPointInfoVector.end(); ++itor)

  0099c	0f b6 45 1b	 movzx	 eax, BYTE PTR $T53[ebp]
  009a0	85 c0		 test	 eax, eax
  009a2	0f 84 df 02 00
	00		 je	 $LN9@Update
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  009a8	8b 45 e8	 mov	 eax, DWORD PTR _itor$43[ebp]
  009ab	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T9[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  009b1	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  009b7	89 45 24	 mov	 DWORD PTR _rAtlasMarkInfo$59[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 210  : 			if (TYPE_TARGET != rAtlasMarkInfo.m_byType)

  009ba	8b 45 24	 mov	 eax, DWORD PTR _rAtlasMarkInfo$59[ebp]
  009bd	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  009c0	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  009c3	74 05		 je	 SHORT $LN34@Update

; 211  : 				continue;

  009c5	e9 56 ff ff ff	 jmp	 $LN8@Update
$LN34@Update:

; 212  : 
; 213  : 			if (0 != rAtlasMarkInfo.m_dwChrVID)

  009ca	8b 45 24	 mov	 eax, DWORD PTR _rAtlasMarkInfo$59[ebp]
  009cd	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  009d1	74 48		 je	 SHORT $LN36@Update

; 214  : 			{
; 215  : 				CInstanceBase * pInstance = CPythonCharacterManager::Instance().GetInstancePtr(rAtlasMarkInfo.m_dwChrVID);

  009d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  009d8	83 c0 04	 add	 eax, 4
  009db	89 45 b4	 mov	 DWORD PTR tv500[ebp], eax
  009de	8b 45 24	 mov	 eax, DWORD PTR _rAtlasMarkInfo$59[ebp]
  009e1	ff 70 20	 push	 DWORD PTR [eax+32]
  009e4	8b 45 b4	 mov	 eax, DWORD PTR tv500[ebp]
  009e7	8b 00		 mov	 eax, DWORD PTR [eax]
  009e9	8b 4d b4	 mov	 ecx, DWORD PTR tv500[ebp]
  009ec	ff 50 08	 call	 DWORD PTR [eax+8]
  009ef	89 45 b0	 mov	 DWORD PTR _pInstance$39[ebp], eax

; 216  : 				if (pInstance)

  009f2	83 7d b0 00	 cmp	 DWORD PTR _pInstance$39[ebp], 0
  009f6	74 23		 je	 SHORT $LN36@Update

; 217  : 				{
; 218  : 					TPixelPosition kPixelPosition;
; 219  : 					pInstance->NEW_GetPixelPosition(&kPixelPosition);

  009f8	8d 45 30	 lea	 eax, DWORD PTR _kPixelPosition$61[ebp]
  009fb	50		 push	 eax
  009fc	8b 4d b0	 mov	 ecx, DWORD PTR _pInstance$39[ebp]
  009ff	e8 00 00 00 00	 call	 ?NEW_GetPixelPosition@CInstanceBase@@QAEXPAUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_GetPixelPosition

; 220  : 					__UpdateWayPoint(&rAtlasMarkInfo, kPixelPosition.x, kPixelPosition.y);

  00a04	f3 0f 2c 45 34	 cvttss2si eax, DWORD PTR _kPixelPosition$61[ebp+4]
  00a09	50		 push	 eax
  00a0a	f3 0f 2c 45 30	 cvttss2si eax, DWORD PTR _kPixelPosition$61[ebp]
  00a0f	50		 push	 eax
  00a10	ff 75 24	 push	 DWORD PTR _rAtlasMarkInfo$59[ebp]
  00a13	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  00a16	e8 00 00 00 00	 call	 ?__UpdateWayPoint@CPythonMiniMap@@IAEXPAUTAtlasMarkInfo@1@HH@Z ; CPythonMiniMap::__UpdateWayPoint
$LN36@Update:

; 221  : 				}
; 222  : 			}
; 223  : 
; 224  : 			const float c_fMiniMapWindowRadius = 55.0f;

  00a1b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@425c0000
  00a23	f3 0f 11 85 c8
	fe ff ff	 movss	 DWORD PTR _c_fMiniMapWindowRadius$1[ebp], xmm0

; 225  : 
; 226  : 			float fDistanceFromCenterX = (rAtlasMarkInfo.m_fX - m_fCenterX) * fooCellScale * m_fScale;

  00a2b	8b 45 24	 mov	 eax, DWORD PTR _rAtlasMarkInfo$59[ebp]
  00a2e	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  00a31	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00a36	f3 0f 5c 41 14	 subss	 xmm0, DWORD PTR [ecx+20]
  00a3b	f3 0f 59 45 04	 mulss	 xmm0, DWORD PTR _fooCellScale$[ebp]
  00a40	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00a43	f3 0f 59 40 10	 mulss	 xmm0, DWORD PTR [eax+16]
  00a48	f3 0f 11 45 00	 movss	 DWORD PTR _fDistanceFromCenterX$48[ebp], xmm0

; 227  : 			float fDistanceFromCenterY = (rAtlasMarkInfo.m_fY - m_fCenterY) * fooCellScale * m_fScale;

  00a4d	8b 45 24	 mov	 eax, DWORD PTR _rAtlasMarkInfo$59[ebp]
  00a50	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  00a53	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00a58	f3 0f 5c 41 18	 subss	 xmm0, DWORD PTR [ecx+24]
  00a5d	f3 0f 59 45 04	 mulss	 xmm0, DWORD PTR _fooCellScale$[ebp]
  00a62	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00a65	f3 0f 59 40 10	 mulss	 xmm0, DWORD PTR [eax+16]
  00a6a	f3 0f 11 45 fc	 movss	 DWORD PTR _fDistanceFromCenterY$47[ebp], xmm0

; 228  : 			float fDistanceFromCenter = sqrtf(fDistanceFromCenterX * fDistanceFromCenterX + fDistanceFromCenterY * fDistanceFromCenterY );

  00a6f	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fDistanceFromCenterY$47[ebp]
  00a74	f3 0f 59 45 fc	 mulss	 xmm0, DWORD PTR _fDistanceFromCenterY$47[ebp]
  00a79	f3 0f 10 4d 00	 movss	 xmm1, DWORD PTR _fDistanceFromCenterX$48[ebp]
  00a7e	f3 0f 59 4d 00	 mulss	 xmm1, DWORD PTR _fDistanceFromCenterX$48[ebp]
  00a83	f3 0f 58 c8	 addss	 xmm1, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  00a87	f3 0f 5a c1	 cvtss2sd xmm0, xmm1
  00a8b	51		 push	 ecx
  00a8c	51		 push	 ecx
  00a8d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00a92	e8 00 00 00 00	 call	 _sqrt
  00a97	59		 pop	 ecx
  00a98	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 228  : 			float fDistanceFromCenter = sqrtf(fDistanceFromCenterX * fDistanceFromCenterX + fDistanceFromCenterY * fDistanceFromCenterY );

  00a99	d9 5d e0	 fstp	 DWORD PTR _fDistanceFromCenter$42[ebp]

; 229  : 
; 230  : 			if (fDistanceFromCenter >= c_fMiniMapWindowRadius)

  00a9c	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fDistanceFromCenter$42[ebp]
  00aa1	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@425c0000
  00aa8	0f 82 5e 01 00
	00		 jb	 $LN37@Update

; 232  : 				float fRadianX = acosf(fDistanceFromCenterX / fDistanceFromCenter);

  00aae	f3 0f 10 45 00	 movss	 xmm0, DWORD PTR _fDistanceFromCenterX$48[ebp]
  00ab3	f3 0f 5e 45 e0	 divss	 xmm0, DWORD PTR _fDistanceFromCenter$42[ebp]
  00ab8	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR __X$[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 624  :             return (float)acos(_X);

  00ac0	f3 0f 5a 85 1c
	ff ff ff	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00ac8	51		 push	 ecx
  00ac9	51		 push	 ecx
  00aca	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00acf	e8 00 00 00 00	 call	 _acos
  00ad4	59		 pop	 ecx
  00ad5	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 232  : 				float fRadianX = acosf(fDistanceFromCenterX / fDistanceFromCenter);

  00ad6	d9 9d 14 ff ff
	ff		 fstp	 DWORD PTR _fRadianX$8[ebp]

; 233  : 				float fRadianY = asinf(fDistanceFromCenterY / fDistanceFromCenter);

  00adc	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fDistanceFromCenterY$47[ebp]
  00ae1	f3 0f 5e 45 e0	 divss	 xmm0, DWORD PTR _fDistanceFromCenter$42[ebp]
  00ae6	f3 0f 11 85 18
	ff ff ff	 movss	 DWORD PTR __X$[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 629  :             return (float)asin(_X);

  00aee	f3 0f 5a 85 18
	ff ff ff	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00af6	51		 push	 ecx
  00af7	51		 push	 ecx
  00af8	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00afd	e8 00 00 00 00	 call	 _asin
  00b02	59		 pop	 ecx
  00b03	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 233  : 				float fRadianY = asinf(fDistanceFromCenterY / fDistanceFromCenter);

  00b04	d9 9d 08 ff ff
	ff		 fstp	 DWORD PTR _fRadianY$7[ebp]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 649  :             return (float)cos(_X);

  00b0a	f3 0f 5a 85 14
	ff ff ff	 cvtss2sd xmm0, DWORD PTR _fRadianX$8[ebp]
  00b12	51		 push	 ecx
  00b13	51		 push	 ecx
  00b14	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00b19	e8 00 00 00 00	 call	 _cos
  00b1e	59		 pop	 ecx
  00b1f	59		 pop	 ecx
  00b20	d9 9d 10 ff ff
	ff		 fstp	 DWORD PTR tv1350[ebp]
  00b26	d9 85 10 ff ff
	ff		 fld	 DWORD PTR tv1350[ebp]
  00b2c	d9 9d 0c ff ff
	ff		 fstp	 DWORD PTR tv1351[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 234  : 				fDistanceFromCenterX = 55.0f * cosf(fRadianX);

  00b32	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR tv1351[ebp]
  00b3a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@425c0000
  00b42	f3 0f 11 45 00	 movss	 DWORD PTR _fDistanceFromCenterX$48[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 750  :             return (float)sin(_X);

  00b47	f3 0f 5a 85 08
	ff ff ff	 cvtss2sd xmm0, DWORD PTR _fRadianY$7[ebp]
  00b4f	51		 push	 ecx
  00b50	51		 push	 ecx
  00b51	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00b56	e8 00 00 00 00	 call	 _sin
  00b5b	59		 pop	 ecx
  00b5c	59		 pop	 ecx
  00b5d	d9 9d 04 ff ff
	ff		 fstp	 DWORD PTR tv1357[ebp]
  00b63	d9 85 04 ff ff
	ff		 fld	 DWORD PTR tv1357[ebp]
  00b69	d9 9d ec fe ff
	ff		 fstp	 DWORD PTR tv1358[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 235  : 				fDistanceFromCenterY = 55.0f * sinf(fRadianY);

  00b6f	f3 0f 10 85 ec
	fe ff ff	 movss	 xmm0, DWORD PTR tv1358[ebp]
  00b77	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@425c0000
  00b7f	f3 0f 11 45 fc	 movss	 DWORD PTR _fDistanceFromCenterY$47[ebp], xmm0

; 236  : 				rAtlasMarkInfo.m_fMiniMapX = ( m_fWidth - (float)m_WhiteMark.GetWidth() ) / 2.0f + fDistanceFromCenterX + m_fScreenX + 2.0f;

  00b84	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  00b87	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00b8d	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  00b92	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00b96	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00b99	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  00b9e	f3 0f 5c c8	 subss	 xmm1, xmm0
  00ba2	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  00baa	f3 0f 58 4d 00	 addss	 xmm1, DWORD PTR _fDistanceFromCenterX$48[ebp]
  00baf	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00bb2	f3 0f 58 48 24	 addss	 xmm1, DWORD PTR [eax+36]
  00bb7	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@40000000
  00bbf	8b 45 24	 mov	 eax, DWORD PTR _rAtlasMarkInfo$59[ebp]
  00bc2	f3 0f 11 48 18	 movss	 DWORD PTR [eax+24], xmm1

; 237  : 				rAtlasMarkInfo.m_fMiniMapY = ( m_fHeight - (float)m_WhiteMark.GetHeight() ) / 2.0f + fDistanceFromCenterY + m_fScreenY + 2.0f;

  00bc7	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  00bca	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00bd0	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  00bd5	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00bd9	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00bdc	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [eax+12]
  00be1	f3 0f 5c c8	 subss	 xmm1, xmm0
  00be5	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  00bed	f3 0f 58 4d fc	 addss	 xmm1, DWORD PTR _fDistanceFromCenterY$47[ebp]
  00bf2	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00bf5	f3 0f 58 48 28	 addss	 xmm1, DWORD PTR [eax+40]
  00bfa	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@40000000
  00c02	8b 45 24	 mov	 eax, DWORD PTR _rAtlasMarkInfo$59[ebp]
  00c05	f3 0f 11 48 1c	 movss	 DWORD PTR [eax+28], xmm1

; 238  : 			}

  00c0a	eb 76		 jmp	 SHORT $LN38@Update
$LN37@Update:

; 239  : 			else
; 240  : 			{
; 241  : 				rAtlasMarkInfo.m_fMiniMapX = ( m_fWidth - (float)m_WhiteMark.GetWidth() ) / 2.0f + fDistanceFromCenterX + m_fScreenX;

  00c0c	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  00c0f	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00c15	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  00c1a	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00c1e	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00c21	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  00c26	f3 0f 5c c8	 subss	 xmm1, xmm0
  00c2a	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  00c32	f3 0f 58 4d 00	 addss	 xmm1, DWORD PTR _fDistanceFromCenterX$48[ebp]
  00c37	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00c3a	f3 0f 58 48 24	 addss	 xmm1, DWORD PTR [eax+36]
  00c3f	8b 45 24	 mov	 eax, DWORD PTR _rAtlasMarkInfo$59[ebp]
  00c42	f3 0f 11 48 18	 movss	 DWORD PTR [eax+24], xmm1

; 242  : 				rAtlasMarkInfo.m_fMiniMapY = ( m_fHeight - (float)m_WhiteMark.GetHeight() ) / 2.0f + fDistanceFromCenterY + m_fScreenY;

  00c47	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  00c4a	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00c50	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  00c55	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00c59	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00c5c	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [eax+12]
  00c61	f3 0f 5c c8	 subss	 xmm1, xmm0
  00c65	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  00c6d	f3 0f 58 4d fc	 addss	 xmm1, DWORD PTR _fDistanceFromCenterY$47[ebp]
  00c72	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00c75	f3 0f 58 48 28	 addss	 xmm1, DWORD PTR [eax+40]
  00c7a	8b 45 24	 mov	 eax, DWORD PTR _rAtlasMarkInfo$59[ebp]
  00c7d	f3 0f 11 48 1c	 movss	 DWORD PTR [eax+28], xmm1
$LN38@Update:

; 243  : 			}
; 244  : 		}

  00c82	e9 99 fc ff ff	 jmp	 $LN8@Update
$LN9@Update:
$LN1@Update:

; 245  : 	}
; 246  : }

  00c87	8b 4d 6c	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c8a	33 cd		 xor	 ecx, ebp
  00c8c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c91	83 c5 70	 add	 ebp, 112		; 00000070H
  00c94	c9		 leave
  00c95	c2 08 00	 ret	 8
?Update@CPythonMiniMap@@QAEXMM@Z ENDP			; CPythonMiniMap::Update
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\gamelib\AreaTerrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\gamelib\MapOutdoor.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?SetCenterPosition@CPythonMiniMap@@QAEXMM@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
_pTerrain$2 = -24					; size = 4
$T3 = -20						; size = 4
_rOutdoorMapCoord$ = -16				; size = 4
_rkMap$ = -12						; size = 4
_byTerrainNum$4 = -8					; size = 1
_this$ = -4						; size = 4
_fCenterX$ = 8						; size = 4
_fCenterY$ = 12						; size = 4
?SetCenterPosition@CPythonMiniMap@@QAEXMM@Z PROC	; CPythonMiniMap::SetCenterPosition, COMDAT
; _this$ = ecx

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 68   : 	m_fCenterX = fCenterX;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fCenterX$[ebp]
  00011	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 69   : 	m_fCenterY = fCenterY;

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fCenterY$[ebp]
  0001e	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  00028	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 71   : 	CMapOutdoor& rkMap = CPythonBackground::Instance().GetMapOutdoorRef();

  0002b	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  0002e	e8 00 00 00 00	 call	 ?GetMapOutdoorRef@CMapManager@@QAEAAVCMapOutdoor@@XZ ; CMapManager::GetMapOutdoorRef
  00033	89 45 f4	 mov	 DWORD PTR _rkMap$[ebp], eax

; 72   : 	for (BYTE byTerrainNum = 0; byTerrainNum < AROUND_AREA_NUM; ++byTerrainNum)

  00036	c6 45 f8 00	 mov	 BYTE PTR _byTerrainNum$4[ebp], 0
  0003a	eb 08		 jmp	 SHORT $LN4@SetCenterP
$LN2@SetCenterP:
  0003c	8a 45 f8	 mov	 al, BYTE PTR _byTerrainNum$4[ebp]
  0003f	04 01		 add	 al, 1
  00041	88 45 f8	 mov	 BYTE PTR _byTerrainNum$4[ebp], al
$LN4@SetCenterP:
  00044	0f b6 45 f8	 movzx	 eax, BYTE PTR _byTerrainNum$4[ebp]
  00048	83 f8 09	 cmp	 eax, 9
  0004b	7d 3b		 jge	 SHORT $LN3@SetCenterP

; 73   : 	{
; 74   : 		m_lpMiniMapTexture[byTerrainNum] = NULL;

  0004d	0f b6 45 f8	 movzx	 eax, BYTE PTR _byTerrainNum$4[ebp]
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	83 64 81 30 00	 and	 DWORD PTR [ecx+eax*4+48], 0

; 75   : 		CTerrain * pTerrain;
; 76   : 		if (rkMap.GetTerrainPointer(byTerrainNum, &pTerrain))

  00059	8d 45 e8	 lea	 eax, DWORD PTR _pTerrain$2[ebp]
  0005c	50		 push	 eax
  0005d	ff 75 f8	 push	 DWORD PTR _byTerrainNum$4[ebp]
  00060	8b 4d f4	 mov	 ecx, DWORD PTR _rkMap$[ebp]
  00063	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  00068	85 c0		 test	 eax, eax
  0006a	74 1a		 je	 SHORT $LN5@SetCenterP
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\gamelib\AreaTerrain.h

; 81   : 		inline LPDIRECT3DTEXTURE8	GetMiniMapTexture() { return m_lpMiniMapTexture; }

  0006c	8b 45 e8	 mov	 eax, DWORD PTR _pTerrain$2[ebp]
  0006f	8b 80 b4 a5 06
	00		 mov	 eax, DWORD PTR [eax+435636]
  00075	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 77   : 			m_lpMiniMapTexture[byTerrainNum] = pTerrain->GetMiniMapTexture();

  00078	0f b6 45 f8	 movzx	 eax, BYTE PTR _byTerrainNum$4[ebp]
  0007c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	8b 55 e4	 mov	 edx, DWORD PTR $T1[ebp]
  00082	89 54 81 30	 mov	 DWORD PTR [ecx+eax*4+48], edx
$LN5@SetCenterP:

; 78   : 	}

  00086	eb b4		 jmp	 SHORT $LN2@SetCenterP
$LN3@SetCenterP:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\gamelib\MapOutdoor.h

; 260  : 		const TOutdoorMapCoordinate & GetCurCoordinate() { return m_CurCoordinate; }

  00088	8b 45 f4	 mov	 eax, DWORD PTR _rkMap$[ebp]
  0008b	83 c0 74	 add	 eax, 116		; 00000074H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 80   : 	const TOutdoorMapCoordinate & rOutdoorMapCoord = rkMap.GetCurCoordinate();

  0008e	89 45 f0	 mov	 DWORD PTR _rOutdoorMapCoord$[ebp], eax

; 81   : 
; 82   : 	m_fCenterCellX = (m_fCenterX - (float)(rOutdoorMapCoord.m_sTerrainCoordX * CTerrainImpl::TERRAIN_XSIZE)) / (float)(CTerrainImpl::CELLSCALE);

  00091	8b 45 f0	 mov	 eax, DWORD PTR _rOutdoorMapCoord$[ebp]
  00094	0f bf 00	 movsx	 eax, WORD PTR [eax]
  00097	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  0009d	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	f3 0f 10 48 14	 movss	 xmm1, DWORD PTR [eax+20]
  000a9	f3 0f 5c c8	 subss	 xmm1, xmm0
  000ad	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@43480000
  000b5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b8	f3 0f 11 48 1c	 movss	 DWORD PTR [eax+28], xmm1

; 83   : 	m_fCenterCellY = (m_fCenterY - (float)(rOutdoorMapCoord.m_sTerrainCoordY * CTerrainImpl::TERRAIN_YSIZE)) / (float)(CTerrainImpl::CELLSCALE);

  000bd	8b 45 f0	 mov	 eax, DWORD PTR _rOutdoorMapCoord$[ebp]
  000c0	0f bf 40 02	 movsx	 eax, WORD PTR [eax+2]
  000c4	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  000ca	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000ce	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d1	f3 0f 10 48 18	 movss	 xmm1, DWORD PTR [eax+24]
  000d6	f3 0f 5c c8	 subss	 xmm1, xmm0
  000da	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@43480000
  000e2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e5	f3 0f 11 48 20	 movss	 DWORD PTR [eax+32], xmm1

; 84   : 
; 85   : 	__SetPosition();

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	e8 00 00 00 00	 call	 ?__SetPosition@CPythonMiniMap@@IAEXXZ ; CPythonMiniMap::__SetPosition

; 86   : }

  000f2	c9		 leave
  000f3	c2 08 00	 ret	 8
?SetCenterPosition@CPythonMiniMap@@QAEXMM@Z ENDP	; CPythonMiniMap::SetCenterPosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?ScaleDown@CPythonMiniMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ScaleDown@CPythonMiniMap@@QAEXXZ PROC			; CPythonMiniMap::ScaleDown, COMDAT
; _this$ = ecx

; 503  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 504  : 	m_fScale *= 0.5f;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  0000f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 505  : 	if (m_fScale <= 0.5f)

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0002a	0f 2f 40 10	 comiss	 xmm0, DWORD PTR [eax+16]
  0002e	72 10		 jb	 SHORT $LN2@ScaleDown

; 506  : 		m_fScale = 0.5f;

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0003b	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0
$LN2@ScaleDown:

; 507  : 	__SetPosition();

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?__SetPosition@CPythonMiniMap@@IAEXXZ ; CPythonMiniMap::__SetPosition

; 508  : }

  00048	c9		 leave
  00049	c3		 ret	 0
?ScaleDown@CPythonMiniMap@@QAEXXZ ENDP			; CPythonMiniMap::ScaleDown
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?ScaleUp@CPythonMiniMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ScaleUp@CPythonMiniMap@@QAEXXZ PROC			; CPythonMiniMap::ScaleUp, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	m_fScale *= 2.0f;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  0000f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 497  : 	if (m_fScale >= 4.0f)

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00027	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@40800000
  0002e	72 10		 jb	 SHORT $LN2@ScaleUp

; 498  : 		m_fScale = 4.0f;

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40800000
  0003b	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0
$LN2@ScaleUp:

; 499  : 	__SetPosition();

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?__SetPosition@CPythonMiniMap@@IAEXXZ ; CPythonMiniMap::__SetPosition

; 500  : }

  00048	c9		 leave
  00049	c3		 ret	 0
?ScaleUp@CPythonMiniMap@@QAEXXZ ENDP			; CPythonMiniMap::ScaleUp
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?SetScale@CPythonMiniMap@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fScale$ = 8						; size = 4
?SetScale@CPythonMiniMap@@QAEXM@Z PROC			; CPythonMiniMap::SetScale, COMDAT
; _this$ = ecx

; 484  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 485  : 	if (fScale >= 4.0f)

  00007	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fScale$[ebp]
  0000c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@40800000
  00013	72 0d		 jb	 SHORT $LN2@SetScale

; 486  : 		fScale = 4.0f;

  00015	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40800000
  0001d	f3 0f 11 45 08	 movss	 DWORD PTR _fScale$[ebp], xmm0
$LN2@SetScale:

; 487  : 	if (fScale <= 0.5f)

  00022	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0002a	0f 2f 45 08	 comiss	 xmm0, DWORD PTR _fScale$[ebp]
  0002e	72 0d		 jb	 SHORT $LN3@SetScale

; 488  : 		fScale = 0.5f;

  00030	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00038	f3 0f 11 45 08	 movss	 DWORD PTR _fScale$[ebp], xmm0
$LN3@SetScale:

; 489  : 	m_fScale = fScale;

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fScale$[ebp]
  00045	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 490  : 
; 491  : 	__SetPosition();

  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?__SetPosition@CPythonMiniMap@@IAEXXZ ; CPythonMiniMap::__SetPosition

; 492  : }

  00052	c9		 leave
  00053	c2 04 00	 ret	 4
?SetScale@CPythonMiniMap@@QAEXM@Z ENDP			; CPythonMiniMap::SetScale
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?SetMiniMapSize@CPythonMiniMap@@QAEXMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fWidth$ = 8						; size = 4
_fHeight$ = 12						; size = 4
?SetMiniMapSize@CPythonMiniMap@@QAEXMM@Z PROC		; CPythonMiniMap::SetMiniMapSize, COMDAT
; _this$ = ecx

; 511  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 512  : 	m_fWidth = fWidth;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fWidth$[ebp]
  0000f	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 513  : 	m_fHeight = fHeight;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fHeight$[ebp]
  0001c	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 514  : }

  00021	c9		 leave
  00022	c2 08 00	 ret	 8
?SetMiniMapSize@CPythonMiniMap@@QAEXMM@Z ENDP		; CPythonMiniMap::SetMiniMapSize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?CanShowAtlas@CPythonMiniMap@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CanShowAtlas@CPythonMiniMap@@QAE_NXZ PROC		; CPythonMiniMap::CanShowAtlas, COMDAT
; _this$ = ecx

; 1403 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1404 : 	return m_bShowAtlas;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 80 68 02 00
	00		 mov	 al, BYTE PTR [eax+616]

; 1405 : }

  00010	c9		 leave
  00011	c3		 ret	 0
?CanShowAtlas@CPythonMiniMap@@QAE_NXZ ENDP		; CPythonMiniMap::CanShowAtlas
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?CanShow@CPythonMiniMap@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CanShow@CPythonMiniMap@@QAE_NXZ PROC			; CPythonMiniMap::CanShow, COMDAT
; _this$ = ecx

; 1408 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1409 : 	return m_bShow;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 80 71 01 00
	00		 mov	 al, BYTE PTR [eax+369]

; 1410 : }

  00010	c9		 leave
  00011	c3		 ret	 0
?CanShow@CPythonMiniMap@@QAE_NXZ ENDP			; CPythonMiniMap::CanShow
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?IsAtlas@CPythonMiniMap@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAtlas@CPythonMiniMap@@QAE_NXZ PROC			; CPythonMiniMap::IsAtlas, COMDAT
; _this$ = ecx

; 1388 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1389 : 	return m_bAtlas;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 80 70 01 00
	00		 mov	 al, BYTE PTR [eax+368]

; 1390 : }

  00010	c9		 leave
  00011	c3		 ret	 0
?IsAtlas@CPythonMiniMap@@QAE_NXZ ENDP			; CPythonMiniMap::IsAtlas
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?Create@CPythonMiniMap@@QAE_NXZ
_TEXT	SEGMENT
_pIndices$ = -104					; size = 4
_lpOrigMiniMapVertex$ = -100				; size = 4
$T2 = -96						; size = 4
$T3 = -92						; size = 4
$T4 = -88						; size = 4
$T5 = -84						; size = 4
$T6 = -80						; size = 4
$T7 = -76						; size = 4
$T8 = -72						; size = 4
$T9 = -68						; size = 4
_pSubImage$ = -64					; size = 4
_pImage$ = -60						; size = 4
_fY$10 = -56						; size = 4
_fX$11 = -52						; size = 4
_iX$12 = -48						; size = 4
_iY$13 = -44						; size = 4
_k$14 = -40						; size = 4
_j$15 = -36						; size = 4
_i$16 = -32						; size = 4
$T17 = -27						; size = 1
$T18 = -26						; size = 1
$T19 = -25						; size = 1
_pchMiniMapVertex$20 = -24				; size = 4
_this$ = -20						; size = 4
_lpMiniMapVertex$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strImageFilter$ = 0					; size = 24
_strImageCamera$ = 24					; size = 24
_strPlayerMark$ = 48					; size = 24
_strWhiteMark$ = 72					; size = 24
_strImageRoot$ = 96					; size = 24
_buf$ = 120						; size = 256
_pwIndices$ = 376					; size = 108
__$ArrayPad$ = 484					; size = 4
?Create@CPythonMiniMap@@QAE_NXZ PROC			; CPythonMiniMap::Create, COMDAT
; _this$ = ecx

; 526  : {

  00000	55		 push	 ebp
  00001	8d ac 24 18 fe
	ff ff		 lea	 ebp, DWORD PTR [esp-488]
  00008	81 ec e8 01 00
	00		 sub	 esp, 488		; 000001e8H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?Create@CPythonMiniMap@@QAE_NXZ
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	83 ec 5c	 sub	 esp, 92			; 0000005cH
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 85 e4 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 527  : 	const std::string strImageRoot = "D:/ymir work/ui/";

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FOBBAEMC@D?3?1ymir?5work?1ui?1@
  0003e	8d 4d 60	 lea	 ecx, DWORD PTR _strImageRoot$[ebp]
  00041	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00046	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 528  : 	const std::string strImageFilter = strImageRoot + "minimap_image_filter.dds";

  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@NLDABMC@minimap_image_filter?4dds@
  0004f	8d 45 60	 lea	 eax, DWORD PTR _strImageRoot$[ebp]
  00052	50		 push	 eax
  00053	8d 45 00	 lea	 eax, DWORD PTR _strImageFilter$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 529  : 	const std::string strImageCamera = strImageRoot + "minimap_camera.dds";

  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@BAIINCPI@minimap_camera?4dds@
  00068	8d 45 60	 lea	 eax, DWORD PTR _strImageRoot$[ebp]
  0006b	50		 push	 eax
  0006c	8d 45 18	 lea	 eax, DWORD PTR _strImageCamera$[ebp]
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH
  00078	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 530  : 	const std::string strPlayerMark = strImageRoot + "minimap/playermark.sub";

  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@IALDDMEN@minimap?1playermark?4sub@
  00081	8d 45 60	 lea	 eax, DWORD PTR _strImageRoot$[ebp]
  00084	50		 push	 eax
  00085	8d 45 30	 lea	 eax, DWORD PTR _strPlayerMark$[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00091	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 531  : 	const std::string strWhiteMark = strImageRoot + "minimap/whitemark.sub";

  00095	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@ODEIMIMD@minimap?1whitemark?4sub@
  0009a	8d 45 60	 lea	 eax, DWORD PTR _strImageRoot$[ebp]
  0009d	50		 push	 eax
  0009e	8d 45 48	 lea	 eax, DWORD PTR _strWhiteMark$[ebp]
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000aa	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  000ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  000b3	89 45 bc	 mov	 DWORD PTR $T9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 534  : 	CGraphicImage * pImage = (CGraphicImage *) CResourceManager::Instance().GetResourcePointer(strImageFilter.c_str());

  000b6	8d 4d 00	 lea	 ecx, DWORD PTR _strImageFilter$[ebp]
  000b9	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  000be	50		 push	 eax
  000bf	8b 4d bc	 mov	 ecx, DWORD PTR $T9[ebp]
  000c2	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  000c7	89 45 c4	 mov	 DWORD PTR _pImage$[ebp], eax

; 535  : 	m_MiniMapFilterGraphicImageInstance.SetImagePointer(pImage);

  000ca	ff 75 c4	 push	 DWORD PTR _pImage$[ebp]
  000cd	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	83 c1 54	 add	 ecx, 84			; 00000054H
  000d3	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  000d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  000dd	89 45 b8	 mov	 DWORD PTR $T8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 536  : 	pImage = (CGraphicImage *) CResourceManager::Instance().GetResourcePointer(strImageCamera.c_str());

  000e0	8d 4d 18	 lea	 ecx, DWORD PTR _strImageCamera$[ebp]
  000e3	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  000e8	50		 push	 eax
  000e9	8b 4d b8	 mov	 ecx, DWORD PTR $T8[ebp]
  000ec	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  000f1	89 45 c4	 mov	 DWORD PTR _pImage$[ebp], eax

; 537  : 	m_MiniMapCameraraphicImageInstance.SetImagePointer(pImage);

  000f4	ff 75 c4	 push	 DWORD PTR _pImage$[ebp]
  000f7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fa	83 c1 74	 add	 ecx, 116		; 00000074H
  000fd	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer

; 538  : 
; 539  : 	m_matMiniMapCover._11 = 1.0f / ((float)m_MiniMapFilterGraphicImageInstance.GetWidth());

  00102	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	83 c1 54	 add	 ecx, 84			; 00000054H
  00108	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  0010d	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00111	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00119	f3 0f 5e c8	 divss	 xmm1, xmm0
  0011d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00120	f3 0f 11 88 28
	02 00 00	 movss	 DWORD PTR [eax+552], xmm1

; 540  : 	m_matMiniMapCover._22 = 1.0f / ((float)m_MiniMapFilterGraphicImageInstance.GetHeight());

  00128	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012b	83 c1 54	 add	 ecx, 84			; 00000054H
  0012e	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  00133	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00137	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0013f	f3 0f 5e c8	 divss	 xmm1, xmm0
  00143	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00146	f3 0f 11 88 3c
	02 00 00	 movss	 DWORD PTR [eax+572], xmm1

; 541  : 	m_matMiniMapCover._33 = 0.0f;

  0014e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00151	0f 57 c0	 xorps	 xmm0, xmm0
  00154	f3 0f 11 80 50
	02 00 00	 movss	 DWORD PTR [eax+592], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0015c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  00161	89 45 b4	 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 544  : 	CGraphicSubImage * pSubImage = (CGraphicSubImage *) CResourceManager::Instance().GetResourcePointer(strPlayerMark.c_str());

  00164	8d 4d 30	 lea	 ecx, DWORD PTR _strPlayerMark$[ebp]
  00167	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0016c	50		 push	 eax
  0016d	8b 4d b4	 mov	 ecx, DWORD PTR $T7[ebp]
  00170	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  00175	89 45 c0	 mov	 DWORD PTR _pSubImage$[ebp], eax

; 545  : 	m_PlayerMark.SetImagePointer(pSubImage);

  00178	ff 75 c0	 push	 DWORD PTR _pSubImage$[ebp]
  0017b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0017e	81 c1 c0 00 00
	00		 add	 ecx, 192		; 000000c0H
  00184	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00189	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  0018e	89 45 b0	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 547  : 	pSubImage = (CGraphicSubImage *) CResourceManager::Instance().GetResourcePointer(strWhiteMark.c_str());

  00191	8d 4d 48	 lea	 ecx, DWORD PTR _strWhiteMark$[ebp]
  00194	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00199	50		 push	 eax
  0019a	8b 4d b0	 mov	 ecx, DWORD PTR $T6[ebp]
  0019d	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  001a2	89 45 c0	 mov	 DWORD PTR _pSubImage$[ebp], eax

; 548  : 	m_WhiteMark.SetImagePointer(pSubImage);

  001a5	ff 75 c0	 push	 DWORD PTR _pSubImage$[ebp]
  001a8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001ab	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  001b1	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer

; 549  : 
; 550  : 	char buf[256];
; 551  : 	for (int i = 0; i < MINI_WAYPOINT_IMAGE_COUNT; ++i)

  001b6	83 65 e0 00	 and	 DWORD PTR _i$16[ebp], 0
  001ba	eb 07		 jmp	 SHORT $LN4@Create
$LN2@Create:
  001bc	8b 45 e0	 mov	 eax, DWORD PTR _i$16[ebp]
  001bf	40		 inc	 eax
  001c0	89 45 e0	 mov	 DWORD PTR _i$16[ebp], eax
$LN4@Create:
  001c3	83 7d e0 0c	 cmp	 DWORD PTR _i$16[ebp], 12 ; 0000000cH
  001c7	7d 5e		 jge	 SHORT $LN3@Create

; 552  : 	{
; 553  : 		sprintf(buf, "%sminimap/mini_waypoint%02d.sub", strImageRoot.c_str(), i+1);

  001c9	8b 45 e0	 mov	 eax, DWORD PTR _i$16[ebp]
  001cc	40		 inc	 eax
  001cd	50		 push	 eax
  001ce	8d 4d 60	 lea	 ecx, DWORD PTR _strImageRoot$[ebp]
  001d1	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  001d6	50		 push	 eax
  001d7	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@MEBBNPAF@?$CFsminimap?1mini_waypoint?$CF02d?4sub@
  001dc	8d 45 78	 lea	 eax, DWORD PTR _buf$[ebp]
  001df	50		 push	 eax
  001e0	e8 00 00 00 00	 call	 _sprintf
  001e5	83 c4 10	 add	 esp, 16			; 00000010H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  001e8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  001ed	89 45 ac	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 554  : 		m_MiniWayPointGraphicImageInstances[i].SetImagePointer((CGraphicSubImage *) CResourceManager::Instance().GetResourcePointer(buf));

  001f0	8d 45 78	 lea	 eax, DWORD PTR _buf$[ebp]
  001f3	50		 push	 eax
  001f4	8b 4d ac	 mov	 ecx, DWORD PTR $T5[ebp]
  001f7	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  001fc	50		 push	 eax
  001fd	6b 45 e0 4c	 imul	 eax, DWORD PTR _i$16[ebp], 76
  00201	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00204	8d 8c 01 54 03
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+852]
  0020b	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer

; 555  : 		m_MiniWayPointGraphicImageInstances[i].SetRenderingMode(CGraphicExpandedImageInstance::RENDERING_MODE_SCREEN);

  00210	6a 01		 push	 1
  00212	6b 45 e0 4c	 imul	 eax, DWORD PTR _i$16[ebp], 76
  00216	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00219	8d 8c 01 54 03
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+852]
  00220	e8 00 00 00 00	 call	 ?SetRenderingMode@CGraphicExpandedImageInstance@@QAEXH@Z ; CGraphicExpandedImageInstance::SetRenderingMode

; 556  : 	}

  00225	eb 95		 jmp	 SHORT $LN2@Create
$LN3@Create:

; 557  : 	for (int j = 0; j < WAYPOINT_IMAGE_COUNT; ++j)

  00227	83 65 dc 00	 and	 DWORD PTR _j$15[ebp], 0
  0022b	eb 07		 jmp	 SHORT $LN7@Create
$LN5@Create:
  0022d	8b 45 dc	 mov	 eax, DWORD PTR _j$15[ebp]
  00230	40		 inc	 eax
  00231	89 45 dc	 mov	 DWORD PTR _j$15[ebp], eax
$LN7@Create:
  00234	83 7d dc 0f	 cmp	 DWORD PTR _j$15[ebp], 15 ; 0000000fH
  00238	7d 5e		 jge	 SHORT $LN6@Create

; 558  : 	{
; 559  : 		sprintf(buf, "%sminimap/waypoint%02d.sub", strImageRoot.c_str(), j+1);

  0023a	8b 45 dc	 mov	 eax, DWORD PTR _j$15[ebp]
  0023d	40		 inc	 eax
  0023e	50		 push	 eax
  0023f	8d 4d 60	 lea	 ecx, DWORD PTR _strImageRoot$[ebp]
  00242	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00247	50		 push	 eax
  00248	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@CILDCNBH@?$CFsminimap?1waypoint?$CF02d?4sub@
  0024d	8d 45 78	 lea	 eax, DWORD PTR _buf$[ebp]
  00250	50		 push	 eax
  00251	e8 00 00 00 00	 call	 _sprintf
  00256	83 c4 10	 add	 esp, 16			; 00000010H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00259	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  0025e	89 45 a8	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 560  : 		m_WayPointGraphicImageInstances[j].SetImagePointer((CGraphicSubImage *) CResourceManager::Instance().GetResourcePointer(buf));

  00261	8d 45 78	 lea	 eax, DWORD PTR _buf$[ebp]
  00264	50		 push	 eax
  00265	8b 4d a8	 mov	 ecx, DWORD PTR $T4[ebp]
  00268	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  0026d	50		 push	 eax
  0026e	6b 45 dc 4c	 imul	 eax, DWORD PTR _j$15[ebp], 76
  00272	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00275	8d 8c 01 e4 06
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+1764]
  0027c	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer

; 561  : 		m_WayPointGraphicImageInstances[j].SetRenderingMode(CGraphicExpandedImageInstance::RENDERING_MODE_SCREEN);

  00281	6a 01		 push	 1
  00283	6b 45 dc 4c	 imul	 eax, DWORD PTR _j$15[ebp], 76
  00287	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0028a	8d 8c 01 e4 06
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+1764]
  00291	e8 00 00 00 00	 call	 ?SetRenderingMode@CGraphicExpandedImageInstance@@QAEXH@Z ; CGraphicExpandedImageInstance::SetRenderingMode

; 562  : 	}

  00296	eb 95		 jmp	 SHORT $LN5@Create
$LN6@Create:

; 563  : 	for (int k = 0; k < TARGET_MARK_IMAGE_COUNT; ++k)

  00298	83 65 d8 00	 and	 DWORD PTR _k$14[ebp], 0
  0029c	eb 07		 jmp	 SHORT $LN10@Create
$LN8@Create:
  0029e	8b 45 d8	 mov	 eax, DWORD PTR _k$14[ebp]
  002a1	40		 inc	 eax
  002a2	89 45 d8	 mov	 DWORD PTR _k$14[ebp], eax
$LN10@Create:
  002a5	83 7d d8 02	 cmp	 DWORD PTR _k$14[ebp], 2
  002a9	7d 5e		 jge	 SHORT $LN9@Create

; 564  : 	{
; 565  : 		sprintf(buf, "%sminimap/targetmark%02d.sub", strImageRoot.c_str(), k+1);

  002ab	8b 45 d8	 mov	 eax, DWORD PTR _k$14[ebp]
  002ae	40		 inc	 eax
  002af	50		 push	 eax
  002b0	8d 4d 60	 lea	 ecx, DWORD PTR _strImageRoot$[ebp]
  002b3	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  002b8	50		 push	 eax
  002b9	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@MHOOKNLA@?$CFsminimap?1targetmark?$CF02d?4sub@
  002be	8d 45 78	 lea	 eax, DWORD PTR _buf$[ebp]
  002c1	50		 push	 eax
  002c2	e8 00 00 00 00	 call	 _sprintf
  002c7	83 c4 10	 add	 esp, 16			; 00000010H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  002ca	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  002cf	89 45 a4	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 566  : 		m_TargetMarkGraphicImageInstances[k].SetImagePointer((CGraphicSubImage *) CResourceManager::Instance().GetResourcePointer(buf));

  002d2	8d 45 78	 lea	 eax, DWORD PTR _buf$[ebp]
  002d5	50		 push	 eax
  002d6	8b 4d a4	 mov	 ecx, DWORD PTR $T3[ebp]
  002d9	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  002de	50		 push	 eax
  002df	6b 45 d8 4c	 imul	 eax, DWORD PTR _k$14[ebp], 76
  002e3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002e6	8d 8c 01 58 0b
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+2904]
  002ed	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer

; 567  : 		m_TargetMarkGraphicImageInstances[k].SetRenderingMode(CGraphicExpandedImageInstance::RENDERING_MODE_SCREEN);

  002f2	6a 01		 push	 1
  002f4	6b 45 d8 4c	 imul	 eax, DWORD PTR _k$14[ebp], 76
  002f8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002fb	8d 8c 01 58 0b
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+2904]
  00302	e8 00 00 00 00	 call	 ?SetRenderingMode@CGraphicExpandedImageInstance@@QAEXH@Z ; CGraphicExpandedImageInstance::SetRenderingMode

; 568  : 	}

  00307	eb 95		 jmp	 SHORT $LN8@Create
$LN9@Create:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00309	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  0030e	89 45 a0	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 570  : 	m_GuildAreaFlagImageInstance.SetImagePointer((CGraphicSubImage *) CResourceManager::Instance().GetResourcePointer("d:/ymir work/ui/minimap/GuildArea01.sub"));

  00311	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@EODFAHAD@d?3?1ymir?5work?1ui?1minimap?1GuildAr@
  00316	8b 4d a0	 mov	 ecx, DWORD PTR $T2[ebp]
  00319	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  0031e	50		 push	 eax
  0031f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00322	81 c1 f0 0b 00
	00		 add	 ecx, 3056		; 00000bf0H
  00328	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer

; 571  : 
; 572  : 	//   
; 573  : #pragma pack(push)
; 574  : #pragma pack(1)
; 575  : 	LPMINIMAPVERTEX		lpMiniMapVertex;
; 576  : 	LPMINIMAPVERTEX		lpOrigMiniMapVertex;
; 577  : #pragma pack(pop)
; 578  : 
; 579  : 	if (!m_VertexBuffer.Create(36, D3DFVF_XYZ | D3DFVF_TEX1, D3DUSAGE_WRITEONLY, D3DPOOL_MANAGED) )

  0032d	6a 01		 push	 1
  0032f	6a 08		 push	 8
  00331	68 02 01 00 00	 push	 258			; 00000102H
  00336	6a 24		 push	 36			; 00000024H
  00338	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0033b	81 c1 74 01 00
	00		 add	 ecx, 372		; 00000174H
  00341	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00344	8b 80 74 01 00
	00		 mov	 eax, DWORD PTR [eax+372]
  0034a	ff 50 04	 call	 DWORD PTR [eax+4]
  0034d	0f b6 c0	 movzx	 eax, al
  00350	85 c0		 test	 eax, eax
  00352	75 48		 jne	 SHORT $LN17@Create

; 581  : 		return false;

  00354	c6 45 e7 00	 mov	 BYTE PTR $T19[ebp], 0
  00358	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0035c	8d 4d 48	 lea	 ecx, DWORD PTR _strWhiteMark$[ebp]
  0035f	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 581  : 		return false;

  00364	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00368	8d 4d 30	 lea	 ecx, DWORD PTR _strPlayerMark$[ebp]
  0036b	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 581  : 		return false;

  00370	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00374	8d 4d 18	 lea	 ecx, DWORD PTR _strImageCamera$[ebp]
  00377	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 581  : 		return false;

  0037c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00380	8d 4d 00	 lea	 ecx, DWORD PTR _strImageFilter$[ebp]
  00383	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 581  : 		return false;

  00388	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0038c	8d 4d 60	 lea	 ecx, DWORD PTR _strImageRoot$[ebp]
  0038f	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 581  : 		return false;

  00394	8a 45 e7	 mov	 al, BYTE PTR $T19[ebp]
  00397	e9 2e 05 00 00	 jmp	 $LN1@Create
$LN17@Create:

; 582  : 	}
; 583  : 
; 584  : 	if (m_VertexBuffer.Lock((void **) &lpOrigMiniMapVertex))

  0039c	8d 45 9c	 lea	 eax, DWORD PTR _lpOrigMiniMapVertex$[ebp]
  0039f	50		 push	 eax
  003a0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  003a3	81 c1 74 01 00
	00		 add	 ecx, 372		; 00000174H
  003a9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  003ac	8b 80 74 01 00
	00		 mov	 eax, DWORD PTR [eax+372]
  003b2	ff 50 08	 call	 DWORD PTR [eax+8]
  003b5	0f b6 c0	 movzx	 eax, al
  003b8	85 c0		 test	 eax, eax
  003ba	0f 84 10 02 00
	00		 je	 $LN18@Create

; 585  : 	{		
; 586  : 		char * pchMiniMapVertex = (char *)lpOrigMiniMapVertex;

  003c0	8b 45 9c	 mov	 eax, DWORD PTR _lpOrigMiniMapVertex$[ebp]
  003c3	89 45 e8	 mov	 DWORD PTR _pchMiniMapVertex$20[ebp], eax

; 587  : 		memset(pchMiniMapVertex, 0, sizeof(char) * 720);

  003c6	68 d0 02 00 00	 push	 720			; 000002d0H
  003cb	6a 00		 push	 0
  003cd	ff 75 e8	 push	 DWORD PTR _pchMiniMapVertex$20[ebp]
  003d0	e8 00 00 00 00	 call	 _memset
  003d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 588  : 		lpMiniMapVertex = (LPMINIMAPVERTEX) pchMiniMapVertex;

  003d8	8b 45 e8	 mov	 eax, DWORD PTR _pchMiniMapVertex$20[ebp]
  003db	89 45 f0	 mov	 DWORD PTR _lpMiniMapVertex$[ebp], eax

; 589  : 
; 590  : 		for (int iY = -3; iY <= 1; ++iY)

  003de	c7 45 d4 fd ff
	ff ff		 mov	 DWORD PTR _iY$13[ebp], -3 ; fffffffdH
  003e5	eb 07		 jmp	 SHORT $LN13@Create
$LN11@Create:
  003e7	8b 45 d4	 mov	 eax, DWORD PTR _iY$13[ebp]
  003ea	40		 inc	 eax
  003eb	89 45 d4	 mov	 DWORD PTR _iY$13[ebp], eax
$LN13@Create:
  003ee	83 7d d4 01	 cmp	 DWORD PTR _iY$13[ebp], 1
  003f2	0f 8f ca 01 00
	00		 jg	 $LN12@Create

; 591  : 		{
; 592  : 			if (0 == iY%2)

  003f8	8b 45 d4	 mov	 eax, DWORD PTR _iY$13[ebp]
  003fb	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00400	79 05		 jns	 SHORT $LN354@Create
  00402	48		 dec	 eax
  00403	83 c8 fe	 or	 eax, -2			; fffffffeH
  00406	40		 inc	 eax
$LN354@Create:
  00407	85 c0		 test	 eax, eax
  00409	75 02		 jne	 SHORT $LN19@Create

; 593  : 				continue;

  0040b	eb da		 jmp	 SHORT $LN11@Create
$LN19@Create:

; 594  : 			float fY = 0.5f * ((float)iY);

  0040d	f3 0f 2a 45 d4	 cvtsi2ss xmm0, DWORD PTR _iY$13[ebp]
  00412	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0041a	f3 0f 11 45 c8	 movss	 DWORD PTR _fY$10[ebp], xmm0

; 595  : 			for (int iX = -3; iX <= 1; ++iX)

  0041f	c7 45 d0 fd ff
	ff ff		 mov	 DWORD PTR _iX$12[ebp], -3 ; fffffffdH
  00426	eb 07		 jmp	 SHORT $LN16@Create
$LN14@Create:
  00428	8b 45 d0	 mov	 eax, DWORD PTR _iX$12[ebp]
  0042b	40		 inc	 eax
  0042c	89 45 d0	 mov	 DWORD PTR _iX$12[ebp], eax
$LN16@Create:
  0042f	83 7d d0 01	 cmp	 DWORD PTR _iX$12[ebp], 1
  00433	0f 8f 84 01 00
	00		 jg	 $LN15@Create

; 596  : 			{
; 597  : 				if (0 == iX%2)

  00439	8b 45 d0	 mov	 eax, DWORD PTR _iX$12[ebp]
  0043c	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00441	79 05		 jns	 SHORT $LN355@Create
  00443	48		 dec	 eax
  00444	83 c8 fe	 or	 eax, -2			; fffffffeH
  00447	40		 inc	 eax
$LN355@Create:
  00448	85 c0		 test	 eax, eax
  0044a	75 02		 jne	 SHORT $LN20@Create

; 598  : 					continue;

  0044c	eb da		 jmp	 SHORT $LN14@Create
$LN20@Create:

; 599  : 				float fX = 0.5f * ((float)iX);

  0044e	f3 0f 2a 45 d0	 cvtsi2ss xmm0, DWORD PTR _iX$12[ebp]
  00453	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0045b	f3 0f 11 45 cc	 movss	 DWORD PTR _fX$11[ebp], xmm0

; 600  : 				lpMiniMapVertex = (LPMINIMAPVERTEX) pchMiniMapVertex;

  00460	8b 45 e8	 mov	 eax, DWORD PTR _pchMiniMapVertex$20[ebp]
  00463	89 45 f0	 mov	 DWORD PTR _lpMiniMapVertex$[ebp], eax

; 601  : 				lpMiniMapVertex->x = fX;

  00466	8b 45 f0	 mov	 eax, DWORD PTR _lpMiniMapVertex$[ebp]
  00469	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _fX$11[ebp]
  0046e	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 602  : 				lpMiniMapVertex->y = fY;

  00472	8b 45 f0	 mov	 eax, DWORD PTR _lpMiniMapVertex$[ebp]
  00475	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _fY$10[ebp]
  0047a	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 603  : 				lpMiniMapVertex->z = 0.0f;

  0047f	8b 45 f0	 mov	 eax, DWORD PTR _lpMiniMapVertex$[ebp]
  00482	0f 57 c0	 xorps	 xmm0, xmm0
  00485	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 604  : 				lpMiniMapVertex->u = 0.0f;

  0048a	8b 45 f0	 mov	 eax, DWORD PTR _lpMiniMapVertex$[ebp]
  0048d	0f 57 c0	 xorps	 xmm0, xmm0
  00490	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 605  : 				lpMiniMapVertex->v = 0.0f;

  00495	8b 45 f0	 mov	 eax, DWORD PTR _lpMiniMapVertex$[ebp]
  00498	0f 57 c0	 xorps	 xmm0, xmm0
  0049b	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 606  : 				pchMiniMapVertex += 20;

  004a0	8b 45 e8	 mov	 eax, DWORD PTR _pchMiniMapVertex$20[ebp]
  004a3	83 c0 14	 add	 eax, 20			; 00000014H
  004a6	89 45 e8	 mov	 DWORD PTR _pchMiniMapVertex$20[ebp], eax

; 607  : 				lpMiniMapVertex = (LPMINIMAPVERTEX) pchMiniMapVertex;

  004a9	8b 45 e8	 mov	 eax, DWORD PTR _pchMiniMapVertex$20[ebp]
  004ac	89 45 f0	 mov	 DWORD PTR _lpMiniMapVertex$[ebp], eax

; 608  : 				lpMiniMapVertex->x = fX;

  004af	8b 45 f0	 mov	 eax, DWORD PTR _lpMiniMapVertex$[ebp]
  004b2	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _fX$11[ebp]
  004b7	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 609  : 				lpMiniMapVertex->y = fY + 1.0f;

  004bb	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _fY$10[ebp]
  004c0	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  004c8	8b 45 f0	 mov	 eax, DWORD PTR _lpMiniMapVertex$[ebp]
  004cb	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 610  : 				lpMiniMapVertex->z = 0.0f;

  004d0	8b 45 f0	 mov	 eax, DWORD PTR _lpMiniMapVertex$[ebp]
  004d3	0f 57 c0	 xorps	 xmm0, xmm0
  004d6	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 611  : 				lpMiniMapVertex->u = 0.0f;

  004db	8b 45 f0	 mov	 eax, DWORD PTR _lpMiniMapVertex$[ebp]
  004de	0f 57 c0	 xorps	 xmm0, xmm0
  004e1	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 612  : 				lpMiniMapVertex->v = 1.0f;

  004e6	8b 45 f0	 mov	 eax, DWORD PTR _lpMiniMapVertex$[ebp]
  004e9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  004f1	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 613  : 				pchMiniMapVertex += 20;

  004f6	8b 45 e8	 mov	 eax, DWORD PTR _pchMiniMapVertex$20[ebp]
  004f9	83 c0 14	 add	 eax, 20			; 00000014H
  004fc	89 45 e8	 mov	 DWORD PTR _pchMiniMapVertex$20[ebp], eax

; 614  : 				lpMiniMapVertex = (LPMINIMAPVERTEX) pchMiniMapVertex;

  004ff	8b 45 e8	 mov	 eax, DWORD PTR _pchMiniMapVertex$20[ebp]
  00502	89 45 f0	 mov	 DWORD PTR _lpMiniMapVertex$[ebp], eax

; 615  : 				lpMiniMapVertex->x = fX + 1.0f;

  00505	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _fX$11[ebp]
  0050a	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00512	8b 45 f0	 mov	 eax, DWORD PTR _lpMiniMapVertex$[ebp]
  00515	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 616  : 				lpMiniMapVertex->y = fY;

  00519	8b 45 f0	 mov	 eax, DWORD PTR _lpMiniMapVertex$[ebp]
  0051c	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _fY$10[ebp]
  00521	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 617  : 				lpMiniMapVertex->z = 0.0f;

  00526	8b 45 f0	 mov	 eax, DWORD PTR _lpMiniMapVertex$[ebp]
  00529	0f 57 c0	 xorps	 xmm0, xmm0
  0052c	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 618  : 				lpMiniMapVertex->u = 1.0f;

  00531	8b 45 f0	 mov	 eax, DWORD PTR _lpMiniMapVertex$[ebp]
  00534	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0053c	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 619  : 				lpMiniMapVertex->v = 0.0f;

  00541	8b 45 f0	 mov	 eax, DWORD PTR _lpMiniMapVertex$[ebp]
  00544	0f 57 c0	 xorps	 xmm0, xmm0
  00547	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 620  : 				pchMiniMapVertex += 20;

  0054c	8b 45 e8	 mov	 eax, DWORD PTR _pchMiniMapVertex$20[ebp]
  0054f	83 c0 14	 add	 eax, 20			; 00000014H
  00552	89 45 e8	 mov	 DWORD PTR _pchMiniMapVertex$20[ebp], eax

; 621  : 				lpMiniMapVertex = (LPMINIMAPVERTEX) pchMiniMapVertex;

  00555	8b 45 e8	 mov	 eax, DWORD PTR _pchMiniMapVertex$20[ebp]
  00558	89 45 f0	 mov	 DWORD PTR _lpMiniMapVertex$[ebp], eax

; 622  : 				lpMiniMapVertex->x = fX + 1.0f;

  0055b	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _fX$11[ebp]
  00560	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00568	8b 45 f0	 mov	 eax, DWORD PTR _lpMiniMapVertex$[ebp]
  0056b	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 623  : 				lpMiniMapVertex->y = fY + 1.0f;

  0056f	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _fY$10[ebp]
  00574	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  0057c	8b 45 f0	 mov	 eax, DWORD PTR _lpMiniMapVertex$[ebp]
  0057f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 624  : 				lpMiniMapVertex->z = 0.0f;

  00584	8b 45 f0	 mov	 eax, DWORD PTR _lpMiniMapVertex$[ebp]
  00587	0f 57 c0	 xorps	 xmm0, xmm0
  0058a	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 625  : 				lpMiniMapVertex->u = 1.0f;

  0058f	8b 45 f0	 mov	 eax, DWORD PTR _lpMiniMapVertex$[ebp]
  00592	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0059a	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 626  : 				lpMiniMapVertex->v = 1.0f;

  0059f	8b 45 f0	 mov	 eax, DWORD PTR _lpMiniMapVertex$[ebp]
  005a2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  005aa	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 627  : 				pchMiniMapVertex += 20;

  005af	8b 45 e8	 mov	 eax, DWORD PTR _pchMiniMapVertex$20[ebp]
  005b2	83 c0 14	 add	 eax, 20			; 00000014H
  005b5	89 45 e8	 mov	 DWORD PTR _pchMiniMapVertex$20[ebp], eax

; 628  : 			}

  005b8	e9 6b fe ff ff	 jmp	 $LN14@Create
$LN15@Create:

; 629  : 		}

  005bd	e9 25 fe ff ff	 jmp	 $LN11@Create
$LN12@Create:

; 630  : 
; 631  : 		m_VertexBuffer.Unlock();

  005c2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  005c5	81 c1 74 01 00
	00		 add	 ecx, 372		; 00000174H
  005cb	e8 00 00 00 00	 call	 ?Unlock@CGraphicVertexBuffer@@QAE_NXZ ; CGraphicVertexBuffer::Unlock
$LN18@Create:

; 632  : 	}
; 633  : 	
; 634  : 	if (!m_IndexBuffer.Create(54, D3DFMT_INDEX16))

  005d0	6a 65		 push	 101			; 00000065H
  005d2	6a 36		 push	 54			; 00000036H
  005d4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  005d7	81 c1 94 01 00
	00		 add	 ecx, 404		; 00000194H
  005dd	e8 00 00 00 00	 call	 ?Create@CGraphicIndexBuffer@@QAE_NHW4_D3DFORMAT@@@Z ; CGraphicIndexBuffer::Create
  005e2	0f b6 c0	 movzx	 eax, al
  005e5	85 c0		 test	 eax, eax
  005e7	75 48		 jne	 SHORT $LN21@Create

; 636  : 		return false;

  005e9	c6 45 e6 00	 mov	 BYTE PTR $T18[ebp], 0
  005ed	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  005f1	8d 4d 48	 lea	 ecx, DWORD PTR _strWhiteMark$[ebp]
  005f4	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 636  : 		return false;

  005f9	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  005fd	8d 4d 30	 lea	 ecx, DWORD PTR _strPlayerMark$[ebp]
  00600	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 636  : 		return false;

  00605	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00609	8d 4d 18	 lea	 ecx, DWORD PTR _strImageCamera$[ebp]
  0060c	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 636  : 		return false;

  00611	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00615	8d 4d 00	 lea	 ecx, DWORD PTR _strImageFilter$[ebp]
  00618	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 636  : 		return false;

  0061d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00621	8d 4d 60	 lea	 ecx, DWORD PTR _strImageRoot$[ebp]
  00624	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 636  : 		return false;

  00629	8a 45 e6	 mov	 al, BYTE PTR $T18[ebp]
  0062c	e9 99 02 00 00	 jmp	 $LN1@Create
$LN21@Create:

; 637  : 	}
; 638  : 
; 639  : 	WORD pwIndices[54] = 
; 640  : 	{
; 641  : 		0, 1, 2, 2, 1, 3,

  00631	33 c0		 xor	 eax, eax
  00633	66 89 85 78 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp], ax
  0063a	33 c0		 xor	 eax, eax
  0063c	40		 inc	 eax
  0063d	66 89 85 7a 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+2], ax
  00644	6a 02		 push	 2
  00646	58		 pop	 eax
  00647	66 89 85 7c 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+4], ax
  0064e	6a 02		 push	 2
  00650	58		 pop	 eax
  00651	66 89 85 7e 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+6], ax
  00658	33 c0		 xor	 eax, eax
  0065a	40		 inc	 eax
  0065b	66 89 85 80 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+8], ax
  00662	6a 03		 push	 3
  00664	58		 pop	 eax
  00665	66 89 85 82 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+10], ax

; 642  : 		4, 5, 6, 6, 5, 7,

  0066c	6a 04		 push	 4
  0066e	58		 pop	 eax
  0066f	66 89 85 84 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+12], ax
  00676	6a 05		 push	 5
  00678	58		 pop	 eax
  00679	66 89 85 86 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+14], ax
  00680	6a 06		 push	 6
  00682	58		 pop	 eax
  00683	66 89 85 88 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+16], ax
  0068a	6a 06		 push	 6
  0068c	58		 pop	 eax
  0068d	66 89 85 8a 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+18], ax
  00694	6a 05		 push	 5
  00696	58		 pop	 eax
  00697	66 89 85 8c 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+20], ax
  0069e	6a 07		 push	 7
  006a0	58		 pop	 eax
  006a1	66 89 85 8e 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+22], ax

; 643  : 		8, 9, 10, 10, 9, 11,

  006a8	6a 08		 push	 8
  006aa	58		 pop	 eax
  006ab	66 89 85 90 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+24], ax
  006b2	6a 09		 push	 9
  006b4	58		 pop	 eax
  006b5	66 89 85 92 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+26], ax
  006bc	6a 0a		 push	 10			; 0000000aH
  006be	58		 pop	 eax
  006bf	66 89 85 94 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+28], ax
  006c6	6a 0a		 push	 10			; 0000000aH
  006c8	58		 pop	 eax
  006c9	66 89 85 96 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+30], ax
  006d0	6a 09		 push	 9
  006d2	58		 pop	 eax
  006d3	66 89 85 98 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+32], ax
  006da	6a 0b		 push	 11			; 0000000bH
  006dc	58		 pop	 eax
  006dd	66 89 85 9a 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+34], ax

; 644  : 		
; 645  : 		12, 13, 14, 14, 13, 15,

  006e4	6a 0c		 push	 12			; 0000000cH
  006e6	58		 pop	 eax
  006e7	66 89 85 9c 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+36], ax
  006ee	6a 0d		 push	 13			; 0000000dH
  006f0	58		 pop	 eax
  006f1	66 89 85 9e 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+38], ax
  006f8	6a 0e		 push	 14			; 0000000eH
  006fa	58		 pop	 eax
  006fb	66 89 85 a0 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+40], ax
  00702	6a 0e		 push	 14			; 0000000eH
  00704	58		 pop	 eax
  00705	66 89 85 a2 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+42], ax
  0070c	6a 0d		 push	 13			; 0000000dH
  0070e	58		 pop	 eax
  0070f	66 89 85 a4 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+44], ax
  00716	6a 0f		 push	 15			; 0000000fH
  00718	58		 pop	 eax
  00719	66 89 85 a6 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+46], ax

; 646  : 		16, 17, 18, 18, 17, 19,

  00720	6a 10		 push	 16			; 00000010H
  00722	58		 pop	 eax
  00723	66 89 85 a8 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+48], ax
  0072a	6a 11		 push	 17			; 00000011H
  0072c	58		 pop	 eax
  0072d	66 89 85 aa 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+50], ax
  00734	6a 12		 push	 18			; 00000012H
  00736	58		 pop	 eax
  00737	66 89 85 ac 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+52], ax
  0073e	6a 12		 push	 18			; 00000012H
  00740	58		 pop	 eax
  00741	66 89 85 ae 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+54], ax
  00748	6a 11		 push	 17			; 00000011H
  0074a	58		 pop	 eax
  0074b	66 89 85 b0 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+56], ax
  00752	6a 13		 push	 19			; 00000013H
  00754	58		 pop	 eax
  00755	66 89 85 b2 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+58], ax

; 647  : 		20, 21, 22, 22, 21, 23,

  0075c	6a 14		 push	 20			; 00000014H
  0075e	58		 pop	 eax
  0075f	66 89 85 b4 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+60], ax
  00766	6a 15		 push	 21			; 00000015H
  00768	58		 pop	 eax
  00769	66 89 85 b6 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+62], ax
  00770	6a 16		 push	 22			; 00000016H
  00772	58		 pop	 eax
  00773	66 89 85 b8 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+64], ax
  0077a	6a 16		 push	 22			; 00000016H
  0077c	58		 pop	 eax
  0077d	66 89 85 ba 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+66], ax
  00784	6a 15		 push	 21			; 00000015H
  00786	58		 pop	 eax
  00787	66 89 85 bc 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+68], ax
  0078e	6a 17		 push	 23			; 00000017H
  00790	58		 pop	 eax
  00791	66 89 85 be 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+70], ax

; 648  : 		
; 649  : 		24, 25, 26, 26, 25, 27,

  00798	6a 18		 push	 24			; 00000018H
  0079a	58		 pop	 eax
  0079b	66 89 85 c0 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+72], ax
  007a2	6a 19		 push	 25			; 00000019H
  007a4	58		 pop	 eax
  007a5	66 89 85 c2 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+74], ax
  007ac	6a 1a		 push	 26			; 0000001aH
  007ae	58		 pop	 eax
  007af	66 89 85 c4 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+76], ax
  007b6	6a 1a		 push	 26			; 0000001aH
  007b8	58		 pop	 eax
  007b9	66 89 85 c6 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+78], ax
  007c0	6a 19		 push	 25			; 00000019H
  007c2	58		 pop	 eax
  007c3	66 89 85 c8 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+80], ax
  007ca	6a 1b		 push	 27			; 0000001bH
  007cc	58		 pop	 eax
  007cd	66 89 85 ca 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+82], ax

; 650  : 		28, 29, 30, 30, 29, 31,

  007d4	6a 1c		 push	 28			; 0000001cH
  007d6	58		 pop	 eax
  007d7	66 89 85 cc 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+84], ax
  007de	6a 1d		 push	 29			; 0000001dH
  007e0	58		 pop	 eax
  007e1	66 89 85 ce 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+86], ax
  007e8	6a 1e		 push	 30			; 0000001eH
  007ea	58		 pop	 eax
  007eb	66 89 85 d0 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+88], ax
  007f2	6a 1e		 push	 30			; 0000001eH
  007f4	58		 pop	 eax
  007f5	66 89 85 d2 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+90], ax
  007fc	6a 1d		 push	 29			; 0000001dH
  007fe	58		 pop	 eax
  007ff	66 89 85 d4 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+92], ax
  00806	6a 1f		 push	 31			; 0000001fH
  00808	58		 pop	 eax
  00809	66 89 85 d6 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+94], ax

; 651  : 		32, 33, 34, 34, 33, 35

  00810	6a 20		 push	 32			; 00000020H
  00812	58		 pop	 eax
  00813	66 89 85 d8 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+96], ax
  0081a	6a 21		 push	 33			; 00000021H
  0081c	58		 pop	 eax
  0081d	66 89 85 da 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+98], ax
  00824	6a 22		 push	 34			; 00000022H
  00826	58		 pop	 eax
  00827	66 89 85 dc 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+100], ax
  0082e	6a 22		 push	 34			; 00000022H
  00830	58		 pop	 eax
  00831	66 89 85 de 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+102], ax
  00838	6a 21		 push	 33			; 00000021H
  0083a	58		 pop	 eax
  0083b	66 89 85 e0 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+104], ax
  00842	6a 23		 push	 35			; 00000023H
  00844	58		 pop	 eax
  00845	66 89 85 e2 01
	00 00		 mov	 WORD PTR _pwIndices$[ebp+106], ax

; 652  : 	};
; 653  : 
; 654  : 	void * pIndices;
; 655  : 		
; 656  : 	if (m_IndexBuffer.Lock(&pIndices))

  0084c	8d 45 98	 lea	 eax, DWORD PTR _pIndices$[ebp]
  0084f	50		 push	 eax
  00850	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00853	81 c1 94 01 00
	00		 add	 ecx, 404		; 00000194H
  00859	e8 00 00 00 00	 call	 ?Lock@CGraphicIndexBuffer@@QAE_NPAPAX@Z ; CGraphicIndexBuffer::Lock
  0085e	0f b6 c0	 movzx	 eax, al
  00861	85 c0		 test	 eax, eax
  00863	74 22		 je	 SHORT $LN22@Create

; 657  : 	{
; 658  : 		memcpy(pIndices, pwIndices, 54 * sizeof(WORD));

  00865	6a 6c		 push	 108			; 0000006cH
  00867	8d 85 78 01 00
	00		 lea	 eax, DWORD PTR _pwIndices$[ebp]
  0086d	50		 push	 eax
  0086e	ff 75 98	 push	 DWORD PTR _pIndices$[ebp]
  00871	e8 00 00 00 00	 call	 _memcpy
  00876	83 c4 0c	 add	 esp, 12			; 0000000cH

; 659  : 		m_IndexBuffer.Unlock();

  00879	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0087c	81 c1 94 01 00
	00		 add	 ecx, 404		; 00000194H
  00882	e8 00 00 00 00	 call	 ?Unlock@CGraphicIndexBuffer@@QAEXXZ ; CGraphicIndexBuffer::Unlock
$LN22@Create:

; 662  : 	return true;

  00887	c6 45 e5 01	 mov	 BYTE PTR $T17[ebp], 1
  0088b	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0088f	8d 4d 48	 lea	 ecx, DWORD PTR _strWhiteMark$[ebp]
  00892	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 662  : 	return true;

  00897	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0089b	8d 4d 30	 lea	 ecx, DWORD PTR _strPlayerMark$[ebp]
  0089e	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 662  : 	return true;

  008a3	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  008a7	8d 4d 18	 lea	 ecx, DWORD PTR _strImageCamera$[ebp]
  008aa	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 662  : 	return true;

  008af	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  008b3	8d 4d 00	 lea	 ecx, DWORD PTR _strImageFilter$[ebp]
  008b6	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 662  : 	return true;

  008bb	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  008bf	8d 4d 60	 lea	 ecx, DWORD PTR _strImageRoot$[ebp]
  008c2	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 662  : 	return true;

  008c7	8a 45 e5	 mov	 al, BYTE PTR $T17[ebp]
$LN1@Create:

; 663  : }

  008ca	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  008cd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  008d4	59		 pop	 ecx
  008d5	8b 8d e4 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008db	33 cd		 xor	 ecx, ebp
  008dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008e2	81 c5 e8 01 00
	00		 add	 ebp, 488		; 000001e8H
  008e8	c9		 leave
  008e9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create@CPythonMiniMap@@QAE_NXZ$0:
  00000	8d 4d 60	 lea	 ecx, DWORD PTR _strImageRoot$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Create@CPythonMiniMap@@QAE_NXZ$1:
  00008	8d 4d 00	 lea	 ecx, DWORD PTR _strImageFilter$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Create@CPythonMiniMap@@QAE_NXZ$2:
  00010	8d 4d 18	 lea	 ecx, DWORD PTR _strImageCamera$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Create@CPythonMiniMap@@QAE_NXZ$3:
  00018	8d 4d 30	 lea	 ecx, DWORD PTR _strPlayerMark$[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Create@CPythonMiniMap@@QAE_NXZ$4:
  00020	8d 4d 48	 lea	 ecx, DWORD PTR _strWhiteMark$[ebp]
  00023	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00028	cc		 int	 3
  00029	cc		 int	 3
  0002a	cc		 int	 3
  0002b	cc		 int	 3
  0002c	cc		 int	 3
__ehhandler$?Create@CPythonMiniMap@@QAE_NXZ:
  0002d	90		 npad	 1
  0002e	90		 npad	 1
  0002f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00033	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00036	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00039	33 c8		 xor	 ecx, eax
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	8b 8a f0 01 00
	00		 mov	 ecx, DWORD PTR [edx+496]
  00046	33 c8		 xor	 ecx, eax
  00048	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Create@CPythonMiniMap@@QAE_NXZ
  00052	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Create@CPythonMiniMap@@QAE_NXZ ENDP			; CPythonMiniMap::Create
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?Destroy@CPythonMiniMap@@QAEXXZ
_TEXT	SEGMENT
_k$1 = -16						; size = 4
_j$2 = -12						; size = 4
_i$3 = -8						; size = 4
_this$ = -4						; size = 4
?Destroy@CPythonMiniMap@@QAEXXZ PROC			; CPythonMiniMap::Destroy, COMDAT
; _this$ = ecx

; 1460 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1461 : 	ClearAllSignalPoint();

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?ClearAllSignalPoint@CPythonMiniMap@@QAEXXZ ; CPythonMiniMap::ClearAllSignalPoint

; 1462 : 	m_poHandler = 0;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	83 a0 34 0c 00
	00 00		 and	 DWORD PTR [eax+3124], 0

; 1463 : 
; 1464 : 	m_VertexBuffer.Destroy();

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	81 c1 74 01 00
	00		 add	 ecx, 372		; 00000174H
  00024	e8 00 00 00 00	 call	 ?Destroy@CGraphicVertexBuffer@@QAEXXZ ; CGraphicVertexBuffer::Destroy

; 1465 : 	m_IndexBuffer.Destroy();

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	81 c1 94 01 00
	00		 add	 ecx, 404		; 00000194H
  00032	e8 00 00 00 00	 call	 ?Destroy@CGraphicIndexBuffer@@QAEXXZ ; CGraphicIndexBuffer::Destroy

; 1466 : 
; 1467 : 	m_PlayerMark.Destroy();

  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	81 c1 c0 00 00
	00		 add	 ecx, 192		; 000000c0H
  00040	e8 00 00 00 00	 call	 ?Destroy@CGraphicExpandedImageInstance@@QAEXXZ ; CGraphicExpandedImageInstance::Destroy

; 1468 : 
; 1469 : 	m_MiniMapFilterGraphicImageInstance.Destroy();

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	83 c1 54	 add	 ecx, 84			; 00000054H
  0004b	e8 00 00 00 00	 call	 ?Destroy@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Destroy

; 1470 : 	m_MiniMapCameraraphicImageInstance.Destroy();

  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	83 c1 74	 add	 ecx, 116		; 00000074H
  00056	e8 00 00 00 00	 call	 ?Destroy@CGraphicExpandedImageInstance@@QAEXXZ ; CGraphicExpandedImageInstance::Destroy

; 1471 : 
; 1472 : 	m_AtlasWayPointInfoVector.clear();

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	81 c1 10 0c 00
	00		 add	 ecx, 3088		; 00000c10H
  00064	e8 00 00 00 00	 call	 ?clear@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAEXXZ ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::clear

; 1473 : 	m_AtlasImageInstance.Destroy();

  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	81 c1 6c 02 00
	00		 add	 ecx, 620		; 0000026cH
  00072	e8 00 00 00 00	 call	 ?Destroy@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Destroy

; 1474 : 	m_AtlasPlayerMark.Destroy();

  00077	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	81 c1 cc 02 00
	00		 add	 ecx, 716		; 000002ccH
  00080	e8 00 00 00 00	 call	 ?Destroy@CGraphicExpandedImageInstance@@QAEXXZ ; CGraphicExpandedImageInstance::Destroy

; 1475 : 	m_WhiteMark.Destroy();

  00085	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  0008e	e8 00 00 00 00	 call	 ?Destroy@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Destroy

; 1476 : 
; 1477 : 	for (int i = 0; i < MINI_WAYPOINT_IMAGE_COUNT; ++i)

  00093	83 65 f8 00	 and	 DWORD PTR _i$3[ebp], 0
  00097	eb 07		 jmp	 SHORT $LN4@Destroy
$LN2@Destroy:
  00099	8b 45 f8	 mov	 eax, DWORD PTR _i$3[ebp]
  0009c	40		 inc	 eax
  0009d	89 45 f8	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@Destroy:
  000a0	83 7d f8 0c	 cmp	 DWORD PTR _i$3[ebp], 12	; 0000000cH
  000a4	7d 15		 jge	 SHORT $LN3@Destroy

; 1478 : 		m_MiniWayPointGraphicImageInstances[i].Destroy();

  000a6	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$3[ebp], 76
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	8d 8c 01 54 03
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+852]
  000b4	e8 00 00 00 00	 call	 ?Destroy@CGraphicExpandedImageInstance@@QAEXXZ ; CGraphicExpandedImageInstance::Destroy
  000b9	eb de		 jmp	 SHORT $LN2@Destroy
$LN3@Destroy:

; 1479 : 	for (int j = 0; j < WAYPOINT_IMAGE_COUNT; ++j)

  000bb	83 65 f4 00	 and	 DWORD PTR _j$2[ebp], 0
  000bf	eb 07		 jmp	 SHORT $LN7@Destroy
$LN5@Destroy:
  000c1	8b 45 f4	 mov	 eax, DWORD PTR _j$2[ebp]
  000c4	40		 inc	 eax
  000c5	89 45 f4	 mov	 DWORD PTR _j$2[ebp], eax
$LN7@Destroy:
  000c8	83 7d f4 0f	 cmp	 DWORD PTR _j$2[ebp], 15	; 0000000fH
  000cc	7d 15		 jge	 SHORT $LN6@Destroy

; 1480 : 		m_WayPointGraphicImageInstances[j].Destroy();

  000ce	6b 45 f4 4c	 imul	 eax, DWORD PTR _j$2[ebp], 76
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	8d 8c 01 e4 06
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+1764]
  000dc	e8 00 00 00 00	 call	 ?Destroy@CGraphicExpandedImageInstance@@QAEXXZ ; CGraphicExpandedImageInstance::Destroy
  000e1	eb de		 jmp	 SHORT $LN5@Destroy
$LN6@Destroy:

; 1481 : 	for (int k = 0; k < TARGET_MARK_IMAGE_COUNT; ++k)

  000e3	83 65 f0 00	 and	 DWORD PTR _k$1[ebp], 0
  000e7	eb 07		 jmp	 SHORT $LN10@Destroy
$LN8@Destroy:
  000e9	8b 45 f0	 mov	 eax, DWORD PTR _k$1[ebp]
  000ec	40		 inc	 eax
  000ed	89 45 f0	 mov	 DWORD PTR _k$1[ebp], eax
$LN10@Destroy:
  000f0	83 7d f0 02	 cmp	 DWORD PTR _k$1[ebp], 2
  000f4	7d 15		 jge	 SHORT $LN9@Destroy

; 1482 : 		m_TargetMarkGraphicImageInstances[k].Destroy();

  000f6	6b 45 f0 4c	 imul	 eax, DWORD PTR _k$1[ebp], 76
  000fa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fd	8d 8c 01 58 0b
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+2904]
  00104	e8 00 00 00 00	 call	 ?Destroy@CGraphicExpandedImageInstance@@QAEXXZ ; CGraphicExpandedImageInstance::Destroy
  00109	eb de		 jmp	 SHORT $LN8@Destroy
$LN9@Destroy:

; 1483 : 
; 1484 : 	m_GuildAreaFlagImageInstance.Destroy();

  0010b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	81 c1 f0 0b 00
	00		 add	 ecx, 3056		; 00000bf0H
  00114	e8 00 00 00 00	 call	 ?Destroy@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Destroy

; 1485 : 
; 1486 : 	__Initialize();

  00119	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011c	e8 00 00 00 00	 call	 ?__Initialize@CPythonMiniMap@@IAEXXZ ; CPythonMiniMap::__Initialize

; 1487 : }

  00121	c9		 leave
  00122	c3		 ret	 0
?Destroy@CPythonMiniMap@@QAEXXZ ENDP			; CPythonMiniMap::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ??1CPythonMiniMap@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CPythonMiniMap@@UAE@XZ PROC				; CPythonMiniMap::~CPythonMiniMap, COMDAT
; _this$ = ecx

; 1495 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CPythonMiniMap@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CPythonMiniMap@@6BCScreen@@@
  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00032	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_7CPythonMiniMap@@6B?$CSingleton@VCPythonMiniMap@@@@@

; 1496 : 	Destroy();

  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?Destroy@CPythonMiniMap@@QAEXXZ ; CPythonMiniMap::Destroy

; 1497 : }

  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	81 c1 28 0c 00
	00		 add	 ecx, 3112		; 00000c28H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0004a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@AAEXXZ ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1497 : }

  0004f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	81 c1 1c 0c 00
	00		 add	 ecx, 3100		; 00000c1cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00058	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@AAEXXZ ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1497 : }

  0005d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	81 c1 10 0c 00
	00		 add	 ecx, 3088		; 00000c10H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00066	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXXZ ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1497 : }

  0006b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	81 c1 f0 0b 00
	00		 add	 ecx, 3056		; 00000bf0H
  00074	e8 00 00 00 00	 call	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
  00079	68 00 00 00 00	 push	 OFFSET ??1CGraphicExpandedImageInstance@@UAE@XZ ; CGraphicExpandedImageInstance::~CGraphicExpandedImageInstance
  0007e	6a 02		 push	 2
  00080	6a 4c		 push	 76			; 0000004cH
  00082	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00085	05 58 0b 00 00	 add	 eax, 2904		; 00000b58H
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00090	68 00 00 00 00	 push	 OFFSET ??1CGraphicExpandedImageInstance@@UAE@XZ ; CGraphicExpandedImageInstance::~CGraphicExpandedImageInstance
  00095	6a 0f		 push	 15			; 0000000fH
  00097	6a 4c		 push	 76			; 0000004cH
  00099	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009c	05 e4 06 00 00	 add	 eax, 1764		; 000006e4H
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  000a7	68 00 00 00 00	 push	 OFFSET ??1CGraphicExpandedImageInstance@@UAE@XZ ; CGraphicExpandedImageInstance::~CGraphicExpandedImageInstance
  000ac	6a 0c		 push	 12			; 0000000cH
  000ae	6a 4c		 push	 76			; 0000004cH
  000b0	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	05 54 03 00 00	 add	 eax, 852		; 00000354H
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  000be	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	81 c1 48 03 00
	00		 add	 ecx, 840		; 00000348H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  000c7	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXXZ ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1497 : }

  000cc	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000cf	81 c1 3c 03 00
	00		 add	 ecx, 828		; 0000033cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  000d5	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@AAEXXZ ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1497 : }

  000da	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000dd	81 c1 cc 02 00
	00		 add	 ecx, 716		; 000002ccH
  000e3	e8 00 00 00 00	 call	 ??1CGraphicExpandedImageInstance@@UAE@XZ ; CGraphicExpandedImageInstance::~CGraphicExpandedImageInstance
  000e8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	81 c1 6c 02 00
	00		 add	 ecx, 620		; 0000026cH
  000f1	e8 00 00 00 00	 call	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
  000f6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f9	81 c1 94 01 00
	00		 add	 ecx, 404		; 00000194H
  000ff	e8 00 00 00 00	 call	 ??1CGraphicIndexBuffer@@UAE@XZ ; CGraphicIndexBuffer::~CGraphicIndexBuffer
  00104	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00107	81 c1 74 01 00
	00		 add	 ecx, 372		; 00000174H
  0010d	e8 00 00 00 00	 call	 ??1CGraphicVertexBuffer@@UAE@XZ ; CGraphicVertexBuffer::~CGraphicVertexBuffer
  00112	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00115	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  0011b	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >
  00120	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00123	81 c1 5c 01 00
	00		 add	 ecx, 348		; 0000015cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00129	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@AAEXXZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1497 : }

  0012e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00131	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00137	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@AAEXXZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1497 : }

  0013c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0013f	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00145	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@AAEXXZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1497 : }

  0014a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0014d	81 c1 38 01 00
	00		 add	 ecx, 312		; 00000138H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00153	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@AAEXXZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1497 : }

  00158	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0015b	81 c1 2c 01 00
	00		 add	 ecx, 300		; 0000012cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00161	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@AAEXXZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1497 : }

  00166	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00169	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  0016f	e8 00 00 00 00	 call	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
  00174	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00177	81 c1 c0 00 00
	00		 add	 ecx, 192		; 000000c0H
  0017d	e8 00 00 00 00	 call	 ??1CGraphicExpandedImageInstance@@UAE@XZ ; CGraphicExpandedImageInstance::~CGraphicExpandedImageInstance
  00182	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00185	83 c1 74	 add	 ecx, 116		; 00000074H
  00188	e8 00 00 00 00	 call	 ??1CGraphicExpandedImageInstance@@UAE@XZ ; CGraphicExpandedImageInstance::~CGraphicExpandedImageInstance
  0018d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00190	83 c1 54	 add	 ecx, 84			; 00000054H
  00193	e8 00 00 00 00	 call	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 19   : 	{ 

  00198	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0019b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_7?$CSingleton@VCPythonMiniMap@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  001a2	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A, 0 ; CSingleton<CPythonMiniMap>::ms_singleton
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1497 : }

  001a9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001ac	e8 00 00 00 00	 call	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
  001b1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001b4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001bb	59		 pop	 ecx
  001bc	c9		 leave
  001bd	c3		 ret	 0
  001be	cc		 int	 3
  001bf	cc		 int	 3
  001c0	cc		 int	 3
  001c1	cc		 int	 3
  001c2	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CPythonMiniMap@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CPythonMiniMap@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CPythonMiniMap@@UAE@XZ ENDP				; CPythonMiniMap::~CPythonMiniMap
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ??0CPythonMiniMap@@QAE@XZ
_TEXT	SEGMENT
_this$ = -140						; size = 4
_this$ = -136						; size = 4
_this$ = -132						; size = 4
_this$ = -128						; size = 4
_this$ = -124						; size = 4
_this$ = -120						; size = 4
_this$ = -116						; size = 4
_this$ = -112						; size = 4
_this$ = -108						; size = 4
_this$ = -104						; size = 4
_this$ = -100						; size = 4
_this$ = -96						; size = 4
_this$ = -92						; size = 4
_this$ = -88						; size = 4
_this$ = -84						; size = 4
_this$ = -80						; size = 4
_this$ = -76						; size = 4
_this$ = -72						; size = 4
_this$ = -68						; size = 4
_this$ = -64						; size = 4
_this$ = -60						; size = 4
_this$ = -56						; size = 4
_offset$2 = -52						; size = 4
_this$ = -48						; size = 4
tv335 = -44						; size = 4
_this$3 = -40						; size = 4
_this$4 = -36						; size = 4
_this$5 = -32						; size = 4
_this$6 = -28						; size = 4
_this$7 = -24						; size = 4
_this$ = -20						; size = 4
$T8 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??0CPythonMiniMap@@QAE@XZ PROC				; CPythonMiniMap::CPythonMiniMap, COMDAT
; _this$ = ecx

; 1490 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CPythonMiniMap@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  00033	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00037	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	83 c0 04	 add	 eax, 4
  0003d	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 12   : 	{ 

  00040	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CSingleton@VCPythonMiniMap@@@@6B@

; 13   : 		assert(!ms_singleton);
; 14   : 		int offset = (int) (T*) 1 - (int) (CSingleton <T>*) (T*) 1; 

  00049	33 c0		 xor	 eax, eax
  0004b	40		 inc	 eax
  0004c	74 0a		 je	 SHORT $LN30@CPythonMin
  0004e	33 c0		 xor	 eax, eax
  00050	83 c0 05	 add	 eax, 5
  00053	89 45 d4	 mov	 DWORD PTR tv335[ebp], eax
  00056	eb 04		 jmp	 SHORT $LN31@CPythonMin
$LN30@CPythonMin:
  00058	83 65 d4 00	 and	 DWORD PTR tv335[ebp], 0
$LN31@CPythonMin:
  0005c	33 c0		 xor	 eax, eax
  0005e	40		 inc	 eax
  0005f	2b 45 d4	 sub	 eax, DWORD PTR tv335[ebp]
  00062	89 45 cc	 mov	 DWORD PTR _offset$2[ebp], eax

; 15   : 		ms_singleton = (T*) ((int) this + offset);

  00065	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00068	03 45 cc	 add	 eax, DWORD PTR _offset$2[ebp]
  0006b	a3 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A, eax ; CSingleton<CPythonMiniMap>::ms_singleton
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1490 : {

  00070	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00074	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00077	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CPythonMiniMap@@6BCScreen@@@
  0007d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00080	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_7CPythonMiniMap@@6B?$CSingleton@VCPythonMiniMap@@@@@
  00087	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	83 c1 54	 add	 ecx, 84			; 00000054H
  0008d	e8 00 00 00 00	 call	 ??0CGraphicImageInstance@@QAE@XZ ; CGraphicImageInstance::CGraphicImageInstance
  00092	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 74	 add	 ecx, 116		; 00000074H
  0009c	e8 00 00 00 00	 call	 ??0CGraphicExpandedImageInstance@@QAE@XZ ; CGraphicExpandedImageInstance::CGraphicExpandedImageInstance
  000a1	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000a5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	81 c1 c0 00 00
	00		 add	 ecx, 192		; 000000c0H
  000ae	e8 00 00 00 00	 call	 ??0CGraphicExpandedImageInstance@@QAE@XZ ; CGraphicExpandedImageInstance::CGraphicExpandedImageInstance
  000b3	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  000b7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  000c0	e8 00 00 00 00	 call	 ??0CGraphicImageInstance@@QAE@XZ ; CGraphicImageInstance::CGraphicImageInstance
  000c5	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  000d1	89 45 c8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  000d4	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  000d7	89 45 c4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  000da	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  000dd	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CPythonMiniMap::TMarkPosition> >::_Vector_val<std::_Simple_types<CPythonMiniMap::TMarkPosition> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1490 : {

  000e2	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	05 38 01 00 00	 add	 eax, 312		; 00000138H
  000ee	89 45 c0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  000f1	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  000f4	89 45 bc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  000f7	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fa	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CPythonMiniMap::TMarkPosition> >::_Vector_val<std::_Simple_types<CPythonMiniMap::TMarkPosition> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1490 : {

  000ff	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00103	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00106	05 44 01 00 00	 add	 eax, 324		; 00000144H
  0010b	89 45 b8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0010e	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00111	89 45 b4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00114	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CPythonMiniMap::TMarkPosition> >::_Vector_val<std::_Simple_types<CPythonMiniMap::TMarkPosition> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1490 : {

  0011c	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00120	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00123	05 50 01 00 00	 add	 eax, 336		; 00000150H
  00128	89 45 b0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0012b	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  0012e	89 45 ac	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00131	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00134	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CPythonMiniMap::TMarkPosition> >::_Vector_val<std::_Simple_types<CPythonMiniMap::TMarkPosition> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1490 : {

  00139	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  0013d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00140	05 5c 01 00 00	 add	 eax, 348		; 0000015cH
  00145	89 45 a8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00148	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  0014b	89 45 a4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0014e	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  00151	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CPythonMiniMap::TMarkPosition> >::_Vector_val<std::_Simple_types<CPythonMiniMap::TMarkPosition> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1490 : {

  00156	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  0015a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0015d	05 68 01 00 00	 add	 eax, 360		; 00000168H
  00162	89 45 a0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 107  :     map() : _Mybase(key_compare()) {}

  00165	8d 45 f3	 lea	 eax, DWORD PTR $T8[ebp]
  00168	50		 push	 eax
  00169	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  0016c	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >::_Tree<std::_Tmap_traits<unsigned long,CPythonMiniMap::SObserver,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonMiniMap::SObserver> >,0> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1490 : {

  00171	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00175	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00178	81 c1 74 01 00
	00		 add	 ecx, 372		; 00000174H
  0017e	e8 00 00 00 00	 call	 ??0CGraphicVertexBuffer@@QAE@XZ ; CGraphicVertexBuffer::CGraphicVertexBuffer
  00183	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  00187	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0018a	81 c1 94 01 00
	00		 add	 ecx, 404		; 00000194H
  00190	e8 00 00 00 00	 call	 ??0CGraphicIndexBuffer@@QAE@XZ ; CGraphicIndexBuffer::CGraphicIndexBuffer
  00195	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  00199	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0019c	81 c1 6c 02 00
	00		 add	 ecx, 620		; 0000026cH
  001a2	e8 00 00 00 00	 call	 ??0CGraphicImageInstance@@QAE@XZ ; CGraphicImageInstance::CGraphicImageInstance
  001a7	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  001ab	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001ae	81 c1 cc 02 00
	00		 add	 ecx, 716		; 000002ccH
  001b4	e8 00 00 00 00	 call	 ??0CGraphicExpandedImageInstance@@QAE@XZ ; CGraphicExpandedImageInstance::CGraphicExpandedImageInstance
  001b9	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  001bd	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001c0	05 38 03 00 00	 add	 eax, 824		; 00000338H
  001c5	89 45 9c	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  001c8	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  001cb	83 20 00	 and	 DWORD PTR [eax], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1490 : {

  001ce	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001d1	05 3c 03 00 00	 add	 eax, 828		; 0000033cH
  001d6	89 45 98	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  001d9	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  001dc	89 45 94	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  001df	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  001e2	89 45 e8	 mov	 DWORD PTR _this$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  001e5	8b 45 e8	 mov	 eax, DWORD PTR _this$7[ebp]
  001e8	83 20 00	 and	 DWORD PTR [eax], 0
  001eb	8b 45 e8	 mov	 eax, DWORD PTR _this$7[ebp]
  001ee	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  001f2	8b 45 e8	 mov	 eax, DWORD PTR _this$7[ebp]
  001f5	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1490 : {

  001f9	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  001fd	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00200	05 48 03 00 00	 add	 eax, 840		; 00000348H
  00205	89 45 90	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00208	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0020b	89 45 8c	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0020e	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  00211	89 45 e4	 mov	 DWORD PTR _this$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00214	8b 45 e4	 mov	 eax, DWORD PTR _this$6[ebp]
  00217	83 20 00	 and	 DWORD PTR [eax], 0
  0021a	8b 45 e4	 mov	 eax, DWORD PTR _this$6[ebp]
  0021d	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00221	8b 45 e4	 mov	 eax, DWORD PTR _this$6[ebp]
  00224	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1490 : {

  00228	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H
  0022c	68 00 00 00 00	 push	 OFFSET ??1CGraphicExpandedImageInstance@@UAE@XZ ; CGraphicExpandedImageInstance::~CGraphicExpandedImageInstance
  00231	68 00 00 00 00	 push	 OFFSET ??0CGraphicExpandedImageInstance@@QAE@XZ ; CGraphicExpandedImageInstance::CGraphicExpandedImageInstance
  00236	6a 0c		 push	 12			; 0000000cH
  00238	6a 4c		 push	 76			; 0000004cH
  0023a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0023d	05 54 03 00 00	 add	 eax, 852		; 00000354H
  00242	50		 push	 eax
  00243	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  00248	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  0024c	68 00 00 00 00	 push	 OFFSET ??1CGraphicExpandedImageInstance@@UAE@XZ ; CGraphicExpandedImageInstance::~CGraphicExpandedImageInstance
  00251	68 00 00 00 00	 push	 OFFSET ??0CGraphicExpandedImageInstance@@QAE@XZ ; CGraphicExpandedImageInstance::CGraphicExpandedImageInstance
  00256	6a 0f		 push	 15			; 0000000fH
  00258	6a 4c		 push	 76			; 0000004cH
  0025a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0025d	05 e4 06 00 00	 add	 eax, 1764		; 000006e4H
  00262	50		 push	 eax
  00263	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  00268	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
  0026c	68 00 00 00 00	 push	 OFFSET ??1CGraphicExpandedImageInstance@@UAE@XZ ; CGraphicExpandedImageInstance::~CGraphicExpandedImageInstance
  00271	68 00 00 00 00	 push	 OFFSET ??0CGraphicExpandedImageInstance@@QAE@XZ ; CGraphicExpandedImageInstance::CGraphicExpandedImageInstance
  00276	6a 02		 push	 2
  00278	6a 4c		 push	 76			; 0000004cH
  0027a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0027d	05 58 0b 00 00	 add	 eax, 2904		; 00000b58H
  00282	50		 push	 eax
  00283	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  00288	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
  0028c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0028f	81 c1 f0 0b 00
	00		 add	 ecx, 3056		; 00000bf0H
  00295	e8 00 00 00 00	 call	 ??0CGraphicImageInstance@@QAE@XZ ; CGraphicImageInstance::CGraphicImageInstance
  0029a	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+8], 21 ; 00000015H
  0029e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  002a1	05 10 0c 00 00	 add	 eax, 3088		; 00000c10H
  002a6	89 45 88	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  002a9	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  002ac	89 45 84	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  002af	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  002b2	89 45 e0	 mov	 DWORD PTR _this$5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  002b5	8b 45 e0	 mov	 eax, DWORD PTR _this$5[ebp]
  002b8	83 20 00	 and	 DWORD PTR [eax], 0
  002bb	8b 45 e0	 mov	 eax, DWORD PTR _this$5[ebp]
  002be	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  002c2	8b 45 e0	 mov	 eax, DWORD PTR _this$5[ebp]
  002c5	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1490 : {

  002c9	c6 45 fc 16	 mov	 BYTE PTR __$EHRec$[ebp+8], 22 ; 00000016H
  002cd	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  002d0	05 1c 0c 00 00	 add	 eax, 3100		; 00000c1cH
  002d5	89 45 80	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  002d8	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  002db	89 85 7c ff ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  002e1	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  002e7	89 45 dc	 mov	 DWORD PTR _this$4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  002ea	8b 45 dc	 mov	 eax, DWORD PTR _this$4[ebp]
  002ed	83 20 00	 and	 DWORD PTR [eax], 0
  002f0	8b 45 dc	 mov	 eax, DWORD PTR _this$4[ebp]
  002f3	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  002f7	8b 45 dc	 mov	 eax, DWORD PTR _this$4[ebp]
  002fa	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1490 : {

  002fe	c6 45 fc 17	 mov	 BYTE PTR __$EHRec$[ebp+8], 23 ; 00000017H
  00302	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00305	05 28 0c 00 00	 add	 eax, 3112		; 00000c28H
  0030a	89 85 78 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00310	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00316	89 85 74 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0031c	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00322	89 45 d8	 mov	 DWORD PTR _this$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00325	8b 45 d8	 mov	 eax, DWORD PTR _this$3[ebp]
  00328	83 20 00	 and	 DWORD PTR [eax], 0
  0032b	8b 45 d8	 mov	 eax, DWORD PTR _this$3[ebp]
  0032e	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00332	8b 45 d8	 mov	 eax, DWORD PTR _this$3[ebp]
  00335	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp

; 1490 : {

  00339	c6 45 fc 18	 mov	 BYTE PTR __$EHRec$[ebp+8], 24 ; 00000018H

; 1491 : 	__Initialize();

  0033d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00340	e8 00 00 00 00	 call	 ?__Initialize@CPythonMiniMap@@IAEXXZ ; CPythonMiniMap::__Initialize

; 1492 : }

  00345	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00349	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0034c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0034f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00356	59		 pop	 ecx
  00357	c9		 leave
  00358	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$1:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$CSingleton@VCPythonMiniMap@@@@UAE@XZ ; CSingleton<CPythonMiniMap>::~CSingleton<CPythonMiniMap>
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$2:
  00013	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 54	 add	 ecx, 84			; 00000054H
  00019	e9 00 00 00 00	 jmp	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$3:
  0001e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 74	 add	 ecx, 116		; 00000074H
  00024	e9 00 00 00 00	 jmp	 ??1CGraphicExpandedImageInstance@@UAE@XZ ; CGraphicExpandedImageInstance::~CGraphicExpandedImageInstance
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$4:
  00029	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	81 c1 c0 00 00
	00		 add	 ecx, 192		; 000000c0H
  00032	e9 00 00 00 00	 jmp	 ??1CGraphicExpandedImageInstance@@UAE@XZ ; CGraphicExpandedImageInstance::~CGraphicExpandedImageInstance
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$5:
  00037	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00040	e9 00 00 00 00	 jmp	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$6:
  00045	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	81 c1 2c 01 00
	00		 add	 ecx, 300		; 0000012cH
  0004e	e9 00 00 00 00	 jmp	 ??1?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::~vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$7:
  00053	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	81 c1 38 01 00
	00		 add	 ecx, 312		; 00000138H
  0005c	e9 00 00 00 00	 jmp	 ??1?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::~vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$8:
  00061	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  0006a	e9 00 00 00 00	 jmp	 ??1?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::~vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$9:
  0006f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
  00078	e9 00 00 00 00	 jmp	 ??1?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::~vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$10:
  0007d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	81 c1 5c 01 00
	00		 add	 ecx, 348		; 0000015cH
  00086	e9 00 00 00 00	 jmp	 ??1?$vector@UTMarkPosition@CPythonMiniMap@@V?$allocator@UTMarkPosition@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >::~vector<CPythonMiniMap::TMarkPosition,std::allocator<CPythonMiniMap::TMarkPosition> >
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$11:
  0008b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  00094	e9 00 00 00 00	 jmp	 ??1?$map@KUSObserver@CPythonMiniMap@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSObserver@CPythonMiniMap@@@std@@@4@@std@@QAE@XZ
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$12:
  00099	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	81 c1 74 01 00
	00		 add	 ecx, 372		; 00000174H
  000a2	e9 00 00 00 00	 jmp	 ??1CGraphicVertexBuffer@@UAE@XZ ; CGraphicVertexBuffer::~CGraphicVertexBuffer
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$13:
  000a7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	81 c1 94 01 00
	00		 add	 ecx, 404		; 00000194H
  000b0	e9 00 00 00 00	 jmp	 ??1CGraphicIndexBuffer@@UAE@XZ ; CGraphicIndexBuffer::~CGraphicIndexBuffer
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$14:
  000b5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	81 c1 6c 02 00
	00		 add	 ecx, 620		; 0000026cH
  000be	e9 00 00 00 00	 jmp	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$15:
  000c3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c6	81 c1 cc 02 00
	00		 add	 ecx, 716		; 000002ccH
  000cc	e9 00 00 00 00	 jmp	 ??1CGraphicExpandedImageInstance@@UAE@XZ ; CGraphicExpandedImageInstance::~CGraphicExpandedImageInstance
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$16:
  000d1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d4	81 c1 3c 03 00
	00		 add	 ecx, 828		; 0000033cH
  000da	e9 00 00 00 00	 jmp	 ??1?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::~vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$17:
  000df	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e2	81 c1 48 03 00
	00		 add	 ecx, 840		; 00000348H
  000e8	e9 00 00 00 00	 jmp	 ??1?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::~vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$18:
  000ed	68 00 00 00 00	 push	 OFFSET ??1CGraphicExpandedImageInstance@@UAE@XZ ; CGraphicExpandedImageInstance::~CGraphicExpandedImageInstance
  000f2	6a 0c		 push	 12			; 0000000cH
  000f4	6a 4c		 push	 76			; 0000004cH
  000f6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f9	05 54 03 00 00	 add	 eax, 852		; 00000354H
  000fe	50		 push	 eax
  000ff	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00104	c3		 ret	 0
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$19:
  00105	68 00 00 00 00	 push	 OFFSET ??1CGraphicExpandedImageInstance@@UAE@XZ ; CGraphicExpandedImageInstance::~CGraphicExpandedImageInstance
  0010a	6a 0f		 push	 15			; 0000000fH
  0010c	6a 4c		 push	 76			; 0000004cH
  0010e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00111	05 e4 06 00 00	 add	 eax, 1764		; 000006e4H
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0011c	c3		 ret	 0
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$20:
  0011d	68 00 00 00 00	 push	 OFFSET ??1CGraphicExpandedImageInstance@@UAE@XZ ; CGraphicExpandedImageInstance::~CGraphicExpandedImageInstance
  00122	6a 02		 push	 2
  00124	6a 4c		 push	 76			; 0000004cH
  00126	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00129	05 58 0b 00 00	 add	 eax, 2904		; 00000b58H
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00134	c3		 ret	 0
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$21:
  00135	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00138	81 c1 f0 0b 00
	00		 add	 ecx, 3056		; 00000bf0H
  0013e	e9 00 00 00 00	 jmp	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$22:
  00143	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00146	81 c1 10 0c 00
	00		 add	 ecx, 3088		; 00000c10H
  0014c	e9 00 00 00 00	 jmp	 ??1?$vector@UTAtlasMarkInfo@CPythonMiniMap@@V?$allocator@UTAtlasMarkInfo@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >::~vector<CPythonMiniMap::TAtlasMarkInfo,std::allocator<CPythonMiniMap::TAtlasMarkInfo> >
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$23:
  00151	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00154	81 c1 1c 0c 00
	00		 add	 ecx, 3100		; 00000c1cH
  0015a	e9 00 00 00 00	 jmp	 ??1?$vector@UTGuildAreaInfo@CPythonMiniMap@@V?$allocator@UTGuildAreaInfo@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >::~vector<CPythonMiniMap::TGuildAreaInfo,std::allocator<CPythonMiniMap::TGuildAreaInfo> >
__unwindfunclet$??0CPythonMiniMap@@QAE@XZ$24:
  0015f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00162	81 c1 28 0c 00
	00		 add	 ecx, 3112		; 00000c28H
  00168	e9 00 00 00 00	 jmp	 ??1?$vector@UTSignalPoint@CPythonMiniMap@@V?$allocator@UTSignalPoint@CPythonMiniMap@@@std@@@std@@QAE@XZ ; std::vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >::~vector<CPythonMiniMap::TSignalPoint,std::allocator<CPythonMiniMap::TSignalPoint> >
  0016d	cc		 int	 3
  0016e	cc		 int	 3
  0016f	cc		 int	 3
  00170	cc		 int	 3
  00171	cc		 int	 3
__ehhandler$??0CPythonMiniMap@@QAE@XZ:
  00172	90		 npad	 1
  00173	90		 npad	 1
  00174	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00178	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0017b	8b 8a 7c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-132]
  00181	33 c8		 xor	 ecx, eax
  00183	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00188	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CPythonMiniMap@@QAE@XZ
  0018d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CPythonMiniMap@@QAE@XZ ENDP				; CPythonMiniMap::CPythonMiniMap
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
;	COMDAT ??_G?$CSingleton@VCPythonMiniMap@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CSingleton@VCPythonMiniMap@@@@UAEPAXI@Z PROC	; CSingleton<CPythonMiniMap>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 19   : 	{ 

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CSingleton@VCPythonMiniMap@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00010	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A, 0 ; CSingleton<CPythonMiniMap>::ms_singleton
  00017	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001a	83 e0 01	 and	 eax, 1
  0001d	74 0c		 je	 SHORT $LN2@scalar
  0001f	6a 04		 push	 4
  00021	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	59		 pop	 ecx
  0002a	59		 pop	 ecx
$LN2@scalar:
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c9		 leave
  0002f	c2 04 00	 ret	 4
??_G?$CSingleton@VCPythonMiniMap@@@@UAEPAXI@Z ENDP	; CSingleton<CPythonMiniMap>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
;	COMDAT ??1?$CSingleton@VCPythonMiniMap@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CSingleton@VCPythonMiniMap@@@@UAE@XZ PROC		; CSingleton<CPythonMiniMap>::~CSingleton<CPythonMiniMap>, COMDAT
; _this$ = ecx

; 19   : 	{ 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CSingleton@VCPythonMiniMap@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00010	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A, 0 ; CSingleton<CPythonMiniMap>::ms_singleton

; 22   : 	}

  00017	c9		 leave
  00018	c3		 ret	 0
??1?$CSingleton@VCPythonMiniMap@@@@UAE@XZ ENDP		; CSingleton<CPythonMiniMap>::~CSingleton<CPythonMiniMap>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 908  : void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { // (maybe) propagate on container move assignment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 909  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 910  :         _Left = _STD move(_Right);
; 911  :     }
; 912  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Al$ = -40						; size = 4
__Ptr$ = -36						; size = 4
__Ptr$ = -32						; size = 4
$T1 = -28						; size = 4
__Old_capacity$ = -24					; size = 4
$T2 = -20						; size = 4
__New_capacity$ = -16					; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$3 = -2				; size = 1
$T4 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0003e	c6 45 fe 00	 mov	 BYTE PTR __Overflow_is_possible$3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00042	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00045	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0004c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004d	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00056	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0005f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00062	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006e	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00071	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00074	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0007f	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0

; 428  :         _Left = _Right;

  00083	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00086	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00089	8a 4d ff	 mov	 cl, BYTE PTR $T4[ebp]
  0008c	88 08		 mov	 BYTE PTR [eax], cl

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  0008e	83 7d e8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00092	72 21		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0009c	8b 45 e8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  0009f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	50		 push	 eax
  000a1	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  000a4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a9	59		 pop	 ecx
  000aa	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000b3	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b5	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c1	59		 pop	 ecx
  000c2	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4325 :     }

  000c6	c9		 leave
  000c7	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 75		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 18		 push	 24			; 00000018H
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 18	 imul	 eax, DWORD PTR __Count$[ebp], 24
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00098	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009b	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009e	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a1	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a4	c9		 leave
  000a5	c3		 ret	 0
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Throw_tree_length_error@std@@YAXXZ
_TEXT	SEGMENT
?_Throw_tree_length_error@std@@YAXXZ PROC		; std::_Throw_tree_length_error, COMDAT

; 414  : [[noreturn]] inline void _Throw_tree_length_error() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 415  :     _Xlength_error("map/set too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Throw_tree:

; 416  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Throw_tree_length_error@std@@YAXXZ ENDP		; std::_Throw_tree_length_error
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -2						; size = 1
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 34		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	ff 75 ec	 push	 DWORD PTR __Count$[ebp]
  00057	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0005f	59		 pop	 ecx
  00060	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00072	c6 45 fe 00	 mov	 BYTE PTR $T4[ebp], 0
  00076	33 c0		 xor	 eax, eax
  00078	40		 inc	 eax
  00079	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	8a 55 fe	 mov	 dl, BYTE PTR $T4[ebp]
  00082	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4396 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4376 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00019	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0001d	33 c0		 xor	 eax, eax
  0001f	40		 inc	 eax
  00020	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8a 55 ff	 mov	 dl, BYTE PTR $T1[ebp]
  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4381 :     }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 0f	 or	 eax, 15			; 0000000fH
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT
$T1 = -80						; size = 4
$T2 = -76						; size = 4
__Count$ = -72						; size = 4
$T3 = -68						; size = 4
$T4 = -64						; size = 4
__Ptr$ = -60						; size = 4
__Ptr$ = -56						; size = 4
__Ans$5 = -52						; size = 4
tv146 = -48						; size = 4
_this$ = -44						; size = 4
__Result$6 = -40					; size = 4
tv137 = -36						; size = 4
__Result$7 = -32					; size = 4
tv95 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
$T8 = -16						; size = 4
__Right_size$ = -12					; size = 4
__Left_size$ = -8					; size = 4
$T9 = -2						; size = 1
$T10 = -1						; size = 1
__Right$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 4212 :     _NODISCARD int compare(const basic_string& _Right) const noexcept { // compare [0, size()) with _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 4213 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 e0	 mov	 DWORD PTR __Result$7[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@compare
  0001e	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv95[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@compare
$LN9@compare:
  00027	83 65 e4 00	 and	 DWORD PTR tv95[ebp], 0
$LN10@compare:
  0002b	8a 45 e4	 mov	 al, BYTE PTR tv95[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T10[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T10[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@compare

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 c8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 c8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 e0	 mov	 DWORD PTR __Result$7[ebp], eax
$LN4@compare:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 e0	 mov	 eax, DWORD PTR __Result$7[ebp]
  0004a	89 45 b4	 mov	 DWORD PTR $T2[ebp], eax

; 4213 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0004d	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00050	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  00053	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	89 45 d8	 mov	 DWORD PTR __Result$6[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00059	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00060	72 09		 jb	 SHORT $LN21@compare
  00062	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv137[ebp], 1
  00069	eb 04		 jmp	 SHORT $LN22@compare
$LN21@compare:
  0006b	83 65 dc 00	 and	 DWORD PTR tv137[ebp], 0
$LN22@compare:
  0006f	8a 45 dc	 mov	 al, BYTE PTR tv137[ebp]
  00072	88 45 fe	 mov	 BYTE PTR $T9[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00075	0f b6 45 fe	 movzx	 eax, BYTE PTR $T9[ebp]
  00079	85 c0		 test	 eax, eax
  0007b	74 0e		 je	 SHORT $LN16@compare

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  0007d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 00		 mov	 eax, DWORD PTR [eax]
  00082	89 45 c4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00085	8b 45 c4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00088	89 45 d8	 mov	 DWORD PTR __Result$6[ebp], eax
$LN16@compare:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  0008b	8b 45 d8	 mov	 eax, DWORD PTR __Result$6[ebp]
  0008e	89 45 b0	 mov	 DWORD PTR $T1[ebp], eax

; 4213 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00091	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00094	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00097	89 45 f4	 mov	 DWORD PTR __Right_size$[ebp], eax
  0009a	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000a0	89 45 f8	 mov	 DWORD PTR __Left_size$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  000a3	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  000a6	3b 45 f8	 cmp	 eax, DWORD PTR __Left_size$[ebp]
  000a9	73 08		 jae	 SHORT $LN35@compare
  000ab	8d 45 f4	 lea	 eax, DWORD PTR __Right_size$[ebp]
  000ae	89 45 d0	 mov	 DWORD PTR tv146[ebp], eax
  000b1	eb 06		 jmp	 SHORT $LN36@compare
$LN35@compare:
  000b3	8d 45 f8	 lea	 eax, DWORD PTR __Left_size$[ebp]
  000b6	89 45 d0	 mov	 DWORD PTR tv146[ebp], eax
$LN36@compare:
  000b9	8b 45 d0	 mov	 eax, DWORD PTR tv146[ebp]
  000bc	89 45 c0	 mov	 DWORD PTR $T4[ebp], eax
  000bf	8b 45 c0	 mov	 eax, DWORD PTR $T4[ebp]
  000c2	89 45 bc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 568  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  000c5	8b 45 bc	 mov	 eax, DWORD PTR $T3[ebp]
  000c8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ca	89 45 b8	 mov	 DWORD PTR __Count$[ebp], eax

; 369  :         return _CSTD memcmp(_First1, _First2, _Count);

  000cd	ff 75 b8	 push	 DWORD PTR __Count$[ebp]
  000d0	ff 75 b4	 push	 DWORD PTR $T2[ebp]
  000d3	ff 75 b0	 push	 DWORD PTR $T1[ebp]
  000d6	e8 00 00 00 00	 call	 _memcmp
  000db	83 c4 0c	 add	 esp, 12			; 0000000cH
  000de	89 45 cc	 mov	 DWORD PTR __Ans$5[ebp], eax

; 570  :     if (_Ans != 0) {

  000e1	83 7d cc 00	 cmp	 DWORD PTR __Ans$5[ebp], 0
  000e5	74 08		 je	 SHORT $LN28@compare

; 571  :         return _Ans;

  000e7	8b 45 cc	 mov	 eax, DWORD PTR __Ans$5[ebp]
  000ea	89 45 f0	 mov	 DWORD PTR $T8[ebp], eax
  000ed	eb 23		 jmp	 SHORT $LN31@compare
$LN28@compare:

; 572  :     }
; 573  : 
; 574  :     if (_Left_size < _Right_size) {

  000ef	8b 45 f8	 mov	 eax, DWORD PTR __Left_size$[ebp]
  000f2	3b 45 f4	 cmp	 eax, DWORD PTR __Right_size$[ebp]
  000f5	73 06		 jae	 SHORT $LN29@compare

; 575  :         return -1;

  000f7	83 4d f0 ff	 or	 DWORD PTR $T8[ebp], -1
  000fb	eb 15		 jmp	 SHORT $LN31@compare
$LN29@compare:

; 576  :     }
; 577  : 
; 578  :     if (_Left_size > _Right_size) {

  000fd	8b 45 f8	 mov	 eax, DWORD PTR __Left_size$[ebp]
  00100	3b 45 f4	 cmp	 eax, DWORD PTR __Right_size$[ebp]
  00103	76 09		 jbe	 SHORT $LN30@compare

; 579  :         return 1;

  00105	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T8[ebp], 1
  0010c	eb 04		 jmp	 SHORT $LN31@compare
$LN30@compare:

; 580  :     }
; 581  : 
; 582  :     return 0;

  0010e	83 65 f0 00	 and	 DWORD PTR $T8[ebp], 0
$LN31@compare:

; 4213 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00112	8b 45 f0	 mov	 eax, DWORD PTR $T8[ebp]

; 4214 :             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 4215 :     }

  00115	c9		 leave
  00116	c2 04 00	 ret	 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z
_TEXT	SEGMENT
$T1 = -32						; size = 4
$T2 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$3 = -16					; size = 4
tv92 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 3963 :     /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00009	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000c	e8 00 00 00 00	 call	 _strlen
  00011	59		 pop	 ecx
  00012	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax

; 3964 :         // look for [_Ptr, <null>) beginning at or after _Off
; 3965 :         return static_cast<size_type>(_Traits_find<_Traits>(

  00015	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR __Result$3[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00021	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00028	72 09		 jb	 SHORT $LN12@find
  0002a	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv92[ebp], 1
  00031	eb 04		 jmp	 SHORT $LN13@find
$LN12@find:
  00033	83 65 f4 00	 and	 DWORD PTR tv92[ebp], 0
$LN13@find:
  00037	8a 45 f4	 mov	 al, BYTE PTR tv92[ebp]
  0003a	88 45 ff	 mov	 BYTE PTR $T4[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0003d	0f b6 45 ff	 movzx	 eax, BYTE PTR $T4[ebp]
  00041	85 c0		 test	 eax, eax
  00043	74 0e		 je	 SHORT $LN7@find

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00045	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 00		 mov	 eax, DWORD PTR [eax]
  0004a	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0004d	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00050	89 45 f0	 mov	 DWORD PTR __Result$3[ebp], eax
$LN7@find:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00053	8b 45 f0	 mov	 eax, DWORD PTR __Result$3[ebp]
  00056	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax

; 3964 :         // look for [_Ptr, <null>) beginning at or after _Off
; 3965 :         return static_cast<size_type>(_Traits_find<_Traits>(

  00059	ff 75 e4	 push	 DWORD PTR $T2[ebp]
  0005c	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0005f	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00062	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00065	ff 70 10	 push	 DWORD PTR [eax+16]
  00068	ff 75 e0	 push	 DWORD PTR $T1[ebp]
  0006b	e8 00 00 00 00	 call	 ??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z ; std::_Traits_find<std::char_traits<char> >
  00070	83 c4 14	 add	 esp, 20			; 00000014H

; 3966 :             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
; 3967 :     }

  00073	c9		 leave
  00074	c2 08 00	 ret	 8
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	83 4d f8 ff	 or	 DWORD PTR __Alloc_max$[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00019	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00026	73 08		 jae	 SHORT $LN14@max_size
  00028	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0002e	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00030	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00036	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00042	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004a	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0004d	48		 dec	 eax
  0004e	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00051	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00058	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00064	73 08		 jae	 SHORT $LN22@max_size
  00066	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  00069	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006c	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  0006e	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007a	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3751 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3752 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@c_str
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@c_str
$LN9@c_str:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@c_str:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@c_str

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3752 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3753 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv82 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 3670 :     _NODISCARD reference operator[](const size_type _Off) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3671 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3672 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 3673 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3674 :         return _Mypair._Myval2._Myptr()[_Off];

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2209 :         value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@operator
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv82[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@operator
$LN9@operator:
  00027	83 65 f4 00	 and	 DWORD PTR tv82[ebp], 0
$LN10@operator:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv82[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@operator

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3671 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3672 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 3673 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3674 :         return _Mypair._Myval2._Myptr()[_Off];

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00050	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]

; 3675 :     }

  00053	c9		 leave
  00054	c2 04 00	 ret	 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 39		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0002b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002e	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00031	e8 00 00 00 00	 call	 _memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00039	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00040	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00043	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 3049 :             return *this;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  0004d	33 c0		 xor	 eax, eax
  0004f	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00052	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00055	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00058	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  00063	c9		 leave
  00064	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
__Ptr$ = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
_this$ = -20						; size = 4
__Result$6 = -16					; size = 4
tv134 = -12						; size = 4
_this$ = -8						; size = 4
$T7 = -1						; size = 1
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign, COMDAT
; _this$ = ecx

; 2826 :     void _Copy_assign(const basic_string& _Right, false_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00015	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0001b	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  0001e	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax

; 2827 :         _Pocca(_Getal(), _Right._Getal());

  00021	ff 75 e0	 push	 DWORD PTR $T3[ebp]
  00024	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  00027	e8 00 00 00 00	 call	 ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
  0002c	59		 pop	 ecx
  0002d	59		 pop	 ecx

; 2828 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00031	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 f0	 mov	 DWORD PTR __Result$6[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00041	72 09		 jb	 SHORT $LN21@Copy_assig
  00043	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv134[ebp], 1
  0004a	eb 04		 jmp	 SHORT $LN22@Copy_assig
$LN21@Copy_assig:
  0004c	83 65 f4 00	 and	 DWORD PTR tv134[ebp], 0
$LN22@Copy_assig:
  00050	8a 45 f4	 mov	 al, BYTE PTR tv134[ebp]
  00053	88 45 ff	 mov	 BYTE PTR $T7[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00056	0f b6 45 ff	 movzx	 eax, BYTE PTR $T7[ebp]
  0005a	85 c0		 test	 eax, eax
  0005c	74 0e		 je	 SHORT $LN16@Copy_assig

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 00		 mov	 eax, DWORD PTR [eax]
  00063	89 45 d8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00066	8b 45 d8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00069	89 45 f0	 mov	 DWORD PTR __Result$6[ebp], eax
$LN16@Copy_assig:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  0006c	8b 45 f0	 mov	 eax, DWORD PTR __Result$6[ebp]
  0006f	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax

; 2828 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00072	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00075	ff 70 10	 push	 DWORD PTR [eax+16]
  00078	ff 75 d4	 push	 DWORD PTR $T1[ebp]
  0007b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2829 :     }

  00083	c9		 leave
  00084	c2 08 00	 ret	 8
?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2801 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__Al$ = -72						; size = 4
$T1 = -68						; size = 4
__Ptr$ = -64						; size = 4
$T2 = -60						; size = 4
$T3 = -56						; size = 4
$T4 = -52						; size = 4
__First1$ = -48						; size = 4
__New_capacity$ = -44					; size = 4
__Right_ptr$ = -40					; size = 4
__New_array$ = -36					; size = 4
tv138 = -32						; size = 4
$T5 = -28						; size = 4
$T6 = -24						; size = 4
__Right_data$ = -20					; size = 4
_this$ = -16						; size = 4
__Right_size$ = -12					; size = 4
__My_data$ = -8						; size = 4
__Overflow_is_possible$7 = -1				; size = 1
__Right$ = 8						; size = 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents, COMDAT
; _this$ = ecx

; 2728 :     void _Construct_lv_contents(const basic_string& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2729 :         // assign by copying data stored in _Right
; 2730 :         // pre: this != &_Right
; 2731 :         // pre: *this owns no memory, iterators orphaned (note:
; 2732 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2733 :         auto& _Right_data             = _Right._Mypair._Myval2;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR __Right_data$[ebp], eax

; 2734 :         const size_type _Right_size   = _Right_data._Mysize;

  0000f	8b 45 ec	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 f4	 mov	 DWORD PTR __Right_size$[ebp], eax

; 2735 :         const _Elem* const _Right_ptr = _Right_data._Myptr();

  00018	8b 4d ec	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00020	89 45 d8	 mov	 DWORD PTR __Right_ptr$[ebp], eax

; 2736 :         auto& _My_data                = _Mypair._Myval2;

  00023	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 2737 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

  00029	83 7d f4 10	 cmp	 DWORD PTR __Right_size$[ebp], 16 ; 00000010H
  0002d	73 2e		 jae	 SHORT $LN2@Construct_

; 2738 :             _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00032	89 45 d0	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00035	6a 10		 push	 16			; 00000010H
  00037	ff 75 d8	 push	 DWORD PTR __Right_ptr$[ebp]
  0003a	ff 75 d0	 push	 DWORD PTR __First1$[ebp]
  0003d	e8 00 00 00 00	 call	 _memcpy
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2739 :             _My_data._Mysize = _Right_size;

  00045	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00048	8b 4d f4	 mov	 ecx, DWORD PTR __Right_size$[ebp]
  0004b	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2740 :             _My_data._Myres  = _BUF_SIZE - 1;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00051	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 2741 :             return;

  00058	e9 9b 00 00 00	 jmp	 $LN1@Construct_
$LN2@Construct_:

; 4409 :         return _Mypair._Get_first();

  0005d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00060	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00063	8b 45 cc	 mov	 eax, DWORD PTR $T4[ebp]
  00066	89 45 b8	 mov	 DWORD PTR __Al$[ebp], eax

; 2745 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  00069	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00071	89 45 e8	 mov	 DWORD PTR $T6[ebp], eax
  00074	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  00077	83 c8 0f	 or	 eax, 15			; 0000000fH
  0007a	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0007d	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  00080	3b 45 e4	 cmp	 eax, DWORD PTR $T5[ebp]
  00083	73 08		 jae	 SHORT $LN52@Construct_
  00085	8d 45 e8	 lea	 eax, DWORD PTR $T6[ebp]
  00088	89 45 e0	 mov	 DWORD PTR tv138[ebp], eax
  0008b	eb 06		 jmp	 SHORT $LN53@Construct_
$LN52@Construct_:
  0008d	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  00090	89 45 e0	 mov	 DWORD PTR tv138[ebp], eax
$LN53@Construct_:
  00093	8b 45 e0	 mov	 eax, DWORD PTR tv138[ebp]
  00096	89 45 c8	 mov	 DWORD PTR $T3[ebp], eax
  00099	8b 45 c8	 mov	 eax, DWORD PTR $T3[ebp]
  0009c	89 45 c4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2745 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  0009f	8b 45 c4	 mov	 eax, DWORD PTR $T2[ebp]
  000a2	8b 00		 mov	 eax, DWORD PTR [eax]
  000a4	89 45 d4	 mov	 DWORD PTR __New_capacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000a7	c6 45 ff 00	 mov	 BYTE PTR __Overflow_is_possible$7[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2746 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000ab	8b 45 d4	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  000ae	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000b5	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2746 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000b6	89 45 dc	 mov	 DWORD PTR __New_array$[ebp], eax

; 2747 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);

  000b9	8d 45 dc	 lea	 eax, DWORD PTR __New_array$[ebp]
  000bc	50		 push	 eax
  000bd	ff 75 f8	 push	 DWORD PTR __My_data$[ebp]
  000c0	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c5	59		 pop	 ecx
  000c6	59		 pop	 ecx

; 2748 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  000c7	8b 45 dc	 mov	 eax, DWORD PTR __New_array$[ebp]
  000ca	89 45 c0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000cd	8b 45 c0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000d0	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2748 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  000d3	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  000d6	40		 inc	 eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d7	50		 push	 eax
  000d8	ff 75 d8	 push	 DWORD PTR __Right_ptr$[ebp]
  000db	ff 75 bc	 push	 DWORD PTR $T1[ebp]
  000de	e8 00 00 00 00	 call	 _memcpy
  000e3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2749 :         _My_data._Mysize = _Right_size;

  000e6	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000e9	8b 4d f4	 mov	 ecx, DWORD PTR __Right_size$[ebp]
  000ec	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2750 :         _My_data._Myres  = _New_capacity;

  000ef	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000f2	8b 4d d4	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  000f5	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN1@Construct_:

; 2751 :     }

  000f8	c9		 leave
  000f9	c2 04 00	 ret	 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z
_TEXT	SEGMENT
__My_data_mem$1 = -36					; size = 4
__Right_data_mem$2 = -32				; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
$T6 = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T7 = -1						; size = 1
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign, COMDAT
; _this$ = ecx

; 2636 :     void _Move_assign(basic_string& _Right, _Equal_allocators) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2637 :         _Tidy_deallocate();

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 4409 :         return _Mypair._Get_first();

  00011	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00014	89 45 f0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00017	8b 45 f0	 mov	 eax, DWORD PTR $T6[ebp]
  0001a	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
  0001d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00020	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00023	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00026	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 2638 :         _Pocma(_Getal(), _Right._Getal());

  00029	ff 75 e8	 push	 DWORD PTR $T4[ebp]
  0002c	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
  00034	59		 pop	 ecx
  00035	59		 pop	 ecx

; 2639 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});

  00036	33 c0		 xor	 eax, eax
  00038	88 45 ff	 mov	 BYTE PTR $T7[ebp], al
  0003b	8a 45 ff	 mov	 al, BYTE PTR $T7[ebp]
  0003e	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al

; 2680 :         const auto _My_data_mem =

  00041	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00044	89 45 dc	 mov	 DWORD PTR __My_data_mem$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2682 :         const auto _Right_data_mem =

  00047	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004a	89 45 e0	 mov	 DWORD PTR __Right_data_mem$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2684 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0004d	6a 18		 push	 24			; 00000018H
  0004f	ff 75 e0	 push	 DWORD PTR __Right_data_mem$2[ebp]
  00052	ff 75 dc	 push	 DWORD PTR __My_data_mem$1[ebp]
  00055	e8 00 00 00 00	 call	 _memcpy
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2703 :         _Right._Tidy_init();

  0005d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00060	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2640 :     }

  00065	c9		 leave
  00066	c2 08 00	 ret	 8
?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
_TEXT	SEGMENT
$T2 = -100						; size = 4
__Alproxy$ = -96					; size = 4
$T3 = -92						; size = 4
__First1$ = -88						; size = 4
__Ptr$ = -84						; size = 4
$T4 = -80						; size = 4
$T5 = -76						; size = 4
$T6 = -72						; size = 4
_this$ = -68						; size = 4
$T7 = -64						; size = 4
__Fancyptr$8 = -60					; size = 4
tv190 = -56						; size = 4
$T9 = -52						; size = 4
_this$ = -48						; size = 4
__Masked$10 = -44					; size = 4
__New_size$ = -40					; size = 4
__Ptr$ = -36						; size = 4
__My_data$ = -32					; size = 4
__Max$ = -28						; size = 4
_this$ = -24						; size = 4
__New_capacity$ = -20					; size = 4
__Overflow_is_possible$11 = -15				; size = 1
_$S21$ = -14						; size = 1
$T12 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 1
__Source_of_al$ = 12					; size = 4
__Left_ptr$ = 16					; size = 4
__Left_size$ = 20					; size = 4
__Right_ptr$ = 24					; size = 4
__Right_size$ = 28					; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2521 :             _One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 58	 sub	 esp, 88			; 00000058H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Source_of_al$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002b	89 45 c0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0002e	8b 45 c0	 mov	 eax, DWORD PTR $T7[ebp]
  00031	89 45 a4	 mov	 DWORD PTR $T3[ebp], eax

; 2199 : 
; 2200 :     // length of internal buffer, [1, 16]:
; 2201 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2202 :     // roundup mask for allocated buffers, [0, 15]:
; 2203 :     static constexpr size_type _ALLOC_MASK =
; 2204 :         sizeof(value_type) <= 1
; 2205 :             ? 15
; 2206 :             : sizeof(value_type) <= 2 ? 7 : sizeof(value_type) <= 4 ? 3 : sizeof(value_type) <= 8 ? 1 : 0;
; 2207 : 
; 2208 :     value_type* _Myptr() noexcept {
; 2209 :         value_type* _Result = _Bx._Buf;
; 2210 :         if (_Large_string_engaged()) {
; 2211 :             _Result = _Unfancy(_Bx._Ptr);
; 2212 :         }
; 2213 : 
; 2214 :         return _Result;
; 2215 :     }
; 2216 : 
; 2217 :     const value_type* _Myptr() const noexcept {
; 2218 :         const value_type* _Result = _Bx._Buf;
; 2219 :         if (_Large_string_engaged()) {
; 2220 :             _Result = _Unfancy(_Bx._Ptr);
; 2221 :         }
; 2222 : 
; 2223 :         return _Result;
; 2224 :     }
; 2225 : 
; 2226 :     bool _Large_string_engaged() const noexcept {
; 2227 :         return _BUF_SIZE <= _Myres;
; 2228 :     }
; 2229 : 
; 2230 :     void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]
; 2231 :         if (_Mysize < _Off) {
; 2232 :             _Xran();
; 2233 :         }
; 2234 :     }
; 2235 : 
; 2236 :     void _Check_offset_exclusive(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size())
; 2237 :         if (_Mysize <= _Off) {
; 2238 :             _Xran();
; 2239 :         }
; 2240 :     }
; 2241 : 
; 2242 :     [[noreturn]] static void _Xran() {
; 2243 :         _Xout_of_range("invalid string position");
; 2244 :     }
; 2245 : 
; 2246 :     size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2247 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2248 :         return (_STD min)(_Size, _Mysize - _Off);
; 2249 :     }
; 2250 : 
; 2251 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2252 :         _Bxty() noexcept {} // user-provided, for fancy pointers
; 2253 : 
; 2254 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2255 : 
; 2256 :         value_type _Buf[_BUF_SIZE];
; 2257 :         pointer _Ptr;
; 2258 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2259 :     } _Bx;
; 2260 : 
; 2261 :     size_type _Mysize; // current length of string
; 2262 :     size_type _Myres; // current storage reserved for string
; 2263 : };
; 2264 : 
; 2265 : // CLASS TEMPLATE basic_string
; 2266 : template <class _Ty>
; 2267 : constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty); // get _Ty's size after being EBCO'd
; 2268 : 
; 2269 : struct _String_constructor_concat_tag {
; 2270 :     // tag to select constructors used by basic_string's concatenation operators (operator+)
; 2271 :     explicit _String_constructor_concat_tag() = default;
; 2272 : };
; 2273 : 
; 2274 : [[noreturn]] inline void _Xlen_string() {
; 2275 :     _Xlength_error("string too long");
; 2276 : }
; 2277 : 
; 2278 : template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
; 2279 : class basic_string { // null-terminated transparent array of elements
; 2280 : private:
; 2281 :     friend _Tidy_deallocate_guard<basic_string>;
; 2282 : 
; 2283 :     using _Alty        = _Rebind_alloc_t<_Alloc, _Elem>;
; 2284 :     using _Alty_traits = allocator_traits<_Alty>;
; 2285 : 
; 2286 :     using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
; 2287 :         _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
; 2288 :             typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Elem&, const _Elem&>>>;
; 2289 : 
; 2290 :     static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
; 2291 :         _MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));
; 2292 : 
; 2293 :     static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 2294 :         "N4659 24.3.2.1 [string.require]/3 requires that the supplied "
; 2295 :         "char_traits character type match the string's character type.");
; 2296 : 
; 2297 :     static_assert(!is_array_v<_Elem> && is_trivial_v<_Elem> && is_standard_layout_v<_Elem>,
; 2298 :         "The character type of basic_string must be a non-array trivial standard-layout type. See N4861 "
; 2299 :         "[strings.general]/1.");
; 2300 : 
; 2301 : public:
; 2302 :     using traits_type    = _Traits;
; 2303 :     using allocator_type = _Alloc;
; 2304 : 
; 2305 :     using value_type      = _Elem;
; 2306 :     using size_type       = typename _Alty_traits::size_type;
; 2307 :     using difference_type = typename _Alty_traits::difference_type;
; 2308 :     using pointer         = typename _Alty_traits::pointer;
; 2309 :     using const_pointer   = typename _Alty_traits::const_pointer;
; 2310 :     using reference       = value_type&;
; 2311 :     using const_reference = const value_type&;
; 2312 : 
; 2313 :     using iterator       = _String_iterator<_Scary_val>;
; 2314 :     using const_iterator = _String_const_iterator<_Scary_val>;
; 2315 : 
; 2316 :     using reverse_iterator       = _STD reverse_iterator<iterator>;
; 2317 :     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 2318 : 
; 2319 : private:
; 2320 :     static constexpr auto _BUF_SIZE   = _Scary_val::_BUF_SIZE;
; 2321 :     static constexpr auto _ALLOC_MASK = _Scary_val::_ALLOC_MASK;
; 2322 : 
; 2323 :     // When doing _String_val operations by memcpy, we are touching:
; 2324 :     //   _String_val::_Bx::_Buf (type is array of _Elem)
; 2325 :     //   _String_val::_Bx::_Ptr (type is pointer)
; 2326 :     //   _String_val::_Mysize   (type is size_type)
; 2327 :     //   _String_val::_Myres    (type is size_type)
; 2328 :     // N4810 21.1 [strings.general]/1 says _Elem must be trivial standard-layout, so memcpy is safe.
; 2329 :     // We need to ask if pointer is safe to memcpy.
; 2330 :     // size_type must be an unsigned integral type so memcpy is safe.
; 2331 :     // We also need to disable memcpy if the user has supplied _Traits, since
; 2332 :     //   they can observe traits::assign and similar.
; 2333 :     static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;
; 2334 :     // This offset skips over the _Container_base members, if any
; 2335 :     static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
; 2336 :     static constexpr size_t _Memcpy_val_size   = sizeof(_Scary_val) - _Memcpy_val_offset;
; 2337 : 
; 2338 :     template <class _Iter>
; 2339 :     using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;
; 2340 : 
; 2341 : #if _HAS_CXX17
; 2342 :     template <class _StringViewIsh>
; 2343 :     using _Is_string_view_ish =
; 2344 :         enable_if_t<conjunction_v<is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
; 2345 :                         negation<is_convertible<const _StringViewIsh&, const _Elem*>>>,
; 2346 :             int>;
; 2347 : #endif // _HAS_CXX17
; 2348 : 
; 2349 : public:
; 2350 :     basic_string(const basic_string& _Right)
; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Construct_lv_contents(_Right);
; 2355 :         _Proxy._Release();
; 2356 :     }
; 2357 : 
; 2358 :     basic_string(const basic_string& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2359 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2360 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2361 :         _Construct_lv_contents(_Right);
; 2362 :         _Proxy._Release();
; 2363 :     }
; 2364 : 
; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();
; 2368 :     }
; 2369 : 
; 2370 :     explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2371 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2372 :         _Tidy_init();
; 2373 :     }
; 2374 : 
; 2375 :     basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
; 2376 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, <end>)
; 2377 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2378 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2379 :         _Tidy_init();
; 2380 :         assign(_Right, _Roff, npos);
; 2381 :         _Proxy._Release();
; 2382 :     }
; 2383 : 
; 2384 :     basic_string(
; 2385 :         const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2386 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)
; 2387 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2388 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2389 :         _Tidy_init();
; 2390 :         assign(_Right, _Roff, _Count);
; 2391 :         _Proxy._Release();
; 2392 :     }
; 2393 : 
; 2394 :     basic_string(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count)
; 2395 :         : _Mypair(_Zero_then_variadic_args_t{}) {
; 2396 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2397 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2398 :         _Tidy_init();
; 2399 :         assign(_Ptr, _Count);
; 2400 :         _Proxy._Release();
; 2401 :     }
; 2402 : 
; 2403 :     basic_string(
; 2404 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al)
; 2405 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2406 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2407 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2408 :         _Tidy_init();
; 2409 :         assign(_Ptr, _Count);
; 2410 :         _Proxy._Release();
; 2411 :     }
; 2412 : 
; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2414 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2415 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2416 :         _Tidy_init();
; 2417 :         assign(_Ptr);
; 2418 :         _Proxy._Release();
; 2419 :     }
; 2420 : 
; 2421 : #if _HAS_CXX17
; 2422 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2423 : #endif // _HAS_CXX17
; 2424 :     basic_string(_In_z_ const _Elem* const _Ptr, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2425 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2426 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2427 :         _Tidy_init();
; 2428 :         assign(_Ptr);
; 2429 :         _Proxy._Release();
; 2430 :     }
; 2431 : 
; 2432 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2433 :         // construct from _Count * _Ch
; 2434 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2435 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2436 :         _Tidy_init();
; 2437 :         assign(_Count, _Ch);
; 2438 :         _Proxy._Release();
; 2439 :     }
; 2440 : 
; 2441 : #if _HAS_CXX17
; 2442 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2443 : #endif // _HAS_CXX17
; 2444 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
; 2445 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Count * _Ch with allocator
; 2446 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2447 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2448 :         _Tidy_init();
; 2449 :         assign(_Count, _Ch);
; 2450 :         _Proxy._Release();
; 2451 :     }
; 2452 : 
; 2453 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2454 :     basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2455 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2456 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2457 :         _Tidy_init();
; 2458 :         _Adl_verify_range(_First, _Last);
; 2459 :         _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
; 2460 :         _Proxy._Release();
; 2461 :     }
; 2462 : 
; 2463 :     template <class _Iter>
; 2464 :     void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag) {
; 2465 :         // initialize from [_First, _Last), input iterators
; 2466 :         _Tidy_deallocate_guard<basic_string> _Guard{this};
; 2467 :         for (; _First != _Last; ++_First) {
; 2468 :             push_back(*_First);
; 2469 :         }
; 2470 : 
; 2471 :         _Guard._Target = nullptr;
; 2472 :     }
; 2473 : 
; 2474 :     template <class _Iter>
; 2475 :     void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag) {
; 2476 :         // initialize from [_First, _Last), forward iterators
; 2477 :         const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 2478 :         reserve(_Count);
; 2479 :         _Construct(_First, _Last, input_iterator_tag{});
; 2480 :     }
; 2481 : 
; 2482 :     void _Construct(_Elem* const _First, _Elem* const _Last, random_access_iterator_tag) {
; 2483 :         // initialize from [_First, _Last), pointers
; 2484 :         if (_First != _Last) {
; 2485 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2486 :         }
; 2487 :     }
; 2488 : 
; 2489 :     void _Construct(const _Elem* const _First, const _Elem* const _Last, random_access_iterator_tag) {
; 2490 :         // initialize from [_First, _Last), const pointers
; 2491 :         if (_First != _Last) {
; 2492 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2493 :         }
; 2494 :     }
; 2495 : 
; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {
; 2497 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2498 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2499 :     }
; 2500 : 
; 2501 :     basic_string(basic_string&& _Right, const _Alloc& _Al) noexcept(
; 2502 :         _Alty_traits::is_always_equal::value) // strengthened
; 2503 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2504 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2505 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2506 :         if _CONSTEXPR_IF (!_Alty_traits::is_always_equal::value) {
; 2507 :             if (_Getal() != _Right._Getal()) {
; 2508 :                 _Construct_lv_contents(_Right);
; 2509 :                 _Proxy._Release();
; 2510 :                 return;
; 2511 :             }
; 2512 :         }
; 2513 : 
; 2514 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2515 :         _Proxy._Release();
; 2516 :     }
; 2517 : 
; 2518 :     basic_string(_String_constructor_concat_tag, const basic_string& _Source_of_al, const _Elem* const _Left_ptr,
; 2519 :         const size_type _Left_size, const _Elem* const _Right_ptr, const size_type _Right_size)
; 2520 :         : _Mypair(

  00034	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 bc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0003a	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00040	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00043	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00047	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2199 : 
; 2200 :     // length of internal buffer, [1, 16]:
; 2201 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2202 :     // roundup mask for allocated buffers, [0, 15]:
; 2203 :     static constexpr size_type _ALLOC_MASK =
; 2204 :         sizeof(value_type) <= 1
; 2205 :             ? 15
; 2206 :             : sizeof(value_type) <= 2 ? 7 : sizeof(value_type) <= 4 ? 3 : sizeof(value_type) <= 8 ? 1 : 0;
; 2207 : 
; 2208 :     value_type* _Myptr() noexcept {
; 2209 :         value_type* _Result = _Bx._Buf;
; 2210 :         if (_Large_string_engaged()) {
; 2211 :             _Result = _Unfancy(_Bx._Ptr);
; 2212 :         }
; 2213 : 
; 2214 :         return _Result;
; 2215 :     }
; 2216 : 
; 2217 :     const value_type* _Myptr() const noexcept {
; 2218 :         const value_type* _Result = _Bx._Buf;
; 2219 :         if (_Large_string_engaged()) {
; 2220 :             _Result = _Unfancy(_Bx._Ptr);
; 2221 :         }
; 2222 : 
; 2223 :         return _Result;
; 2224 :     }
; 2225 : 
; 2226 :     bool _Large_string_engaged() const noexcept {
; 2227 :         return _BUF_SIZE <= _Myres;
; 2228 :     }
; 2229 : 
; 2230 :     void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]
; 2231 :         if (_Mysize < _Off) {
; 2232 :             _Xran();
; 2233 :         }
; 2234 :     }
; 2235 : 
; 2236 :     void _Check_offset_exclusive(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size())
; 2237 :         if (_Mysize <= _Off) {
; 2238 :             _Xran();
; 2239 :         }
; 2240 :     }
; 2241 : 
; 2242 :     [[noreturn]] static void _Xran() {
; 2243 :         _Xout_of_range("invalid string position");
; 2244 :     }
; 2245 : 
; 2246 :     size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2247 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2248 :         return (_STD min)(_Size, _Mysize - _Off);
; 2249 :     }
; 2250 : 
; 2251 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2252 :         _Bxty() noexcept {} // user-provided, for fancy pointers
; 2253 : 
; 2254 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2255 : 
; 2256 :         value_type _Buf[_BUF_SIZE];
; 2257 :         pointer _Ptr;
; 2258 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2259 :     } _Bx;
; 2260 : 
; 2261 :     size_type _Mysize; // current length of string
; 2262 :     size_type _Myres; // current storage reserved for string
; 2263 : };
; 2264 : 
; 2265 : // CLASS TEMPLATE basic_string
; 2266 : template <class _Ty>
; 2267 : constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty); // get _Ty's size after being EBCO'd
; 2268 : 
; 2269 : struct _String_constructor_concat_tag {
; 2270 :     // tag to select constructors used by basic_string's concatenation operators (operator+)
; 2271 :     explicit _String_constructor_concat_tag() = default;
; 2272 : };
; 2273 : 
; 2274 : [[noreturn]] inline void _Xlen_string() {
; 2275 :     _Xlength_error("string too long");
; 2276 : }
; 2277 : 
; 2278 : template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
; 2279 : class basic_string { // null-terminated transparent array of elements
; 2280 : private:
; 2281 :     friend _Tidy_deallocate_guard<basic_string>;
; 2282 : 
; 2283 :     using _Alty        = _Rebind_alloc_t<_Alloc, _Elem>;
; 2284 :     using _Alty_traits = allocator_traits<_Alty>;
; 2285 : 
; 2286 :     using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
; 2287 :         _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
; 2288 :             typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Elem&, const _Elem&>>>;
; 2289 : 
; 2290 :     static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
; 2291 :         _MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));
; 2292 : 
; 2293 :     static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 2294 :         "N4659 24.3.2.1 [string.require]/3 requires that the supplied "
; 2295 :         "char_traits character type match the string's character type.");
; 2296 : 
; 2297 :     static_assert(!is_array_v<_Elem> && is_trivial_v<_Elem> && is_standard_layout_v<_Elem>,
; 2298 :         "The character type of basic_string must be a non-array trivial standard-layout type. See N4861 "
; 2299 :         "[strings.general]/1.");
; 2300 : 
; 2301 : public:
; 2302 :     using traits_type    = _Traits;
; 2303 :     using allocator_type = _Alloc;
; 2304 : 
; 2305 :     using value_type      = _Elem;
; 2306 :     using size_type       = typename _Alty_traits::size_type;
; 2307 :     using difference_type = typename _Alty_traits::difference_type;
; 2308 :     using pointer         = typename _Alty_traits::pointer;
; 2309 :     using const_pointer   = typename _Alty_traits::const_pointer;
; 2310 :     using reference       = value_type&;
; 2311 :     using const_reference = const value_type&;
; 2312 : 
; 2313 :     using iterator       = _String_iterator<_Scary_val>;
; 2314 :     using const_iterator = _String_const_iterator<_Scary_val>;
; 2315 : 
; 2316 :     using reverse_iterator       = _STD reverse_iterator<iterator>;
; 2317 :     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 2318 : 
; 2319 : private:
; 2320 :     static constexpr auto _BUF_SIZE   = _Scary_val::_BUF_SIZE;
; 2321 :     static constexpr auto _ALLOC_MASK = _Scary_val::_ALLOC_MASK;
; 2322 : 
; 2323 :     // When doing _String_val operations by memcpy, we are touching:
; 2324 :     //   _String_val::_Bx::_Buf (type is array of _Elem)
; 2325 :     //   _String_val::_Bx::_Ptr (type is pointer)
; 2326 :     //   _String_val::_Mysize   (type is size_type)
; 2327 :     //   _String_val::_Myres    (type is size_type)
; 2328 :     // N4810 21.1 [strings.general]/1 says _Elem must be trivial standard-layout, so memcpy is safe.
; 2329 :     // We need to ask if pointer is safe to memcpy.
; 2330 :     // size_type must be an unsigned integral type so memcpy is safe.
; 2331 :     // We also need to disable memcpy if the user has supplied _Traits, since
; 2332 :     //   they can observe traits::assign and similar.
; 2333 :     static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;
; 2334 :     // This offset skips over the _Container_base members, if any
; 2335 :     static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
; 2336 :     static constexpr size_t _Memcpy_val_size   = sizeof(_Scary_val) - _Memcpy_val_offset;
; 2337 : 
; 2338 :     template <class _Iter>
; 2339 :     using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;
; 2340 : 
; 2341 : #if _HAS_CXX17
; 2342 :     template <class _StringViewIsh>
; 2343 :     using _Is_string_view_ish =
; 2344 :         enable_if_t<conjunction_v<is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
; 2345 :                         negation<is_convertible<const _StringViewIsh&, const _Elem*>>>,
; 2346 :             int>;
; 2347 : #endif // _HAS_CXX17
; 2348 : 
; 2349 : public:
; 2350 :     basic_string(const basic_string& _Right)
; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Construct_lv_contents(_Right);
; 2355 :         _Proxy._Release();
; 2356 :     }
; 2357 : 
; 2358 :     basic_string(const basic_string& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2359 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2360 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2361 :         _Construct_lv_contents(_Right);
; 2362 :         _Proxy._Release();
; 2363 :     }
; 2364 : 
; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();
; 2368 :     }
; 2369 : 
; 2370 :     explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2371 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2372 :         _Tidy_init();
; 2373 :     }
; 2374 : 
; 2375 :     basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
; 2376 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, <end>)
; 2377 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2378 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2379 :         _Tidy_init();
; 2380 :         assign(_Right, _Roff, npos);
; 2381 :         _Proxy._Release();
; 2382 :     }
; 2383 : 
; 2384 :     basic_string(
; 2385 :         const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2386 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)
; 2387 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2388 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2389 :         _Tidy_init();
; 2390 :         assign(_Right, _Roff, _Count);
; 2391 :         _Proxy._Release();
; 2392 :     }
; 2393 : 
; 2394 :     basic_string(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count)
; 2395 :         : _Mypair(_Zero_then_variadic_args_t{}) {
; 2396 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2397 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2398 :         _Tidy_init();
; 2399 :         assign(_Ptr, _Count);
; 2400 :         _Proxy._Release();
; 2401 :     }
; 2402 : 
; 2403 :     basic_string(
; 2404 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al)
; 2405 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2406 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2407 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2408 :         _Tidy_init();
; 2409 :         assign(_Ptr, _Count);
; 2410 :         _Proxy._Release();
; 2411 :     }
; 2412 : 
; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2414 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2415 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2416 :         _Tidy_init();
; 2417 :         assign(_Ptr);
; 2418 :         _Proxy._Release();
; 2419 :     }
; 2420 : 
; 2421 : #if _HAS_CXX17
; 2422 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2423 : #endif // _HAS_CXX17
; 2424 :     basic_string(_In_z_ const _Elem* const _Ptr, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2425 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2426 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2427 :         _Tidy_init();
; 2428 :         assign(_Ptr);
; 2429 :         _Proxy._Release();
; 2430 :     }
; 2431 : 
; 2432 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2433 :         // construct from _Count * _Ch
; 2434 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2435 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2436 :         _Tidy_init();
; 2437 :         assign(_Count, _Ch);
; 2438 :         _Proxy._Release();
; 2439 :     }
; 2440 : 
; 2441 : #if _HAS_CXX17
; 2442 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2443 : #endif // _HAS_CXX17
; 2444 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
; 2445 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Count * _Ch with allocator
; 2446 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2447 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2448 :         _Tidy_init();
; 2449 :         assign(_Count, _Ch);
; 2450 :         _Proxy._Release();
; 2451 :     }
; 2452 : 
; 2453 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2454 :     basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2455 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2456 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2457 :         _Tidy_init();
; 2458 :         _Adl_verify_range(_First, _Last);
; 2459 :         _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
; 2460 :         _Proxy._Release();
; 2461 :     }
; 2462 : 
; 2463 :     template <class _Iter>
; 2464 :     void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag) {
; 2465 :         // initialize from [_First, _Last), input iterators
; 2466 :         _Tidy_deallocate_guard<basic_string> _Guard{this};
; 2467 :         for (; _First != _Last; ++_First) {
; 2468 :             push_back(*_First);
; 2469 :         }
; 2470 : 
; 2471 :         _Guard._Target = nullptr;
; 2472 :     }
; 2473 : 
; 2474 :     template <class _Iter>
; 2475 :     void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag) {
; 2476 :         // initialize from [_First, _Last), forward iterators
; 2477 :         const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 2478 :         reserve(_Count);
; 2479 :         _Construct(_First, _Last, input_iterator_tag{});
; 2480 :     }
; 2481 : 
; 2482 :     void _Construct(_Elem* const _First, _Elem* const _Last, random_access_iterator_tag) {
; 2483 :         // initialize from [_First, _Last), pointers
; 2484 :         if (_First != _Last) {
; 2485 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2486 :         }
; 2487 :     }
; 2488 : 
; 2489 :     void _Construct(const _Elem* const _First, const _Elem* const _Last, random_access_iterator_tag) {
; 2490 :         // initialize from [_First, _Last), const pointers
; 2491 :         if (_First != _Last) {
; 2492 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2493 :         }
; 2494 :     }
; 2495 : 
; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {
; 2497 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2498 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2499 :     }
; 2500 : 
; 2501 :     basic_string(basic_string&& _Right, const _Alloc& _Al) noexcept(
; 2502 :         _Alty_traits::is_always_equal::value) // strengthened
; 2503 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2504 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2505 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2506 :         if _CONSTEXPR_IF (!_Alty_traits::is_always_equal::value) {
; 2507 :             if (_Getal() != _Right._Getal()) {
; 2508 :                 _Construct_lv_contents(_Right);
; 2509 :                 _Proxy._Release();
; 2510 :                 return;
; 2511 :             }
; 2512 :         }
; 2513 : 
; 2514 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2515 :         _Proxy._Release();
; 2516 :     }
; 2517 : 
; 2518 :     basic_string(_String_constructor_concat_tag, const basic_string& _Source_of_al, const _Elem* const _Left_ptr,
; 2519 :         const size_type _Left_size, const _Elem* const _Right_ptr, const size_type _Right_size)
; 2520 :         : _Mypair(

  0004e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2522 :         _STL_INTERNAL_CHECK(_Left_size <= max_size());
; 2523 :         _STL_INTERNAL_CHECK(_Right_size <= max_size());
; 2524 :         _STL_INTERNAL_CHECK(_Right_size <= max_size() - _Left_size);
; 2525 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);

  00052	8b 45 14	 mov	 eax, DWORD PTR __Left_size$[ebp]
  00055	03 45 1c	 add	 eax, DWORD PTR __Right_size$[ebp]
  00058	89 45 d8	 mov	 DWORD PTR __New_size$[ebp], eax

; 2526 :         size_type _New_capacity = _BUF_SIZE - 1;

  0005b	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR __New_capacity$[ebp], 15 ; 0000000fH

; 2527 :         auto& _My_data          = _Mypair._Myval2;

  00062	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __My_data$[ebp], eax

; 2528 :         _Elem* _Ptr             = _My_data._Bx._Buf;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0006b	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2529 :         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0006e	8d 45 f2	 lea	 eax, DWORD PTR _$S21$[ebp]
  00071	89 45 a0	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2530 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 2531 :         if (_New_capacity < _New_size) {

  00074	8b 45 ec	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00077	3b 45 d8	 cmp	 eax, DWORD PTR __New_size$[ebp]
  0007a	0f 83 a8 00 00
	00		 jae	 $LN2@basic_stri

; 2532 :             _New_capacity           = _Calculate_growth(_New_size, _BUF_SIZE - 1, max_size());

  00080	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00088	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0008b	8b 45 d8	 mov	 eax, DWORD PTR __New_size$[ebp]
  0008e	83 c8 0f	 or	 eax, 15			; 0000000fH
  00091	89 45 d4	 mov	 DWORD PTR __Masked$10[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00094	8b 45 d4	 mov	 eax, DWORD PTR __Masked$10[ebp]
  00097	3b 45 e4	 cmp	 eax, DWORD PTR __Max$[ebp]
  0009a	76 08		 jbe	 SHORT $LN54@basic_stri

; 4287 :             return _Max;

  0009c	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0009f	89 45 ec	 mov	 DWORD PTR __New_capacity$[ebp], eax
  000a2	eb 4c		 jmp	 SHORT $LN56@basic_stri
$LN54@basic_stri:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  000a4	6a 0f		 push	 15			; 0000000fH
  000a6	58		 pop	 eax
  000a7	d1 e8		 shr	 eax, 1
  000a9	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  000ac	2b c8		 sub	 ecx, eax
  000ae	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  000b1	73 08		 jae	 SHORT $LN55@basic_stri

; 4291 :             return _Max;

  000b3	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  000b6	89 45 ec	 mov	 DWORD PTR __New_capacity$[ebp], eax
  000b9	eb 35		 jmp	 SHORT $LN56@basic_stri
$LN55@basic_stri:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000bb	6a 0f		 push	 15			; 0000000fH
  000bd	58		 pop	 eax
  000be	d1 e8		 shr	 eax, 1
  000c0	83 c0 0f	 add	 eax, 15			; 0000000fH
  000c3	89 45 cc	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  000c6	8b 45 d4	 mov	 eax, DWORD PTR __Masked$10[ebp]
  000c9	3b 45 cc	 cmp	 eax, DWORD PTR $T9[ebp]
  000cc	73 08		 jae	 SHORT $LN60@basic_stri
  000ce	8d 45 cc	 lea	 eax, DWORD PTR $T9[ebp]
  000d1	89 45 c8	 mov	 DWORD PTR tv190[ebp], eax
  000d4	eb 06		 jmp	 SHORT $LN61@basic_stri
$LN60@basic_stri:
  000d6	8d 45 d4	 lea	 eax, DWORD PTR __Masked$10[ebp]
  000d9	89 45 c8	 mov	 DWORD PTR tv190[ebp], eax
$LN61@basic_stri:
  000dc	8b 45 c8	 mov	 eax, DWORD PTR tv190[ebp]
  000df	89 45 b8	 mov	 DWORD PTR $T6[ebp], eax
  000e2	8b 45 b8	 mov	 eax, DWORD PTR $T6[ebp]
  000e5	89 45 b4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000e8	8b 45 b4	 mov	 eax, DWORD PTR $T5[ebp]
  000eb	8b 00		 mov	 eax, DWORD PTR [eax]
  000ed	89 45 ec	 mov	 DWORD PTR __New_capacity$[ebp], eax
$LN56@basic_stri:

; 4409 :         return _Mypair._Get_first();

  000f0	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000f3	89 45 b0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  000f6	8b 45 b0	 mov	 eax, DWORD PTR $T4[ebp]
  000f9	89 45 9c	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000fc	c6 45 f1 00	 mov	 BYTE PTR __Overflow_is_possible$11[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2533 :             const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws

  00100	8b 45 ec	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00103	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0010a	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2533 :             const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws

  0010b	89 45 c4	 mov	 DWORD PTR __Fancyptr$8[ebp], eax

; 2534 :             _Ptr                    = _Unfancy(_Fancyptr);

  0010e	8b 45 c4	 mov	 eax, DWORD PTR __Fancyptr$8[ebp]
  00111	89 45 ac	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00114	8b 45 ac	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00117	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2535 :             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

  0011a	8d 45 c4	 lea	 eax, DWORD PTR __Fancyptr$8[ebp]
  0011d	50		 push	 eax
  0011e	ff 75 e0	 push	 DWORD PTR __My_data$[ebp]
  00121	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  00126	59		 pop	 ecx
  00127	59		 pop	 ecx
$LN2@basic_stri:

; 2536 :         }
; 2537 : 
; 2538 :         _My_data._Mysize = _New_size;

  00128	8b 45 e0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0012b	8b 4d d8	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0012e	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2539 :         _My_data._Myres  = _New_capacity;

  00131	8b 45 e0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00134	8b 4d ec	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00137	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0013a	ff 75 14	 push	 DWORD PTR __Left_size$[ebp]
  0013d	ff 75 10	 push	 DWORD PTR __Left_ptr$[ebp]
  00140	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  00143	e8 00 00 00 00	 call	 _memcpy
  00148	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2540 :         _Traits::copy(_Ptr, _Left_ptr, _Left_size);
; 2541 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);

  0014b	8b 45 dc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0014e	03 45 14	 add	 eax, DWORD PTR __Left_size$[ebp]
  00151	89 45 a8	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00154	ff 75 1c	 push	 DWORD PTR __Right_size$[ebp]
  00157	ff 75 18	 push	 DWORD PTR __Right_ptr$[ebp]
  0015a	ff 75 a8	 push	 DWORD PTR __First1$[ebp]
  0015d	e8 00 00 00 00	 call	 _memcpy
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2542 :         _Traits::assign(_Ptr[_New_size], _Elem());

  00165	c6 45 f3 00	 mov	 BYTE PTR $T12[ebp], 0

; 428  :         _Left = _Right;

  00169	8b 45 dc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0016c	03 45 d8	 add	 eax, DWORD PTR __New_size$[ebp]
  0016f	8a 4d f3	 mov	 cl, BYTE PTR $T12[ebp]
  00172	88 08		 mov	 BYTE PTR [eax], cl

; 2543 :         _Proxy._Release();
; 2544 :     }

  00174	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00178	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0017b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00185	59		 pop	 ecx
  00186	c9		 leave
  00187	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z$0:
  00000	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 4
__My_data_mem$2 = -36					; size = 4
__Right_data_mem$3 = -32				; size = 4
_this$ = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T6 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 4409 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00015	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  0001b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0002e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00031	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2497 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2498 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});

  00035	33 c0		 xor	 eax, eax
  00037	88 45 ff	 mov	 BYTE PTR $T6[ebp], al
  0003a	8a 45 ff	 mov	 al, BYTE PTR $T6[ebp]
  0003d	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al

; 2680 :         const auto _My_data_mem =

  00040	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00043	89 45 dc	 mov	 DWORD PTR __My_data_mem$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2682 :         const auto _Right_data_mem =

  00046	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00049	89 45 e0	 mov	 DWORD PTR __Right_data_mem$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2684 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0004c	6a 18		 push	 24			; 00000018H
  0004e	ff 75 e0	 push	 DWORD PTR __Right_data_mem$3[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __My_data_mem$2[ebp]
  00054	e8 00 00 00 00	 call	 _memcpy
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2703 :         _Right._Tidy_init();

  0005c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2499 :     }

  00064	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c9		 leave
  00068	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Alproxy$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_$S6$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0002e	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00031	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00034	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0003b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00042	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2414 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00046	8d 45 f3	 lea	 eax, DWORD PTR _$S6$[ebp]
  00049	89 45 d8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2415 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2416 :         _Tidy_init();

  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00054	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00057	e8 00 00 00 00	 call	 _strlen
  0005c	59		 pop	 ecx
  0005d	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00060	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00063	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00066	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  00069	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0006c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2417 :         assign(_Ptr);
; 2418 :         _Proxy._Release();
; 2419 :     }

  00074	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00078	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	c9		 leave
  00087	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0001c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2368 :     }

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c9		 leave
  0002f	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Alproxy$ = -40					; size = 4
$T2 = -36						; size = 4
_this$ = -32						; size = 4
$T3 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_$S9$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00028	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002b	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0002e	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00031	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00034	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0003a	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00040	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00047	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  0004e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00052	8d 45 f3	 lea	 eax, DWORD PTR _$S9$[ebp]
  00055	89 45 d8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Construct_lv_contents(_Right);

  00058	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents

; 2355 :         _Proxy._Release();
; 2356 :     }

  00063	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00067	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00074	59		 pop	 ecx
  00075	c9		 leave
  00076	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2217 :     const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2218 :         const value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2224 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __snprintf
_TEXT	SEGMENT
__Result$ = -20						; size = 4
__Format$ = -16						; size = 4
__ArgList$ = -12					; size = 4
tv86 = -8						; size = 4
__Result$1 = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snprintf PROC						; COMDAT

; 1969 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1970 :         int _Result;
; 1971 :         va_list _ArgList;
; 1972 :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 f4	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1973 :     #pragma warning(suppress:28719)    // 28719
; 1974 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0000c	8b 45 10	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Format$[ebp], eax

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00012	ff 75 f4	 push	 DWORD PTR __ArgList$[ebp]
  00015	6a 00		 push	 0
  00017	ff 75 f0	 push	 DWORD PTR __Format$[ebp]
  0001a	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0001d	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00020	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	83 c9 01	 or	 ecx, 1
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	50		 push	 eax
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00034	83 c4 1c	 add	 esp, 28			; 0000001cH
  00037	89 45 fc	 mov	 DWORD PTR __Result$1[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  0003a	83 7d fc 00	 cmp	 DWORD PTR __Result$1[ebp], 0
  0003e	7d 06		 jge	 SHORT $LN7@snprintf
  00040	83 4d f8 ff	 or	 DWORD PTR tv86[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN3@snprintf
$LN7@snprintf:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$1[ebp]
  00049	89 45 f8	 mov	 DWORD PTR tv86[ebp], eax
$LN3@snprintf:

; 1973 :     #pragma warning(suppress:28719)    // 28719
; 1974 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0004c	8b 45 f8	 mov	 eax, DWORD PTR tv86[ebp]
  0004f	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 1975 :         __crt_va_end(_ArgList);

  00052	83 65 f4 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 1976 :         return _Result;

  00056	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 1977 :     }

  00059	c9		 leave
  0005a	c3		 ret	 0
__snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -20						; size = 4
__Format$ = -16						; size = 4
__ArgList$ = -12					; size = 4
tv86 = -8						; size = 4
__Result$1 = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 f4	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Format$[ebp], eax

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00012	ff 75 f4	 push	 DWORD PTR __ArgList$[ebp]
  00015	6a 00		 push	 0
  00017	ff 75 f0	 push	 DWORD PTR __Format$[ebp]
  0001a	6a ff		 push	 -1
  0001c	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  0001f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	83 c9 01	 or	 ecx, 1
  00029	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002c	50		 push	 eax
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00033	83 c4 1c	 add	 esp, 28			; 0000001cH
  00036	89 45 fc	 mov	 DWORD PTR __Result$1[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00039	83 7d fc 00	 cmp	 DWORD PTR __Result$1[ebp], 0
  0003d	7d 06		 jge	 SHORT $LN7@sprintf
  0003f	83 4d f8 ff	 or	 DWORD PTR tv86[ebp], -1
  00043	eb 06		 jmp	 SHORT $LN3@sprintf
$LN7@sprintf:
  00045	8b 45 fc	 mov	 eax, DWORD PTR __Result$1[ebp]
  00048	89 45 f8	 mov	 DWORD PTR tv86[ebp], eax
$LN3@sprintf:

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0004b	8b 45 f8	 mov	 eax, DWORD PTR tv86[ebp]
  0004e	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);

  00051	83 65 f4 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 1792 :         return _Result;

  00055	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 1793 :     }

  00058	c9		 leave
  00059	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonMiniMap.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000d	48		 dec	 eax
  0000e	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00015	76 11		 jbe	 SHORT $LN1@vector
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001a	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00020	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00023	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00026	eb dc		 jmp	 SHORT $LN2@vector
$LN1@vector:
  00028	c9		 leave
  00029	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
