; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0CFrameController@@QAE@ABV0@@Z		; CFrameController::CFrameController
PUBLIC	??_GCFrameController@@UAEPAXI@Z			; CFrameController::`scalar deleting destructor'
PUBLIC	?begin@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::begin
PUBLIC	?deallocate@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXQAPAVCGraphicImageInstance@@I@Z ; std::allocator<CGraphicImageInstance *>::deallocate
PUBLIC	??0?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@$$QAV01@@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >
PUBLIC	?_Reallocate_exactly@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXI@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Reallocate_exactly
PUBLIC	?reserve@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXI@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::reserve
PUBLIC	?clear@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXPAPAVCGraphicImageInstance@@0@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@ABEII@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXQAPAVCGraphicImageInstance@@II@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@CAXXZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Xlength
PUBLIC	?_Getal@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEAAV?$allocator@PAVCGraphicImageInstance@@@2@XZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Getal
PUBLIC	??0STextureInstance@CEffectMeshInstance@@QAE@XZ	; CEffectMeshInstance::STextureInstance::STextureInstance
PUBLIC	??_GSTextureInstance@CEffectMeshInstance@@QAEPAXI@Z ; CEffectMeshInstance::STextureInstance::`scalar deleting destructor'
PUBLIC	??0CEffectMeshInstance@@QAE@XZ			; CEffectMeshInstance::CEffectMeshInstance
PUBLIC	??1CEffectMeshInstance@@UAE@XZ			; CEffectMeshInstance::~CEffectMeshInstance
PUBLIC	?DestroySystem@CEffectMeshInstance@@SAXXZ	; CEffectMeshInstance::DestroySystem
PUBLIC	?New@CEffectMeshInstance@@SAPAV1@XZ		; CEffectMeshInstance::New
PUBLIC	?Delete@CEffectMeshInstance@@SAXPAV1@@Z		; CEffectMeshInstance::Delete
PUBLIC	?OnSetDataPointer@CEffectMeshInstance@@MAEXPAVCEffectElementBase@@@Z ; CEffectMeshInstance::OnSetDataPointer
PUBLIC	?OnInitialize@CEffectMeshInstance@@MAEXXZ	; CEffectMeshInstance::OnInitialize
PUBLIC	?OnDestroy@CEffectMeshInstance@@MAEXXZ		; CEffectMeshInstance::OnDestroy
PUBLIC	?OnUpdate@CEffectMeshInstance@@MAE_NM@Z		; CEffectMeshInstance::OnUpdate
PUBLIC	?OnRender@CEffectMeshInstance@@MAEXXZ		; CEffectMeshInstance::OnRender
PUBLIC	?isActive@CEffectMeshInstance@@IAEHXZ		; CEffectMeshInstance::isActive
PUBLIC	?deallocate@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXQAUSTextureInstance@CEffectMeshInstance@@I@Z ; std::allocator<CEffectMeshInstance::STextureInstance>::deallocate
PUBLIC	??1?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::~vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >
PUBLIC	?clear@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXXZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::clear
PUBLIC	?_Destroy@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXPAUSTextureInstance@CEffectMeshInstance@@0@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@ABEII@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXQAUSTextureInstance@CEffectMeshInstance@@II@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Change_array
PUBLIC	?_Tidy@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXXZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Tidy
PUBLIC	?_Xlength@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@CAXXZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Xlength
PUBLIC	?_Getal@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@2@XZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Getal
PUBLIC	??1?$CRef@VCEffectMesh@@@@QAE@XZ		; CRef<CEffectMesh>::~CRef<CEffectMesh>
PUBLIC	?SetPointer@?$CRef@VCEffectMesh@@@@QAEXPAVCReferenceObject@@@Z ; CRef<CEffectMesh>::SetPointer
PUBLIC	??_GCEffectMeshInstance@@UAEPAXI@Z		; CEffectMeshInstance::`scalar deleting destructor'
PUBLIC	?SafeRotationNormalizedArc@@YA?AUD3DXQUATERNION@@ABUD3DXVECTOR3@@0@Z ; SafeRotationNormalizedArc
PUBLIC	??0?$CDynamicPool@VCEffectMeshInstance@@@@QAE@XZ ; CDynamicPool<CEffectMeshInstance>::CDynamicPool<CEffectMeshInstance>
PUBLIC	??1?$CDynamicPool@VCEffectMeshInstance@@@@UAE@XZ ; CDynamicPool<CEffectMeshInstance>::~CDynamicPool<CEffectMeshInstance>
PUBLIC	?Destroy@?$CDynamicPool@VCEffectMeshInstance@@@@QAEXXZ ; CDynamicPool<CEffectMeshInstance>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ ; CDynamicPool<CEffectMeshInstance>::Alloc
PUBLIC	?Delete@?$CDynamicPool@VCEffectMeshInstance@@@@KAXPAVCEffectMeshInstance@@@Z ; CDynamicPool<CEffectMeshInstance>::Delete
PUBLIC	?deallocate@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXQAPAVCEffectMeshInstance@@I@Z ; std::allocator<CEffectMeshInstance *>::deallocate
PUBLIC	?clear@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXXZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXPAPAVCEffectMeshInstance@@0@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@ABEII@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXQAPAVCEffectMeshInstance@@II@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXXZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@CAXXZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Xlength
PUBLIC	??_G?$CDynamicPool@VCEffectMeshInstance@@@@UAEPAXI@Z ; CDynamicPool<CEffectMeshInstance>::`scalar deleting destructor'
PUBLIC	?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ ; CDynamicPool<CGraphicImageInstance>::Alloc
PUBLIC	?CEffectMeshInstance_DeleteImageInstance@@YAXPAVCGraphicImageInstance@@@Z ; CEffectMeshInstance_DeleteImageInstance
PUBLIC	?CEffectMeshInstance_DeleteTextureInstance@@YAXAAUSTextureInstance@CEffectMeshInstance@@@Z ; CEffectMeshInstance_DeleteTextureInstance
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@P6AXPAVCEffectMeshInstance@@@Z@std@@YAP6AXPAVCEffectMeshInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >,void (__cdecl*)(CEffectMeshInstance *)>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Resize<std::_Value_init_tag>
PUBLIC	??$emplace_back@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXABQAVCGraphicImageInstance@@@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::emplace_back<CGraphicImageInstance * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXABQAVCGraphicImageInstance@@@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Emplace_back_with_unused_capacity<CGraphicImageInstance * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Emplace_reallocate<CGraphicImageInstance * const &>
PUBLIC	??$emplace_back@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXABQAVCEffectMeshInstance@@@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::emplace_back<CEffectMeshInstance * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXABQAVCEffectMeshInstance@@@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Emplace_back_with_unused_capacity<CEffectMeshInstance * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Emplace_reallocate<CEffectMeshInstance * const &>
PUBLIC	??$_Destroy_range@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@QAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshInstance::STextureInstance> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@YAXPAPAVCGraphicImageInstance@@QAPAV1@AAV?$allocator@PAVCGraphicImageInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicImageInstance *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@YAXPAPAVCEffectMeshInstance@@QAPAV1@AAV?$allocator@PAVCEffectMeshInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshInstance *> >
PUBLIC	??$_Uninitialized_move@PAPAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@YAPAPAVCGraphicImageInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicImageInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicImageInstance * *,std::allocator<CGraphicImageInstance *> >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Copy_memmove@PAPAVCGraphicImageInstance@@PAPAV1@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicImageInstance * *,CGraphicImageInstance * *>
PUBLIC	??$_Const_cast@$$CBV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PBV1@@Z ; std::_Const_cast<CTimeEvent<float> const >
PUBLIC	??$_Uninitialized_move@PAPAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@YAPAPAVCEffectMeshInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectMeshInstance@@@0@@Z ; std::_Uninitialized_move<CEffectMeshInstance * *,std::allocator<CEffectMeshInstance *> >
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@IAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<CEffectMeshInstance::STextureInstance> >
PUBLIC	??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@MU?$less@X@2@@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABMU?$less@X@0@@Z ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float,std::less<void> >
PUBLIC	??$_Copy_memmove@PAPAVCEffectMeshInstance@@PAPAV1@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CEffectMeshInstance * *,CEffectMeshInstance * *>
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<CEffectMeshInstance::STextureInstance> >::~_Uninitialized_backout_al<std::allocator<CEffectMeshInstance::STextureInstance> >
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<std::allocator<CEffectMeshInstance::STextureInstance> >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PAUSTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@QAU12@0PAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z ; std::_Uninitialized_move<CEffectMeshInstance::STextureInstance *,std::allocator<CEffectMeshInstance::STextureInstance> >
PUBLIC	??$lower_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@QAV1@ABMU?$less@X@0@@Z ; std::lower_bound<CTimeEvent<float> *,float,std::less<void> >
PUBLIC	??$upper_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z ; std::upper_bound<CTimeEvent<float> *,float,std::less<void> >
PUBLIC	??$_Emplace_back@USTextureInstance@CEffectMeshInstance@@@?$_Uninitialized_backout_al@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEX$$QAUSTextureInstance@CEffectMeshInstance@@@Z ; std::_Uninitialized_backout_al<std::allocator<CEffectMeshInstance::STextureInstance> >::_Emplace_back<CEffectMeshInstance::STextureInstance>
PUBLIC	??$_Refancy@PAV?$CTimeEvent@M@@$0A@@std@@YAPAV?$CTimeEvent@M@@PAV1@@Z ; std::_Refancy<CTimeEvent<float> *,0>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
PUBLIC	??_7CFrameController@@6B@			; CFrameController::`vftable'
PUBLIC	?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A ; CEffectMeshInstance::ms_kPool
PUBLIC	??_7CEffectMeshInstance@@6B@			; CEffectMeshInstance::`vftable'
PUBLIC	??_7?$CDynamicPool@VCEffectMeshInstance@@@@6B@	; CDynamicPool<CEffectMeshInstance>::`vftable'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CFrameController@@6B@			; CFrameController::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCFrameController@@@8			; CFrameController `RTTI Type Descriptor'
PUBLIC	??_R3CFrameController@@8			; CFrameController::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CFrameController@@8			; CFrameController::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CFrameController@@8		; CFrameController::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CEffectMeshInstance@@6B@			; CEffectMeshInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCEffectMeshInstance@@@8			; CEffectMeshInstance `RTTI Type Descriptor'
PUBLIC	??_R3CEffectMeshInstance@@8			; CEffectMeshInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CEffectMeshInstance@@8			; CEffectMeshInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CEffectMeshInstance@@8		; CEffectMeshInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CEffectElementBaseInstance@@8	; CEffectElementBaseInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCEffectElementBaseInstance@@@8		; CEffectElementBaseInstance `RTTI Type Descriptor'
PUBLIC	??_R3CEffectElementBaseInstance@@8		; CEffectElementBaseInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CEffectElementBaseInstance@@8		; CEffectElementBaseInstance::`RTTI Base Class Array'
PUBLIC	??_R4?$CDynamicPool@VCEffectMeshInstance@@@@6B@	; CDynamicPool<CEffectMeshInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCEffectMeshInstance@@@@@8 ; CDynamicPool<CEffectMeshInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCEffectMeshInstance@@@@8	; CDynamicPool<CEffectMeshInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCEffectMeshInstance@@@@8	; CDynamicPool<CEffectMeshInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCEffectMeshInstance@@@@8 ; CDynamicPool<CEffectMeshInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3a83126f
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@42b40000
PUBLIC	__real@437f0000
PUBLIC	__real@bf800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memmove:PROC
EXTRN	_sqrt:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?GetElapsedSecond@CTimer@@QAEMXZ:PROC		; CTimer::GetElapsedSecond
EXTRN	_D3DXVec3Normalize@8:PROC
EXTRN	_D3DXMatrixMultiply@12:PROC
EXTRN	_D3DXMatrixInverse@12:PROC
EXTRN	_D3DXMatrixRotationX@8:PROC
EXTRN	_D3DXMatrixRotationQuaternion@8:PROC
EXTRN	?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SetRenderState
EXTRN	?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z:PROC ; CStateManager::SetTexture
EXTRN	?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SetTextureStageState
EXTRN	?SetVertexShader@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetVertexShader
EXTRN	?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SetTransform
EXTRN	?DrawPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IPBXI@Z:PROC ; CStateManager::DrawPrimitiveUP
EXTRN	?AddReference@CReferenceObject@@QAEXXZ:PROC	; CReferenceObject::AddReference
EXTRN	?Release@CReferenceObject@@QAEXXZ:PROC		; CReferenceObject::Release
EXTRN	?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z:PROC ; CResourceManager::GetResourcePointer
EXTRN	?GetViewMatrix@CGraphicBase@@SAABUD3DXMATRIX@@XZ:PROC ; CGraphicBase::GetViewMatrix
EXTRN	?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ:PROC ; CGraphicTexture::GetD3DTexture
EXTRN	??0CGraphicImageInstance@@QAE@XZ:PROC		; CGraphicImageInstance::CGraphicImageInstance
EXTRN	?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z:PROC ; CGraphicImageInstance::SetImagePointer
EXTRN	?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ:PROC ; CGraphicImageInstance::GetTexturePointer
EXTRN	?GetPosition@CEffectElementBase@@QAEXMAAUD3DXVECTOR3@@@Z:PROC ; CEffectElementBase::GetPosition
EXTRN	??0CEffectElementBaseInstance@@QAE@XZ:PROC	; CEffectElementBaseInstance::CEffectElementBaseInstance
EXTRN	??1CEffectElementBaseInstance@@UAE@XZ:PROC	; CEffectElementBaseInstance::~CEffectElementBaseInstance
EXTRN	?Initialize@CEffectElementBaseInstance@@QAEXXZ:PROC ; CEffectElementBaseInstance::Initialize
EXTRN	?Destroy@CEffectElementBaseInstance@@QAEXXZ:PROC ; CEffectElementBaseInstance::Destroy
EXTRN	?isActive@CEffectElementBaseInstance@@QAE_NXZ:PROC ; CEffectElementBaseInstance::isActive
EXTRN	??0CFrameController@@QAE@XZ:PROC		; CFrameController::CFrameController
EXTRN	??1CFrameController@@UAE@XZ:PROC		; CFrameController::~CFrameController
EXTRN	?Clear@CFrameController@@QAEXXZ:PROC		; CFrameController::Clear
EXTRN	?Update@CFrameController@@QAEXM@Z:PROC		; CFrameController::Update
EXTRN	?GetCurrentFrame@CFrameController@@QAEEXZ:PROC	; CFrameController::GetCurrentFrame
EXTRN	?SetMaxFrame@CFrameController@@QAEXK@Z:PROC	; CFrameController::SetMaxFrame
EXTRN	?SetFrameTime@CFrameController@@QAEXM@Z:PROC	; CFrameController::SetFrameTime
EXTRN	?SetStartFrame@CFrameController@@QAEXK@Z:PROC	; CFrameController::SetStartFrame
EXTRN	?SetLoopFlag@CFrameController@@QAEXH@Z:PROC	; CFrameController::SetLoopFlag
EXTRN	?SetLoopCount@CFrameController@@QAEXH@Z:PROC	; CFrameController::SetLoopCount
EXTRN	?isActive@CFrameController@@QAEHK@Z:PROC	; CFrameController::isActive
EXTRN	??_ECFrameController@@UAEPAXI@Z:PROC		; CFrameController::`vector deleting destructor'
EXTRN	?GetFrameCount@CEffectMesh@@QAEKXZ:PROC		; CEffectMesh::GetFrameCount
EXTRN	?GetMeshCount@CEffectMesh@@QAEKXZ:PROC		; CEffectMesh::GetMeshCount
EXTRN	?GetMeshDataPointer@CEffectMesh@@QAEPAUSEffectMeshData@1@K@Z:PROC ; CEffectMesh::GetMeshDataPointer
EXTRN	?GetTextureVectorPointer@CEffectMesh@@QAEPAV?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@K@Z:PROC ; CEffectMesh::GetTextureVectorPointer
EXTRN	?GetMeshFileName@CEffectMeshScript@@QAEPBDXZ:PROC ; CEffectMeshScript::GetMeshFileName
EXTRN	?GetMeshDataPointer@CEffectMeshScript@@QAE_NKPAPAUSMeshData@1@@Z:PROC ; CEffectMeshScript::GetMeshDataPointer
EXTRN	?GetBillboardType@CEffectMeshScript@@QAEHK@Z:PROC ; CEffectMeshScript::GetBillboardType
EXTRN	?isBlendingEnable@CEffectMeshScript@@QAEHK@Z:PROC ; CEffectMeshScript::isBlendingEnable
EXTRN	?GetBlendingSrcType@CEffectMeshScript@@QAEEK@Z:PROC ; CEffectMeshScript::GetBlendingSrcType
EXTRN	?GetBlendingDestType@CEffectMeshScript@@QAEEK@Z:PROC ; CEffectMeshScript::GetBlendingDestType
EXTRN	?GetColorOperationType@CEffectMeshScript@@QAEHKPAE@Z:PROC ; CEffectMeshScript::GetColorOperationType
EXTRN	?GetColorFactor@CEffectMeshScript@@QAEHKPAUD3DXCOLOR@@@Z:PROC ; CEffectMeshScript::GetColorFactor
EXTRN	?GetTimeTableAlphaPointer@CEffectMeshScript@@QAEHKPAPAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@Z:PROC ; CEffectMeshScript::GetTimeTableAlphaPointer
EXTRN	?isMeshAnimationLoop@CEffectMeshScript@@QAEHXZ:PROC ; CEffectMeshScript::isMeshAnimationLoop
EXTRN	?GetMeshAnimationLoopCount@CEffectMeshScript@@QAEHXZ:PROC ; CEffectMeshScript::GetMeshAnimationLoopCount
EXTRN	?GetMeshAnimationFrameDelay@CEffectMeshScript@@QAEMXZ:PROC ; CEffectMeshScript::GetMeshAnimationFrameDelay
EXTRN	??_ECEffectMeshInstance@@UAEPAXI@Z:PROC		; CEffectMeshInstance::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@VCEffectMeshInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CEffectMeshInstance>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftoui3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?ms_kPool@CGraphicImageInstance@@2V?$CDynamicPool@VCGraphicImageInstance@@@@A:BYTE ; CGraphicImageInstance::ms_kPool
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A DD 01H DUP (?) ; CSingleton<CTimer>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A DD 01H DUP (?) ; CSingleton<CResourceManager>::ms_singleton
_BSS	ENDS
_BSS	SEGMENT
?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A DB 024H DUP (?) ; CEffectMeshInstance::ms_kPool
_BSS	ENDS
CRT$XCU	SEGMENT
??ms_kPool$initializer$@CEffectMeshInstance@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A@@YAXXZ ; ??ms_kPool$initializer$@CEffectMeshInstance@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCEffectMeshInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCEffectMeshInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCEffectMeshInstance@@@@@8 ; CDynamicPool<CEffectMeshInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCEffectMeshInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCEffectMeshInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCEffectMeshInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCEffectMeshInstance@@@@8 ; CDynamicPool<CEffectMeshInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCEffectMeshInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCEffectMeshInstance@@@@8 DD 00H	; CDynamicPool<CEffectMeshInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCEffectMeshInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCEffectMeshInstance@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCEffectMeshInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CEffectMeshInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCEffectMeshInstance@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCEffectMeshInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCEffectMeshInstance@@@@6B@ DD 00H	; CDynamicPool<CEffectMeshInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCEffectMeshInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCEffectMeshInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2CEffectElementBaseInstance@@8
rdata$r	SEGMENT
??_R2CEffectElementBaseInstance@@8 DD FLAT:??_R1A@?0A@EA@CEffectElementBaseInstance@@8 ; CEffectElementBaseInstance::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CEffectElementBaseInstance@@8
rdata$r	SEGMENT
??_R3CEffectElementBaseInstance@@8 DD 00H		; CEffectElementBaseInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CEffectElementBaseInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEffectElementBaseInstance@@@8
data$rs	SEGMENT
??_R0?AVCEffectElementBaseInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CEffectElementBaseInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEffectElementBaseInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CEffectElementBaseInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CEffectElementBaseInstance@@8 DD FLAT:??_R0?AVCEffectElementBaseInstance@@@8 ; CEffectElementBaseInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEffectElementBaseInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CEffectMeshInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CEffectMeshInstance@@8 DD FLAT:??_R0?AVCEffectMeshInstance@@@8 ; CEffectMeshInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEffectMeshInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CEffectMeshInstance@@8
rdata$r	SEGMENT
??_R2CEffectMeshInstance@@8 DD FLAT:??_R1A@?0A@EA@CEffectMeshInstance@@8 ; CEffectMeshInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CEffectElementBaseInstance@@8
rdata$r	ENDS
;	COMDAT ??_R3CEffectMeshInstance@@8
rdata$r	SEGMENT
??_R3CEffectMeshInstance@@8 DD 00H			; CEffectMeshInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CEffectMeshInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEffectMeshInstance@@@8
data$rs	SEGMENT
??_R0?AVCEffectMeshInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CEffectMeshInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEffectMeshInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CEffectMeshInstance@@6B@
rdata$r	SEGMENT
??_R4CEffectMeshInstance@@6B@ DD 00H			; CEffectMeshInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCEffectMeshInstance@@@8
	DD	FLAT:??_R3CEffectMeshInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CFrameController@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CFrameController@@8 DD FLAT:??_R0?AVCFrameController@@@8 ; CFrameController::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CFrameController@@8
rdata$r	ENDS
;	COMDAT ??_R2CFrameController@@8
rdata$r	SEGMENT
??_R2CFrameController@@8 DD FLAT:??_R1A@?0A@EA@CFrameController@@8 ; CFrameController::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CFrameController@@8
rdata$r	SEGMENT
??_R3CFrameController@@8 DD 00H				; CFrameController::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CFrameController@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCFrameController@@@8
data$rs	SEGMENT
??_R0?AVCFrameController@@@8 DD FLAT:??_7type_info@@6B@	; CFrameController `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCFrameController@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CFrameController@@6B@
rdata$r	SEGMENT
??_R4CFrameController@@6B@ DD 00H			; CFrameController::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCFrameController@@@8
	DD	FLAT:??_R3CFrameController@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCEffectMeshInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCEffectMeshInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCEffectMeshInstance@@@@6B@ ; CDynamicPool<CEffectMeshInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCEffectMeshInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CEffectMeshInstance@@6B@
CONST	SEGMENT
??_7CEffectMeshInstance@@6B@ DD FLAT:??_R4CEffectMeshInstance@@6B@ ; CEffectMeshInstance::`vftable'
	DD	FLAT:??_ECEffectMeshInstance@@UAEPAXI@Z
	DD	FLAT:?OnSetDataPointer@CEffectMeshInstance@@MAEXPAVCEffectElementBase@@@Z
	DD	FLAT:?OnInitialize@CEffectMeshInstance@@MAEXXZ
	DD	FLAT:?OnDestroy@CEffectMeshInstance@@MAEXXZ
	DD	FLAT:?OnUpdate@CEffectMeshInstance@@MAE_NM@Z
	DD	FLAT:?OnRender@CEffectMeshInstance@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7CFrameController@@6B@
CONST	SEGMENT
??_7CFrameController@@6B@ DD FLAT:??_R4CFrameController@@6B@ ; CFrameController::`vftable'
	DD	FLAT:??_ECFrameController@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_move@PAUSTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@QAU12@0PAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_move@PAUSTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@QAU12@0PAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_move@PAUSTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@QAU12@0PAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_move@PAUSTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@QAU12@0PAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_value_construct_n@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@IAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_value_construct_n@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@IAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_value_construct_n@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@IAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_value_construct_n@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@IAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$26 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$26
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ$0
__ehfuncinfo$?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ$0
__ehfuncinfo$?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CRef@VCEffectMesh@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CEffectMeshInstance@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1CEffectMeshInstance@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CEffectMeshInstance@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CEffectMeshInstance@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CEffectMeshInstance@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CEffectMeshInstance@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CEffectMeshInstance@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CEffectMeshInstance@@QAE@XZ$3
__ehfuncinfo$??0CEffectMeshInstance@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0CEffectMeshInstance@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate_exactly@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXI@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate_exactly@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXI@Z$0
__unwindtable$?_Reallocate_exactly@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate_exactly@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate_exactly@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXI@Z$11
__ehfuncinfo$?_Reallocate_exactly@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate_exactly@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate_exactly@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Refancy@PAV?$CTimeEvent@M@@$0A@@std@@YAPAV?$CTimeEvent@M@@PAV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Refancy@PAV?$CTimeEvent@M@@$0A@@std@@YAPAV?$CTimeEvent@M@@PAV1@@Z PROC ; std::_Refancy<CTimeEvent<float> *,0>, COMDAT

; 261  : _Pointer _Refancy(_Pointer _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 263  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Refancy@PAV?$CTimeEvent@M@@$0A@@std@@YAPAV?$CTimeEvent@M@@PAV1@@Z ENDP ; std::_Refancy<CTimeEvent<float> *,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Emplace_back@USTextureInstance@CEffectMeshInstance@@@?$_Uninitialized_backout_al@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEX$$QAUSTextureInstance@CEffectMeshInstance@@@Z
_TEXT	SEGMENT
___formal$ = -28					; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Ptr$ = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
_this$ = -4						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@USTextureInstance@CEffectMeshInstance@@@?$_Uninitialized_backout_al@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEX$$QAUSTextureInstance@CEffectMeshInstance@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<CEffectMeshInstance::STextureInstance> >::_Emplace_back<CEffectMeshInstance::STextureInstance>, COMDAT
; _this$ = ecx

; 1545 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00024	89 45 e4	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00027	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  0002a	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0002d	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  00030	89 45 f8	 mov	 DWORD PTR $T4[ebp], eax
  00033	ff 75 f8	 push	 DWORD PTR $T4[ebp]
  00036	8b 4d f4	 mov	 ecx, DWORD PTR $T3[ebp]
  00039	e8 00 00 00 00	 call	 ??0CFrameController@@QAE@ABV0@@Z
  0003e	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  00041	83 c0 24	 add	 eax, 36			; 00000024H
  00044	50		 push	 eax
  00045	8b 4d f4	 mov	 ecx, DWORD PTR $T3[ebp]
  00048	83 c1 24	 add	 ecx, 36			; 00000024H
  0004b	e8 00 00 00 00	 call	 ??0?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@$$QAV01@@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1547 :         ++_Last;

  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00056	83 c0 30	 add	 eax, 48			; 00000030H
  00059	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1548 :     }

  0005f	c9		 leave
  00060	c2 04 00	 ret	 4
??$_Emplace_back@USTextureInstance@CEffectMeshInstance@@@?$_Uninitialized_backout_al@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEX$$QAUSTextureInstance@CEffectMeshInstance@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<CEffectMeshInstance::STextureInstance> >::_Emplace_back<CEffectMeshInstance::STextureInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$upper_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z
_TEXT	SEGMENT
$T1 = -32						; size = 4
__UMid$2 = -28						; size = 4
tv91 = -24						; size = 4
__Count2$3 = -20					; size = 4
__First$ = -16						; size = 4
__First$ = -12						; size = 4
__UFirst$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$upper_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z PROC ; std::upper_bound<CTimeEvent<float> *,float,std::less<void> >, COMDAT

; 6725 : _NODISCARD _CONSTEXPR20 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 6726 :     // find first element that _Val is before
; 6727 :     _Adl_verify_range(_First, _Last);
; 6728 :     auto _UFirst                = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1303 :         return _It + 0;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax

; 1794 :         return _Last - _First; // assume the iterator will do debug checking

  00012	8b 45 e0	 mov	 eax, DWORD PTR $T1[ebp]
  00015	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  00018	c1 f8 03	 sar	 eax, 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6729 :     _Iter_diff_t<_FwdIt> _Count = _STD distance(_UFirst, _Get_unwrapped(_Last));

  0001b	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax
$LN2@upper_boun:

; 6730 : 
; 6731 :     while (0 < _Count) { // divide and conquer, find half that contains answer

  0001e	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00022	7e 72		 jle	 SHORT $LN3@upper_boun

; 6732 :         _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;

  00024	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00027	99		 cdq
  00028	2b c2		 sub	 eax, edx
  0002a	d1 f8		 sar	 eax, 1
  0002c	89 45 ec	 mov	 DWORD PTR __Count2$3[ebp], eax

; 6733 :         const auto _UMid             = _STD next(_UFirst, _Count2);

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00032	89 45 f4	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1714 :         _Where += _Off;

  00035	8b 45 ec	 mov	 eax, DWORD PTR __Count2$3[ebp]
  00038	8b 4d f4	 mov	 ecx, DWORD PTR __First$[ebp]
  0003b	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  0003e	89 45 f4	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6733 :         const auto _UMid             = _STD next(_UFirst, _Count2);

  00041	8b 45 f4	 mov	 eax, DWORD PTR __First$[ebp]
  00044	89 45 e4	 mov	 DWORD PTR __UMid$2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h

; 199  : 	return lhs < rhs.m_fTime;

  00047	8b 45 e4	 mov	 eax, DWORD PTR __UMid$2[ebp]
  0004a	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00051	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00054	76 09		 jbe	 SHORT $LN23@upper_boun
  00056	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv91[ebp], 1
  0005d	eb 04		 jmp	 SHORT $LN24@upper_boun
$LN23@upper_boun:
  0005f	83 65 e8 00	 and	 DWORD PTR tv91[ebp], 0
$LN24@upper_boun:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6734 :         if (_Pred(_Val, *_UMid)) {

  00063	0f b6 45 e8	 movzx	 eax, BYTE PTR tv91[ebp]
  00067	85 c0		 test	 eax, eax
  00069	74 08		 je	 SHORT $LN4@upper_boun

; 6735 :             _Count = _Count2;

  0006b	8b 45 ec	 mov	 eax, DWORD PTR __Count2$3[ebp]
  0006e	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 6736 :         } else { // try top half

  00071	eb 21		 jmp	 SHORT $LN5@upper_boun
$LN4@upper_boun:

; 6737 :             _UFirst = _Next_iter(_UMid);

  00073	8b 45 e4	 mov	 eax, DWORD PTR __UMid$2[ebp]
  00076	89 45 f0	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1837 :     return ++_First;

  00079	8b 45 f0	 mov	 eax, DWORD PTR __First$[ebp]
  0007c	83 c0 08	 add	 eax, 8
  0007f	89 45 f0	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6737 :             _UFirst = _Next_iter(_UMid);

  00082	8b 45 f0	 mov	 eax, DWORD PTR __First$[ebp]
  00085	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 6738 :             _Count -= _Count2 + 1;

  00088	8b 45 ec	 mov	 eax, DWORD PTR __Count2$3[ebp]
  0008b	40		 inc	 eax
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  0008f	2b c8		 sub	 ecx, eax
  00091	89 4d fc	 mov	 DWORD PTR __Count$[ebp], ecx
$LN5@upper_boun:

; 6739 :         }
; 6740 :     }

  00094	eb 88		 jmp	 SHORT $LN2@upper_boun
$LN3@upper_boun:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1492 :         _It = static_cast<_UIter&&>(_UIt);

  00096	8b 45 f8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00099	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6743 :     return _First;

  0009c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 6744 : }

  0009f	c9		 leave
  000a0	c3		 ret	 0
??$upper_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z ENDP ; std::upper_bound<CTimeEvent<float> *,float,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$lower_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@QAV1@ABMU?$less@X@0@@Z
_TEXT	SEGMENT
$T1 = -32						; size = 4
__UMid$2 = -28						; size = 4
tv91 = -24						; size = 4
__Count2$3 = -20					; size = 4
__First$ = -16						; size = 4
__First$ = -12						; size = 4
__UFirst$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$lower_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@QAV1@ABMU?$less@X@0@@Z PROC ; std::lower_bound<CTimeEvent<float> *,float,std::less<void> >, COMDAT

; 5849 : _NODISCARD _CONSTEXPR20 _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 5850 :     // find first element not before _Val
; 5851 :     _Adl_verify_range(_First, _Last);
; 5852 :     auto _UFirst                = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1303 :         return _It + 0;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax

; 1794 :         return _Last - _First; // assume the iterator will do debug checking

  00012	8b 45 e0	 mov	 eax, DWORD PTR $T1[ebp]
  00015	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  00018	c1 f8 03	 sar	 eax, 3

; 5853 :     _Iter_diff_t<_FwdIt> _Count = _STD distance(_UFirst, _Get_unwrapped(_Last));

  0001b	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax
$LN2@lower_boun:

; 5854 : 
; 5855 :     while (0 < _Count) { // divide and conquer, find half that contains answer

  0001e	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00022	7e 72		 jle	 SHORT $LN3@lower_boun

; 5856 :         const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;

  00024	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00027	99		 cdq
  00028	2b c2		 sub	 eax, edx
  0002a	d1 f8		 sar	 eax, 1
  0002c	89 45 ec	 mov	 DWORD PTR __Count2$3[ebp], eax

; 5857 :         const auto _UMid                   = _STD next(_UFirst, _Count2);

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00032	89 45 f4	 mov	 DWORD PTR __First$[ebp], eax

; 1714 :         _Where += _Off;

  00035	8b 45 ec	 mov	 eax, DWORD PTR __Count2$3[ebp]
  00038	8b 4d f4	 mov	 ecx, DWORD PTR __First$[ebp]
  0003b	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  0003e	89 45 f4	 mov	 DWORD PTR __First$[ebp], eax

; 5857 :         const auto _UMid                   = _STD next(_UFirst, _Count2);

  00041	8b 45 f4	 mov	 eax, DWORD PTR __First$[ebp]
  00044	89 45 e4	 mov	 DWORD PTR __UMid$2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h

; 193  : 	return lhs.m_fTime < rhs;

  00047	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0004a	8b 4d e4	 mov	 ecx, DWORD PTR __UMid$2[ebp]
  0004d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00051	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00054	76 09		 jbe	 SHORT $LN23@lower_boun
  00056	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv91[ebp], 1
  0005d	eb 04		 jmp	 SHORT $LN24@lower_boun
$LN23@lower_boun:
  0005f	83 65 e8 00	 and	 DWORD PTR tv91[ebp], 0
$LN24@lower_boun:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 5858 :         if (_Pred(*_UMid, _Val)) { // try top half

  00063	0f b6 45 e8	 movzx	 eax, BYTE PTR tv91[ebp]
  00067	85 c0		 test	 eax, eax
  00069	74 23		 je	 SHORT $LN4@lower_boun

; 5859 :             _UFirst = _Next_iter(_UMid);

  0006b	8b 45 e4	 mov	 eax, DWORD PTR __UMid$2[ebp]
  0006e	89 45 f0	 mov	 DWORD PTR __First$[ebp], eax

; 1837 :     return ++_First;

  00071	8b 45 f0	 mov	 eax, DWORD PTR __First$[ebp]
  00074	83 c0 08	 add	 eax, 8
  00077	89 45 f0	 mov	 DWORD PTR __First$[ebp], eax

; 5859 :             _UFirst = _Next_iter(_UMid);

  0007a	8b 45 f0	 mov	 eax, DWORD PTR __First$[ebp]
  0007d	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 5860 :             _Count -= _Count2 + 1;

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Count2$3[ebp]
  00083	40		 inc	 eax
  00084	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  00087	2b c8		 sub	 ecx, eax
  00089	89 4d fc	 mov	 DWORD PTR __Count$[ebp], ecx

; 5861 :         } else {

  0008c	eb 06		 jmp	 SHORT $LN5@lower_boun
$LN4@lower_boun:

; 5862 :             _Count = _Count2;

  0008e	8b 45 ec	 mov	 eax, DWORD PTR __Count2$3[ebp]
  00091	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax
$LN5@lower_boun:

; 5863 :         }
; 5864 :     }

  00094	eb 88		 jmp	 SHORT $LN2@lower_boun
$LN3@lower_boun:

; 1492 :         _It = static_cast<_UIter&&>(_UIt);

  00096	8b 45 f8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00099	89 45 08	 mov	 DWORD PTR __First$[ebp], eax

; 5865 : 
; 5866 :     _Seek_wrapped(_First, _UFirst);
; 5867 :     return _First;

  0009c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 5868 : }

  0009f	c9		 leave
  000a0	c3		 ret	 0
??$lower_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@QAV1@ABMU?$less@X@0@@Z ENDP ; std::lower_bound<CTimeEvent<float> *,float,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@QAU12@0PAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z
_TEXT	SEGMENT
__Backout$2 = -40					; size = 12
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__ULast$ = -20						; size = 4
__UFirst$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUSTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@QAU12@0PAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z PROC ; std::_Uninitialized_move<CEffectMeshInstance::STextureInstance *,std::allocator<CEffectMeshInstance::STextureInstance> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_move@PAUSTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@QAU12@0PAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __ULast$[ebp], eax

; 1535 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00031	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00034	89 45 d8	 mov	 DWORD PTR __Backout$2[ebp], eax
  00037	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003a	89 45 dc	 mov	 DWORD PTR __Backout$2[ebp+4], eax
  0003d	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00040	89 45 e0	 mov	 DWORD PTR __Backout$2[ebp+8], eax

; 1691 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1692 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1694 :         return _Dest + (_ULast - _UFirst);
; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00043	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {

  00047	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00049	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	83 c0 30	 add	 eax, 48			; 00000030H
  0004f	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  00052	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00055	3b 45 ec	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00058	74 13		 je	 SHORT $LN3@Uninitiali
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0005a	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0005d	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));

  00060	ff 75 e8	 push	 DWORD PTR $T4[ebp]
  00063	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00066	e8 00 00 00 00	 call	 ??$_Emplace_back@USTextureInstance@CEffectMeshInstance@@@?$_Uninitialized_backout_al@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEX$$QAUSTextureInstance@CEffectMeshInstance@@@Z ; std::_Uninitialized_backout_al<std::allocator<CEffectMeshInstance::STextureInstance> >::_Emplace_back<CEffectMeshInstance::STextureInstance>

; 1699 :         }

  0006b	eb dc		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1551 :         _First = _Last;

  0006d	8b 45 dc	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00070	89 45 d8	 mov	 DWORD PTR __Backout$2[ebp], eax

; 1552 :         return _Last;

  00073	8b 45 dc	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00076	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1700 : 
; 1701 :         return _Backout._Release();

  00079	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1541 :         _Destroy_range(_First, _Last, _Al);

  0007d	ff 75 e0	 push	 DWORD PTR __Backout$2[ebp+8]
  00080	ff 75 dc	 push	 DWORD PTR __Backout$2[ebp+4]
  00083	ff 75 d8	 push	 DWORD PTR __Backout$2[ebp]
  00086	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@QAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshInstance::STextureInstance> >
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1700 : 
; 1701 :         return _Backout._Release();

  0008e	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]

; 1702 :     }
; 1703 : }

  00091	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00094	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009b	59		 pop	 ecx
  0009c	c9		 leave
  0009d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_move@PAUSTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@QAU12@0PAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<CEffectMeshInstance::STextureInstance> >::~_Uninitialized_backout_al<std::allocator<CEffectMeshInstance::STextureInstance> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_move@PAUSTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@QAU12@0PAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_move@PAUSTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@QAU12@0PAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move@PAUSTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@QAU12@0PAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z ENDP ; std::_Uninitialized_move<CEffectMeshInstance::STextureInstance *,std::allocator<CEffectMeshInstance::STextureInstance> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
___formal$ = -20					; size = 4
$T1 = -16						; size = 4
__Ptr$ = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<CEffectMeshInstance::STextureInstance> >::_Emplace_back<>, COMDAT
; _this$ = ecx

; 1545 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001e	89 45 ec	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00021	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00024	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00027	6a 30		 push	 48			; 00000030H
  00029	6a 00		 push	 0
  0002b	ff 75 f8	 push	 DWORD PTR $T2[ebp]
  0002e	e8 00 00 00 00	 call	 _memset
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00039	e8 00 00 00 00	 call	 ??0STextureInstance@CEffectMeshInstance@@QAE@XZ

; 1547 :         ++_Last;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	83 c0 30	 add	 eax, 48			; 00000030H
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1548 :     }

  0004d	c9		 leave
  0004e	c3		 ret	 0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<CEffectMeshInstance::STextureInstance> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Uninitialized_backout_al@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<CEffectMeshInstance::STextureInstance> >::~_Uninitialized_backout_al<std::allocator<CEffectMeshInstance::STextureInstance> >, COMDAT
; _this$ = ecx

; 1540 :     ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1541 :         _Destroy_range(_First, _Last, _Al);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	ff 70 08	 push	 DWORD PTR [eax+8]
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	ff 70 04	 push	 DWORD PTR [eax+4]
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	ff 30		 push	 DWORD PTR [eax]
  00018	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@QAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshInstance::STextureInstance> >
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1542 :     }

  00020	c9		 leave
  00021	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<CEffectMeshInstance::STextureInstance> >::~_Uninitialized_backout_al<std::allocator<CEffectMeshInstance::STextureInstance> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCEffectMeshInstance@@PAPAV1@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCEffectMeshInstance@@PAPAV1@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CEffectMeshInstance * *,CEffectMeshInstance * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCEffectMeshInstance@@PAPAV1@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CEffectMeshInstance * *,CEffectMeshInstance * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@MU?$less@X@2@@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABMU?$less@X@0@@Z
_TEXT	SEGMENT
$T1 = -104						; size = 4
$T2 = -100						; size = 4
__It$ = -96						; size = 4
__UFirst2$3 = -92					; size = 4
__It$ = -88						; size = 4
__ULast2$4 = -84					; size = 4
$T5 = -80						; size = 1
$T6 = -76						; size = 1
__It$ = -72						; size = 4
__It$ = -68						; size = 4
__ULast$ = -64						; size = 4
$T7 = -60						; size = 4
$T8 = -56						; size = 4
__Ptr$9 = -52						; size = 4
$T10 = -48						; size = 4
$T11 = -44						; size = 4
__Ptr$12 = -40						; size = 4
tv182 = -36						; size = 4
tv180 = -32						; size = 4
__First$ = -28						; size = 4
__Count2$13 = -24					; size = 4
__First$ = -20						; size = 4
__First$ = -16						; size = 4
__UMid$14 = -12						; size = 4
__Count$ = -8						; size = 4
__UFirst$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@MU?$less@X@2@@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABMU?$less@X@0@@Z PROC ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float,std::less<void> >, COMDAT

; 6812 : _NODISCARD _CONSTEXPR20 pair<_FwdIt, _FwdIt> equal_range(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 d8	 mov	 DWORD PTR __Ptr$12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 d8	 mov	 eax, DWORD PTR __Ptr$12[ebp]
  0000f	89 45 d4	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 d4	 mov	 eax, DWORD PTR $T11[ebp]
  00015	89 45 d0	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6815 :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 d0	 mov	 eax, DWORD PTR $T10[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 cc	 mov	 DWORD PTR __Ptr$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 cc	 mov	 eax, DWORD PTR __Ptr$9[ebp]
  00027	89 45 c8	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 c8	 mov	 eax, DWORD PTR $T8[ebp]
  0002d	89 45 c4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6816 :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 c4	 mov	 eax, DWORD PTR $T7[ebp]
  00033	89 45 c0	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1794 :         return _Last - _First; // assume the iterator will do debug checking

  00036	8b 45 c0	 mov	 eax, DWORD PTR __ULast$[ebp]
  00039	2b 45 fc	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0003c	c1 f8 03	 sar	 eax, 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6819 :     _Diff _Count = _STD distance(_UFirst, _ULast);

  0003f	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax
$LN2@equal_rang:

; 6820 : 
; 6821 :     for (;;) { // divide and conquer, check midpoint
; 6822 :         if (_Count <= 0) {

  00042	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00046	7f 29		 jg	 SHORT $LN5@equal_rang
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1490 :         _It._Seek_to(static_cast<_UIter&&>(_UIt));

  00048	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004b	89 45 bc	 mov	 DWORD PTR __It$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 195  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

  0004e	ff 75 bc	 push	 DWORD PTR __It$[ebp]
  00051	e8 00 00 00 00	 call	 ??$_Refancy@PAV?$CTimeEvent@M@@$0A@@std@@YAPAV?$CTimeEvent@M@@PAV1@@Z ; std::_Refancy<CTimeEvent<float> *,0>
  00056	59		 pop	 ecx
  00057	89 45 10	 mov	 DWORD PTR __Last$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1490 :         _It._Seek_to(static_cast<_UIter&&>(_UIt));

  0005a	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0005d	89 45 b8	 mov	 DWORD PTR __It$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 195  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

  00060	ff 75 b8	 push	 DWORD PTR __It$[ebp]
  00063	e8 00 00 00 00	 call	 ??$_Refancy@PAV?$CTimeEvent@M@@$0A@@std@@YAPAV?$CTimeEvent@M@@PAV1@@Z ; std::_Refancy<CTimeEvent<float> *,0>
  00068	59		 pop	 ecx
  00069	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6825 :             break;

  0006c	e9 19 01 00 00	 jmp	 $LN3@equal_rang
$LN5@equal_rang:

; 6826 :         }
; 6827 : 
; 6828 :         _Diff _Count2    = _Count / 2;

  00071	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  00074	99		 cdq
  00075	2b c2		 sub	 eax, edx
  00077	d1 f8		 sar	 eax, 1
  00079	89 45 e8	 mov	 DWORD PTR __Count2$13[ebp], eax

; 6829 :         const auto _UMid = _STD next(_UFirst, _Count2);

  0007c	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0007f	89 45 f0	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1714 :         _Where += _Off;

  00082	8b 45 e8	 mov	 eax, DWORD PTR __Count2$13[ebp]
  00085	8b 4d f0	 mov	 ecx, DWORD PTR __First$[ebp]
  00088	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  0008b	89 45 f0	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6829 :         const auto _UMid = _STD next(_UFirst, _Count2);

  0008e	8b 45 f0	 mov	 eax, DWORD PTR __First$[ebp]
  00091	89 45 f4	 mov	 DWORD PTR __UMid$14[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h

; 193  : 	return lhs.m_fTime < rhs;

  00094	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  00097	8b 4d f4	 mov	 ecx, DWORD PTR __UMid$14[ebp]
  0009a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0009e	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  000a1	76 09		 jbe	 SHORT $LN49@equal_rang
  000a3	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv180[ebp], 1
  000aa	eb 04		 jmp	 SHORT $LN50@equal_rang
$LN49@equal_rang:
  000ac	83 65 e0 00	 and	 DWORD PTR tv180[ebp], 0
$LN50@equal_rang:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6830 :         if (_DEBUG_LT_PRED(_Pred, *_UMid, _Val)) { // range begins above _UMid, loop

  000b0	0f b6 45 e0	 movzx	 eax, BYTE PTR tv180[ebp]
  000b4	85 c0		 test	 eax, eax
  000b6	74 26		 je	 SHORT $LN6@equal_rang

; 6831 :             _UFirst = _Next_iter(_UMid);

  000b8	8b 45 f4	 mov	 eax, DWORD PTR __UMid$14[ebp]
  000bb	89 45 ec	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1837 :     return ++_First;

  000be	8b 45 ec	 mov	 eax, DWORD PTR __First$[ebp]
  000c1	83 c0 08	 add	 eax, 8
  000c4	89 45 ec	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6831 :             _UFirst = _Next_iter(_UMid);

  000c7	8b 45 ec	 mov	 eax, DWORD PTR __First$[ebp]
  000ca	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax

; 6832 :             _Count -= _Count2 + 1;

  000cd	8b 45 e8	 mov	 eax, DWORD PTR __Count2$13[ebp]
  000d0	40		 inc	 eax
  000d1	8b 4d f8	 mov	 ecx, DWORD PTR __Count$[ebp]
  000d4	2b c8		 sub	 ecx, eax
  000d6	89 4d f8	 mov	 DWORD PTR __Count$[ebp], ecx

; 6833 :         } else if (_Pred(_Val, *_UMid)) {

  000d9	e9 a7 00 00 00	 jmp	 $LN9@equal_rang
$LN6@equal_rang:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h

; 199  : 	return lhs < rhs.m_fTime;

  000de	8b 45 f4	 mov	 eax, DWORD PTR __UMid$14[ebp]
  000e1	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  000e4	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000e8	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  000eb	76 09		 jbe	 SHORT $LN57@equal_rang
  000ed	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv182[ebp], 1
  000f4	eb 04		 jmp	 SHORT $LN58@equal_rang
$LN57@equal_rang:
  000f6	83 65 dc 00	 and	 DWORD PTR tv182[ebp], 0
$LN58@equal_rang:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6833 :         } else if (_Pred(_Val, *_UMid)) {

  000fa	0f b6 45 dc	 movzx	 eax, BYTE PTR tv182[ebp]
  000fe	85 c0		 test	 eax, eax
  00100	74 08		 je	 SHORT $LN8@equal_rang

; 6834 :             _Count = _Count2; // range in first half, loop

  00102	8b 45 e8	 mov	 eax, DWORD PTR __Count2$13[ebp]
  00105	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 6835 :         } else { // range straddles _UMid, find each end and return

  00108	eb 7b		 jmp	 SHORT $LN9@equal_rang
$LN8@equal_rang:

; 6836 :             auto _UFirst2 = _STD lower_bound(_UFirst, _UMid, _Val, _Pass_fn(_Pred));

  0010a	8a 45 18	 mov	 al, BYTE PTR __Pred$[ebp]
  0010d	88 45 b4	 mov	 BYTE PTR $T6[ebp], al
  00110	ff 75 b4	 push	 DWORD PTR $T6[ebp]
  00113	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  00116	ff 75 f4	 push	 DWORD PTR __UMid$14[ebp]
  00119	ff 75 fc	 push	 DWORD PTR __UFirst$[ebp]
  0011c	e8 00 00 00 00	 call	 ??$lower_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@QAV1@ABMU?$less@X@0@@Z ; std::lower_bound<CTimeEvent<float> *,float,std::less<void> >
  00121	83 c4 10	 add	 esp, 16			; 00000010H
  00124	89 45 a4	 mov	 DWORD PTR __UFirst2$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1714 :         _Where += _Off;

  00127	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0012a	8b 4d fc	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  0012d	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00130	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6838 :             auto _ULast2 = _STD upper_bound(_Next_iter(_UMid), _UFirst, _Val, _Pass_fn(_Pred));

  00133	8a 45 18	 mov	 al, BYTE PTR __Pred$[ebp]
  00136	88 45 b0	 mov	 BYTE PTR $T5[ebp], al
  00139	8b 45 f4	 mov	 eax, DWORD PTR __UMid$14[ebp]
  0013c	89 45 e4	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1837 :     return ++_First;

  0013f	8b 45 e4	 mov	 eax, DWORD PTR __First$[ebp]
  00142	83 c0 08	 add	 eax, 8
  00145	89 45 e4	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6838 :             auto _ULast2 = _STD upper_bound(_Next_iter(_UMid), _UFirst, _Val, _Pass_fn(_Pred));

  00148	ff 75 b0	 push	 DWORD PTR $T5[ebp]
  0014b	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  0014e	ff 75 fc	 push	 DWORD PTR __UFirst$[ebp]
  00151	ff 75 e4	 push	 DWORD PTR __First$[ebp]
  00154	e8 00 00 00 00	 call	 ??$upper_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z ; std::upper_bound<CTimeEvent<float> *,float,std::less<void> >
  00159	83 c4 10	 add	 esp, 16			; 00000010H
  0015c	89 45 ac	 mov	 DWORD PTR __ULast2$4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1490 :         _It._Seek_to(static_cast<_UIter&&>(_UIt));

  0015f	8b 45 ac	 mov	 eax, DWORD PTR __ULast2$4[ebp]
  00162	89 45 a8	 mov	 DWORD PTR __It$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 195  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

  00165	ff 75 a8	 push	 DWORD PTR __It$[ebp]
  00168	e8 00 00 00 00	 call	 ??$_Refancy@PAV?$CTimeEvent@M@@$0A@@std@@YAPAV?$CTimeEvent@M@@PAV1@@Z ; std::_Refancy<CTimeEvent<float> *,0>
  0016d	59		 pop	 ecx
  0016e	89 45 10	 mov	 DWORD PTR __Last$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1490 :         _It._Seek_to(static_cast<_UIter&&>(_UIt));

  00171	8b 45 a4	 mov	 eax, DWORD PTR __UFirst2$3[ebp]
  00174	89 45 a0	 mov	 DWORD PTR __It$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 195  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

  00177	ff 75 a0	 push	 DWORD PTR __It$[ebp]
  0017a	e8 00 00 00 00	 call	 ??$_Refancy@PAV?$CTimeEvent@M@@$0A@@std@@YAPAV?$CTimeEvent@M@@PAV1@@Z ; std::_Refancy<CTimeEvent<float> *,0>
  0017f	59		 pop	 ecx
  00180	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6841 :             break;

  00183	eb 05		 jmp	 SHORT $LN3@equal_rang
$LN9@equal_rang:

; 6842 :         }
; 6843 :     }

  00185	e9 b8 fe ff ff	 jmp	 $LN2@equal_rang
$LN3@equal_rang:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0018a	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  0018d	89 45 9c	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00190	8b 45 9c	 mov	 eax, DWORD PTR $T2[ebp]
  00193	8b 00		 mov	 eax, DWORD PTR [eax]
  00195	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00198	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0019a	8d 45 10	 lea	 eax, DWORD PTR __Last$[ebp]
  0019d	89 45 98	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  001a0	8b 45 98	 mov	 eax, DWORD PTR $T1[ebp]
  001a3	8b 00		 mov	 eax, DWORD PTR [eax]
  001a5	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001a8	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6845 :     return {_First, _Last};

  001ab	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 6846 : }

  001ae	c9		 leave
  001af	c3		 ret	 0
??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@MU?$less@X@2@@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABMU?$less@X@0@@Z ENDP ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@IAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z
_TEXT	SEGMENT
__Backout$2 = -28					; size = 12
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@IAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<CEffectMeshInstance::STextureInstance> >, COMDAT

; 1862 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_value_construct_n@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@IAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1535 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	89 45 e4	 mov	 DWORD PTR __Backout$2[ebp], eax
  0002b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002e	89 45 e8	 mov	 DWORD PTR __Backout$2[ebp+4], eax
  00031	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00034	89 45 ec	 mov	 DWORD PTR __Backout$2[ebp+8], eax

; 1863 :     // value-initialize _Count objects to raw _First, using _Al
; 1864 :     using _Ptrty = typename _Alloc::value_type*;
; 1865 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1866 :         auto _PFirst = _Unfancy(_First);
; 1867 :         _Zero_range(_PFirst, _PFirst + _Count);
; 1868 :         return _First + _Count;
; 1869 :     } else {
; 1870 :         _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};

  00037	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1871 :         for (; 0 < _Count; --_Count) {

  0003b	eb 07		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  0003d	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00040	48		 dec	 eax
  00041	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax
$LN4@Uninitiali:
  00044	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00048	76 0a		 jbe	 SHORT $LN3@Uninitiali

; 1872 :             _Backout._Emplace_back();

  0004a	8d 4d e4	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  0004d	e8 00 00 00 00	 call	 ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<std::allocator<CEffectMeshInstance::STextureInstance> >::_Emplace_back<>

; 1873 :         }

  00052	eb e9		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1551 :         _First = _Last;

  00054	8b 45 e8	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00057	89 45 e4	 mov	 DWORD PTR __Backout$2[ebp], eax

; 1552 :         return _Last;

  0005a	8b 45 e8	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  0005d	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax

; 1874 : 
; 1875 :         return _Backout._Release();

  00060	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1541 :         _Destroy_range(_First, _Last, _Al);

  00064	ff 75 ec	 push	 DWORD PTR __Backout$2[ebp+8]
  00067	ff 75 e8	 push	 DWORD PTR __Backout$2[ebp+4]
  0006a	ff 75 e4	 push	 DWORD PTR __Backout$2[ebp]
  0006d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@QAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshInstance::STextureInstance> >
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1874 : 
; 1875 :         return _Backout._Release();

  00075	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]

; 1876 :     }
; 1877 : }

  00078	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00082	59		 pop	 ecx
  00083	c9		 leave
  00084	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_value_construct_n@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@IAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<CEffectMeshInstance::STextureInstance> >::~_Uninitialized_backout_al<std::allocator<CEffectMeshInstance::STextureInstance> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_value_construct_n@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@IAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_value_construct_n@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@IAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_value_construct_n@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@IAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<CEffectMeshInstance::STextureInstance> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@YAPAPAVCEffectMeshInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectMeshInstance@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@YAPAPAVCEffectMeshInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectMeshInstance@@@0@@Z PROC ; std::_Uninitialized_move<CEffectMeshInstance * *,std::allocator<CEffectMeshInstance *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCEffectMeshInstance@@PAPAV1@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CEffectMeshInstance * *,CEffectMeshInstance * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@YAPAPAVCEffectMeshInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectMeshInstance@@@0@@Z ENDP ; std::_Uninitialized_move<CEffectMeshInstance * *,std::allocator<CEffectMeshInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Const_cast@$$CBV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PBV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Const_cast@$$CBV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PBV1@@Z PROC ; std::_Const_cast<CTimeEvent<float> const >, COMDAT

; 292  : auto _Const_cast(_Ty* _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 293  :     return const_cast<remove_const_t<_Ty>*>(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 294  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Const_cast@$$CBV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PBV1@@Z ENDP ; std::_Const_cast<CTimeEvent<float> const >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCGraphicImageInstance@@PAPAV1@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCGraphicImageInstance@@PAPAV1@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CGraphicImageInstance * *,CGraphicImageInstance * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCGraphicImageInstance@@PAPAV1@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CGraphicImageInstance * *,CGraphicImageInstance * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Max_possible$2 = -148					; size = 4
$T3 = -144						; size = 4
$T4 = -140						; size = 4
__First$ = -136						; size = 4
__Last$ = -132						; size = 4
$T5 = -128						; size = 4
$T6 = -124						; size = 4
tv244 = -120						; size = 4
$T7 = -116						; size = 4
$T8 = -112						; size = 4
$T9 = -108						; size = 4
$T10 = -104						; size = 4
$T11 = -100						; size = 4
$T12 = -96						; size = 4
$T13 = -92						; size = 4
$T14 = -88						; size = 4
$T15 = -84						; size = 4
__Appended_last$ = -80					; size = 4
__Myfirst$ = -76					; size = 4
__Mylast$ = -72						; size = 4
__Oldsize$ = -68					; size = 4
__My_data$ = -64					; size = 4
tv147 = -60						; size = 4
$T16 = -56						; size = 4
$T17 = -52						; size = 4
__Appended_first$ = -48					; size = 4
___formal$ = -44					; size = 1
___formal$ = -40					; size = 1
__Overflow_is_possible$18 = -33				; size = 1
__Newvec$ = -32						; size = 4
__Newcapacity$ = -28					; size = 4
$T19 = -21						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1182 :     void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1737 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00035	89 45 ac	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00038	8b 45 ac	 mov	 eax, DWORD PTR $T15[ebp]
  0003b	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00041	c7 45 cc 55 55
	55 05		 mov	 DWORD PTR $T17[ebp], 89478485 ; 05555555H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00048	c7 45 a8 ff ff
	ff 7f		 mov	 DWORD PTR $T14[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0004f	8b 45 a8	 mov	 eax, DWORD PTR $T14[ebp]
  00052	89 45 c8	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00055	8b 45 cc	 mov	 eax, DWORD PTR $T17[ebp]
  00058	3b 45 c8	 cmp	 eax, DWORD PTR $T16[ebp]
  0005b	73 08		 jae	 SHORT $LN26@Resize_rea
  0005d	8d 45 cc	 lea	 eax, DWORD PTR $T17[ebp]
  00060	89 45 c4	 mov	 DWORD PTR tv147[ebp], eax
  00063	eb 06		 jmp	 SHORT $LN27@Resize_rea
$LN26@Resize_rea:
  00065	8d 45 c8	 lea	 eax, DWORD PTR $T16[ebp]
  00068	89 45 c4	 mov	 DWORD PTR tv147[ebp], eax
$LN27@Resize_rea:
  0006b	8b 45 c4	 mov	 eax, DWORD PTR tv147[ebp]
  0006e	89 45 a4	 mov	 DWORD PTR $T13[ebp], eax
  00071	8b 45 a4	 mov	 eax, DWORD PTR $T13[ebp]
  00074	89 45 a0	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00077	8b 45 a0	 mov	 eax, DWORD PTR $T12[ebp]
  0007a	8b 00		 mov	 eax, DWORD PTR [eax]
  0007c	89 45 9c	 mov	 DWORD PTR $T11[ebp], eax

; 1183 :         if (_Newsize > max_size()) {

  0007f	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00082	3b 45 9c	 cmp	 eax, DWORD PTR $T11[ebp]
  00085	76 05		 jbe	 SHORT $LN2@Resize_rea

; 1184 :             _Xlength();

  00087	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@CAXXZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Xlength
$LN2@Resize_rea:

; 1185 :         }
; 1186 : 
; 1187 :         auto& _My_data    = _Mypair._Myval2;

  0008c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	89 45 c0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1188 :         pointer& _Myfirst = _My_data._Myfirst;

  00092	8b 45 c0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00095	89 45 b4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1189 :         pointer& _Mylast  = _My_data._Mylast;

  00098	8b 45 c0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0009b	83 c0 04	 add	 eax, 4
  0009e	89 45 b8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1190 : 
; 1191 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  000a1	8b 45 b8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000a4	8b 4d b4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	2b 01		 sub	 eax, DWORD PTR [ecx]
  000ab	99		 cdq
  000ac	6a 30		 push	 48			; 00000030H
  000ae	59		 pop	 ecx
  000af	f7 f9		 idiv	 ecx
  000b1	89 45 bc	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1192 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000b4	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  000b7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@ABEII@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Calculate_growth
  000bf	89 45 e4	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  000c2	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000c5	89 45 98	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000c8	8b 45 98	 mov	 eax, DWORD PTR $T10[ebp]
  000cb	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000d1	c6 45 df 01	 mov	 BYTE PTR __Overflow_is_possible$18[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000d5	c7 85 6c ff ff
	ff 55 55 55 05	 mov	 DWORD PTR __Max_possible$2[ebp], 89478485 ; 05555555H

; 60   :         if (_Count > _Max_possible) {

  000df	81 7d e4 55 55
	55 05		 cmp	 DWORD PTR __Newcapacity$[ebp], 89478485 ; 05555555H
  000e6	76 05		 jbe	 SHORT $LN65@Resize_rea

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000e8	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN65@Resize_rea:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000ed	6b 45 e4 30	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 48
  000f1	89 45 94	 mov	 DWORD PTR $T9[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000f4	ff 75 94	 push	 DWORD PTR $T9[ebp]
  000f7	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000fc	59		 pop	 ecx
  000fd	89 45 e0	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1195 :         const pointer _Appended_first = _Newvec + _Oldsize;

  00100	6b 45 bc 30	 imul	 eax, DWORD PTR __Oldsize$[ebp], 48
  00104	03 45 e0	 add	 eax, DWORD PTR __Newvec$[ebp]
  00107	89 45 d0	 mov	 DWORD PTR __Appended_first$[ebp], eax

; 1196 :         pointer _Appended_last        = _Appended_first;

  0010a	8b 45 d0	 mov	 eax, DWORD PTR __Appended_first$[ebp]
  0010d	89 45 b0	 mov	 DWORD PTR __Appended_last$[ebp], eax

; 1197 : 
; 1198 :         _TRY_BEGIN

  00110	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00114	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00117	8a 00		 mov	 al, BYTE PTR [eax]
  00119	88 45 d8	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0011c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0011f	89 45 90	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00122	8b 45 90	 mov	 eax, DWORD PTR $T8[ebp]
  00125	89 45 8c	 mov	 DWORD PTR $T7[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00128	ff 75 8c	 push	 DWORD PTR $T7[ebp]

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  0012b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0012e	2b 45 bc	 sub	 eax, DWORD PTR __Oldsize$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00131	50		 push	 eax
  00132	ff 75 d0	 push	 DWORD PTR __Appended_first$[ebp]
  00135	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@IAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<CEffectMeshInstance::STextureInstance> >
  0013a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013d	89 45 88	 mov	 DWORD PTR tv244[ebp], eax

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00140	8b 45 88	 mov	 eax, DWORD PTR tv244[ebp]
  00143	89 45 b0	 mov	 DWORD PTR __Appended_last$[ebp], eax

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00146	8b 45 b8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00149	8b 00		 mov	 eax, DWORD PTR [eax]
  0014b	89 85 7c ff ff
	ff		 mov	 DWORD PTR __Last$[ebp], eax
  00151	8b 45 b4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00154	8b 00		 mov	 eax, DWORD PTR [eax]
  00156	89 85 78 ff ff
	ff		 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  0015c	33 c0		 xor	 eax, eax
  0015e	88 45 eb	 mov	 BYTE PTR $T19[ebp], al
  00161	8a 45 eb	 mov	 al, BYTE PTR $T19[ebp]
  00164	88 45 d4	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  00167	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0016a	89 45 84	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0016d	8b 45 84	 mov	 eax, DWORD PTR $T6[ebp]
  00170	89 45 80	 mov	 DWORD PTR $T5[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00173	ff 75 80	 push	 DWORD PTR $T5[ebp]
  00176	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  00179	ff b5 7c ff ff
	ff		 push	 DWORD PTR __Last$[ebp]
  0017f	ff b5 78 ff ff
	ff		 push	 DWORD PTR __First$[ebp]
  00185	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@QAU12@0PAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z ; std::_Uninitialized_move<CEffectMeshInstance::STextureInstance *,std::allocator<CEffectMeshInstance::STextureInstance> >
  0018a	83 c4 10	 add	 esp, 16			; 00000010H

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  0018d	eb 32		 jmp	 SHORT $LN5@Resize_rea
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1201 :         _CATCH_ALL
; 1202 :         _Destroy(_Appended_first, _Appended_last);

  0018f	ff 75 b0	 push	 DWORD PTR __Appended_last$[ebp]
  00192	ff 75 d0	 push	 DWORD PTR __Appended_first$[ebp]
  00195	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00198	e8 00 00 00 00	 call	 ?_Destroy@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXPAUSTextureInstance@CEffectMeshInstance@@0@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Destroy

; 1203 :         _Getal().deallocate(_Newvec, _Newcapacity);

  0019d	ff 75 e4	 push	 DWORD PTR __Newcapacity$[ebp]
  001a0	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  001a3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001a6	e8 00 00 00 00	 call	 ?_Getal@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@2@XZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Getal
  001ab	8b c8		 mov	 ecx, eax
  001ad	e8 00 00 00 00	 call	 ?deallocate@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXQAUSTextureInstance@CEffectMeshInstance@@I@Z ; std::allocator<CEffectMeshInstance::STextureInstance>::deallocate

; 1204 :         _RERAISE;

  001b2	6a 00		 push	 0
  001b4	6a 00		 push	 0
  001b6	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1205 :         _CATCH_END

  001bb	b8 00 00 00 00	 mov	 eax, $LN8@Resize_rea
  001c0	c3		 ret	 0
$LN5@Resize_rea:
  001c1	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  001c5	eb 04		 jmp	 SHORT __tryend$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$1
$LN8@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  001c7	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1206 : 
; 1207 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  001cb	ff 75 e4	 push	 DWORD PTR __Newcapacity$[ebp]
  001ce	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  001d1	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  001d4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001d7	e8 00 00 00 00	 call	 ?_Change_array@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXQAUSTextureInstance@CEffectMeshInstance@@II@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Change_array
$LN68@Resize_rea:

; 1208 :     }

  001dc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001df	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e6	59		 pop	 ecx
  001e7	5f		 pop	 edi
  001e8	5e		 pop	 esi
  001e9	5b		 pop	 ebx
  001ea	c9		 leave
  001eb	c2 08 00	 ret	 8
  001ee	cc		 int	 3
  001ef	cc		 int	 3
  001f0	cc		 int	 3
  001f1	cc		 int	 3
  001f2	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >, COMDAT
; _this$ = ecx

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 43   :         this->_Adopt(_Pvector);
; 44   :     }

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c9		 leave
  00013	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@YAPAPAVCGraphicImageInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicImageInstance@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@YAPAPAVCGraphicImageInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicImageInstance@@@0@@Z PROC ; std::_Uninitialized_move<CGraphicImageInstance * *,std::allocator<CGraphicImageInstance *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCGraphicImageInstance@@PAPAV1@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicImageInstance * *,CGraphicImageInstance * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@YAPAPAVCGraphicImageInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicImageInstance@@@0@@Z ENDP ; std::_Uninitialized_move<CGraphicImageInstance * *,std::allocator<CGraphicImageInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@YAXPAPAVCEffectMeshInstance@@QAPAV1@AAV?$allocator@PAVCEffectMeshInstance@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@YAXPAPAVCEffectMeshInstance@@QAPAV1@AAV?$allocator@PAVCEffectMeshInstance@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CEffectMeshInstance *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@YAXPAPAVCEffectMeshInstance@@QAPAV1@AAV?$allocator@PAVCEffectMeshInstance@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CEffectMeshInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@YAXPAPAVCGraphicImageInstance@@QAPAV1@AAV?$allocator@PAVCGraphicImageInstance@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@YAXPAPAVCGraphicImageInstance@@QAPAV1@AAV?$allocator@PAVCGraphicImageInstance@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CGraphicImageInstance *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@YAXPAPAVCGraphicImageInstance@@QAPAV1@AAV?$allocator@PAVCGraphicImageInstance@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CGraphicImageInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@QAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@QAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CEffectMeshInstance::STextureInstance> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {

  00004	eb 09		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	83 c0 30	 add	 eax, 48			; 00000030H
  0000c	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
  0000f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00012	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00015	74 12		 je	 SHORT $LN5@Destroy_ra
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001a	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 706  :         _Ptr->~_Uty();

  0001d	6a 00		 push	 0
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00022	e8 00 00 00 00	 call	 ??_GSTextureInstance@CEffectMeshInstance@@QAEPAXI@Z

; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }

  00027	eb dd		 jmp	 SHORT $LN2@Destroy_ra
$LN5@Destroy_ra:

; 969  :     }
; 970  : }

  00029	c9		 leave
  0002a	c3		 ret	 0
??$_Destroy_range@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@QAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CEffectMeshInstance::STextureInstance> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Emplace_reallocate<CEffectMeshInstance * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@CAXXZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@ABEII@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@YAPAPAVCEffectMeshInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectMeshInstance@@@0@@Z ; std::_Uninitialized_move<CEffectMeshInstance * *,std::allocator<CEffectMeshInstance *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@YAPAPAVCEffectMeshInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectMeshInstance@@@0@@Z ; std::_Uninitialized_move<CEffectMeshInstance * *,std::allocator<CEffectMeshInstance *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@YAPAPAVCEffectMeshInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectMeshInstance@@@0@@Z ; std::_Uninitialized_move<CEffectMeshInstance * *,std::allocator<CEffectMeshInstance *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXPAPAVCEffectMeshInstance@@0@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXQAPAVCEffectMeshInstance@@I@Z ; std::allocator<CEffectMeshInstance *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXQAPAVCEffectMeshInstance@@II@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Emplace_reallocate<CEffectMeshInstance * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXABQAVCEffectMeshInstance@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXABQAVCEffectMeshInstance@@@Z PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Emplace_back_with_unused_capacity<CEffectMeshInstance * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXABQAVCEffectMeshInstance@@@Z ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Emplace_back_with_unused_capacity<CEffectMeshInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXABQAVCEffectMeshInstance@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXABQAVCEffectMeshInstance@@@Z PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::emplace_back<CEffectMeshInstance * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXABQAVCEffectMeshInstance@@@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Emplace_back_with_unused_capacity<CEffectMeshInstance * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Emplace_reallocate<CEffectMeshInstance * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXABQAVCEffectMeshInstance@@@Z ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::emplace_back<CEffectMeshInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Emplace_reallocate<CGraphicImageInstance * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@CAXXZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@ABEII@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@YAPAPAVCGraphicImageInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicImageInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicImageInstance * *,std::allocator<CGraphicImageInstance *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@YAPAPAVCGraphicImageInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicImageInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicImageInstance * *,std::allocator<CGraphicImageInstance *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@YAPAPAVCGraphicImageInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicImageInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicImageInstance * *,std::allocator<CGraphicImageInstance *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXPAPAVCGraphicImageInstance@@0@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXQAPAVCGraphicImageInstance@@I@Z ; std::allocator<CGraphicImageInstance *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXQAPAVCGraphicImageInstance@@II@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Emplace_reallocate<CGraphicImageInstance * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXABQAVCGraphicImageInstance@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXABQAVCGraphicImageInstance@@@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Emplace_back_with_unused_capacity<CGraphicImageInstance * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXABQAVCGraphicImageInstance@@@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Emplace_back_with_unused_capacity<CGraphicImageInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXABQAVCGraphicImageInstance@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXABQAVCGraphicImageInstance@@@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::emplace_back<CGraphicImageInstance * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXABQAVCGraphicImageInstance@@@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Emplace_back_with_unused_capacity<CGraphicImageInstance * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Emplace_reallocate<CGraphicImageInstance * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXABQAVCGraphicImageInstance@@@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::emplace_back<CGraphicImageInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Oldlast$1 = -56					; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
__Oldcapacity$4 = -44					; size = 4
__Last$ = -40						; size = 4
$T5 = -36						; size = 4
$T6 = -32						; size = 4
__Newlast$7 = -28					; size = 4
__Oldsize$ = -24					; size = 4
__Myfirst$ = -20					; size = 4
__My_data$ = -16					; size = 4
_this$ = -12						; size = 4
__Mylast$ = -8						; size = 4
___formal$ = -4						; size = 1
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1211 :     void _Resize(const size_type _Newsize, const _Ty2& _Val) { // trim or append elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1212 :         auto& _My_data      = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1213 :         pointer& _Myfirst   = _My_data._Myfirst;

  0000f	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 ec	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1214 :         pointer& _Mylast    = _My_data._Mylast;

  00015	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	2b 01		 sub	 eax, DWORD PTR [ecx]
  00028	99		 cdq
  00029	6a 30		 push	 48			; 00000030H
  0002b	59		 pop	 ecx
  0002c	f7 f9		 idiv	 ecx
  0002e	89 45 e8	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1216 :         if (_Newsize < _Oldsize) { // trim

  00031	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00034	3b 45 e8	 cmp	 eax, DWORD PTR __Oldsize$[ebp]
  00037	73 3b		 jae	 SHORT $LN2@Resize

; 1217 :             const pointer _Newlast = _Myfirst + _Newsize;

  00039	6b 45 08 30	 imul	 eax, DWORD PTR __Newsize$[ebp], 48
  0003d	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00040	03 01		 add	 eax, DWORD PTR [ecx]
  00042	89 45 e4	 mov	 DWORD PTR __Newlast$7[ebp], eax

; 1218 :             _Orphan_range(_Newlast, _Mylast);
; 1219 :             _Destroy(_Newlast, _Mylast);

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00048	8b 00		 mov	 eax, DWORD PTR [eax]
  0004a	89 45 d8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0004d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00050	89 45 e0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00053	8b 45 e0	 mov	 eax, DWORD PTR $T6[ebp]
  00056	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00059	ff 75 dc	 push	 DWORD PTR $T5[ebp]
  0005c	ff 75 d8	 push	 DWORD PTR __Last$[ebp]
  0005f	ff 75 e4	 push	 DWORD PTR __Newlast$7[ebp]
  00062	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@QAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshInstance::STextureInstance> >
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1220 :             _Mylast = _Newlast;

  0006a	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006d	8b 4d e4	 mov	 ecx, DWORD PTR __Newlast$7[ebp]
  00070	89 08		 mov	 DWORD PTR [eax], ecx

; 1221 :             return;

  00072	eb 6a		 jmp	 SHORT $LN1@Resize
$LN2@Resize:

; 1222 :         }
; 1223 : 
; 1224 :         if (_Newsize > _Oldsize) { // append

  00074	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00077	3b 45 e8	 cmp	 eax, DWORD PTR __Oldsize$[ebp]
  0007a	76 62		 jbe	 SHORT $LN1@Resize

; 1225 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0007c	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00082	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00085	2b 01		 sub	 eax, DWORD PTR [ecx]
  00087	99		 cdq
  00088	6a 30		 push	 48			; 00000030H
  0008a	59		 pop	 ecx
  0008b	f7 f9		 idiv	 ecx
  0008d	89 45 d4	 mov	 DWORD PTR __Oldcapacity$4[ebp], eax

; 1226 :             if (_Newsize > _Oldcapacity) { // reallocate

  00090	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00093	3b 45 d4	 cmp	 eax, DWORD PTR __Oldcapacity$4[ebp]
  00096	76 10		 jbe	 SHORT $LN4@Resize

; 1227 :                 _Resize_reallocate(_Newsize, _Val);

  00098	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  0009b	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Resize_reallocate<std::_Value_init_tag>

; 1228 :                 return;

  000a6	eb 36		 jmp	 SHORT $LN1@Resize
$LN4@Resize:

; 1229 :             }
; 1230 : 
; 1231 :             const pointer _Oldlast = _Mylast;

  000a8	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000ab	8b 00		 mov	 eax, DWORD PTR [eax]
  000ad	89 45 c8	 mov	 DWORD PTR __Oldlast$1[ebp], eax

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000b0	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  000b3	8a 00		 mov	 al, BYTE PTR [eax]
  000b5	88 45 fc	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  000b8	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000bb	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000be	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  000c1	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000c4	ff 75 cc	 push	 DWORD PTR $T2[ebp]

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000c7	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000ca	2b 45 e8	 sub	 eax, DWORD PTR __Oldsize$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000cd	50		 push	 eax
  000ce	ff 75 c8	 push	 DWORD PTR __Oldlast$1[ebp]
  000d1	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@IAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<CEffectMeshInstance::STextureInstance> >
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000d9	8b 4d f8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000dc	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@Resize:

; 1233 :             _Orphan_range(_Oldlast, _Oldlast);
; 1234 :         }
; 1235 : 
; 1236 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1237 :     }

  000de	c9		 leave
  000df	c2 08 00	 ret	 8
??$_Resize@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@P6AXPAVCEffectMeshInstance@@@Z@std@@YAP6AXPAVCEffectMeshInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@P6AXPAVCEffectMeshInstance@@@Z@std@@YAP6AXPAVCEffectMeshInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >,void (__cdecl*)(CEffectMeshInstance *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@P6AXPAVCEffectMeshInstance@@@Z@std@@YAP6AXPAVCEffectMeshInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >,void (__cdecl*)(CEffectMeshInstance *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
;	COMDAT ?CEffectMeshInstance_DeleteTextureInstance@@YAXAAUSTextureInstance@CEffectMeshInstance@@@Z
_TEXT	SEGMENT
$T1 = -84						; size = 4
$T2 = -80						; size = 4
__ULast$3 = -76						; size = 4
$T4 = -72						; size = 4
$T5 = -68						; size = 4
__Ptr$6 = -64						; size = 4
__Last$ = -60						; size = 4
$T7 = -56						; size = 4
$T8 = -52						; size = 4
__Ptr$9 = -48						; size = 4
__First$ = -44						; size = 4
$T10 = -40						; size = 4
$T11 = -36						; size = 4
$T12 = -32						; size = 4
___param0$ = -28					; size = 4
$T13 = -24						; size = 4
___param0$ = -20					; size = 4
__My_data$14 = -16					; size = 4
__My_data$15 = -12					; size = 4
_rVector$ = -8						; size = 4
__UFirst$16 = -4					; size = 4
_rkInstance$ = 8					; size = 4
?CEffectMeshInstance_DeleteTextureInstance@@YAXAAUSTextureInstance@CEffectMeshInstance@@@Z PROC ; CEffectMeshInstance_DeleteTextureInstance, COMDAT

; 246  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H

; 247  : 	std::vector<CGraphicImageInstance*> & rVector = rkInstance.TextureInstanceVector;

  00006	8b 45 08	 mov	 eax, DWORD PTR _rkInstance$[ebp]
  00009	83 c0 24	 add	 eax, 36			; 00000024H
  0000c	89 45 f8	 mov	 DWORD PTR _rVector$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _rVector$[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __My_data$15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00015	8b 45 f4	 mov	 eax, DWORD PTR __My_data$15[ebp]
  00018	89 45 b0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0001b	8b 45 f4	 mov	 eax, DWORD PTR __My_data$15[ebp]
  0001e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00021	89 45 ec	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00024	8b 45 ec	 mov	 eax, DWORD PTR ___param0$[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T13[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0002a	8d 45 e8	 lea	 eax, DWORD PTR $T13[ebp]
  0002d	89 45 dc	 mov	 DWORD PTR $T11[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _rVector$[ebp]
  00033	89 45 f0	 mov	 DWORD PTR __My_data$14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f0	 mov	 eax, DWORD PTR __My_data$14[ebp]
  00039	89 45 ac	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f0	 mov	 eax, DWORD PTR __My_data$14[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e0	 mov	 DWORD PTR $T12[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e0	 lea	 eax, DWORD PTR $T12[ebp]
  0004d	89 45 d8	 mov	 DWORD PTR $T10[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 248  : 	for_each(rVector.begin(), rVector.end(), CEffectMeshInstance_DeleteImageInstance);

  00050	8b 45 dc	 mov	 eax, DWORD PTR $T11[ebp]
  00053	8b 00		 mov	 eax, DWORD PTR [eax]
  00055	89 45 c4	 mov	 DWORD PTR __Last$[ebp], eax
  00058	8b 45 d8	 mov	 eax, DWORD PTR $T10[ebp]
  0005b	8b 00		 mov	 eax, DWORD PTR [eax]
  0005d	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00060	8b 45 d4	 mov	 eax, DWORD PTR __First$[ebp]
  00063	89 45 d0	 mov	 DWORD PTR __Ptr$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00066	8b 45 d0	 mov	 eax, DWORD PTR __Ptr$9[ebp]
  00069	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0006c	8b 45 cc	 mov	 eax, DWORD PTR $T8[ebp]
  0006f	89 45 c8	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00072	8b 45 c8	 mov	 eax, DWORD PTR $T7[ebp]
  00075	89 45 fc	 mov	 DWORD PTR __UFirst$16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00078	8b 45 c4	 mov	 eax, DWORD PTR __Last$[ebp]
  0007b	89 45 c0	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0007e	8b 45 c0	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  00081	89 45 bc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00084	8b 45 bc	 mov	 eax, DWORD PTR $T5[ebp]
  00087	89 45 b8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  0008a	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  0008d	89 45 b4	 mov	 DWORD PTR __ULast$3[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00090	eb 09		 jmp	 SHORT $LN36@CEffectMes
$LN34@CEffectMes:
  00092	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$16[ebp]
  00095	83 c0 04	 add	 eax, 4
  00098	89 45 fc	 mov	 DWORD PTR __UFirst$16[ebp], eax
$LN36@CEffectMes:
  0009b	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$16[ebp]
  0009e	3b 45 b4	 cmp	 eax, DWORD PTR __ULast$3[ebp]
  000a1	74 0d		 je	 SHORT $LN33@CEffectMes

; 308  :         _Func(*_UFirst);

  000a3	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$16[ebp]
  000a6	ff 30		 push	 DWORD PTR [eax]
  000a8	e8 00 00 00 00	 call	 ?CEffectMeshInstance_DeleteImageInstance@@YAXPAVCGraphicImageInstance@@@Z ; CEffectMeshInstance_DeleteImageInstance
  000ad	59		 pop	 ecx

; 309  :     }

  000ae	eb e2		 jmp	 SHORT $LN34@CEffectMes
$LN33@CEffectMes:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 249  : 	rVector.clear();

  000b0	8b 4d f8	 mov	 ecx, DWORD PTR _rVector$[ebp]
  000b3	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::clear

; 250  : }

  000b8	c9		 leave
  000b9	c3		 ret	 0
?CEffectMeshInstance_DeleteTextureInstance@@YAXAAUSTextureInstance@CEffectMeshInstance@@@Z ENDP ; CEffectMeshInstance_DeleteTextureInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
;	COMDAT ?CEffectMeshInstance_DeleteImageInstance@@YAXPAVCGraphicImageInstance@@@Z
_TEXT	SEGMENT
_pkData$ = -4						; size = 4
_pkInstance$ = 8					; size = 4
?CEffectMeshInstance_DeleteImageInstance@@YAXPAVCGraphicImageInstance@@@Z PROC ; CEffectMeshInstance_DeleteImageInstance, COMDAT

; 241  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 242  : 	CGraphicImageInstance::ms_kPool.Free(pkInstance);

  00004	8b 45 08	 mov	 eax, DWORD PTR _pkInstance$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _pkData$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0000a	8d 45 fc	 lea	 eax, DWORD PTR _pkData$[ebp]
  0000d	50		 push	 eax
  0000e	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicImageInstance@@2V?$CDynamicPool@VCGraphicImageInstance@@@@A+16
  00013	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXABQAVCGraphicImageInstance@@@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::emplace_back<CGraphicImageInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 243  : }

  00018	c9		 leave
  00019	c3		 ret	 0
?CEffectMeshInstance_DeleteImageInstance@@YAXPAVCGraphicImageInstance@@@Z ENDP ; CEffectMeshInstance_DeleteImageInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ
_TEXT	SEGMENT
$T2 = -84						; size = 4
$T3 = -80						; size = 4
_pkFreeData$ = -76					; size = 4
$T4 = -72						; size = 4
__Ptr$ = -68						; size = 4
__My_data$5 = -64					; size = 4
$T6 = -60						; size = 4
__My_data$7 = -56					; size = 4
$T8 = -52						; size = 4
_this$ = -48						; size = 4
_pkNewData$9 = -44					; size = 4
tv80 = -40						; size = 4
$T10 = -36						; size = 4
tv130 = -32						; size = 4
__My_data$11 = -28					; size = 4
__Mylast$12 = -24					; size = 4
_this$ = -20						; size = 4
$T13 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ PROC ; CDynamicPool<CGraphicImageInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 10	 add	 eax, 16			; 00000010H
  0002e	89 45 e4	 mov	 DWORD PTR __My_data$11[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00031	8b 45 e4	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00034	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$11[ebp]
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0003c	75 09		 jne	 SHORT $LN9@Alloc
  0003e	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00045	eb 04		 jmp	 SHORT $LN10@Alloc
$LN9@Alloc:
  00047	83 65 e0 00	 and	 DWORD PTR tv130[ebp], 0
$LN10@Alloc:
  0004b	8a 45 e0	 mov	 al, BYTE PTR tv130[ebp]
  0004e	88 45 f3	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00051	0f b6 45 f3	 movzx	 eax, BYTE PTR $T13[ebp]
  00055	85 c0		 test	 eax, eax
  00057	74 57		 je	 SHORT $LN2@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  00059	6a 20		 push	 32			; 00000020H
  0005b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00060	59		 pop	 ecx
  00061	89 45 dc	 mov	 DWORD PTR $T10[ebp], eax
  00064	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00068	83 7d dc 00	 cmp	 DWORD PTR $T10[ebp], 0
  0006c	74 0d		 je	 SHORT $LN4@Alloc
  0006e	8b 4d dc	 mov	 ecx, DWORD PTR $T10[ebp]
  00071	e8 00 00 00 00	 call	 ??0CGraphicImageInstance@@QAE@XZ ; CGraphicImageInstance::CGraphicImageInstance
  00076	89 45 d8	 mov	 DWORD PTR tv80[ebp], eax
  00079	eb 04		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  0007b	83 65 d8 00	 and	 DWORD PTR tv80[ebp], 0
$LN5@Alloc:
  0007f	8b 45 d8	 mov	 eax, DWORD PTR tv80[ebp]
  00082	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax
  00085	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00089	8b 45 cc	 mov	 eax, DWORD PTR $T8[ebp]
  0008c	89 45 d4	 mov	 DWORD PTR _pkNewData$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0008f	8d 45 d4	 lea	 eax, DWORD PTR _pkNewData$9[ebp]
  00092	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  00093	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00099	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXABQAVCGraphicImageInstance@@@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::emplace_back<CGraphicImageInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  0009e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000a4	40		 inc	 eax
  000a5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 68   : 				return pkNewData;

  000ab	8b 45 d4	 mov	 eax, DWORD PTR _pkNewData$9[ebp]
  000ae	eb 65		 jmp	 SHORT $LN1@Alloc
$LN2@Alloc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  000b0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	83 c0 10	 add	 eax, 16			; 00000010H
  000b6	89 45 c8	 mov	 DWORD PTR __My_data$7[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  000b9	6a 04		 push	 4
  000bb	58		 pop	 eax
  000bc	6b c0 ff	 imul	 eax, eax, -1
  000bf	8b 4d c8	 mov	 ecx, DWORD PTR __My_data$7[ebp]
  000c2	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000c5	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000c8	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000cb	8b 00		 mov	 eax, DWORD PTR [eax]
  000cd	89 45 b4	 mov	 DWORD PTR _pkFreeData$[ebp], eax

; 72   : 			m_kVct_pkFree.pop_back();

  000d0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d3	83 c0 10	 add	 eax, 16			; 00000010H
  000d6	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1329 :         auto& _My_data   = _Mypair._Myval2;

  000d9	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	89 45 c0	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1330 :         pointer& _Mylast = _My_data._Mylast;

  000df	8b 45 c0	 mov	 eax, DWORD PTR __My_data$5[ebp]
  000e2	83 c0 04	 add	 eax, 4
  000e5	89 45 e8	 mov	 DWORD PTR __Mylast$12[ebp], eax

; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1333 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1334 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1336 : 
; 1337 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  000e8	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  000eb	8b 00		 mov	 eax, DWORD PTR [eax]
  000ed	83 e8 04	 sub	 eax, 4
  000f0	89 45 bc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000f3	8b 45 bc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000f6	89 45 b0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000f9	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000fc	89 45 b8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000ff	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  00102	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax

; 1338 :         --_Mylast;

  00105	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  00108	8b 00		 mov	 eax, DWORD PTR [eax]
  0010a	83 e8 04	 sub	 eax, 4
  0010d	8b 4d e8	 mov	 ecx, DWORD PTR __Mylast$12[ebp]
  00110	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 73   : 			return pkFreeData;

  00112	8b 45 b4	 mov	 eax, DWORD PTR _pkFreeData$[ebp]
$LN1@Alloc:

; 74   : 		}

  00115	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00118	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011f	59		 pop	 ecx
  00120	c9		 leave
  00121	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ$0:
  00000	6a 20		 push	 32			; 00000020H
  00002	ff 75 dc	 push	 DWORD PTR $T10[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
__ehhandler$?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ:
  00012	90		 npad	 1
  00013	90		 npad	 1
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ ENDP ; CDynamicPool<CGraphicImageInstance>::Alloc
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CEffectMeshInstance::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A ; CEffectMeshInstance::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCEffectMeshInstance@@@@UAE@XZ ; CDynamicPool<CEffectMeshInstance>::~CDynamicPool<CEffectMeshInstance>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CEffectMeshInstance::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
;	COMDAT ??__E?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CEffectMeshInstance::ms_kPool'', COMDAT

; 7    : CDynamicPool<CEffectMeshInstance>		CEffectMeshInstance::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A ; CEffectMeshInstance::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPool@VCEffectMeshInstance@@@@QAE@XZ ; CDynamicPool<CEffectMeshInstance>::CDynamicPool<CEffectMeshInstance>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CEffectMeshInstance::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CEffectMeshInstance::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPool@VCEffectMeshInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCEffectMeshInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CEffectMeshInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCEffectMeshInstance@@@@UAE@XZ ; CDynamicPool<CEffectMeshInstance>::~CDynamicPool<CEffectMeshInstance>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCEffectMeshInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CEffectMeshInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXXZ PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@YAXPAPAVCEffectMeshInstance@@QAPAV1@AAV?$allocator@PAVCEffectMeshInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXXZ ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXQAPAVCEffectMeshInstance@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXQAPAVCEffectMeshInstance@@II@Z PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@YAXPAPAVCEffectMeshInstance@@QAPAV1@AAV?$allocator@PAVCEffectMeshInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXQAPAVCEffectMeshInstance@@II@Z ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@ABEII@Z PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@ABEII@Z ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXPAPAVCEffectMeshInstance@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXPAPAVCEffectMeshInstance@@0@Z PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@YAXPAPAVCEffectMeshInstance@@QAPAV1@AAV?$allocator@PAVCEffectMeshInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshInstance *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXPAPAVCEffectMeshInstance@@0@Z ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@YAXPAPAVCEffectMeshInstance@@QAPAV1@AAV?$allocator@PAVCEffectMeshInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshInstance *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXQAPAVCEffectMeshInstance@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXQAPAVCEffectMeshInstance@@I@Z PROC ; std::allocator<CEffectMeshInstance *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXQAPAVCEffectMeshInstance@@I@Z ENDP ; std::allocator<CEffectMeshInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCEffectMeshInstance@@@@KAXPAVCEffectMeshInstance@@@Z
_TEXT	SEGMENT
tv74 = -8						; size = 4
$T1 = -4						; size = 4
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCEffectMeshInstance@@@@KAXPAVCEffectMeshInstance@@@Z PROC ; CDynamicPool<CEffectMeshInstance>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 110  : 			delete pkData;

  00005	8b 45 08	 mov	 eax, DWORD PTR _pkData$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000b	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  0000f	74 11		 je	 SHORT $LN3@Delete
  00011	6a 01		 push	 1
  00013	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0001b	ff 10		 call	 DWORD PTR [eax]
  0001d	89 45 f8	 mov	 DWORD PTR tv74[ebp], eax
  00020	eb 04		 jmp	 SHORT $LN1@Delete
$LN3@Delete:
  00022	83 65 f8 00	 and	 DWORD PTR tv74[ebp], 0
$LN1@Delete:

; 111  : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
?Delete@?$CDynamicPool@VCEffectMeshInstance@@@@KAXPAVCEffectMeshInstance@@@Z ENDP ; CDynamicPool<CEffectMeshInstance>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ
_TEXT	SEGMENT
$T2 = -84						; size = 4
$T3 = -80						; size = 4
_pkFreeData$ = -76					; size = 4
$T4 = -72						; size = 4
__Ptr$ = -68						; size = 4
__My_data$5 = -64					; size = 4
$T6 = -60						; size = 4
__My_data$7 = -56					; size = 4
$T8 = -52						; size = 4
_this$ = -48						; size = 4
_pkNewData$9 = -44					; size = 4
tv80 = -40						; size = 4
$T10 = -36						; size = 4
tv130 = -32						; size = 4
__My_data$11 = -28					; size = 4
__Mylast$12 = -24					; size = 4
_this$ = -20						; size = 4
$T13 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ PROC ; CDynamicPool<CEffectMeshInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 10	 add	 eax, 16			; 00000010H
  0002e	89 45 e4	 mov	 DWORD PTR __My_data$11[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00031	8b 45 e4	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00034	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$11[ebp]
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0003c	75 09		 jne	 SHORT $LN9@Alloc
  0003e	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00045	eb 04		 jmp	 SHORT $LN10@Alloc
$LN9@Alloc:
  00047	83 65 e0 00	 and	 DWORD PTR tv130[ebp], 0
$LN10@Alloc:
  0004b	8a 45 e0	 mov	 al, BYTE PTR tv130[ebp]
  0004e	88 45 f3	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00051	0f b6 45 f3	 movzx	 eax, BYTE PTR $T13[ebp]
  00055	85 c0		 test	 eax, eax
  00057	74 57		 je	 SHORT $LN2@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  00059	6a 60		 push	 96			; 00000060H
  0005b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00060	59		 pop	 ecx
  00061	89 45 dc	 mov	 DWORD PTR $T10[ebp], eax
  00064	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00068	83 7d dc 00	 cmp	 DWORD PTR $T10[ebp], 0
  0006c	74 0d		 je	 SHORT $LN4@Alloc
  0006e	8b 4d dc	 mov	 ecx, DWORD PTR $T10[ebp]
  00071	e8 00 00 00 00	 call	 ??0CEffectMeshInstance@@QAE@XZ ; CEffectMeshInstance::CEffectMeshInstance
  00076	89 45 d8	 mov	 DWORD PTR tv80[ebp], eax
  00079	eb 04		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  0007b	83 65 d8 00	 and	 DWORD PTR tv80[ebp], 0
$LN5@Alloc:
  0007f	8b 45 d8	 mov	 eax, DWORD PTR tv80[ebp]
  00082	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax
  00085	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00089	8b 45 cc	 mov	 eax, DWORD PTR $T8[ebp]
  0008c	89 45 d4	 mov	 DWORD PTR _pkNewData$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0008f	8d 45 d4	 lea	 eax, DWORD PTR _pkNewData$9[ebp]
  00092	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  00093	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00099	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXABQAVCEffectMeshInstance@@@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::emplace_back<CEffectMeshInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  0009e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000a4	40		 inc	 eax
  000a5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 68   : 				return pkNewData;

  000ab	8b 45 d4	 mov	 eax, DWORD PTR _pkNewData$9[ebp]
  000ae	eb 65		 jmp	 SHORT $LN1@Alloc
$LN2@Alloc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  000b0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	83 c0 10	 add	 eax, 16			; 00000010H
  000b6	89 45 c8	 mov	 DWORD PTR __My_data$7[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  000b9	6a 04		 push	 4
  000bb	58		 pop	 eax
  000bc	6b c0 ff	 imul	 eax, eax, -1
  000bf	8b 4d c8	 mov	 ecx, DWORD PTR __My_data$7[ebp]
  000c2	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000c5	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000c8	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000cb	8b 00		 mov	 eax, DWORD PTR [eax]
  000cd	89 45 b4	 mov	 DWORD PTR _pkFreeData$[ebp], eax

; 72   : 			m_kVct_pkFree.pop_back();

  000d0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d3	83 c0 10	 add	 eax, 16			; 00000010H
  000d6	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1329 :         auto& _My_data   = _Mypair._Myval2;

  000d9	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	89 45 c0	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1330 :         pointer& _Mylast = _My_data._Mylast;

  000df	8b 45 c0	 mov	 eax, DWORD PTR __My_data$5[ebp]
  000e2	83 c0 04	 add	 eax, 4
  000e5	89 45 e8	 mov	 DWORD PTR __Mylast$12[ebp], eax

; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1333 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1334 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1336 : 
; 1337 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  000e8	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  000eb	8b 00		 mov	 eax, DWORD PTR [eax]
  000ed	83 e8 04	 sub	 eax, 4
  000f0	89 45 bc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000f3	8b 45 bc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000f6	89 45 b0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000f9	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000fc	89 45 b8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000ff	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  00102	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax

; 1338 :         --_Mylast;

  00105	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  00108	8b 00		 mov	 eax, DWORD PTR [eax]
  0010a	83 e8 04	 sub	 eax, 4
  0010d	8b 4d e8	 mov	 ecx, DWORD PTR __Mylast$12[ebp]
  00110	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 73   : 			return pkFreeData;

  00112	8b 45 b4	 mov	 eax, DWORD PTR _pkFreeData$[ebp]
$LN1@Alloc:

; 74   : 		}

  00115	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00118	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011f	59		 pop	 ecx
  00120	c9		 leave
  00121	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ$0:
  00000	6a 60		 push	 96			; 00000060H
  00002	ff 75 dc	 push	 DWORD PTR $T10[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
__ehhandler$?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ:
  00012	90		 npad	 1
  00013	90		 npad	 1
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ ENDP ; CDynamicPool<CEffectMeshInstance>::Alloc
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCEffectMeshInstance@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCEffectMeshInstance@@@@QAEXXZ PROC ; CDynamicPool<CEffectMeshInstance>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 50   : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPool@VCEffectMeshInstance@@@@KAXPAVCEffectMeshInstance@@@Z ; CDynamicPool<CEffectMeshInstance>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@P6AXPAVCEffectMeshInstance@@@Z@std@@YAP6AXPAVCEffectMeshInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >,void (__cdecl*)(CEffectMeshInstance *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXXZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::clear

; 52   : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXXZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::clear

; 53   : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPool@VCEffectMeshInstance@@@@QAEXXZ ENDP ; CDynamicPool<CEffectMeshInstance>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCEffectMeshInstance@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CDynamicPool@VCEffectMeshInstance@@@@UAE@XZ PROC	; CDynamicPool<CEffectMeshInstance>::~CDynamicPool<CEffectMeshInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCEffectMeshInstance@@@@6B@

; 26   : 		}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00016	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXXZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 26   : 		}

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00021	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@AAEXXZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 26   : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
??1?$CDynamicPool@VCEffectMeshInstance@@@@UAE@XZ ENDP	; CDynamicPool<CEffectMeshInstance>::~CDynamicPool<CEffectMeshInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPool@VCEffectMeshInstance@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPool@VCEffectMeshInstance@@@@QAE@XZ PROC	; CDynamicPool<CEffectMeshInstance>::CDynamicPool<CEffectMeshInstance>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 12   : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCEffectMeshInstance@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 12   : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 14   : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 15   : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 16   : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPool@VCEffectMeshInstance@@@@QAE@XZ ENDP	; CDynamicPool<CEffectMeshInstance>::CDynamicPool<CEffectMeshInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\GrpMath.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\GrpMath.h
;	COMDAT ?SafeRotationNormalizedArc@@YA?AUD3DXQUATERNION@@ABUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
_fz$ = -80						; size = 4
_fy$ = -76						; size = 4
_fx$ = -72						; size = 4
_d$ = -68						; size = 4
_fz$ = -64						; size = 4
_fy$ = -60						; size = 4
_fx$ = -56						; size = 4
tv251 = -52						; size = 4
tv185 = -48						; size = 4
_s$ = -44						; size = 4
_c$ = -40						; size = 12
_v$1 = -28						; size = 12
$T2 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_vFrom$ = 12						; size = 4
_vTo$ = 16						; size = 4
?SafeRotationNormalizedArc@@YA?AUD3DXQUATERNION@@ABUD3DXVECTOR3@@0@Z PROC ; SafeRotationNormalizedArc, COMDAT

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 290  :     return x == v.x && y == v.y && z == v.z;

  00012	8b 45 0c	 mov	 eax, DWORD PTR _vFrom$[ebp]
  00015	8b 4d 10	 mov	 ecx, DWORD PTR _vTo$[ebp]
  00018	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0001c	0f 2e 01	 ucomiss xmm0, DWORD PTR [ecx]
  0001f	9f		 lahf
  00020	f6 c4 44	 test	 ah, 68			; 00000044H
  00023	7a 33		 jp	 SHORT $LN7@SafeRotati
  00025	8b 45 0c	 mov	 eax, DWORD PTR _vFrom$[ebp]
  00028	8b 4d 10	 mov	 ecx, DWORD PTR _vTo$[ebp]
  0002b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00030	0f 2e 41 04	 ucomiss xmm0, DWORD PTR [ecx+4]
  00034	9f		 lahf
  00035	f6 c4 44	 test	 ah, 68			; 00000044H
  00038	7a 1e		 jp	 SHORT $LN7@SafeRotati
  0003a	8b 45 0c	 mov	 eax, DWORD PTR _vFrom$[ebp]
  0003d	8b 4d 10	 mov	 ecx, DWORD PTR _vTo$[ebp]
  00040	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00045	0f 2e 41 08	 ucomiss xmm0, DWORD PTR [ecx+8]
  00049	9f		 lahf
  0004a	f6 c4 44	 test	 ah, 68			; 00000044H
  0004d	7a 09		 jp	 SHORT $LN7@SafeRotati
  0004f	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR tv185[ebp], 1
  00056	eb 04		 jmp	 SHORT $LN8@SafeRotati
$LN7@SafeRotati:
  00058	83 65 d0 00	 and	 DWORD PTR tv185[ebp], 0
$LN8@SafeRotati:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\GrpMath.h

; 49   : 	if (vFrom == vTo)

  0005c	83 7d d0 00	 cmp	 DWORD PTR tv185[ebp], 0
  00060	74 38		 je	 SHORT $LN2@SafeRotati
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 667  :     x = fx;

  00062	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00065	0f 57 c0	 xorps	 xmm0, xmm0
  00068	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 668  :     y = fy;

  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0006f	0f 57 c0	 xorps	 xmm0, xmm0
  00072	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 669  :     z = fz;

  00077	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0007a	0f 57 c0	 xorps	 xmm0, xmm0
  0007d	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 670  :     w = fw;

  00082	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00085	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0008d	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\GrpMath.h

; 50   : 		return D3DXQUATERNION(0.0f,0.0f,0.0f,1.0f);

  00092	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00095	e9 29 02 00 00	 jmp	 $LN1@SafeRotati
$LN2@SafeRotati:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 249  :     return D3DXVECTOR3(-x, -y, -z);

  0009a	8b 45 10	 mov	 eax, DWORD PTR _vTo$[ebp]
  0009d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000a1	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000a8	f3 0f 11 45 c8	 movss	 DWORD PTR _fx$[ebp], xmm0
  000ad	8b 45 10	 mov	 eax, DWORD PTR _vTo$[ebp]
  000b0	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000b5	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000bc	f3 0f 11 45 c4	 movss	 DWORD PTR _fy$[ebp], xmm0
  000c1	8b 45 10	 mov	 eax, DWORD PTR _vTo$[ebp]
  000c4	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000c9	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000d0	f3 0f 11 45 c0	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  000d5	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _fx$[ebp]
  000da	f3 0f 11 45 f0	 movss	 DWORD PTR $T2[ebp], xmm0

; 181  :     y = fy;

  000df	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _fy$[ebp]
  000e4	f3 0f 11 45 f4	 movss	 DWORD PTR $T2[ebp+4], xmm0

; 182  :     z = fz;

  000e9	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _fz$[ebp]
  000ee	f3 0f 11 45 f8	 movss	 DWORD PTR $T2[ebp+8], xmm0

; 290  :     return x == v.x && y == v.y && z == v.z;

  000f3	8b 45 0c	 mov	 eax, DWORD PTR _vFrom$[ebp]
  000f6	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000fa	0f 2e 45 f0	 ucomiss xmm0, DWORD PTR $T2[ebp]
  000fe	9f		 lahf
  000ff	f6 c4 44	 test	 ah, 68			; 00000044H
  00102	7a 2d		 jp	 SHORT $LN17@SafeRotati
  00104	8b 45 0c	 mov	 eax, DWORD PTR _vFrom$[ebp]
  00107	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0010c	0f 2e 45 f4	 ucomiss xmm0, DWORD PTR $T2[ebp+4]
  00110	9f		 lahf
  00111	f6 c4 44	 test	 ah, 68			; 00000044H
  00114	7a 1b		 jp	 SHORT $LN17@SafeRotati
  00116	8b 45 0c	 mov	 eax, DWORD PTR _vFrom$[ebp]
  00119	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0011e	0f 2e 45 f8	 ucomiss xmm0, DWORD PTR $T2[ebp+8]
  00122	9f		 lahf
  00123	f6 c4 44	 test	 ah, 68			; 00000044H
  00126	7a 09		 jp	 SHORT $LN17@SafeRotati
  00128	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR tv251[ebp], 1
  0012f	eb 04		 jmp	 SHORT $LN18@SafeRotati
$LN17@SafeRotati:
  00131	83 65 cc 00	 and	 DWORD PTR tv251[ebp], 0
$LN18@SafeRotati:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\GrpMath.h

; 51   : 	if (vFrom == -vTo)

  00135	83 7d cc 00	 cmp	 DWORD PTR tv251[ebp], 0
  00139	74 38		 je	 SHORT $LN3@SafeRotati
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 667  :     x = fx;

  0013b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0013e	0f 57 c0	 xorps	 xmm0, xmm0
  00141	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 668  :     y = fy;

  00145	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00148	0f 57 c0	 xorps	 xmm0, xmm0
  0014b	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 669  :     z = fz;

  00150	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00153	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0015b	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 670  :     w = fw;

  00160	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00163	0f 57 c0	 xorps	 xmm0, xmm0
  00166	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\GrpMath.h

; 52   : 		return D3DXQUATERNION(0.0f,0.0f,1.0f,0.0f);

  0016b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0016e	e9 50 01 00 00	 jmp	 $LN1@SafeRotati
$LN3@SafeRotati:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00173	8b 45 0c	 mov	 eax, DWORD PTR _vFrom$[ebp]
  00176	8b 4d 10	 mov	 ecx, DWORD PTR _vTo$[ebp]
  00179	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0017e	f3 0f 59 41 08	 mulss	 xmm0, DWORD PTR [ecx+8]
  00183	8b 45 0c	 mov	 eax, DWORD PTR _vFrom$[ebp]
  00186	8b 4d 10	 mov	 ecx, DWORD PTR _vTo$[ebp]
  00189	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  0018e	f3 0f 59 49 04	 mulss	 xmm1, DWORD PTR [ecx+4]
  00193	f3 0f 5c c1	 subss	 xmm0, xmm1
  00197	f3 0f 11 45 e4	 movss	 DWORD PTR _v$1[ebp], xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0019c	8b 45 0c	 mov	 eax, DWORD PTR _vFrom$[ebp]
  0019f	8b 4d 10	 mov	 ecx, DWORD PTR _vTo$[ebp]
  001a2	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001a7	f3 0f 59 01	 mulss	 xmm0, DWORD PTR [ecx]
  001ab	8b 45 0c	 mov	 eax, DWORD PTR _vFrom$[ebp]
  001ae	8b 4d 10	 mov	 ecx, DWORD PTR _vTo$[ebp]
  001b1	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  001b5	f3 0f 59 49 08	 mulss	 xmm1, DWORD PTR [ecx+8]
  001ba	f3 0f 5c c1	 subss	 xmm0, xmm1
  001be	f3 0f 11 45 e8	 movss	 DWORD PTR _v$1[ebp+4], xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  001c3	8b 45 0c	 mov	 eax, DWORD PTR _vFrom$[ebp]
  001c6	8b 4d 10	 mov	 ecx, DWORD PTR _vTo$[ebp]
  001c9	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001cd	f3 0f 59 41 04	 mulss	 xmm0, DWORD PTR [ecx+4]
  001d2	8b 45 0c	 mov	 eax, DWORD PTR _vFrom$[ebp]
  001d5	8b 4d 10	 mov	 ecx, DWORD PTR _vTo$[ebp]
  001d8	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  001dd	f3 0f 59 09	 mulss	 xmm1, DWORD PTR [ecx]
  001e1	f3 0f 5c c1	 subss	 xmm0, xmm1
  001e5	f3 0f 11 45 ec	 movss	 DWORD PTR _v$1[ebp+8], xmm0

; 1280 : 
; 1281 :     *pOut = v;

  001ea	8d 75 e4	 lea	 esi, DWORD PTR _v$1[ebp]
  001ed	8d 7d d8	 lea	 edi, DWORD PTR _c$[ebp]
  001f0	a5		 movsd
  001f1	a5		 movsd
  001f2	a5		 movsd

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  001f3	8b 45 0c	 mov	 eax, DWORD PTR _vFrom$[ebp]
  001f6	8b 4d 10	 mov	 ecx, DWORD PTR _vTo$[ebp]
  001f9	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001fe	f3 0f 59 41 08	 mulss	 xmm0, DWORD PTR [ecx+8]
  00203	8b 45 0c	 mov	 eax, DWORD PTR _vFrom$[ebp]
  00206	8b 4d 10	 mov	 ecx, DWORD PTR _vTo$[ebp]
  00209	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0020e	f3 0f 59 49 04	 mulss	 xmm1, DWORD PTR [ecx+4]
  00213	8b 45 0c	 mov	 eax, DWORD PTR _vFrom$[ebp]
  00216	8b 4d 10	 mov	 ecx, DWORD PTR _vTo$[ebp]
  00219	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  0021d	f3 0f 59 11	 mulss	 xmm2, DWORD PTR [ecx]
  00221	f3 0f 58 d1	 addss	 xmm2, xmm1
  00225	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\GrpMath.h

; 55   : 	float d = D3DXVec3Dot(&vFrom, &vTo);

  00229	f3 0f 11 55 bc	 movss	 DWORD PTR _d$[ebp], xmm2

; 56   : 	float s = sqrtf((1+d)*2);

  0022e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00236	f3 0f 58 45 bc	 addss	 xmm0, DWORD PTR _d$[ebp]
  0023b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  00243	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00247	51		 push	 ecx
  00248	51		 push	 ecx
  00249	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0024e	e8 00 00 00 00	 call	 _sqrt
  00253	59		 pop	 ecx
  00254	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\GrpMath.h

; 56   : 	float s = sqrtf((1+d)*2);

  00255	d9 5d d4	 fstp	 DWORD PTR _s$[ebp]

; 58   : 	return D3DXQUATERNION(c.x/s,c.y/s,c.z/s,s*0.5f);

  00258	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _c$[ebp]
  0025d	f3 0f 5e 45 d4	 divss	 xmm0, DWORD PTR _s$[ebp]
  00262	f3 0f 11 45 b8	 movss	 DWORD PTR _fx$[ebp], xmm0
  00267	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _c$[ebp+4]
  0026c	f3 0f 5e 45 d4	 divss	 xmm0, DWORD PTR _s$[ebp]
  00271	f3 0f 11 45 b4	 movss	 DWORD PTR _fy$[ebp], xmm0
  00276	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _c$[ebp+8]
  0027b	f3 0f 5e 45 d4	 divss	 xmm0, DWORD PTR _s$[ebp]
  00280	f3 0f 11 45 b0	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 667  :     x = fx;

  00285	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00288	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0028d	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 668  :     y = fy;

  00291	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00294	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00299	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 669  :     z = fz;

  0029e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002a1	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _fz$[ebp]
  002a6	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\GrpMath.h

; 58   : 	return D3DXQUATERNION(c.x/s,c.y/s,c.z/s,s*0.5f);

  002ab	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _s$[ebp]
  002b0	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 670  :     w = fw;

  002b8	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002bb	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\GrpMath.h

; 58   : 	return D3DXQUATERNION(c.x/s,c.y/s,c.z/s,s*0.5f);

  002c0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@SafeRotati:

; 59   : }

  002c3	5f		 pop	 edi
  002c4	5e		 pop	 esi
  002c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c8	33 cd		 xor	 ecx, ebp
  002ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002cf	c9		 leave
  002d0	c3		 ret	 0
?SafeRotationNormalizedArc@@YA?AUD3DXQUATERNION@@ABUD3DXVECTOR3@@0@Z ENDP ; SafeRotationNormalizedArc
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCEffectMeshInstance@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCEffectMeshInstance@@UAEPAXI@Z PROC			; CEffectMeshInstance::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CEffectMeshInstance@@UAE@XZ ; CEffectMeshInstance::~CEffectMeshInstance
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 60		 push	 96			; 00000060H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_GCEffectMeshInstance@@UAEPAXI@Z ENDP			; CEffectMeshInstance::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\Ref.h
;	COMDAT ?SetPointer@?$CRef@VCEffectMesh@@@@QAEXPAVCReferenceObject@@@Z
_TEXT	SEGMENT
_pOldObject$ = -8					; size = 4
_this$ = -4						; size = 4
_pObject$ = 8						; size = 4
?SetPointer@?$CRef@VCEffectMesh@@@@QAEXPAVCReferenceObject@@@Z PROC ; CRef<CEffectMesh>::SetPointer, COMDAT
; _this$ = ecx

; 66   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 67   : 			CReferenceObject* pOldObject = m_pObject;

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	89 45 f8	 mov	 DWORD PTR _pOldObject$[ebp], eax

; 68   : 
; 69   : 			m_pObject = pObject;

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _pObject$[ebp]
  00016	89 08		 mov	 DWORD PTR [eax], ecx

; 70   : 
; 71   : 			if (m_pObject)

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001e	74 0a		 je	 SHORT $LN2@SetPointer

; 72   : 				m_pObject->AddReference();

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	e8 00 00 00 00	 call	 ?AddReference@CReferenceObject@@QAEXXZ ; CReferenceObject::AddReference
$LN2@SetPointer:

; 73   : 
; 74   : 			if (pOldObject)

  0002a	83 7d f8 00	 cmp	 DWORD PTR _pOldObject$[ebp], 0
  0002e	74 08		 je	 SHORT $LN1@SetPointer

; 75   : 				pOldObject->Release();

  00030	8b 4d f8	 mov	 ecx, DWORD PTR _pOldObject$[ebp]
  00033	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release
$LN1@SetPointer:

; 76   : 		}

  00038	c9		 leave
  00039	c2 04 00	 ret	 4
?SetPointer@?$CRef@VCEffectMesh@@@@QAEXPAVCReferenceObject@@@Z ENDP ; CRef<CEffectMesh>::SetPointer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\Ref.h
;	COMDAT ??1?$CRef@VCEffectMesh@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CRef@VCEffectMesh@@@@QAE@XZ PROC			; CRef<CEffectMesh>::~CRef<CEffectMesh>, COMDAT
; _this$ = ecx

; 37   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CRef@VCEffectMesh@@@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 53   : 			if (m_pObject)

  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002c	74 10		 je	 SHORT $LN2@CRef

; 54   : 			{
; 55   : 				m_pObject->Release();

  0002e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 56   : 				m_pObject = NULL;

  00038	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	83 20 00	 and	 DWORD PTR [eax], 0
$LN2@CRef:

; 38   : 			Clear();
; 39   : 		}

  0003e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00041	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00048	59		 pop	 ecx
  00049	c9		 leave
  0004a	c3		 ret	 0
  0004b	cc		 int	 3
  0004c	cc		 int	 3
  0004d	cc		 int	 3
  0004e	cc		 int	 3
  0004f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CRef@VCEffectMesh@@@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CRef@VCEffectMesh@@@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CRef@VCEffectMesh@@@@QAE@XZ ENDP			; CRef<CEffectMesh>::~CRef<CEffectMesh>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Getal@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Getal@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@2@XZ PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Getal, COMDAT
; _this$ = ecx

; 1732 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000b	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000e	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 1734 :     }

  00011	c9		 leave
  00012	c3		 ret	 0
?_Getal@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@2@XZ ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXXZ PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 75		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@QAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshInstance::STextureInstance> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 30		 push	 48			; 00000030H
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 30	 imul	 eax, DWORD PTR __Count$[ebp], 48
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00098	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009b	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009e	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a1	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a4	c9		 leave
  000a5	c3		 ret	 0
?_Tidy@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXXZ ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXQAUSTextureInstance@CEffectMeshInstance@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXQAUSTextureInstance@CEffectMeshInstance@@II@Z PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 63		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@QAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshInstance::STextureInstance> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 30		 push	 48			; 00000030H
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 30	 imul	 eax, DWORD PTR __Count$[ebp], 48
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00098	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  0009a	6b 45 0c 30	 imul	 eax, DWORD PTR __Newsize$[ebp], 48
  0009e	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000a1	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a4	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a6	6b 45 10 30	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 48
  000aa	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b0	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b2	c9		 leave
  000b3	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXQAUSTextureInstance@CEffectMeshInstance@@II@Z ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@ABEII@Z PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	99		 cdq
  0001b	6a 30		 push	 48			; 00000030H
  0001d	59		 pop	 ecx
  0001e	f7 f9		 idiv	 ecx
  00020	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00023	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00026	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00029	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  0002c	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002f	c7 45 f0 55 55
	55 05		 mov	 DWORD PTR $T7[ebp], 89478485 ; 05555555H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00036	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003d	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  00040	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00043	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00046	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00049	73 08		 jae	 SHORT $LN25@Calculate_
  0004b	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  00051	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00053	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00056	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  0005c	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00062	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00065	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006d	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00070	d1 e8		 shr	 eax, 1
  00072	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00075	2b c8		 sub	 ecx, eax
  00077	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  0007a	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  0007c	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007f	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00081	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00084	d1 e8		 shr	 eax, 1
  00086	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00089	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  0008c	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008f	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00092	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00094	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00097	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00099	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  0009c	c9		 leave
  0009d	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@ABEII@Z ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXPAUSTextureInstance@CEffectMeshInstance@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXPAUSTextureInstance@CEffectMeshInstance@@0@Z PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@QAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshInstance::STextureInstance> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXPAUSTextureInstance@CEffectMeshInstance@@0@Z ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@QAU12@AAV?$allocator@USTextureInstance@CEffectMeshInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshInstance::STextureInstance> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::~vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXXZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::~vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXQAUSTextureInstance@CEffectMeshInstance@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXQAUSTextureInstance@CEffectMeshInstance@@I@Z PROC ; std::allocator<CEffectMeshInstance::STextureInstance>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	6b 45 0c 30	 imul	 eax, DWORD PTR __Count$[ebp], 48
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx

; 811  :     }

  00016	c9		 leave
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXQAUSTextureInstance@CEffectMeshInstance@@I@Z ENDP ; std::allocator<CEffectMeshInstance::STextureInstance>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
;	COMDAT ?isActive@CEffectMeshInstance@@IAEHXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
_iCurrentFrame$2 = -24					; size = 4
__My_data$3 = -20					; size = 4
$T4 = -16						; size = 4
__My_data$5 = -12					; size = 4
_j$6 = -8						; size = 4
_this$ = -4						; size = 4
?isActive@CEffectMeshInstance@@IAEHXZ PROC		; CEffectMeshInstance::isActive, COMDAT
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : 	if (!CEffectElementBaseInstance::isActive())

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?isActive@CEffectElementBaseInstance@@QAE_NXZ ; CEffectElementBaseInstance::isActive
  00011	0f b6 c0	 movzx	 eax, al
  00014	85 c0		 test	 eax, eax
  00016	75 07		 jne	 SHORT $LN5@isActive

; 28   : 		return FALSE;

  00018	33 c0		 xor	 eax, eax
  0001a	e9 85 00 00 00	 jmp	 $LN1@isActive
$LN5@isActive:

; 29   : 
; 30   : 	if (!m_MeshFrameController.isActive())

  0001f	6a 00		 push	 0
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00027	e8 00 00 00 00	 call	 ?isActive@CFrameController@@QAEHK@Z ; CFrameController::isActive
  0002c	85 c0		 test	 eax, eax
  0002e	75 04		 jne	 SHORT $LN6@isActive

; 31   : 		return FALSE;

  00030	33 c0		 xor	 eax, eax
  00032	eb 70		 jmp	 SHORT $LN1@isActive
$LN6@isActive:

; 33   : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  00034	83 65 f8 00	 and	 DWORD PTR _j$6[ebp], 0
  00038	eb 07		 jmp	 SHORT $LN4@isActive
$LN2@isActive:
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _j$6[ebp]
  0003d	40		 inc	 eax
  0003e	89 45 f8	 mov	 DWORD PTR _j$6[ebp], eax
$LN4@isActive:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	83 c0 50	 add	 eax, 80			; 00000050H
  00047	89 45 f4	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0004a	8b 45 f4	 mov	 eax, DWORD PTR __My_data$5[ebp]
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$5[ebp]
  00050	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00053	2b 01		 sub	 eax, DWORD PTR [ecx]
  00055	99		 cdq
  00056	6a 30		 push	 48			; 00000030H
  00058	59		 pop	 ecx
  00059	f7 f9		 idiv	 ecx
  0005b	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 33   : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _j$6[ebp]
  00061	3b 45 f0	 cmp	 eax, DWORD PTR $T4[ebp]
  00064	73 3c		 jae	 SHORT $LN3@isActive

; 34   : 	{
; 35   : 		int iCurrentFrame = m_MeshFrameController.GetCurrentFrame();

  00066	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0006c	e8 00 00 00 00	 call	 ?GetCurrentFrame@CFrameController@@QAEEXZ ; CFrameController::GetCurrentFrame
  00071	0f b6 c0	 movzx	 eax, al
  00074	89 45 e8	 mov	 DWORD PTR _iCurrentFrame$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00077	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	83 c0 50	 add	 eax, 80			; 00000050H
  0007d	89 45 ec	 mov	 DWORD PTR __My_data$3[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00080	6b 45 f8 30	 imul	 eax, DWORD PTR _j$6[ebp], 48
  00084	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$3[ebp]
  00087	03 01		 add	 eax, DWORD PTR [ecx]
  00089	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 36   : 		if (m_TextureInstanceVector[j].TextureFrameController.isActive(iCurrentFrame))

  0008c	ff 75 e8	 push	 DWORD PTR _iCurrentFrame$2[ebp]
  0008f	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp]
  00092	e8 00 00 00 00	 call	 ?isActive@CFrameController@@QAEHK@Z ; CFrameController::isActive
  00097	85 c0		 test	 eax, eax
  00099	74 05		 je	 SHORT $LN7@isActive

; 37   : 			return TRUE;

  0009b	33 c0		 xor	 eax, eax
  0009d	40		 inc	 eax
  0009e	eb 04		 jmp	 SHORT $LN1@isActive
$LN7@isActive:

; 38   : 	}

  000a0	eb 98		 jmp	 SHORT $LN2@isActive
$LN3@isActive:

; 39   : 
; 40   : 	return FALSE;

  000a2	33 c0		 xor	 eax, eax
$LN1@isActive:

; 41   : }

  000a4	c9		 leave
  000a5	c3		 ret	 0
?isActive@CEffectMeshInstance@@IAEHXZ ENDP		; CEffectMeshInstance::isActive
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
;	COMDAT ?OnRender@CEffectMeshInstance@@MAEXXZ
_TEXT	SEGMENT
_q$1 = -840						; size = 16
$T2 = -824						; size = 4
$T3 = -820						; size = 4
$T4 = -816						; size = 4
$T5 = -812						; size = 4
___param0$6 = -808					; size = 4
$T7 = -804						; size = 4
_this$ = -800						; size = 4
_mat$ = -796						; size = 4
_iBlendingDestType$8 = -792				; size = 4
_iBlendingSrcType$9 = -788				; size = 4
tv1443 = -784						; size = 4
$T10 = -780						; size = 4
_iBillboardType$11 = -776				; size = 4
$T12 = -772						; size = 4
__My_data$13 = -768					; size = 4
__My_data$14 = -764					; size = 4
_dwB$15 = -760						; size = 4
_dwA$16 = -756						; size = 4
_dwR$17 = -752						; size = 4
_dwG$18 = -748						; size = 4
$T19 = -744						; size = 4
_pImageInstance$20 = -740				; size = 4
$T21 = -736						; size = 4
__My_data$22 = -732					; size = 4
$T23 = -728						; size = 4
__My_data$24 = -724					; size = 4
$T25 = -720						; size = 4
$T26 = -716						; size = 4
__My_data$27 = -712					; size = 4
__My_data$28 = -708					; size = 4
__Pos$ = -704						; size = 4
_pMeshData$29 = -700					; size = 4
$T30 = -696						; size = 4
_Head$31 = -692						; size = 4
$T32 = -688						; size = 4
$T33 = -684						; size = 4
$T34 = -680						; size = 4
$T35 = -676						; size = 4
$T36 = -672						; size = 4
$T37 = -668						; size = 4
$T38 = -664						; size = 4
$T39 = -660						; size = 4
$T40 = -656						; size = 4
$T41 = -652						; size = 4
$T42 = -648						; size = 4
$T43 = -644						; size = 4
$T44 = -640						; size = 4
__First$ = -636						; size = 4
__Last$ = -632						; size = 4
$T45 = -628						; size = 1
$T46 = -624						; size = 4
$T47 = -620						; size = 4
___param0$48 = -616					; size = 4
$T49 = -612						; size = 4
$T50 = -608						; size = 4
__My_data$51 = -604					; size = 4
$T52 = -600						; size = 4
__My_data$53 = -596					; size = 4
$T54 = -592						; size = 4
__My_data$55 = -588					; size = 4
$T56 = -584						; size = 4
__My_data$57 = -580					; size = 4
$T58 = -576						; size = 4
__My_data$59 = -572					; size = 4
$T60 = -568						; size = 4
$T61 = -564						; size = 4
$T62 = -560						; size = 4
$T63 = -556						; size = 4
$T64 = -552						; size = 4
$T65 = -548						; size = 4
___param0$66 = -544					; size = 4
tv869 = -540						; size = 4
_TableAlpha$67 = -536					; size = 4
__My_data$68 = -532					; size = 4
tv1002 = -528						; size = 4
__My_data$69 = -524					; size = 4
_pEffectMesh$ = -520					; size = 4
__My_data$70 = -516					; size = 4
tv1040 = -512						; size = 4
__My_data$71 = -508					; size = 4
tv1083 = -504						; size = 4
tv1076 = -500						; size = 4
tv1254 = -496						; size = 4
tv1253 = -492						; size = 4
tv1211 = -488						; size = 4
tv1210 = -484						; size = 4
tv1200 = -480						; size = 4
tv1199 = -476						; size = 4
tv1189 = -472						; size = 4
tv1188 = -468						; size = 4
_dwcurTextureFrame$72 = -464				; size = 4
__My_data$73 = -460					; size = 4
_rTextureFrameController$74 = -456			; size = 4
__My_data$75 = -452					; size = 4
_rFrameData$76 = -448					; size = 4
__Tmp$77 = -444						; size = 4
tv92 = -440						; size = 4
_Color$78 = -436					; size = 16
_fElapsedTime$ = -420					; size = 4
_result$79 = -416					; size = 8
_byType$80 = -405					; size = 1
_fAlpha$81 = -404					; size = 4
$T82 = -397						; size = 1
$T83 = -396						; size = 1
$T84 = -395						; size = 1
$T85 = -394						; size = 1
$T86 = -393						; size = 1
_rVector$ = -392					; size = 4
_i$87 = -388						; size = 4
_this$ = -384						; size = 4
_matT$88 = -380						; size = 64
_matTemp$89 = -316					; size = 64
_matT$90 = -252						; size = 64
$T91 = -188						; size = 64
$T92 = -124						; size = 64
_matTemp$93 = -60					; size = 64
_LastPosition$94 = 4					; size = 12
$T95 = 16						; size = 12
_Position$96 = 28					; size = 12
_m_matWorld$97 = 40					; size = 64
_Position$98 = 104					; size = 12
__$ArrayPad$ = 116					; size = 4
?OnRender@CEffectMeshInstance@@MAEXXZ PROC		; CEffectMeshInstance::OnRender, COMDAT
; _this$ = ecx

; 62   : {

  00000	55		 push	 ebp
  00001	8d 6c 24 88	 lea	 ebp, DWORD PTR [esp-120]
  00005	81 ec c0 03 00
	00		 sub	 esp, 960		; 000003c0H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 74	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	89 8d 80 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 63   : 	if (!isActive())

  0001d	8b 8d 80 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?isActive@CEffectMeshInstance@@IAEHXZ ; CEffectMeshInstance::isActive
  00028	85 c0		 test	 eax, eax
  0002a	75 05		 jne	 SHORT $LN7@OnRender

; 64   : 		return;

  0002c	e9 8a 10 00 00	 jmp	 $LN1@OnRender
$LN7@OnRender:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\Ref.h

; 80   : 			return static_cast<T*>(m_pObject);

  00031	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
  0003a	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _pEffectMesh$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 68   : 	for (DWORD i = 0; i < pEffectMesh->GetMeshCount(); ++i)

  00040	83 a5 7c fe ff
	ff 00		 and	 DWORD PTR _i$87[ebp], 0
  00047	eb 0d		 jmp	 SHORT $LN4@OnRender
$LN2@OnRender:
  00049	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _i$87[ebp]
  0004f	40		 inc	 eax
  00050	89 85 7c fe ff
	ff		 mov	 DWORD PTR _i$87[ebp], eax
$LN4@OnRender:
  00056	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR _pEffectMesh$[ebp]
  0005c	e8 00 00 00 00	 call	 ?GetMeshCount@CEffectMesh@@QAEKXZ ; CEffectMesh::GetMeshCount
  00061	39 85 7c fe ff
	ff		 cmp	 DWORD PTR _i$87[ebp], eax
  00067	0f 83 4e 10 00
	00		 jae	 $LN3@OnRender
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0006d	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00073	83 c0 50	 add	 eax, 80			; 00000050H
  00076	89 85 3c fd ff
	ff		 mov	 DWORD PTR __My_data$28[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  0007c	6b 85 7c fe ff
	ff 30		 imul	 eax, DWORD PTR _i$87[ebp], 48
  00083	8b 8d 3c fd ff
	ff		 mov	 ecx, DWORD PTR __My_data$28[ebp]
  00089	03 01		 add	 eax, DWORD PTR [ecx]
  0008b	89 85 fc fc ff
	ff		 mov	 DWORD PTR $T12[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 72   : 		CFrameController & rTextureFrameController = m_TextureInstanceVector[i].TextureFrameController;

  00091	8b 85 fc fc ff
	ff		 mov	 eax, DWORD PTR $T12[ebp]
  00097	89 85 38 fe ff
	ff		 mov	 DWORD PTR _rTextureFrameController$74[ebp], eax

; 73   : 		if (!rTextureFrameController.isActive(m_MeshFrameController.GetCurrentFrame()))

  0009d	8b 8d 80 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	83 c1 2c	 add	 ecx, 44			; 0000002cH
  000a6	e8 00 00 00 00	 call	 ?GetCurrentFrame@CFrameController@@QAEEXZ ; CFrameController::GetCurrentFrame
  000ab	0f b6 c0	 movzx	 eax, al
  000ae	50		 push	 eax
  000af	8b 8d 38 fe ff
	ff		 mov	 ecx, DWORD PTR _rTextureFrameController$74[ebp]
  000b5	e8 00 00 00 00	 call	 ?isActive@CFrameController@@QAEHK@Z ; CFrameController::isActive
  000ba	85 c0		 test	 eax, eax
  000bc	75 02		 jne	 SHORT $LN8@OnRender

; 74   : 			continue;

  000be	eb 89		 jmp	 SHORT $LN2@OnRender
$LN8@OnRender:

; 75   : 
; 76   : 		int iBillboardType = m_pMeshScript->GetBillboardType(i);

  000c0	ff b5 7c fe ff
	ff		 push	 DWORD PTR _i$87[ebp]
  000c6	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000cc	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000cf	e8 00 00 00 00	 call	 ?GetBillboardType@CEffectMeshScript@@QAEHK@Z ; CEffectMeshScript::GetBillboardType
  000d4	89 85 f8 fc ff
	ff		 mov	 DWORD PTR _iBillboardType$11[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  000da	6a 10		 push	 16			; 00000010H
  000dc	58		 pop	 eax
  000dd	6b c0 03	 imul	 eax, eax, 3
  000e0	8d 44 05 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp+eax]
  000e4	6a 04		 push	 4
  000e6	59		 pop	 ecx
  000e7	d1 e1		 shl	 ecx, 1
  000e9	0f 57 c0	 xorps	 xmm0, xmm0
  000ec	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  000f1	6a 10		 push	 16			; 00000010H
  000f3	58		 pop	 eax
  000f4	6b c0 03	 imul	 eax, eax, 3
  000f7	8d 44 05 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp+eax]
  000fb	6a 04		 push	 4
  000fd	59		 pop	 ecx
  000fe	c1 e1 00	 shl	 ecx, 0
  00101	0f 57 c0	 xorps	 xmm0, xmm0
  00104	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00109	6a 10		 push	 16			; 00000010H
  0010b	58		 pop	 eax
  0010c	6b c0 03	 imul	 eax, eax, 3
  0010f	8d 44 05 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp+eax]
  00113	6a 04		 push	 4
  00115	59		 pop	 ecx
  00116	6b c9 00	 imul	 ecx, ecx, 0
  00119	0f 57 c0	 xorps	 xmm0, xmm0
  0011c	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00121	6a 10		 push	 16			; 00000010H
  00123	58		 pop	 eax
  00124	d1 e0		 shl	 eax, 1
  00126	8d 44 05 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp+eax]
  0012a	6a 04		 push	 4
  0012c	59		 pop	 ecx
  0012d	6b c9 03	 imul	 ecx, ecx, 3
  00130	0f 57 c0	 xorps	 xmm0, xmm0
  00133	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00138	6a 10		 push	 16			; 00000010H
  0013a	58		 pop	 eax
  0013b	d1 e0		 shl	 eax, 1
  0013d	8d 44 05 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp+eax]
  00141	6a 04		 push	 4
  00143	59		 pop	 ecx
  00144	c1 e1 00	 shl	 ecx, 0
  00147	0f 57 c0	 xorps	 xmm0, xmm0
  0014a	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0014f	6a 10		 push	 16			; 00000010H
  00151	58		 pop	 eax
  00152	d1 e0		 shl	 eax, 1
  00154	8d 44 05 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp+eax]
  00158	6a 04		 push	 4
  0015a	59		 pop	 ecx
  0015b	6b c9 00	 imul	 ecx, ecx, 0
  0015e	0f 57 c0	 xorps	 xmm0, xmm0
  00161	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00166	6a 10		 push	 16			; 00000010H
  00168	58		 pop	 eax
  00169	c1 e0 00	 shl	 eax, 0
  0016c	8d 44 05 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp+eax]
  00170	6a 04		 push	 4
  00172	59		 pop	 ecx
  00173	6b c9 03	 imul	 ecx, ecx, 3
  00176	0f 57 c0	 xorps	 xmm0, xmm0
  00179	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0017e	6a 10		 push	 16			; 00000010H
  00180	58		 pop	 eax
  00181	c1 e0 00	 shl	 eax, 0
  00184	8d 44 05 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp+eax]
  00188	6a 04		 push	 4
  0018a	59		 pop	 ecx
  0018b	d1 e1		 shl	 ecx, 1
  0018d	0f 57 c0	 xorps	 xmm0, xmm0
  00190	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00195	6a 10		 push	 16			; 00000010H
  00197	58		 pop	 eax
  00198	c1 e0 00	 shl	 eax, 0
  0019b	8d 44 05 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp+eax]
  0019f	6a 04		 push	 4
  001a1	59		 pop	 ecx
  001a2	6b c9 00	 imul	 ecx, ecx, 0
  001a5	0f 57 c0	 xorps	 xmm0, xmm0
  001a8	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001ad	6a 10		 push	 16			; 00000010H
  001af	58		 pop	 eax
  001b0	6b c0 00	 imul	 eax, eax, 0
  001b3	8d 44 05 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp+eax]
  001b7	6a 04		 push	 4
  001b9	59		 pop	 ecx
  001ba	6b c9 03	 imul	 ecx, ecx, 3
  001bd	0f 57 c0	 xorps	 xmm0, xmm0
  001c0	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001c5	6a 10		 push	 16			; 00000010H
  001c7	58		 pop	 eax
  001c8	6b c0 00	 imul	 eax, eax, 0
  001cb	8d 44 05 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp+eax]
  001cf	6a 04		 push	 4
  001d1	59		 pop	 ecx
  001d2	d1 e1		 shl	 ecx, 1
  001d4	0f 57 c0	 xorps	 xmm0, xmm0
  001d7	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001dc	6a 10		 push	 16			; 00000010H
  001de	58		 pop	 eax
  001df	6b c0 00	 imul	 eax, eax, 0
  001e2	8d 44 05 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp+eax]
  001e6	6a 04		 push	 4
  001e8	59		 pop	 ecx
  001e9	c1 e1 00	 shl	 ecx, 0
  001ec	0f 57 c0	 xorps	 xmm0, xmm0
  001ef	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  001f4	6a 10		 push	 16			; 00000010H
  001f6	58		 pop	 eax
  001f7	6b c0 03	 imul	 eax, eax, 3
  001fa	8d 44 05 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp+eax]
  001fe	6a 04		 push	 4
  00200	59		 pop	 ecx
  00201	6b c9 03	 imul	 ecx, ecx, 3
  00204	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0020c	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00211	6a 10		 push	 16			; 00000010H
  00213	58		 pop	 eax
  00214	d1 e0		 shl	 eax, 1
  00216	8d 44 05 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp+eax]
  0021a	6a 04		 push	 4
  0021c	59		 pop	 ecx
  0021d	d1 e1		 shl	 ecx, 1
  0021f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00227	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0022c	6a 10		 push	 16			; 00000010H
  0022e	58		 pop	 eax
  0022f	c1 e0 00	 shl	 eax, 0
  00232	8d 44 05 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp+eax]
  00236	6a 04		 push	 4
  00238	59		 pop	 ecx
  00239	c1 e1 00	 shl	 ecx, 0
  0023c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00244	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00249	6a 10		 push	 16			; 00000010H
  0024b	58		 pop	 eax
  0024c	6b c0 00	 imul	 eax, eax, 0
  0024f	8d 44 05 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp+eax]
  00253	6a 04		 push	 4
  00255	59		 pop	 ecx
  00256	6b c9 00	 imul	 ecx, ecx, 0
  00259	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00261	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 81   : 		switch(iBillboardType)

  00266	8b 85 f8 fc ff
	ff		 mov	 eax, DWORD PTR _iBillboardType$11[ebp]
  0026c	89 85 48 fe ff
	ff		 mov	 DWORD PTR tv92[ebp], eax
  00272	83 bd 48 fe ff
	ff 01		 cmp	 DWORD PTR tv92[ebp], 1
  00279	74 1b		 je	 SHORT $LN9@OnRender
  0027b	83 bd 48 fe ff
	ff 02		 cmp	 DWORD PTR tv92[ebp], 2
  00282	74 78		 je	 SHORT $LN10@OnRender
  00284	83 bd 48 fe ff
	ff 03		 cmp	 DWORD PTR tv92[ebp], 3
  0028b	0f 84 35 02 00
	00		 je	 $LN11@OnRender
  00291	e9 47 03 00 00	 jmp	 $LN5@OnRender
$LN9@OnRender:

; 82   : 		{
; 83   : 			case MESH_BILLBOARD_TYPE_ALL:
; 84   : 				{
; 85   : 					D3DXMATRIX matTemp;
; 86   : 					D3DXMatrixRotationX(&matTemp, 90.0f);

  00296	51		 push	 ecx
  00297	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42b40000
  0029f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a4	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _matTemp$89[ebp]
  002aa	50		 push	 eax
  002ab	e8 00 00 00 00	 call	 _D3DXMatrixRotationX@8

; 87   : 					D3DXMatrixInverse(&m_matWorld, NULL, &CScreen::GetViewMatrix());

  002b0	e8 00 00 00 00	 call	 ?GetViewMatrix@CGraphicBase@@SAABUD3DXMATRIX@@XZ ; CGraphicBase::GetViewMatrix
  002b5	50		 push	 eax
  002b6	6a 00		 push	 0
  002b8	8d 45 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp]
  002bb	50		 push	 eax
  002bc	e8 00 00 00 00	 call	 _D3DXMatrixInverse@12
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  002c1	8d 45 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp]
  002c4	50		 push	 eax
  002c5	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _matTemp$89[ebp]
  002cb	50		 push	 eax
  002cc	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR _matT$90[ebp]
  002d2	50		 push	 eax
  002d3	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 581  :     return matT;

  002d8	6a 10		 push	 16			; 00000010H
  002da	59		 pop	 ecx
  002db	8d b5 04 ff ff
	ff		 lea	 esi, DWORD PTR _matT$90[ebp]
  002e1	8d bd 44 ff ff
	ff		 lea	 edi, DWORD PTR $T91[ebp]
  002e7	f3 a5		 rep movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 89   : 					m_matWorld = matTemp * m_matWorld;

  002e9	6a 10		 push	 16			; 00000010H
  002eb	59		 pop	 ecx
  002ec	8d b5 44 ff ff
	ff		 lea	 esi, DWORD PTR $T91[ebp]
  002f2	8d 7d 28	 lea	 edi, DWORD PTR _m_matWorld$97[ebp]
  002f5	f3 a5		 rep movsd

; 90   : 				}
; 91   : 				break;

  002f7	e9 e1 02 00 00	 jmp	 $LN5@OnRender
$LN10@OnRender:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  002fc	6a 10		 push	 16			; 00000010H
  002fe	58		 pop	 eax
  002ff	6b c0 03	 imul	 eax, eax, 3
  00302	8d 44 05 c4	 lea	 eax, DWORD PTR _matTemp$93[ebp+eax]
  00306	6a 04		 push	 4
  00308	59		 pop	 ecx
  00309	d1 e1		 shl	 ecx, 1
  0030b	0f 57 c0	 xorps	 xmm0, xmm0
  0030e	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00313	6a 10		 push	 16			; 00000010H
  00315	58		 pop	 eax
  00316	6b c0 03	 imul	 eax, eax, 3
  00319	8d 44 05 c4	 lea	 eax, DWORD PTR _matTemp$93[ebp+eax]
  0031d	6a 04		 push	 4
  0031f	59		 pop	 ecx
  00320	c1 e1 00	 shl	 ecx, 0
  00323	0f 57 c0	 xorps	 xmm0, xmm0
  00326	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0032b	6a 10		 push	 16			; 00000010H
  0032d	58		 pop	 eax
  0032e	6b c0 03	 imul	 eax, eax, 3
  00331	8d 44 05 c4	 lea	 eax, DWORD PTR _matTemp$93[ebp+eax]
  00335	6a 04		 push	 4
  00337	59		 pop	 ecx
  00338	6b c9 00	 imul	 ecx, ecx, 0
  0033b	0f 57 c0	 xorps	 xmm0, xmm0
  0033e	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00343	6a 10		 push	 16			; 00000010H
  00345	58		 pop	 eax
  00346	d1 e0		 shl	 eax, 1
  00348	8d 44 05 c4	 lea	 eax, DWORD PTR _matTemp$93[ebp+eax]
  0034c	6a 04		 push	 4
  0034e	59		 pop	 ecx
  0034f	6b c9 03	 imul	 ecx, ecx, 3
  00352	0f 57 c0	 xorps	 xmm0, xmm0
  00355	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0035a	6a 10		 push	 16			; 00000010H
  0035c	58		 pop	 eax
  0035d	d1 e0		 shl	 eax, 1
  0035f	8d 44 05 c4	 lea	 eax, DWORD PTR _matTemp$93[ebp+eax]
  00363	6a 04		 push	 4
  00365	59		 pop	 ecx
  00366	c1 e1 00	 shl	 ecx, 0
  00369	0f 57 c0	 xorps	 xmm0, xmm0
  0036c	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00371	6a 10		 push	 16			; 00000010H
  00373	58		 pop	 eax
  00374	d1 e0		 shl	 eax, 1
  00376	8d 44 05 c4	 lea	 eax, DWORD PTR _matTemp$93[ebp+eax]
  0037a	6a 04		 push	 4
  0037c	59		 pop	 ecx
  0037d	6b c9 00	 imul	 ecx, ecx, 0
  00380	0f 57 c0	 xorps	 xmm0, xmm0
  00383	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00388	6a 10		 push	 16			; 00000010H
  0038a	58		 pop	 eax
  0038b	c1 e0 00	 shl	 eax, 0
  0038e	8d 44 05 c4	 lea	 eax, DWORD PTR _matTemp$93[ebp+eax]
  00392	6a 04		 push	 4
  00394	59		 pop	 ecx
  00395	6b c9 03	 imul	 ecx, ecx, 3
  00398	0f 57 c0	 xorps	 xmm0, xmm0
  0039b	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  003a0	6a 10		 push	 16			; 00000010H
  003a2	58		 pop	 eax
  003a3	c1 e0 00	 shl	 eax, 0
  003a6	8d 44 05 c4	 lea	 eax, DWORD PTR _matTemp$93[ebp+eax]
  003aa	6a 04		 push	 4
  003ac	59		 pop	 ecx
  003ad	d1 e1		 shl	 ecx, 1
  003af	0f 57 c0	 xorps	 xmm0, xmm0
  003b2	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  003b7	6a 10		 push	 16			; 00000010H
  003b9	58		 pop	 eax
  003ba	c1 e0 00	 shl	 eax, 0
  003bd	8d 44 05 c4	 lea	 eax, DWORD PTR _matTemp$93[ebp+eax]
  003c1	6a 04		 push	 4
  003c3	59		 pop	 ecx
  003c4	6b c9 00	 imul	 ecx, ecx, 0
  003c7	0f 57 c0	 xorps	 xmm0, xmm0
  003ca	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  003cf	6a 10		 push	 16			; 00000010H
  003d1	58		 pop	 eax
  003d2	6b c0 00	 imul	 eax, eax, 0
  003d5	8d 44 05 c4	 lea	 eax, DWORD PTR _matTemp$93[ebp+eax]
  003d9	6a 04		 push	 4
  003db	59		 pop	 ecx
  003dc	6b c9 03	 imul	 ecx, ecx, 3
  003df	0f 57 c0	 xorps	 xmm0, xmm0
  003e2	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  003e7	6a 10		 push	 16			; 00000010H
  003e9	58		 pop	 eax
  003ea	6b c0 00	 imul	 eax, eax, 0
  003ed	8d 44 05 c4	 lea	 eax, DWORD PTR _matTemp$93[ebp+eax]
  003f1	6a 04		 push	 4
  003f3	59		 pop	 ecx
  003f4	d1 e1		 shl	 ecx, 1
  003f6	0f 57 c0	 xorps	 xmm0, xmm0
  003f9	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  003fe	6a 10		 push	 16			; 00000010H
  00400	58		 pop	 eax
  00401	6b c0 00	 imul	 eax, eax, 0
  00404	8d 44 05 c4	 lea	 eax, DWORD PTR _matTemp$93[ebp+eax]
  00408	6a 04		 push	 4
  0040a	59		 pop	 ecx
  0040b	c1 e1 00	 shl	 ecx, 0
  0040e	0f 57 c0	 xorps	 xmm0, xmm0
  00411	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  00416	6a 10		 push	 16			; 00000010H
  00418	58		 pop	 eax
  00419	6b c0 03	 imul	 eax, eax, 3
  0041c	8d 44 05 c4	 lea	 eax, DWORD PTR _matTemp$93[ebp+eax]
  00420	6a 04		 push	 4
  00422	59		 pop	 ecx
  00423	6b c9 03	 imul	 ecx, ecx, 3
  00426	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0042e	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00433	6a 10		 push	 16			; 00000010H
  00435	58		 pop	 eax
  00436	d1 e0		 shl	 eax, 1
  00438	8d 44 05 c4	 lea	 eax, DWORD PTR _matTemp$93[ebp+eax]
  0043c	6a 04		 push	 4
  0043e	59		 pop	 ecx
  0043f	d1 e1		 shl	 ecx, 1
  00441	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00449	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0044e	6a 10		 push	 16			; 00000010H
  00450	58		 pop	 eax
  00451	c1 e0 00	 shl	 eax, 0
  00454	8d 44 05 c4	 lea	 eax, DWORD PTR _matTemp$93[ebp+eax]
  00458	6a 04		 push	 4
  0045a	59		 pop	 ecx
  0045b	c1 e1 00	 shl	 ecx, 0
  0045e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00466	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0046b	6a 10		 push	 16			; 00000010H
  0046d	58		 pop	 eax
  0046e	6b c0 00	 imul	 eax, eax, 0
  00471	8d 44 05 c4	 lea	 eax, DWORD PTR _matTemp$93[ebp+eax]
  00475	6a 04		 push	 4
  00477	59		 pop	 ecx
  00478	6b c9 00	 imul	 ecx, ecx, 0
  0047b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00483	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 98   : 					D3DXMatrixInverse(&matTemp, NULL, &CScreen::GetViewMatrix());

  00488	e8 00 00 00 00	 call	 ?GetViewMatrix@CGraphicBase@@SAABUD3DXMATRIX@@XZ ; CGraphicBase::GetViewMatrix
  0048d	50		 push	 eax
  0048e	6a 00		 push	 0
  00490	8d 45 c4	 lea	 eax, DWORD PTR _matTemp$93[ebp]
  00493	50		 push	 eax
  00494	e8 00 00 00 00	 call	 _D3DXMatrixInverse@12

; 99   : 					m_matWorld._11 = matTemp._11;

  00499	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _matTemp$93[ebp]
  0049e	f3 0f 11 45 28	 movss	 DWORD PTR _m_matWorld$97[ebp], xmm0

; 100  : 					m_matWorld._12 = matTemp._12;

  004a3	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _matTemp$93[ebp+4]
  004a8	f3 0f 11 45 2c	 movss	 DWORD PTR _m_matWorld$97[ebp+4], xmm0

; 101  : 					m_matWorld._21 = matTemp._21;

  004ad	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _matTemp$93[ebp+16]
  004b2	f3 0f 11 45 38	 movss	 DWORD PTR _m_matWorld$97[ebp+16], xmm0

; 102  : 					m_matWorld._22 = matTemp._22;

  004b7	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _matTemp$93[ebp+20]
  004bc	f3 0f 11 45 3c	 movss	 DWORD PTR _m_matWorld$97[ebp+20], xmm0

; 103  : 				}
; 104  : 				break;

  004c1	e9 17 01 00 00	 jmp	 $LN5@OnRender
$LN11@OnRender:

; 105  : 
; 106  : 			case MESH_BILLBOARD_TYPE_MOVE:
; 107  : 				{
; 108  : 					D3DXVECTOR3 Position;
; 109  : 					m_pMeshScript->GetPosition(m_fLocalTime, Position);

  004c6	8d 45 68	 lea	 eax, DWORD PTR _Position$98[ebp]
  004c9	50		 push	 eax
  004ca	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004d0	51		 push	 ecx
  004d1	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  004d6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004db	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004e1	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  004e4	e8 00 00 00 00	 call	 ?GetPosition@CEffectElementBase@@QAEXMAAUD3DXVECTOR3@@@Z ; CEffectElementBase::GetPosition
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  004e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  004ee	89 85 f4 fc ff
	ff		 mov	 DWORD PTR $T10[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 111  : 					m_pMeshScript->GetPosition(m_fLocalTime-CTimer::Instance().GetElapsedSecond(), LastPosition);

  004f4	8d 45 04	 lea	 eax, DWORD PTR _LastPosition$94[ebp]
  004f7	50		 push	 eax
  004f8	8b 8d f4 fc ff
	ff		 mov	 ecx, DWORD PTR $T10[ebp]
  004fe	e8 00 00 00 00	 call	 ?GetElapsedSecond@CTimer@@QAEMXZ ; CTimer::GetElapsedSecond
  00503	d9 9d f0 fc ff
	ff		 fstp	 DWORD PTR tv1443[ebp]
  00509	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0050f	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00514	f3 0f 5c 85 f0
	fc ff ff	 subss	 xmm0, DWORD PTR tv1443[ebp]
  0051c	51		 push	 ecx
  0051d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00522	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00528	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0052b	e8 00 00 00 00	 call	 ?GetPosition@CEffectElementBase@@QAEXMAAUD3DXVECTOR3@@@Z ; CEffectElementBase::GetPosition
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 213  :     x -= v.x;

  00530	f3 0f 10 45 68	 movss	 xmm0, DWORD PTR _Position$98[ebp]
  00535	f3 0f 5c 45 04	 subss	 xmm0, DWORD PTR _LastPosition$94[ebp]
  0053a	f3 0f 11 45 68	 movss	 DWORD PTR _Position$98[ebp], xmm0

; 214  :     y -= v.y;

  0053f	f3 0f 10 45 6c	 movss	 xmm0, DWORD PTR _Position$98[ebp+4]
  00544	f3 0f 5c 45 08	 subss	 xmm0, DWORD PTR _LastPosition$94[ebp+4]
  00549	f3 0f 11 45 6c	 movss	 DWORD PTR _Position$98[ebp+4], xmm0

; 215  :     z -= v.z;

  0054e	f3 0f 10 45 70	 movss	 xmm0, DWORD PTR _Position$98[ebp+8]
  00553	f3 0f 5c 45 0c	 subss	 xmm0, DWORD PTR _LastPosition$94[ebp+8]
  00558	f3 0f 11 45 70	 movss	 DWORD PTR _Position$98[ebp+8], xmm0

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0055d	f3 0f 10 45 70	 movss	 xmm0, DWORD PTR _Position$98[ebp+8]
  00562	f3 0f 59 45 70	 mulss	 xmm0, DWORD PTR _Position$98[ebp+8]
  00567	f3 0f 10 4d 6c	 movss	 xmm1, DWORD PTR _Position$98[ebp+4]
  0056c	f3 0f 59 4d 6c	 mulss	 xmm1, DWORD PTR _Position$98[ebp+4]
  00571	f3 0f 10 55 68	 movss	 xmm2, DWORD PTR _Position$98[ebp]
  00576	f3 0f 59 55 68	 mulss	 xmm2, DWORD PTR _Position$98[ebp]
  0057b	f3 0f 58 d1	 addss	 xmm2, xmm1
  0057f	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 113  : 					if (D3DXVec3LengthSq(&Position)>0.001f)

  00583	0f 2f 15 00 00
	00 00		 comiss	 xmm2, DWORD PTR __real@3a83126f
  0058a	76 51		 jbe	 SHORT $LN12@OnRender

; 114  : 					{
; 115  : 						D3DXVec3Normalize(&Position,&Position);

  0058c	8d 45 68	 lea	 eax, DWORD PTR _Position$98[ebp]
  0058f	50		 push	 eax
  00590	8d 45 68	 lea	 eax, DWORD PTR _Position$98[ebp]
  00593	50		 push	 eax
  00594	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  00599	0f 57 c0	 xorps	 xmm0, xmm0
  0059c	f3 0f 11 45 10	 movss	 DWORD PTR $T95[ebp], xmm0

; 181  :     y = fy;

  005a1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  005a9	f3 0f 11 45 14	 movss	 DWORD PTR $T95[ebp+4], xmm0

; 182  :     z = fz;

  005ae	0f 57 c0	 xorps	 xmm0, xmm0
  005b1	f3 0f 11 45 18	 movss	 DWORD PTR $T95[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 116  : 						D3DXQUATERNION q = SafeRotationNormalizedArc(D3DXVECTOR3(0.0f,-1.0f,0.0f),Position);

  005b6	8d 45 68	 lea	 eax, DWORD PTR _Position$98[ebp]
  005b9	50		 push	 eax
  005ba	8d 45 10	 lea	 eax, DWORD PTR $T95[ebp]
  005bd	50		 push	 eax
  005be	8d 85 b8 fc ff
	ff		 lea	 eax, DWORD PTR _q$1[ebp]
  005c4	50		 push	 eax
  005c5	e8 00 00 00 00	 call	 ?SafeRotationNormalizedArc@@YA?AUD3DXQUATERNION@@ABUD3DXVECTOR3@@0@Z ; SafeRotationNormalizedArc
  005ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 117  : 						D3DXMatrixRotationQuaternion(&m_matWorld,&q);

  005cd	8d 85 b8 fc ff
	ff		 lea	 eax, DWORD PTR _q$1[ebp]
  005d3	50		 push	 eax
  005d4	8d 45 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp]
  005d7	50		 push	 eax
  005d8	e8 00 00 00 00	 call	 _D3DXMatrixRotationQuaternion@8
$LN12@OnRender:
$LN5@OnRender:

; 118  : 					}
; 119  : 				}
; 120  : 				break;
; 121  : 		}
; 122  : 
; 123  : 		if (!m_pMeshScript->isBlendingEnable(i))

  005dd	ff b5 7c fe ff
	ff		 push	 DWORD PTR _i$87[ebp]
  005e3	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  005e9	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  005ec	e8 00 00 00 00	 call	 ?isBlendingEnable@CEffectMeshScript@@QAEHK@Z ; CEffectMeshScript::isBlendingEnable
  005f1	85 c0		 test	 eax, eax
  005f3	75 11		 jne	 SHORT $LN13@OnRender

; 124  : 		{
; 125  : 			STATEMANAGER.SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);

  005f5	6a 00		 push	 0
  005f7	6a 1b		 push	 27			; 0000001bH
  005f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  005ff	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 126  : 		}

  00604	eb 6f		 jmp	 SHORT $LN14@OnRender
$LN13@OnRender:

; 127  : 		else
; 128  : 		{
; 129  : 			int iBlendingSrcType = m_pMeshScript->GetBlendingSrcType(i);

  00606	ff b5 7c fe ff
	ff		 push	 DWORD PTR _i$87[ebp]
  0060c	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00612	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00615	e8 00 00 00 00	 call	 ?GetBlendingSrcType@CEffectMeshScript@@QAEEK@Z ; CEffectMeshScript::GetBlendingSrcType
  0061a	0f b6 c0	 movzx	 eax, al
  0061d	89 85 ec fc ff
	ff		 mov	 DWORD PTR _iBlendingSrcType$9[ebp], eax

; 130  : 			int iBlendingDestType = m_pMeshScript->GetBlendingDestType(i);

  00623	ff b5 7c fe ff
	ff		 push	 DWORD PTR _i$87[ebp]
  00629	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0062f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00632	e8 00 00 00 00	 call	 ?GetBlendingDestType@CEffectMeshScript@@QAEEK@Z ; CEffectMeshScript::GetBlendingDestType
  00637	0f b6 c0	 movzx	 eax, al
  0063a	89 85 e8 fc ff
	ff		 mov	 DWORD PTR _iBlendingDestType$8[ebp], eax

; 131  : 			STATEMANAGER.SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);

  00640	6a 01		 push	 1
  00642	6a 1b		 push	 27			; 0000001bH
  00644	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0064a	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 132  : 			STATEMANAGER.SetRenderState(D3DRS_SRCBLEND, iBlendingSrcType);

  0064f	ff b5 ec fc ff
	ff		 push	 DWORD PTR _iBlendingSrcType$9[ebp]
  00655	6a 13		 push	 19			; 00000013H
  00657	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0065d	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 133  : 			STATEMANAGER.SetRenderState(D3DRS_DESTBLEND, iBlendingDestType);

  00662	ff b5 e8 fc ff
	ff		 push	 DWORD PTR _iBlendingDestType$8[ebp]
  00668	6a 14		 push	 20			; 00000014H
  0066a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00670	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
$LN14@OnRender:

; 134  : 		}
; 135  : 
; 136  : 		D3DXVECTOR3 Position;
; 137  : 		m_pMeshScript->GetPosition(m_fLocalTime, Position);

  00675	8d 45 1c	 lea	 eax, DWORD PTR _Position$96[ebp]
  00678	50		 push	 eax
  00679	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0067f	51		 push	 ecx
  00680	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00685	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0068a	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00690	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00693	e8 00 00 00 00	 call	 ?GetPosition@CEffectElementBase@@QAEXMAAUD3DXVECTOR3@@@Z ; CEffectElementBase::GetPosition

; 138  : 		m_matWorld._41 = Position.x;

  00698	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _Position$96[ebp]
  0069d	f3 0f 11 45 58	 movss	 DWORD PTR _m_matWorld$97[ebp+48], xmm0

; 139  : 		m_matWorld._42 = Position.y;

  006a2	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _Position$96[ebp+4]
  006a7	f3 0f 11 45 5c	 movss	 DWORD PTR _m_matWorld$97[ebp+52], xmm0

; 140  : 		m_matWorld._43 = Position.z;

  006ac	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _Position$96[ebp+8]
  006b1	f3 0f 11 45 60	 movss	 DWORD PTR _m_matWorld$97[ebp+56], xmm0

; 141  : 		m_matWorld = m_matWorld * *mc_pmatLocal;

  006b6	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  006bc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  006bf	89 85 e4 fc ff
	ff		 mov	 DWORD PTR _mat$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  006c5	ff b5 e4 fc ff
	ff		 push	 DWORD PTR _mat$[ebp]
  006cb	8d 45 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp]
  006ce	50		 push	 eax
  006cf	8d 85 84 fe ff
	ff		 lea	 eax, DWORD PTR _matT$88[ebp]
  006d5	50		 push	 eax
  006d6	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 581  :     return matT;

  006db	6a 10		 push	 16			; 00000010H
  006dd	59		 pop	 ecx
  006de	8d b5 84 fe ff
	ff		 lea	 esi, DWORD PTR _matT$88[ebp]
  006e4	8d 7d 84	 lea	 edi, DWORD PTR $T92[ebp]
  006e7	f3 a5		 rep movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 141  : 		m_matWorld = m_matWorld * *mc_pmatLocal;

  006e9	6a 10		 push	 16			; 00000010H
  006eb	59		 pop	 ecx
  006ec	8d 75 84	 lea	 esi, DWORD PTR $T92[ebp]
  006ef	8d 7d 28	 lea	 edi, DWORD PTR _m_matWorld$97[ebp]
  006f2	f3 a5		 rep movsd

; 142  : 		STATEMANAGER.SetTransform(D3DTS_WORLD, &m_matWorld);

  006f4	8d 45 28	 lea	 eax, DWORD PTR _m_matWorld$97[ebp]
  006f7	50		 push	 eax
  006f8	68 00 01 00 00	 push	 256			; 00000100H
  006fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00703	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 920  :     r = fr;

  00708	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00710	f3 0f 11 85 4c
	fe ff ff	 movss	 DWORD PTR _Color$78[ebp], xmm0

; 921  :     g = fg;

  00718	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00720	f3 0f 11 85 50
	fe ff ff	 movss	 DWORD PTR _Color$78[ebp+4], xmm0

; 922  :     b = fb;

  00728	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00730	f3 0f 11 85 54
	fe ff ff	 movss	 DWORD PTR _Color$78[ebp+8], xmm0

; 923  :     a = fa;

  00738	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00740	f3 0f 11 85 58
	fe ff ff	 movss	 DWORD PTR _Color$78[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 146  : 		if (m_pMeshScript->GetColorOperationType(i, &byType))

  00748	8d 85 6b fe ff
	ff		 lea	 eax, DWORD PTR _byType$80[ebp]
  0074e	50		 push	 eax
  0074f	ff b5 7c fe ff
	ff		 push	 DWORD PTR _i$87[ebp]
  00755	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0075b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0075e	e8 00 00 00 00	 call	 ?GetColorOperationType@CEffectMeshScript@@QAEHKPAE@Z ; CEffectMeshScript::GetColorOperationType
  00763	85 c0		 test	 eax, eax
  00765	74 17		 je	 SHORT $LN15@OnRender

; 147  : 			STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP, byType);

  00767	0f b6 85 6b fe
	ff ff		 movzx	 eax, BYTE PTR _byType$80[ebp]
  0076e	50		 push	 eax
  0076f	6a 01		 push	 1
  00771	6a 00		 push	 0
  00773	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00779	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState
$LN15@OnRender:

; 148  : 		m_pMeshScript->GetColorFactor(i, &Color);

  0077e	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR _Color$78[ebp]
  00784	50		 push	 eax
  00785	ff b5 7c fe ff
	ff		 push	 DWORD PTR _i$87[ebp]
  0078b	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00791	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00794	e8 00 00 00 00	 call	 ?GetColorFactor@CEffectMeshScript@@QAEHKPAUD3DXCOLOR@@@Z ; CEffectMeshScript::GetColorFactor

; 149  : 
; 150  : 		TTimeEventTableFloat * TableAlpha;
; 151  : 
; 152  : 		float fAlpha = 1.0f;

  00799	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  007a1	f3 0f 11 85 6c
	fe ff ff	 movss	 DWORD PTR _fAlpha$81[ebp], xmm0

; 153  : 		if (m_pMeshScript->GetTimeTableAlphaPointer(i, &TableAlpha) && !TableAlpha->empty())

  007a9	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _TableAlpha$67[ebp]
  007af	50		 push	 eax
  007b0	ff b5 7c fe ff
	ff		 push	 DWORD PTR _i$87[ebp]
  007b6	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  007bc	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  007bf	e8 00 00 00 00	 call	 ?GetTimeTableAlphaPointer@CEffectMeshScript@@QAEHKPAPAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@Z ; CEffectMeshScript::GetTimeTableAlphaPointer
  007c4	85 c0		 test	 eax, eax
  007c6	0f 84 44 05 00
	00		 je	 $LN75@OnRender
  007cc	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _TableAlpha$67[ebp]
  007d2	89 85 e0 fc ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  007d8	8b 85 e0 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  007de	89 85 3c fe ff
	ff		 mov	 DWORD PTR __My_data$75[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  007e4	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR __My_data$75[ebp]
  007ea	8b 8d 3c fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$75[ebp]
  007f0	8b 00		 mov	 eax, DWORD PTR [eax]
  007f2	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  007f5	75 0c		 jne	 SHORT $LN72@OnRender
  007f7	c7 85 e4 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv869[ebp], 1
  00801	eb 07		 jmp	 SHORT $LN73@OnRender
$LN72@OnRender:
  00803	83 a5 e4 fd ff
	ff 00		 and	 DWORD PTR tv869[ebp], 0
$LN73@OnRender:
  0080a	8a 85 e4 fd ff
	ff		 mov	 al, BYTE PTR tv869[ebp]
  00810	88 85 77 fe ff
	ff		 mov	 BYTE PTR $T86[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 153  : 		if (m_pMeshScript->GetTimeTableAlphaPointer(i, &TableAlpha) && !TableAlpha->empty())

  00816	0f b6 85 77 fe
	ff ff		 movzx	 eax, BYTE PTR $T86[ebp]
  0081d	85 c0		 test	 eax, eax
  0081f	0f 85 eb 04 00
	00		 jne	 $LN75@OnRender

; 154  : 			GetTimeEventBlendValue(m_fLocalTime,*TableAlpha, &fAlpha);

  00825	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _TableAlpha$67[ebp]
  0082b	89 85 78 fe ff
	ff		 mov	 DWORD PTR _rVector$[ebp], eax
  00831	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00837	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0083c	f3 0f 11 85 5c
	fe ff ff	 movss	 DWORD PTR _fElapsedTime$[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00844	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR _rVector$[ebp]
  0084a	89 85 ec fd ff
	ff		 mov	 DWORD PTR __My_data$68[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00850	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR __My_data$68[ebp]
  00856	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR __My_data$68[ebp]
  0085c	8b 00		 mov	 eax, DWORD PTR [eax]
  0085e	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00861	75 0c		 jne	 SHORT $LN85@OnRender
  00863	c7 85 f0 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv1002[ebp], 1
  0086d	eb 07		 jmp	 SHORT $LN86@OnRender
$LN85@OnRender:
  0086f	83 a5 f0 fd ff
	ff 00		 and	 DWORD PTR tv1002[ebp], 0
$LN86@OnRender:
  00876	8a 85 f0 fd ff
	ff		 mov	 al, BYTE PTR tv1002[ebp]
  0087c	88 85 76 fe ff
	ff		 mov	 BYTE PTR $T85[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h

; 229  : 	if (rVector.empty())

  00882	0f b6 85 76 fe
	ff ff		 movzx	 eax, BYTE PTR $T85[ebp]
  00889	85 c0		 test	 eax, eax
  0088b	74 10		 je	 SHORT $LN76@OnRender

; 230  : 	{
; 231  : 		*pReturnValue = T();

  0088d	0f 57 c0	 xorps	 xmm0, xmm0
  00890	f3 0f 11 85 6c
	fe ff ff	 movss	 DWORD PTR _fAlpha$81[ebp], xmm0

; 232  : 		return;

  00898	e9 73 04 00 00	 jmp	 $LN75@OnRender
$LN76@OnRender:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  0089d	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR _rVector$[ebp]
  008a3	89 85 f4 fd ff
	ff		 mov	 DWORD PTR __My_data$69[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  008a9	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR __My_data$69[ebp]
  008af	89 85 dc fc ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  008b5	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR __My_data$69[ebp]
  008bb	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  008be	89 85 d8 fc ff
	ff		 mov	 DWORD PTR ___param0$6[ebp], eax
  008c4	ff b5 dc fc ff
	ff		 push	 DWORD PTR $T7[ebp]
  008ca	ff b5 d8 fc ff
	ff		 push	 DWORD PTR ___param0$6[ebp]
  008d0	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  008d6	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
  008db	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  008e1	89 85 c8 fd ff
	ff		 mov	 DWORD PTR $T60[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  008e7	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR _rVector$[ebp]
  008ed	89 85 fc fd ff
	ff		 mov	 DWORD PTR __My_data$70[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  008f3	8b 85 fc fd ff
	ff		 mov	 eax, DWORD PTR __My_data$70[ebp]
  008f9	89 85 d0 fc ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  008ff	8b 85 fc fd ff
	ff		 mov	 eax, DWORD PTR __My_data$70[ebp]
  00905	8b 00		 mov	 eax, DWORD PTR [eax]
  00907	89 85 e0 fd ff
	ff		 mov	 DWORD PTR ___param0$66[ebp], eax
  0090d	ff b5 d0 fc ff
	ff		 push	 DWORD PTR $T4[ebp]
  00913	ff b5 e0 fd ff
	ff		 push	 DWORD PTR ___param0$66[ebp]
  00919	8d 8d dc fd ff
	ff		 lea	 ecx, DWORD PTR $T65[ebp]
  0091f	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
  00924	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR $T65[ebp]
  0092a	89 85 d8 fd ff
	ff		 mov	 DWORD PTR $T64[ebp], eax

; 287  :         _Vector_iterator _Tmp = *this;

  00930	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR $T64[ebp]
  00936	8b 00		 mov	 eax, DWORD PTR [eax]
  00938	89 85 44 fe ff
	ff		 mov	 DWORD PTR __Tmp$77[ebp], eax

; 120  :         _Ptr += _Off;

  0093e	33 c0		 xor	 eax, eax
  00940	40		 inc	 eax
  00941	c1 e0 03	 shl	 eax, 3
  00944	03 85 44 fe ff
	ff		 add	 eax, DWORD PTR __Tmp$77[ebp]
  0094a	89 85 44 fe ff
	ff		 mov	 DWORD PTR __Tmp$77[ebp], eax

; 283  :         return *this;

  00950	8d 85 44 fe ff
	ff		 lea	 eax, DWORD PTR __Tmp$77[ebp]
  00956	89 85 d4 fd ff
	ff		 mov	 DWORD PTR $T63[ebp], eax

; 288  :         return _Tmp += _Off;

  0095c	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR $T63[ebp]
  00962	8b 00		 mov	 eax, DWORD PTR [eax]
  00964	89 85 d0 fd ff
	ff		 mov	 DWORD PTR $T62[ebp], eax
  0096a	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR $T62[ebp]
  00970	89 85 cc fd ff
	ff		 mov	 DWORD PTR $T61[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00976	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR $T61[ebp]
  0097c	8b 8d c8 fd ff
	ff		 mov	 ecx, DWORD PTR $T60[ebp]
  00982	8b 00		 mov	 eax, DWORD PTR [eax]
  00984	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00986	75 0c		 jne	 SHORT $LN120@OnRender
  00988	c7 85 00 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv1040[ebp], 1
  00992	eb 07		 jmp	 SHORT $LN121@OnRender
$LN120@OnRender:
  00994	83 a5 00 fe ff
	ff 00		 and	 DWORD PTR tv1040[ebp], 0
$LN121@OnRender:
  0099b	8a 85 00 fe ff
	ff		 mov	 al, BYTE PTR tv1040[ebp]
  009a1	88 85 75 fe ff
	ff		 mov	 BYTE PTR $T84[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h

; 235  : 	if(rVector.begin()+1==rVector.end())

  009a7	0f b6 85 75 fe
	ff ff		 movzx	 eax, BYTE PTR $T84[ebp]
  009ae	85 c0		 test	 eax, eax
  009b0	74 32		 je	 SHORT $LN77@OnRender
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1536 :         auto& _My_data = _Mypair._Myval2;

  009b2	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR _rVector$[ebp]
  009b8	89 85 c4 fd ff
	ff		 mov	 DWORD PTR __My_data$59[ebp], eax

; 1537 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1538 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "front() called on empty vector");
; 1539 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1540 : 
; 1541 :         return *_My_data._Myfirst;

  009be	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR __My_data$59[ebp]
  009c4	8b 00		 mov	 eax, DWORD PTR [eax]
  009c6	89 85 c0 fd ff
	ff		 mov	 DWORD PTR $T58[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h

; 237  : 		*pReturnValue = rVector.front().m_Value;

  009cc	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR $T58[ebp]
  009d2	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  009d7	f3 0f 11 85 6c
	fe ff ff	 movss	 DWORD PTR _fAlpha$81[ebp], xmm0

; 238  : 		return;

  009df	e9 2c 03 00 00	 jmp	 $LN75@OnRender
$LN77@OnRender:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1536 :         auto& _My_data = _Mypair._Myval2;

  009e4	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR _rVector$[ebp]
  009ea	89 85 bc fd ff
	ff		 mov	 DWORD PTR __My_data$57[ebp], eax

; 1537 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1538 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "front() called on empty vector");
; 1539 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1540 : 
; 1541 :         return *_My_data._Myfirst;

  009f0	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR __My_data$57[ebp]
  009f6	8b 00		 mov	 eax, DWORD PTR [eax]
  009f8	89 85 b8 fd ff
	ff		 mov	 DWORD PTR $T56[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h

; 241  : 	if (fElapsedTime < rVector.front().m_fTime)

  009fe	8b 85 b8 fd ff
	ff		 mov	 eax, DWORD PTR $T56[ebp]
  00a04	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00a08	0f 2f 85 5c fe
	ff ff		 comiss	 xmm0, DWORD PTR _fElapsedTime$[ebp]
  00a0f	76 32		 jbe	 SHORT $LN78@OnRender
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1536 :         auto& _My_data = _Mypair._Myval2;

  00a11	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR _rVector$[ebp]
  00a17	89 85 b4 fd ff
	ff		 mov	 DWORD PTR __My_data$55[ebp], eax

; 1537 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1538 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "front() called on empty vector");
; 1539 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1540 : 
; 1541 :         return *_My_data._Myfirst;

  00a1d	8b 85 b4 fd ff
	ff		 mov	 eax, DWORD PTR __My_data$55[ebp]
  00a23	8b 00		 mov	 eax, DWORD PTR [eax]
  00a25	89 85 b0 fd ff
	ff		 mov	 DWORD PTR $T54[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h

; 243  : 		*pReturnValue = rVector.front().m_Value;

  00a2b	8b 85 b0 fd ff
	ff		 mov	 eax, DWORD PTR $T54[ebp]
  00a31	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00a36	f3 0f 11 85 6c
	fe ff ff	 movss	 DWORD PTR _fAlpha$81[ebp], xmm0

; 244  : 		return;

  00a3e	e9 cd 02 00 00	 jmp	 $LN75@OnRender
$LN78@OnRender:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  00a43	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR _rVector$[ebp]
  00a49	89 85 ac fd ff
	ff		 mov	 DWORD PTR __My_data$53[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  00a4f	6a 08		 push	 8
  00a51	58		 pop	 eax
  00a52	6b c0 ff	 imul	 eax, eax, -1
  00a55	8b 8d ac fd ff
	ff		 mov	 ecx, DWORD PTR __My_data$53[ebp]
  00a5b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  00a5e	89 85 a8 fd ff
	ff		 mov	 DWORD PTR $T52[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h

; 247  : 	if (fElapsedTime > rVector.back().m_fTime)

  00a64	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR $T52[ebp]
  00a6a	f3 0f 10 85 5c
	fe ff ff	 movss	 xmm0, DWORD PTR _fElapsedTime$[ebp]
  00a72	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  00a75	76 39		 jbe	 SHORT $LN79@OnRender
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  00a77	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR _rVector$[ebp]
  00a7d	89 85 a4 fd ff
	ff		 mov	 DWORD PTR __My_data$51[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  00a83	6a 08		 push	 8
  00a85	58		 pop	 eax
  00a86	6b c0 ff	 imul	 eax, eax, -1
  00a89	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR __My_data$51[ebp]
  00a8f	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  00a92	89 85 a0 fd ff
	ff		 mov	 DWORD PTR $T50[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h

; 249  : 		*pReturnValue = rVector.back().m_Value;

  00a98	8b 85 a0 fd ff
	ff		 mov	 eax, DWORD PTR $T50[ebp]
  00a9e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00aa3	f3 0f 11 85 6c
	fe ff ff	 movss	 DWORD PTR _fAlpha$81[ebp], xmm0

; 250  : 		return;

  00aab	e9 60 02 00 00	 jmp	 $LN75@OnRender
$LN79@OnRender:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00ab0	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR _rVector$[ebp]
  00ab6	89 85 04 fe ff
	ff		 mov	 DWORD PTR __My_data$71[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00abc	8b 85 04 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$71[ebp]
  00ac2	89 85 9c fd ff
	ff		 mov	 DWORD PTR $T49[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00ac8	8b 85 04 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$71[ebp]
  00ace	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00ad1	89 85 98 fd ff
	ff		 mov	 DWORD PTR ___param0$48[ebp], eax
  00ad7	ff b5 9c fd ff
	ff		 push	 DWORD PTR $T49[ebp]
  00add	ff b5 98 fd ff
	ff		 push	 DWORD PTR ___param0$48[ebp]
  00ae3	8d 8d 94 fd ff
	ff		 lea	 ecx, DWORD PTR $T47[ebp]
  00ae9	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
  00aee	8d 85 94 fd ff
	ff		 lea	 eax, DWORD PTR $T47[ebp]
  00af4	89 85 90 fd ff
	ff		 mov	 DWORD PTR $T46[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  00afa	8b 85 90 fd ff
	ff		 mov	 eax, DWORD PTR $T46[ebp]
  00b00	8b 00		 mov	 eax, DWORD PTR [eax]
  00b02	89 85 88 fd ff
	ff		 mov	 DWORD PTR __Last$[ebp], eax
  00b08	8d 85 c8 fc ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00b0e	50		 push	 eax
  00b0f	8b 8d 78 fe ff
	ff		 mov	 ecx, DWORD PTR _rVector$[ebp]
  00b15	e8 00 00 00 00	 call	 ?begin@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::begin
  00b1a	8b 00		 mov	 eax, DWORD PTR [eax]
  00b1c	89 85 84 fd ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6851 :     return _STD equal_range(_First, _Last, _Val, less<>{});

  00b22	33 c0		 xor	 eax, eax
  00b24	88 85 8c fd ff
	ff		 mov	 BYTE PTR $T45[ebp], al
  00b2a	ff b5 8c fd ff
	ff		 push	 DWORD PTR $T45[ebp]
  00b30	8d 85 5c fe ff
	ff		 lea	 eax, DWORD PTR _fElapsedTime$[ebp]
  00b36	50		 push	 eax
  00b37	ff b5 88 fd ff
	ff		 push	 DWORD PTR __Last$[ebp]
  00b3d	ff b5 84 fd ff
	ff		 push	 DWORD PTR __First$[ebp]
  00b43	8d 85 60 fe ff
	ff		 lea	 eax, DWORD PTR _result$79[ebp]
  00b49	50		 push	 eax
  00b4a	e8 00 00 00 00	 call	 ??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@MU?$less@X@2@@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABMU?$less@X@0@@Z ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float,std::less<void> >
  00b4f	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 149  :         return _Ptr == _Right._Ptr;

  00b52	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR _result$79[ebp]
  00b58	3b 85 64 fe ff
	ff		 cmp	 eax, DWORD PTR _result$79[ebp+4]
  00b5e	75 0c		 jne	 SHORT $LN159@OnRender
  00b60	c7 85 08 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv1083[ebp], 1
  00b6a	eb 07		 jmp	 SHORT $LN160@OnRender
$LN159@OnRender:
  00b6c	83 a5 08 fe ff
	ff 00		 and	 DWORD PTR tv1083[ebp], 0
$LN160@OnRender:
  00b73	8a 85 08 fe ff
	ff		 mov	 al, BYTE PTR tv1083[ebp]
  00b79	88 85 74 fe ff
	ff		 mov	 BYTE PTR $T83[ebp], al

; 153  :         return !(*this == _Right);

  00b7f	0f b6 85 74 fe
	ff ff		 movzx	 eax, BYTE PTR $T83[ebp]
  00b86	85 c0		 test	 eax, eax
  00b88	75 0c		 jne	 SHORT $LN154@OnRender
  00b8a	c7 85 0c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv1076[ebp], 1
  00b94	eb 07		 jmp	 SHORT $LN155@OnRender
$LN154@OnRender:
  00b96	83 a5 0c fe ff
	ff 00		 and	 DWORD PTR tv1076[ebp], 0
$LN155@OnRender:
  00b9d	8a 85 0c fe ff
	ff		 mov	 al, BYTE PTR tv1076[ebp]
  00ba3	88 85 73 fe ff
	ff		 mov	 BYTE PTR $T82[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h

; 257  : 	if (result.first != result.second)

  00ba9	0f b6 85 73 fe
	ff ff		 movzx	 eax, BYTE PTR $T82[ebp]
  00bb0	85 c0		 test	 eax, eax
  00bb2	74 36		 je	 SHORT $LN80@OnRender
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  00bb4	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR _result$79[ebp]
  00bba	89 85 80 fd ff
	ff		 mov	 DWORD PTR $T44[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  00bc0	ff b5 80 fd ff
	ff		 push	 DWORD PTR $T44[ebp]
  00bc6	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PBV1@@Z ; std::_Const_cast<CTimeEvent<float> const >
  00bcb	59		 pop	 ecx
  00bcc	89 85 7c fd ff
	ff		 mov	 DWORD PTR $T43[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h

; 258  : 		*pReturnValue = result.first->m_Value;

  00bd2	8b 85 7c fd ff
	ff		 mov	 eax, DWORD PTR $T43[ebp]
  00bd8	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00bdd	f3 0f 11 85 6c
	fe ff ff	 movss	 DWORD PTR _fAlpha$81[ebp], xmm0
  00be5	e9 26 01 00 00	 jmp	 $LN81@OnRender
$LN80@OnRender:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 92   :         --_Ptr;

  00bea	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR _result$79[ebp]
  00bf0	83 e8 08	 sub	 eax, 8
  00bf3	89 85 60 fe ff
	ff		 mov	 DWORD PTR _result$79[ebp], eax

; 65   :         return _Ptr;

  00bf9	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR _result$79[ebp+4]
  00bff	89 85 78 fd ff
	ff		 mov	 DWORD PTR $T42[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  00c05	ff b5 78 fd ff
	ff		 push	 DWORD PTR $T42[ebp]
  00c0b	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PBV1@@Z ; std::_Const_cast<CTimeEvent<float> const >
  00c10	59		 pop	 ecx
  00c11	89 85 6c fd ff
	ff		 mov	 DWORD PTR $T39[ebp], eax

; 65   :         return _Ptr;

  00c17	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR _result$79[ebp+4]
  00c1d	89 85 74 fd ff
	ff		 mov	 DWORD PTR $T41[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  00c23	ff b5 74 fd ff
	ff		 push	 DWORD PTR $T41[ebp]
  00c29	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PBV1@@Z ; std::_Const_cast<CTimeEvent<float> const >
  00c2e	59		 pop	 ecx
  00c2f	89 85 68 fd ff
	ff		 mov	 DWORD PTR $T38[ebp], eax

; 65   :         return _Ptr;

  00c35	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR _result$79[ebp]
  00c3b	89 85 70 fd ff
	ff		 mov	 DWORD PTR $T40[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  00c41	ff b5 70 fd ff
	ff		 push	 DWORD PTR $T40[ebp]
  00c47	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PBV1@@Z ; std::_Const_cast<CTimeEvent<float> const >
  00c4c	59		 pop	 ecx
  00c4d	89 85 64 fd ff
	ff		 mov	 DWORD PTR $T37[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h

; 262  : 		float Head = (result.second->m_fTime - fElapsedTime) / (result.second->m_fTime - result.first->m_fTime);

  00c53	8b 85 6c fd ff
	ff		 mov	 eax, DWORD PTR $T39[ebp]
  00c59	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00c5d	f3 0f 5c 85 5c
	fe ff ff	 subss	 xmm0, DWORD PTR _fElapsedTime$[ebp]
  00c65	8b 85 68 fd ff
	ff		 mov	 eax, DWORD PTR $T38[ebp]
  00c6b	8b 8d 64 fd ff
	ff		 mov	 ecx, DWORD PTR $T37[ebp]
  00c71	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  00c75	f3 0f 5c 09	 subss	 xmm1, DWORD PTR [ecx]
  00c79	f3 0f 5e c1	 divss	 xmm0, xmm1
  00c7d	f3 0f 11 85 4c
	fd ff ff	 movss	 DWORD PTR _Head$31[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  00c85	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR _result$79[ebp]
  00c8b	89 85 60 fd ff
	ff		 mov	 DWORD PTR $T36[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  00c91	ff b5 60 fd ff
	ff		 push	 DWORD PTR $T36[ebp]
  00c97	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PBV1@@Z ; std::_Const_cast<CTimeEvent<float> const >
  00c9c	59		 pop	 ecx
  00c9d	89 85 54 fd ff
	ff		 mov	 DWORD PTR $T33[ebp], eax

; 65   :         return _Ptr;

  00ca3	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR _result$79[ebp+4]
  00ca9	89 85 5c fd ff
	ff		 mov	 DWORD PTR $T35[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  00caf	ff b5 5c fd ff
	ff		 push	 DWORD PTR $T35[ebp]
  00cb5	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PBV1@@Z ; std::_Const_cast<CTimeEvent<float> const >
  00cba	59		 pop	 ecx
  00cbb	89 85 50 fd ff
	ff		 mov	 DWORD PTR $T32[ebp], eax

; 65   :         return _Ptr;

  00cc1	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR _result$79[ebp+4]
  00cc7	89 85 58 fd ff
	ff		 mov	 DWORD PTR $T34[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  00ccd	ff b5 58 fd ff
	ff		 push	 DWORD PTR $T34[ebp]
  00cd3	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PBV1@@Z ; std::_Const_cast<CTimeEvent<float> const >
  00cd8	59		 pop	 ecx
  00cd9	89 85 48 fd ff
	ff		 mov	 DWORD PTR $T30[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\Type.h

; 263  : 		*pReturnValue = T((result.first->m_Value-result.second->m_Value)*Head+(result.second->m_Value));

  00cdf	8b 85 54 fd ff
	ff		 mov	 eax, DWORD PTR $T33[ebp]
  00ce5	8b 8d 50 fd ff
	ff		 mov	 ecx, DWORD PTR $T32[ebp]
  00ceb	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00cf0	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00cf5	f3 0f 59 85 4c
	fd ff ff	 mulss	 xmm0, DWORD PTR _Head$31[ebp]
  00cfd	8b 85 48 fd ff
	ff		 mov	 eax, DWORD PTR $T30[ebp]
  00d03	f3 0f 58 40 04	 addss	 xmm0, DWORD PTR [eax+4]
  00d08	f3 0f 11 85 6c
	fe ff ff	 movss	 DWORD PTR _fAlpha$81[ebp], xmm0
$LN81@OnRender:
$LN75@OnRender:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 157  : 		CEffectMesh::TEffectMeshData * pMeshData = pEffectMesh->GetMeshDataPointer(i);

  00d10	ff b5 7c fe ff
	ff		 push	 DWORD PTR _i$87[ebp]
  00d16	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR _pEffectMesh$[ebp]
  00d1c	e8 00 00 00 00	 call	 ?GetMeshDataPointer@CEffectMesh@@QAEPAUSEffectMeshData@1@K@Z ; CEffectMesh::GetMeshDataPointer
  00d21	89 85 44 fd ff
	ff		 mov	 DWORD PTR _pMeshData$29[ebp], eax

; 158  : 
; 159  : 		assert(m_MeshFrameController.GetCurrentFrame() < pMeshData->EffectFrameDataVector.size());
; 160  : 		CEffectMesh::TEffectFrameData & rFrameData = pMeshData->EffectFrameDataVector[m_MeshFrameController.GetCurrentFrame()];

  00d27	8b 8d 80 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00d2d	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00d30	e8 00 00 00 00	 call	 ?GetCurrentFrame@CFrameController@@QAEEXZ ; CFrameController::GetCurrentFrame
  00d35	0f b6 c0	 movzx	 eax, al
  00d38	89 85 40 fd ff
	ff		 mov	 DWORD PTR __Pos$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00d3e	8b 85 44 fd ff
	ff		 mov	 eax, DWORD PTR _pMeshData$29[ebp]
  00d44	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  00d49	89 85 00 fd ff
	ff		 mov	 DWORD PTR __My_data$13[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00d4f	8b 85 40 fd ff
	ff		 mov	 eax, DWORD PTR __Pos$[ebp]
  00d55	c1 e0 05	 shl	 eax, 5
  00d58	8b 8d 00 fd ff
	ff		 mov	 ecx, DWORD PTR __My_data$13[ebp]
  00d5e	03 01		 add	 eax, DWORD PTR [ecx]
  00d60	89 85 40 fe ff
	ff		 mov	 DWORD PTR _rFrameData$76[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 162  : 		DWORD dwcurTextureFrame = rTextureFrameController.GetCurrentFrame();

  00d66	8b 8d 38 fe ff
	ff		 mov	 ecx, DWORD PTR _rTextureFrameController$74[ebp]
  00d6c	e8 00 00 00 00	 call	 ?GetCurrentFrame@CFrameController@@QAEEXZ ; CFrameController::GetCurrentFrame
  00d71	0f b6 c0	 movzx	 eax, al
  00d74	89 85 30 fe ff
	ff		 mov	 DWORD PTR _dwcurTextureFrame$72[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00d7a	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00d80	83 c0 50	 add	 eax, 80			; 00000050H
  00d83	89 85 38 fd ff
	ff		 mov	 DWORD PTR __My_data$27[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00d89	6b 85 7c fe ff
	ff 30		 imul	 eax, DWORD PTR _i$87[ebp], 48
  00d90	8b 8d 38 fd ff
	ff		 mov	 ecx, DWORD PTR __My_data$27[ebp]
  00d96	03 01		 add	 eax, DWORD PTR [ecx]
  00d98	89 85 34 fd ff
	ff		 mov	 DWORD PTR $T26[ebp], eax

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00d9e	8b 85 34 fd ff
	ff		 mov	 eax, DWORD PTR $T26[ebp]
  00da4	83 c0 24	 add	 eax, 36			; 00000024H
  00da7	89 85 34 fe ff
	ff		 mov	 DWORD PTR __My_data$73[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00dad	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$73[ebp]
  00db3	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$73[ebp]
  00db9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00dbc	2b 01		 sub	 eax, DWORD PTR [ecx]
  00dbe	c1 f8 02	 sar	 eax, 2
  00dc1	89 85 30 fd ff
	ff		 mov	 DWORD PTR $T25[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 163  : 		if (dwcurTextureFrame < m_TextureInstanceVector[i].TextureInstanceVector.size())

  00dc7	8b 85 30 fe ff
	ff		 mov	 eax, DWORD PTR _dwcurTextureFrame$72[ebp]
  00dcd	3b 85 30 fd ff
	ff		 cmp	 eax, DWORD PTR $T25[ebp]
  00dd3	0f 83 83 00 00
	00		 jae	 $LN17@OnRender
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00dd9	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00ddf	83 c0 50	 add	 eax, 80			; 00000050H
  00de2	89 85 2c fd ff
	ff		 mov	 DWORD PTR __My_data$24[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00de8	6b 85 7c fe ff
	ff 30		 imul	 eax, DWORD PTR _i$87[ebp], 48
  00def	8b 8d 2c fd ff
	ff		 mov	 ecx, DWORD PTR __My_data$24[ebp]
  00df5	03 01		 add	 eax, DWORD PTR [ecx]
  00df7	89 85 28 fd ff
	ff		 mov	 DWORD PTR $T23[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00dfd	8b 85 28 fd ff
	ff		 mov	 eax, DWORD PTR $T23[ebp]
  00e03	83 c0 24	 add	 eax, 36			; 00000024H
  00e06	89 85 24 fd ff
	ff		 mov	 DWORD PTR __My_data$22[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00e0c	8b 85 24 fd ff
	ff		 mov	 eax, DWORD PTR __My_data$22[ebp]
  00e12	8b 00		 mov	 eax, DWORD PTR [eax]
  00e14	8b 8d 30 fe ff
	ff		 mov	 ecx, DWORD PTR _dwcurTextureFrame$72[ebp]
  00e1a	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00e1d	89 85 20 fd ff
	ff		 mov	 DWORD PTR $T21[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 165  : 			CGraphicImageInstance * pImageInstance = m_TextureInstanceVector[i].TextureInstanceVector[dwcurTextureFrame];

  00e23	8b 85 20 fd ff
	ff		 mov	 eax, DWORD PTR $T21[ebp]
  00e29	8b 00		 mov	 eax, DWORD PTR [eax]
  00e2b	89 85 1c fd ff
	ff		 mov	 DWORD PTR _pImageInstance$20[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00e31	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00e36	89 85 18 fd ff
	ff		 mov	 DWORD PTR $T19[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 166  : 			STATEMANAGER.SetTexture(0, pImageInstance->GetTexturePointer()->GetD3DTexture());

  00e3c	8b 8d 1c fd ff
	ff		 mov	 ecx, DWORD PTR _pImageInstance$20[ebp]
  00e42	e8 00 00 00 00	 call	 ?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTexturePointer
  00e47	8b c8		 mov	 ecx, eax
  00e49	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  00e4e	50		 push	 eax
  00e4f	6a 00		 push	 0
  00e51	8b 8d 18 fd ff
	ff		 mov	 ecx, DWORD PTR $T19[ebp]
  00e57	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture
$LN17@OnRender:

; 167  : 		}
; 168  : 
; 169  : 		Color.a = fAlpha * rFrameData.fVisibility;

  00e5c	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR _rFrameData$76[ebp]
  00e62	f3 0f 10 85 6c
	fe ff ff	 movss	 xmm0, DWORD PTR _fAlpha$81[ebp]
  00e6a	f3 0f 59 40 04	 mulss	 xmm0, DWORD PTR [eax+4]
  00e6f	f3 0f 11 85 58
	fe ff ff	 movss	 DWORD PTR _Color$78[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00e77	f3 0f 10 85 4c
	fe ff ff	 movss	 xmm0, DWORD PTR _Color$78[ebp]
  00e7f	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00e86	72 0c		 jb	 SHORT $LN234@OnRender
  00e88	c7 85 28 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1189[ebp], 255 ; 000000ffH
  00e92	eb 44		 jmp	 SHORT $LN235@OnRender
$LN234@OnRender:
  00e94	0f 57 c0	 xorps	 xmm0, xmm0
  00e97	0f 2f 85 4c fe
	ff ff		 comiss	 xmm0, DWORD PTR _Color$78[ebp]
  00e9e	72 09		 jb	 SHORT $LN232@OnRender
  00ea0	83 a5 2c fe ff
	ff 00		 and	 DWORD PTR tv1188[ebp], 0
  00ea7	eb 23		 jmp	 SHORT $LN233@OnRender
$LN232@OnRender:
  00ea9	f3 0f 10 85 4c
	fe ff ff	 movss	 xmm0, DWORD PTR _Color$78[ebp]
  00eb1	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00eb9	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00ec1	e8 00 00 00 00	 call	 __ftoui3
  00ec6	89 85 2c fe ff
	ff		 mov	 DWORD PTR tv1188[ebp], eax
$LN233@OnRender:
  00ecc	8b 85 2c fe ff
	ff		 mov	 eax, DWORD PTR tv1188[ebp]
  00ed2	89 85 28 fe ff
	ff		 mov	 DWORD PTR tv1189[ebp], eax
$LN235@OnRender:
  00ed8	8b 85 28 fe ff
	ff		 mov	 eax, DWORD PTR tv1189[ebp]
  00ede	89 85 10 fd ff
	ff		 mov	 DWORD PTR _dwR$17[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  00ee4	f3 0f 10 85 50
	fe ff ff	 movss	 xmm0, DWORD PTR _Color$78[ebp+4]
  00eec	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00ef3	72 0c		 jb	 SHORT $LN238@OnRender
  00ef5	c7 85 20 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1200[ebp], 255 ; 000000ffH
  00eff	eb 44		 jmp	 SHORT $LN239@OnRender
$LN238@OnRender:
  00f01	0f 57 c0	 xorps	 xmm0, xmm0
  00f04	0f 2f 85 50 fe
	ff ff		 comiss	 xmm0, DWORD PTR _Color$78[ebp+4]
  00f0b	72 09		 jb	 SHORT $LN236@OnRender
  00f0d	83 a5 24 fe ff
	ff 00		 and	 DWORD PTR tv1199[ebp], 0
  00f14	eb 23		 jmp	 SHORT $LN237@OnRender
$LN236@OnRender:
  00f16	f3 0f 10 85 50
	fe ff ff	 movss	 xmm0, DWORD PTR _Color$78[ebp+4]
  00f1e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00f26	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00f2e	e8 00 00 00 00	 call	 __ftoui3
  00f33	89 85 24 fe ff
	ff		 mov	 DWORD PTR tv1199[ebp], eax
$LN237@OnRender:
  00f39	8b 85 24 fe ff
	ff		 mov	 eax, DWORD PTR tv1199[ebp]
  00f3f	89 85 20 fe ff
	ff		 mov	 DWORD PTR tv1200[ebp], eax
$LN239@OnRender:
  00f45	8b 85 20 fe ff
	ff		 mov	 eax, DWORD PTR tv1200[ebp]
  00f4b	89 85 14 fd ff
	ff		 mov	 DWORD PTR _dwG$18[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  00f51	f3 0f 10 85 54
	fe ff ff	 movss	 xmm0, DWORD PTR _Color$78[ebp+8]
  00f59	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00f60	72 0c		 jb	 SHORT $LN242@OnRender
  00f62	c7 85 18 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1211[ebp], 255 ; 000000ffH
  00f6c	eb 44		 jmp	 SHORT $LN243@OnRender
$LN242@OnRender:
  00f6e	0f 57 c0	 xorps	 xmm0, xmm0
  00f71	0f 2f 85 54 fe
	ff ff		 comiss	 xmm0, DWORD PTR _Color$78[ebp+8]
  00f78	72 09		 jb	 SHORT $LN240@OnRender
  00f7a	83 a5 1c fe ff
	ff 00		 and	 DWORD PTR tv1210[ebp], 0
  00f81	eb 23		 jmp	 SHORT $LN241@OnRender
$LN240@OnRender:
  00f83	f3 0f 10 85 54
	fe ff ff	 movss	 xmm0, DWORD PTR _Color$78[ebp+8]
  00f8b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00f93	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00f9b	e8 00 00 00 00	 call	 __ftoui3
  00fa0	89 85 1c fe ff
	ff		 mov	 DWORD PTR tv1210[ebp], eax
$LN241@OnRender:
  00fa6	8b 85 1c fe ff
	ff		 mov	 eax, DWORD PTR tv1210[ebp]
  00fac	89 85 18 fe ff
	ff		 mov	 DWORD PTR tv1211[ebp], eax
$LN243@OnRender:
  00fb2	8b 85 18 fe ff
	ff		 mov	 eax, DWORD PTR tv1211[ebp]
  00fb8	89 85 08 fd ff
	ff		 mov	 DWORD PTR _dwB$15[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  00fbe	f3 0f 10 85 58
	fe ff ff	 movss	 xmm0, DWORD PTR _Color$78[ebp+12]
  00fc6	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00fcd	72 0c		 jb	 SHORT $LN246@OnRender
  00fcf	c7 85 10 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1254[ebp], 255 ; 000000ffH
  00fd9	eb 44		 jmp	 SHORT $LN247@OnRender
$LN246@OnRender:
  00fdb	0f 57 c0	 xorps	 xmm0, xmm0
  00fde	0f 2f 85 58 fe
	ff ff		 comiss	 xmm0, DWORD PTR _Color$78[ebp+12]
  00fe5	72 09		 jb	 SHORT $LN244@OnRender
  00fe7	83 a5 14 fe ff
	ff 00		 and	 DWORD PTR tv1253[ebp], 0
  00fee	eb 23		 jmp	 SHORT $LN245@OnRender
$LN244@OnRender:
  00ff0	f3 0f 10 85 58
	fe ff ff	 movss	 xmm0, DWORD PTR _Color$78[ebp+12]
  00ff8	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  01000	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  01008	e8 00 00 00 00	 call	 __ftoui3
  0100d	89 85 14 fe ff
	ff		 mov	 DWORD PTR tv1253[ebp], eax
$LN245@OnRender:
  01013	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR tv1253[ebp]
  01019	89 85 10 fe ff
	ff		 mov	 DWORD PTR tv1254[ebp], eax
$LN247@OnRender:
  0101f	8b 85 10 fe ff
	ff		 mov	 eax, DWORD PTR tv1254[ebp]
  01025	89 85 0c fd ff
	ff		 mov	 DWORD PTR _dwA$16[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  0102b	8b 85 14 fd ff
	ff		 mov	 eax, DWORD PTR _dwG$18[ebp]
  01031	c1 e0 08	 shl	 eax, 8
  01034	8b 8d 10 fd ff
	ff		 mov	 ecx, DWORD PTR _dwR$17[ebp]
  0103a	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0103d	8b 95 0c fd ff
	ff		 mov	 edx, DWORD PTR _dwA$16[ebp]
  01043	c1 e2 18	 shl	 edx, 24			; 00000018H
  01046	0b d1		 or	 edx, ecx
  01048	0b d0		 or	 edx, eax
  0104a	0b 95 08 fd ff
	ff		 or	 edx, DWORD PTR _dwB$15[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 170  : 		STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, DWORD(Color));

  01050	52		 push	 edx
  01051	6a 3c		 push	 60			; 0000003cH
  01053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  01059	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 171  : 		STATEMANAGER.SetVertexShader(D3DFVF_XYZ | D3DFVF_TEX1);

  0105e	68 02 01 00 00	 push	 258			; 00000102H
  01063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  01069	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0106e	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR _rFrameData$76[ebp]
  01074	83 c0 14	 add	 eax, 20			; 00000014H
  01077	89 85 04 fd ff
	ff		 mov	 DWORD PTR __My_data$14[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  0107d	33 c0		 xor	 eax, eax
  0107f	6b c0 14	 imul	 eax, eax, 20
  01082	8b 8d 04 fd ff
	ff		 mov	 ecx, DWORD PTR __My_data$14[ebp]
  01088	03 01		 add	 eax, DWORD PTR [ecx]
  0108a	89 85 cc fc ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 172  : 		STATEMANAGER.DrawPrimitiveUP(D3DPT_TRIANGLELIST,

  01090	6a 14		 push	 20			; 00000014H
  01092	ff b5 cc fc ff
	ff		 push	 DWORD PTR $T3[ebp]
  01098	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR _rFrameData$76[ebp]
  0109e	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  010a1	33 d2		 xor	 edx, edx
  010a3	6a 03		 push	 3
  010a5	59		 pop	 ecx
  010a6	f7 f1		 div	 ecx
  010a8	50		 push	 eax
  010a9	6a 04		 push	 4
  010ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  010b1	e8 00 00 00 00	 call	 ?DrawPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IPBXI@Z ; CStateManager::DrawPrimitiveUP

; 173  : 									 rFrameData.dwIndexCount/3,
; 174  : 									 &rFrameData.PDTVertexVector[0],
; 175  : 									 sizeof(TPTVertex));
; 176  : 		// Render //
; 177  : 	}

  010b6	e9 8e ef ff ff	 jmp	 $LN2@OnRender
$LN3@OnRender:
$LN1@OnRender:

; 178  : }

  010bb	5f		 pop	 edi
  010bc	5e		 pop	 esi
  010bd	8b 4d 74	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  010c0	33 cd		 xor	 ecx, ebp
  010c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  010c7	83 c5 78	 add	 ebp, 120		; 00000078H
  010ca	c9		 leave
  010cb	c3		 ret	 0
?OnRender@CEffectMeshInstance@@MAEXXZ ENDP		; CEffectMeshInstance::OnRender
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
;	COMDAT ?OnUpdate@CEffectMeshInstance@@MAE_NM@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
__My_data$2 = -32					; size = 4
$T3 = -28						; size = 4
_iCurrentFrame$4 = -24					; size = 4
__My_data$5 = -20					; size = 4
$T6 = -16						; size = 4
__My_data$7 = -12					; size = 4
_j$8 = -8						; size = 4
_this$ = -4						; size = 4
_fElapsedTime$ = 8					; size = 4
?OnUpdate@CEffectMeshInstance@@MAE_NM@Z PROC		; CEffectMeshInstance::OnUpdate, COMDAT
; _this$ = ecx

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 45   : 	if (!isActive())

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?isActive@CEffectMeshInstance@@IAEHXZ ; CEffectMeshInstance::isActive
  00011	85 c0		 test	 eax, eax
  00013	75 07		 jne	 SHORT $LN5@OnUpdate

; 46   : 		return false;

  00015	32 c0		 xor	 al, al
  00017	e9 bd 00 00 00	 jmp	 $LN1@OnUpdate
$LN5@OnUpdate:

; 47   : 
; 48   : 	if (m_MeshFrameController.isActive())

  0001c	6a 00		 push	 0
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00024	e8 00 00 00 00	 call	 ?isActive@CFrameController@@QAEHK@Z ; CFrameController::isActive
  00029	85 c0		 test	 eax, eax
  0002b	74 16		 je	 SHORT $LN6@OnUpdate

; 49   : 		m_MeshFrameController.Update(fElapsedTime);

  0002d	51		 push	 ecx
  0002e	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fElapsedTime$[ebp]
  00033	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0003e	e8 00 00 00 00	 call	 ?Update@CFrameController@@QAEXM@Z ; CFrameController::Update
$LN6@OnUpdate:

; 51   : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  00043	83 65 f8 00	 and	 DWORD PTR _j$8[ebp], 0
  00047	eb 07		 jmp	 SHORT $LN4@OnUpdate
$LN2@OnUpdate:
  00049	8b 45 f8	 mov	 eax, DWORD PTR _j$8[ebp]
  0004c	40		 inc	 eax
  0004d	89 45 f8	 mov	 DWORD PTR _j$8[ebp], eax
$LN4@OnUpdate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	83 c0 50	 add	 eax, 80			; 00000050H
  00056	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00059	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$7[ebp]
  0005f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00062	2b 01		 sub	 eax, DWORD PTR [ecx]
  00064	99		 cdq
  00065	6a 30		 push	 48			; 00000030H
  00067	59		 pop	 ecx
  00068	f7 f9		 idiv	 ecx
  0006a	89 45 f0	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 51   : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  0006d	8b 45 f8	 mov	 eax, DWORD PTR _j$8[ebp]
  00070	3b 45 f0	 cmp	 eax, DWORD PTR $T6[ebp]
  00073	73 62		 jae	 SHORT $LN3@OnUpdate

; 52   : 	{
; 53   : 		int iCurrentFrame = m_MeshFrameController.GetCurrentFrame();

  00075	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0007b	e8 00 00 00 00	 call	 ?GetCurrentFrame@CFrameController@@QAEEXZ ; CFrameController::GetCurrentFrame
  00080	0f b6 c0	 movzx	 eax, al
  00083	89 45 e8	 mov	 DWORD PTR _iCurrentFrame$4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00086	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00089	83 c0 50	 add	 eax, 80			; 00000050H
  0008c	89 45 ec	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  0008f	6b 45 f8 30	 imul	 eax, DWORD PTR _j$8[ebp], 48
  00093	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$5[ebp]
  00096	03 01		 add	 eax, DWORD PTR [ecx]
  00098	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 54   : 		if (m_TextureInstanceVector[j].TextureFrameController.isActive(iCurrentFrame))

  0009b	ff 75 e8	 push	 DWORD PTR _iCurrentFrame$4[ebp]
  0009e	8b 4d e4	 mov	 ecx, DWORD PTR $T3[ebp]
  000a1	e8 00 00 00 00	 call	 ?isActive@CFrameController@@QAEHK@Z ; CFrameController::isActive
  000a6	85 c0		 test	 eax, eax
  000a8	74 28		 je	 SHORT $LN7@OnUpdate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  000aa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	83 c0 50	 add	 eax, 80			; 00000050H
  000b0	89 45 e0	 mov	 DWORD PTR __My_data$2[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  000b3	6b 45 f8 30	 imul	 eax, DWORD PTR _j$8[ebp], 48
  000b7	8b 4d e0	 mov	 ecx, DWORD PTR __My_data$2[ebp]
  000ba	03 01		 add	 eax, DWORD PTR [ecx]
  000bc	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 55   : 			m_TextureInstanceVector[j].TextureFrameController.Update(fElapsedTime);

  000bf	51		 push	 ecx
  000c0	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fElapsedTime$[ebp]
  000c5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ca	8b 4d dc	 mov	 ecx, DWORD PTR $T1[ebp]
  000cd	e8 00 00 00 00	 call	 ?Update@CFrameController@@QAEXM@Z ; CFrameController::Update
$LN7@OnUpdate:

; 56   : 	}

  000d2	e9 72 ff ff ff	 jmp	 $LN2@OnUpdate
$LN3@OnUpdate:

; 57   : 
; 58   : 	return true;

  000d7	b0 01		 mov	 al, 1
$LN1@OnUpdate:

; 59   : }

  000d9	c9		 leave
  000da	c2 04 00	 ret	 4
?OnUpdate@CEffectMeshInstance@@MAE_NM@Z ENDP		; CEffectMeshInstance::OnUpdate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
;	COMDAT ?OnDestroy@CEffectMeshInstance@@MAEXXZ
_TEXT	SEGMENT
$T1 = -84						; size = 4
$T2 = -80						; size = 4
__ULast$3 = -76						; size = 4
$T4 = -72						; size = 4
$T5 = -68						; size = 4
__Ptr$6 = -64						; size = 4
__Last$ = -60						; size = 4
$T7 = -56						; size = 4
$T8 = -52						; size = 4
__Ptr$9 = -48						; size = 4
__First$ = -44						; size = 4
$T10 = -40						; size = 4
$T11 = -36						; size = 4
$T12 = -32						; size = 4
___param0$ = -28					; size = 4
$T13 = -24						; size = 4
___param0$ = -20					; size = 4
__My_data$14 = -16					; size = 4
__My_data$15 = -12					; size = 4
_this$ = -8						; size = 4
__UFirst$16 = -4					; size = 4
?OnDestroy@CEffectMeshInstance@@MAEXXZ PROC		; CEffectMeshInstance::OnDestroy, COMDAT
; _this$ = ecx

; 257  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 50	 add	 eax, 80			; 00000050H
  0000f	89 45 f4	 mov	 DWORD PTR __My_data$15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f4	 mov	 eax, DWORD PTR __My_data$15[ebp]
  00015	89 45 b0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f4	 mov	 eax, DWORD PTR __My_data$15[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 ec	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 ec	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 e8	 mov	 DWORD PTR $T13[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 e8	 lea	 eax, DWORD PTR $T13[ebp]
  0002a	89 45 dc	 mov	 DWORD PTR $T11[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 50	 add	 eax, 80			; 00000050H
  00033	89 45 f0	 mov	 DWORD PTR __My_data$14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f0	 mov	 eax, DWORD PTR __My_data$14[ebp]
  00039	89 45 ac	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f0	 mov	 eax, DWORD PTR __My_data$14[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e0	 mov	 DWORD PTR $T12[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e0	 lea	 eax, DWORD PTR $T12[ebp]
  0004d	89 45 d8	 mov	 DWORD PTR $T10[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 258  : 	for_each(m_TextureInstanceVector.begin(), m_TextureInstanceVector.end(), CEffectMeshInstance_DeleteTextureInstance);

  00050	8b 45 dc	 mov	 eax, DWORD PTR $T11[ebp]
  00053	8b 00		 mov	 eax, DWORD PTR [eax]
  00055	89 45 c4	 mov	 DWORD PTR __Last$[ebp], eax
  00058	8b 45 d8	 mov	 eax, DWORD PTR $T10[ebp]
  0005b	8b 00		 mov	 eax, DWORD PTR [eax]
  0005d	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00060	8b 45 d4	 mov	 eax, DWORD PTR __First$[ebp]
  00063	89 45 d0	 mov	 DWORD PTR __Ptr$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00066	8b 45 d0	 mov	 eax, DWORD PTR __Ptr$9[ebp]
  00069	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0006c	8b 45 cc	 mov	 eax, DWORD PTR $T8[ebp]
  0006f	89 45 c8	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00072	8b 45 c8	 mov	 eax, DWORD PTR $T7[ebp]
  00075	89 45 fc	 mov	 DWORD PTR __UFirst$16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00078	8b 45 c4	 mov	 eax, DWORD PTR __Last$[ebp]
  0007b	89 45 c0	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0007e	8b 45 c0	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  00081	89 45 bc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00084	8b 45 bc	 mov	 eax, DWORD PTR $T5[ebp]
  00087	89 45 b8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  0008a	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  0008d	89 45 b4	 mov	 DWORD PTR __ULast$3[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00090	eb 09		 jmp	 SHORT $LN36@OnDestroy
$LN34@OnDestroy:
  00092	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$16[ebp]
  00095	83 c0 30	 add	 eax, 48			; 00000030H
  00098	89 45 fc	 mov	 DWORD PTR __UFirst$16[ebp], eax
$LN36@OnDestroy:
  0009b	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$16[ebp]
  0009e	3b 45 b4	 cmp	 eax, DWORD PTR __ULast$3[ebp]
  000a1	74 0b		 je	 SHORT $LN33@OnDestroy

; 308  :         _Func(*_UFirst);

  000a3	ff 75 fc	 push	 DWORD PTR __UFirst$16[ebp]
  000a6	e8 00 00 00 00	 call	 ?CEffectMeshInstance_DeleteTextureInstance@@YAXAAUSTextureInstance@CEffectMeshInstance@@@Z ; CEffectMeshInstance_DeleteTextureInstance
  000ab	59		 pop	 ecx

; 309  :     }

  000ac	eb e4		 jmp	 SHORT $LN34@OnDestroy
$LN33@OnDestroy:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 259  : 	m_TextureInstanceVector.clear();

  000ae	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	83 c1 50	 add	 ecx, 80			; 00000050H
  000b4	e8 00 00 00 00	 call	 ?clear@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXXZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::clear

; 260  : 	m_roMesh.SetPointer(NULL);

  000b9	6a 00		 push	 0
  000bb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	83 c1 5c	 add	 ecx, 92			; 0000005cH
  000c1	e8 00 00 00 00	 call	 ?SetPointer@?$CRef@VCEffectMesh@@@@QAEXPAVCReferenceObject@@@Z ; CRef<CEffectMesh>::SetPointer

; 261  : }

  000c6	c9		 leave
  000c7	c3		 ret	 0
?OnDestroy@CEffectMeshInstance@@MAEXXZ ENDP		; CEffectMeshInstance::OnDestroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
;	COMDAT ?OnInitialize@CEffectMeshInstance@@MAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnInitialize@CEffectMeshInstance@@MAEXXZ PROC		; CEffectMeshInstance::OnInitialize, COMDAT
; _this$ = ecx

; 253  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 254  : }

  00007	c9		 leave
  00008	c3		 ret	 0
?OnInitialize@CEffectMeshInstance@@MAEXXZ ENDP		; CEffectMeshInstance::OnInitialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
;	COMDAT ?OnSetDataPointer@CEffectMeshInstance@@MAEXPAVCEffectElementBase@@@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
_pImage$3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
$T6 = -24						; size = 4
$T7 = -20						; size = 4
___param0$ = -16					; size = 4
___param0$ = -12					; size = 4
$T8 = -8						; size = 4
$T9 = -4						; size = 4
__My_data$10 = 0					; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
__My_data$13 = 12					; size = 4
$T14 = 16						; size = 4
__Newsize$ = 20						; size = 4
$T15 = 24						; size = 4
$T16 = 28						; size = 4
_c_szMeshFileName$ = 32					; size = 4
_pImageInstance$17 = 36					; size = 4
tv367 = 40						; size = 4
tv381 = 44						; size = 4
__My_data$18 = 48					; size = 4
__My_data$19 = 52					; size = 4
__My_data$20 = 56					; size = 4
__My_data$21 = 60					; size = 4
_pTextureVector$22 = 64					; size = 4
_pkEftMesh$23 = 68					; size = 4
__My_data$24 = 72					; size = 4
_rImageInstanceVector$25 = 76				; size = 4
_pMeshData$26 = 80					; size = 4
$T27 = 87						; size = 1
_itor$28 = 88						; size = 4
_rTextureVector$29 = 92					; size = 4
_rFrameController$30 = 96				; size = 4
_pMesh$ = 100						; size = 4
_j$31 = 104						; size = 4
$T32 = 110						; size = 1
$T33 = 111						; size = 1
_this$ = 112						; size = 4
_pElement$ = 124					; size = 4
?OnSetDataPointer@CEffectMeshInstance@@MAEXPAVCEffectElementBase@@@Z PROC ; CEffectMeshInstance::OnSetDataPointer, COMDAT
; _this$ = ecx

; 181  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 8c	 lea	 ebp, DWORD PTR [esp-116]
  00005	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  0000b	89 4d 70	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 	CEffectMeshScript * pMesh = (CEffectMeshScript *)pElement;

  0000e	8b 45 7c	 mov	 eax, DWORD PTR _pElement$[ebp]
  00011	89 45 64	 mov	 DWORD PTR _pMesh$[ebp], eax

; 183  : 	m_pMeshScript = pMesh;

  00014	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 4d 64	 mov	 ecx, DWORD PTR _pMesh$[ebp]
  0001a	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 184  : 
; 185  : 	const char * c_szMeshFileName = pMesh->GetMeshFileName();

  0001d	8b 4d 64	 mov	 ecx, DWORD PTR _pMesh$[ebp]
  00020	e8 00 00 00 00	 call	 ?GetMeshFileName@CEffectMeshScript@@QAEPBDXZ ; CEffectMeshScript::GetMeshFileName
  00025	89 45 20	 mov	 DWORD PTR _c_szMeshFileName$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  0002d	89 45 1c	 mov	 DWORD PTR $T16[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 187  : 	m_pEffectMesh = (CEffectMesh *) CResourceManager::Instance().GetResourcePointer(c_szMeshFileName);

  00030	ff 75 20	 push	 DWORD PTR _c_szMeshFileName$[ebp]
  00033	8b 4d 1c	 mov	 ecx, DWORD PTR $T16[ebp]
  00036	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  0003b	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 188  : 
; 189  : 	if (!m_pEffectMesh)

  00041	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00044	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00048	75 05		 jne	 SHORT $LN8@OnSetDataP

; 190  : 		return;

  0004a	e9 b5 02 00 00	 jmp	 $LN1@OnSetDataP
$LN8@OnSetDataP:

; 191  : 
; 192  : 	m_roMesh.SetPointer(m_pEffectMesh);

  0004f	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00052	ff 70 28	 push	 DWORD PTR [eax+40]
  00055	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	83 c1 5c	 add	 ecx, 92			; 0000005cH
  0005b	e8 00 00 00 00	 call	 ?SetPointer@?$CRef@VCEffectMesh@@@@QAEXPAVCReferenceObject@@@Z ; CRef<CEffectMesh>::SetPointer

; 193  : 
; 194  : 	m_MeshFrameController.Clear();

  00060	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00066	e8 00 00 00 00	 call	 ?Clear@CFrameController@@QAEXXZ ; CFrameController::Clear
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\Ref.h

; 80   : 			return static_cast<T*>(m_pObject);

  0006b	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
  00071	89 45 18	 mov	 DWORD PTR $T15[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 195  : 	m_MeshFrameController.SetMaxFrame(m_roMesh.GetPointer()->GetFrameCount());

  00074	8b 4d 18	 mov	 ecx, DWORD PTR $T15[ebp]
  00077	e8 00 00 00 00	 call	 ?GetFrameCount@CEffectMesh@@QAEKXZ ; CEffectMesh::GetFrameCount
  0007c	50		 push	 eax
  0007d	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00083	e8 00 00 00 00	 call	 ?SetMaxFrame@CFrameController@@QAEXK@Z ; CFrameController::SetMaxFrame

; 196  : 	m_MeshFrameController.SetFrameTime(pMesh->GetMeshAnimationFrameDelay());

  00088	8b 4d 64	 mov	 ecx, DWORD PTR _pMesh$[ebp]
  0008b	e8 00 00 00 00	 call	 ?GetMeshAnimationFrameDelay@CEffectMeshScript@@QAEMXZ ; CEffectMeshScript::GetMeshAnimationFrameDelay
  00090	51		 push	 ecx
  00091	d9 1c 24	 fstp	 DWORD PTR [esp]
  00094	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0009a	e8 00 00 00 00	 call	 ?SetFrameTime@CFrameController@@QAEXM@Z ; CFrameController::SetFrameTime

; 197  : 	m_MeshFrameController.SetLoopFlag(pMesh->isMeshAnimationLoop());

  0009f	8b 4d 64	 mov	 ecx, DWORD PTR _pMesh$[ebp]
  000a2	e8 00 00 00 00	 call	 ?isMeshAnimationLoop@CEffectMeshScript@@QAEHXZ ; CEffectMeshScript::isMeshAnimationLoop
  000a7	50		 push	 eax
  000a8	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	83 c1 2c	 add	 ecx, 44			; 0000002cH
  000ae	e8 00 00 00 00	 call	 ?SetLoopFlag@CFrameController@@QAEXH@Z ; CFrameController::SetLoopFlag

; 198  : 	m_MeshFrameController.SetLoopCount(pMesh->GetMeshAnimationLoopCount());

  000b3	8b 4d 64	 mov	 ecx, DWORD PTR _pMesh$[ebp]
  000b6	e8 00 00 00 00	 call	 ?GetMeshAnimationLoopCount@CEffectMeshScript@@QAEHXZ ; CEffectMeshScript::GetMeshAnimationLoopCount
  000bb	50		 push	 eax
  000bc	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  000bf	83 c1 2c	 add	 ecx, 44			; 0000002cH
  000c2	e8 00 00 00 00	 call	 ?SetLoopCount@CFrameController@@QAEXH@Z ; CFrameController::SetLoopCount

; 199  : 	m_MeshFrameController.SetStartFrame(0);

  000c7	6a 00		 push	 0
  000c9	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	83 c1 2c	 add	 ecx, 44			; 0000002cH
  000cf	e8 00 00 00 00	 call	 ?SetStartFrame@CFrameController@@QAEXK@Z ; CFrameController::SetStartFrame

; 200  : 
; 201  : 	m_TextureInstanceVector.clear();

  000d4	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	83 c1 50	 add	 ecx, 80			; 00000050H
  000da	e8 00 00 00 00	 call	 ?clear@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXXZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::clear

; 202  : 	m_TextureInstanceVector.resize(m_pEffectMesh->GetMeshCount());

  000df	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  000e2	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000e5	e8 00 00 00 00	 call	 ?GetMeshCount@CEffectMesh@@QAEKXZ ; CEffectMesh::GetMeshCount
  000ea	89 45 14	 mov	 DWORD PTR __Newsize$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  000ed	8d 45 57	 lea	 eax, DWORD PTR $T27[ebp]
  000f0	50		 push	 eax
  000f1	ff 75 14	 push	 DWORD PTR __Newsize$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 202  : 	m_TextureInstanceVector.resize(m_pEffectMesh->GetMeshCount());

  000f4	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  000f7	83 c1 50	 add	 ecx, 80			; 00000050H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  000fa	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Resize<std::_Value_init_tag>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 203  : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  000ff	83 65 68 00	 and	 DWORD PTR _j$31[ebp], 0
  00103	eb 07		 jmp	 SHORT $LN4@OnSetDataP
$LN2@OnSetDataP:
  00105	8b 45 68	 mov	 eax, DWORD PTR _j$31[ebp]
  00108	40		 inc	 eax
  00109	89 45 68	 mov	 DWORD PTR _j$31[ebp], eax
$LN4@OnSetDataP:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  0010c	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0010f	83 c0 50	 add	 eax, 80			; 00000050H
  00112	89 45 48	 mov	 DWORD PTR __My_data$24[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00115	8b 45 48	 mov	 eax, DWORD PTR __My_data$24[ebp]
  00118	8b 4d 48	 mov	 ecx, DWORD PTR __My_data$24[ebp]
  0011b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0011e	2b 01		 sub	 eax, DWORD PTR [ecx]
  00120	99		 cdq
  00121	6a 30		 push	 48			; 00000030H
  00123	59		 pop	 ecx
  00124	f7 f9		 idiv	 ecx
  00126	89 45 10	 mov	 DWORD PTR $T14[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 203  : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  00129	8b 45 68	 mov	 eax, DWORD PTR _j$31[ebp]
  0012c	3b 45 10	 cmp	 eax, DWORD PTR $T14[ebp]
  0012f	0f 83 cf 01 00
	00		 jae	 $LN3@OnSetDataP

; 204  : 	{
; 205  : 		CEffectMeshScript::TMeshData * pMeshData;
; 206  : 		if (!m_pMeshScript->GetMeshDataPointer(j, &pMeshData))

  00135	8d 45 50	 lea	 eax, DWORD PTR _pMeshData$26[ebp]
  00138	50		 push	 eax
  00139	ff 75 68	 push	 DWORD PTR _j$31[ebp]
  0013c	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0013f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00142	e8 00 00 00 00	 call	 ?GetMeshDataPointer@CEffectMeshScript@@QAE_NKPAPAUSMeshData@1@@Z ; CEffectMeshScript::GetMeshDataPointer
  00147	0f b6 c0	 movzx	 eax, al
  0014a	85 c0		 test	 eax, eax
  0014c	75 02		 jne	 SHORT $LN9@OnSetDataP

; 207  : 			continue;

  0014e	eb b5		 jmp	 SHORT $LN2@OnSetDataP
$LN9@OnSetDataP:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\Ref.h

; 80   : 			return static_cast<T*>(m_pObject);

  00150	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00153	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
  00156	89 45 44	 mov	 DWORD PTR _pkEftMesh$23[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 211  : 		if (!pkEftMesh)

  00159	83 7d 44 00	 cmp	 DWORD PTR _pkEftMesh$23[ebp], 0
  0015d	75 02		 jne	 SHORT $LN10@OnSetDataP

; 212  : 			continue;

  0015f	eb a4		 jmp	 SHORT $LN2@OnSetDataP
$LN10@OnSetDataP:

; 213  : 
; 214  : 		std::vector<CGraphicImage*>* pTextureVector = pkEftMesh->GetTextureVectorPointer(j);

  00161	ff 75 68	 push	 DWORD PTR _j$31[ebp]
  00164	8b 4d 44	 mov	 ecx, DWORD PTR _pkEftMesh$23[ebp]
  00167	e8 00 00 00 00	 call	 ?GetTextureVectorPointer@CEffectMesh@@QAEPAV?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@K@Z ; CEffectMesh::GetTextureVectorPointer
  0016c	89 45 40	 mov	 DWORD PTR _pTextureVector$22[ebp], eax

; 215  : 		if (!pTextureVector)

  0016f	83 7d 40 00	 cmp	 DWORD PTR _pTextureVector$22[ebp], 0
  00173	75 02		 jne	 SHORT $LN11@OnSetDataP

; 216  : 			continue;

  00175	eb 8e		 jmp	 SHORT $LN2@OnSetDataP
$LN11@OnSetDataP:

; 217  : 
; 218  : 		std::vector<CGraphicImage*>& rTextureVector = *pTextureVector;

  00177	8b 45 40	 mov	 eax, DWORD PTR _pTextureVector$22[ebp]
  0017a	89 45 5c	 mov	 DWORD PTR _rTextureVector$29[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0017d	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00180	83 c0 50	 add	 eax, 80			; 00000050H
  00183	89 45 0c	 mov	 DWORD PTR __My_data$13[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00186	6b 45 68 30	 imul	 eax, DWORD PTR _j$31[ebp], 48
  0018a	8b 4d 0c	 mov	 ecx, DWORD PTR __My_data$13[ebp]
  0018d	03 01		 add	 eax, DWORD PTR [ecx]
  0018f	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 220  : 		CFrameController & rFrameController = m_TextureInstanceVector[j].TextureFrameController;

  00192	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  00195	89 45 60	 mov	 DWORD PTR _rFrameController$30[ebp], eax

; 221  : 		rFrameController.Clear();

  00198	8b 4d 60	 mov	 ecx, DWORD PTR _rFrameController$30[ebp]
  0019b	e8 00 00 00 00	 call	 ?Clear@CFrameController@@QAEXXZ ; CFrameController::Clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  001a0	8b 45 5c	 mov	 eax, DWORD PTR _rTextureVector$29[ebp]
  001a3	89 45 3c	 mov	 DWORD PTR __My_data$21[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  001a6	8b 45 3c	 mov	 eax, DWORD PTR __My_data$21[ebp]
  001a9	8b 4d 3c	 mov	 ecx, DWORD PTR __My_data$21[ebp]
  001ac	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001af	2b 01		 sub	 eax, DWORD PTR [ecx]
  001b1	c1 f8 02	 sar	 eax, 2
  001b4	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 222  : 		rFrameController.SetMaxFrame(rTextureVector.size());

  001b7	ff 75 04	 push	 DWORD PTR $T11[ebp]
  001ba	8b 4d 60	 mov	 ecx, DWORD PTR _rFrameController$30[ebp]
  001bd	e8 00 00 00 00	 call	 ?SetMaxFrame@CFrameController@@QAEXK@Z ; CFrameController::SetMaxFrame

; 223  : 		rFrameController.SetFrameTime(pMeshData->fTextureAnimationFrameDelay);

  001c2	8b 45 50	 mov	 eax, DWORD PTR _pMeshData$26[ebp]
  001c5	51		 push	 ecx
  001c6	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [eax+40]
  001cb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d0	8b 4d 60	 mov	 ecx, DWORD PTR _rFrameController$30[ebp]
  001d3	e8 00 00 00 00	 call	 ?SetFrameTime@CFrameController@@QAEXM@Z ; CFrameController::SetFrameTime

; 224  : 		rFrameController.SetLoopFlag(pMeshData->bTextureAnimationLoopEnable);

  001d8	8b 45 50	 mov	 eax, DWORD PTR _pMeshData$26[ebp]
  001db	ff 70 24	 push	 DWORD PTR [eax+36]
  001de	8b 4d 60	 mov	 ecx, DWORD PTR _rFrameController$30[ebp]
  001e1	e8 00 00 00 00	 call	 ?SetLoopFlag@CFrameController@@QAEXH@Z ; CFrameController::SetLoopFlag

; 225  : 		rFrameController.SetStartFrame(pMeshData->dwTextureAnimationStartFrame);

  001e6	8b 45 50	 mov	 eax, DWORD PTR _pMeshData$26[ebp]
  001e9	ff 70 2c	 push	 DWORD PTR [eax+44]
  001ec	8b 4d 60	 mov	 ecx, DWORD PTR _rFrameController$30[ebp]
  001ef	e8 00 00 00 00	 call	 ?SetStartFrame@CFrameController@@QAEXK@Z ; CFrameController::SetStartFrame
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  001f4	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  001f7	83 c0 50	 add	 eax, 80			; 00000050H
  001fa	89 45 00	 mov	 DWORD PTR __My_data$10[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  001fd	6b 45 68 30	 imul	 eax, DWORD PTR _j$31[ebp], 48
  00201	8b 4d 00	 mov	 ecx, DWORD PTR __My_data$10[ebp]
  00204	03 01		 add	 eax, DWORD PTR [ecx]
  00206	89 45 fc	 mov	 DWORD PTR $T9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 227  : 		std::vector<CGraphicImageInstance*> & rImageInstanceVector = m_TextureInstanceVector[j].TextureInstanceVector;

  00209	8b 45 fc	 mov	 eax, DWORD PTR $T9[ebp]
  0020c	83 c0 24	 add	 eax, 36			; 00000024H
  0020f	89 45 4c	 mov	 DWORD PTR _rImageInstanceVector$25[ebp], eax

; 228  : 		rImageInstanceVector.clear();

  00212	8b 4d 4c	 mov	 ecx, DWORD PTR _rImageInstanceVector$25[ebp]
  00215	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  0021a	8b 45 5c	 mov	 eax, DWORD PTR _rTextureVector$29[ebp]
  0021d	89 45 38	 mov	 DWORD PTR __My_data$20[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00220	8b 45 38	 mov	 eax, DWORD PTR __My_data$20[ebp]
  00223	8b 4d 38	 mov	 ecx, DWORD PTR __My_data$20[ebp]
  00226	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00229	2b 01		 sub	 eax, DWORD PTR [ecx]
  0022b	c1 f8 02	 sar	 eax, 2
  0022e	89 45 f8	 mov	 DWORD PTR $T8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 229  : 		rImageInstanceVector.reserve(rTextureVector.size());

  00231	ff 75 f8	 push	 DWORD PTR $T8[ebp]
  00234	8b 4d 4c	 mov	 ecx, DWORD PTR _rImageInstanceVector$25[ebp]
  00237	e8 00 00 00 00	 call	 ?reserve@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXI@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::reserve
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0023c	8b 45 5c	 mov	 eax, DWORD PTR _rTextureVector$29[ebp]
  0023f	89 45 34	 mov	 DWORD PTR __My_data$19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00242	8b 45 34	 mov	 eax, DWORD PTR __My_data$19[ebp]
  00245	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00248	8b 45 34	 mov	 eax, DWORD PTR __My_data$19[ebp]
  0024b	8b 00		 mov	 eax, DWORD PTR [eax]
  0024d	89 45 f4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00250	8b 45 f4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00253	89 45 58	 mov	 DWORD PTR _itor$28[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 230  : 		for (std::vector<CGraphicImage*>::iterator itor = rTextureVector.begin(); itor != rTextureVector.end(); ++itor)

  00256	eb 09		 jmp	 SHORT $LN110@OnSetDataP
$LN5@OnSetDataP:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00258	8b 45 58	 mov	 eax, DWORD PTR _itor$28[ebp]
  0025b	83 c0 04	 add	 eax, 4
  0025e	89 45 58	 mov	 DWORD PTR _itor$28[ebp], eax
$LN110@OnSetDataP:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00261	8b 45 5c	 mov	 eax, DWORD PTR _rTextureVector$29[ebp]
  00264	89 45 30	 mov	 DWORD PTR __My_data$18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00267	8b 45 30	 mov	 eax, DWORD PTR __My_data$18[ebp]
  0026a	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0026d	8b 45 30	 mov	 eax, DWORD PTR __My_data$18[ebp]
  00270	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00273	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00276	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00279	89 45 ec	 mov	 DWORD PTR $T7[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0027c	8d 45 ec	 lea	 eax, DWORD PTR $T7[ebp]
  0027f	89 45 e8	 mov	 DWORD PTR $T6[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00282	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  00285	8b 4d 58	 mov	 ecx, DWORD PTR _itor$28[ebp]
  00288	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0028a	75 09		 jne	 SHORT $LN138@OnSetDataP
  0028c	c7 45 2c 01 00
	00 00		 mov	 DWORD PTR tv381[ebp], 1
  00293	eb 04		 jmp	 SHORT $LN139@OnSetDataP
$LN138@OnSetDataP:
  00295	83 65 2c 00	 and	 DWORD PTR tv381[ebp], 0
$LN139@OnSetDataP:
  00299	8a 45 2c	 mov	 al, BYTE PTR tv381[ebp]
  0029c	88 45 6f	 mov	 BYTE PTR $T33[ebp], al

; 153  :         return !(*this == _Right);

  0029f	0f b6 45 6f	 movzx	 eax, BYTE PTR $T33[ebp]
  002a3	85 c0		 test	 eax, eax
  002a5	75 09		 jne	 SHORT $LN133@OnSetDataP
  002a7	c7 45 28 01 00
	00 00		 mov	 DWORD PTR tv367[ebp], 1
  002ae	eb 04		 jmp	 SHORT $LN134@OnSetDataP
$LN133@OnSetDataP:
  002b0	83 65 28 00	 and	 DWORD PTR tv367[ebp], 0
$LN134@OnSetDataP:
  002b4	8a 45 28	 mov	 al, BYTE PTR tv367[ebp]
  002b7	88 45 6e	 mov	 BYTE PTR $T32[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 230  : 		for (std::vector<CGraphicImage*>::iterator itor = rTextureVector.begin(); itor != rTextureVector.end(); ++itor)

  002ba	0f b6 45 6e	 movzx	 eax, BYTE PTR $T32[ebp]
  002be	85 c0		 test	 eax, eax
  002c0	74 3d		 je	 SHORT $LN6@OnSetDataP
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  002c2	8b 45 58	 mov	 eax, DWORD PTR _itor$28[ebp]
  002c5	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  002c8	8b 45 e4	 mov	 eax, DWORD PTR $T5[ebp]
  002cb	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 232  : 			CGraphicImage * pImage = *itor;

  002ce	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  002d1	8b 00		 mov	 eax, DWORD PTR [eax]
  002d3	89 45 dc	 mov	 DWORD PTR _pImage$3[ebp], eax

; 233  : 			CGraphicImageInstance * pImageInstance = CGraphicImageInstance::ms_kPool.Alloc();

  002d6	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicImageInstance@@2V?$CDynamicPool@VCGraphicImageInstance@@@@A ; CGraphicImageInstance::ms_kPool
  002db	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ ; CDynamicPool<CGraphicImageInstance>::Alloc
  002e0	89 45 24	 mov	 DWORD PTR _pImageInstance$17[ebp], eax

; 234  : 			pImageInstance->SetImagePointer(pImage);

  002e3	ff 75 dc	 push	 DWORD PTR _pImage$3[ebp]
  002e6	8b 4d 24	 mov	 ecx, DWORD PTR _pImageInstance$17[ebp]
  002e9	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  002ee	8d 45 24	 lea	 eax, DWORD PTR _pImageInstance$17[ebp]
  002f1	50		 push	 eax
  002f2	8b 4d 4c	 mov	 ecx, DWORD PTR _rImageInstanceVector$25[ebp]
  002f5	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXABQAVCGraphicImageInstance@@@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::emplace_back<CGraphicImageInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 236  : 		}

  002fa	e9 59 ff ff ff	 jmp	 $LN5@OnSetDataP
$LN6@OnSetDataP:

; 237  : 	}

  002ff	e9 01 fe ff ff	 jmp	 $LN2@OnSetDataP
$LN3@OnSetDataP:
$LN1@OnSetDataP:

; 238  : }

  00304	83 c5 74	 add	 ebp, 116		; 00000074H
  00307	c9		 leave
  00308	c2 04 00	 ret	 4
?OnSetDataPointer@CEffectMeshInstance@@MAEXPAVCEffectElementBase@@@Z ENDP ; CEffectMeshInstance::OnSetDataPointer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
;	COMDAT ?Delete@CEffectMeshInstance@@SAXPAV1@@Z
_TEXT	SEGMENT
_pkData$ = -4						; size = 4
_pkMeshInstance$ = 8					; size = 4
?Delete@CEffectMeshInstance@@SAXPAV1@@Z PROC		; CEffectMeshInstance::Delete, COMDAT

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 21   : 	pkMeshInstance->Destroy();

  00004	8b 4d 08	 mov	 ecx, DWORD PTR _pkMeshInstance$[ebp]
  00007	e8 00 00 00 00	 call	 ?Destroy@CEffectElementBaseInstance@@QAEXXZ ; CEffectElementBaseInstance::Destroy

; 22   : 	ms_kPool.Free(pkMeshInstance);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _pkMeshInstance$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR _pkData$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00012	8d 45 fc	 lea	 eax, DWORD PTR _pkData$[ebp]
  00015	50		 push	 eax
  00016	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+16
  0001b	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXABQAVCEffectMeshInstance@@@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::emplace_back<CEffectMeshInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 23   : }

  00020	c9		 leave
  00021	c3		 ret	 0
?Delete@CEffectMeshInstance@@SAXPAV1@@Z ENDP		; CEffectMeshInstance::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
;	COMDAT ?New@CEffectMeshInstance@@SAPAV1@XZ
_TEXT	SEGMENT
?New@CEffectMeshInstance@@SAPAV1@XZ PROC		; CEffectMeshInstance::New, COMDAT

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 16   : 	return ms_kPool.Alloc();

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A ; CEffectMeshInstance::ms_kPool
  00008	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ ; CDynamicPool<CEffectMeshInstance>::Alloc

; 17   : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?New@CEffectMeshInstance@@SAPAV1@XZ ENDP		; CEffectMeshInstance::New
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
;	COMDAT ?DestroySystem@CEffectMeshInstance@@SAXXZ
_TEXT	SEGMENT
?DestroySystem@CEffectMeshInstance@@SAXXZ PROC		; CEffectMeshInstance::DestroySystem, COMDAT

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 11   : 	ms_kPool.Destroy();

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A ; CEffectMeshInstance::ms_kPool
  00008	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPool@VCEffectMeshInstance@@@@QAEXXZ ; CDynamicPool<CEffectMeshInstance>::Destroy

; 12   : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?DestroySystem@CEffectMeshInstance@@SAXXZ ENDP		; CEffectMeshInstance::DestroySystem
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
;	COMDAT ??1CEffectMeshInstance@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CEffectMeshInstance@@UAE@XZ PROC			; CEffectMeshInstance::~CEffectMeshInstance, COMDAT
; _this$ = ecx

; 269  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CEffectMeshInstance@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CEffectMeshInstance@@6B@

; 270  : 	Destroy();

  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?Destroy@CEffectElementBaseInstance@@QAEXXZ ; CEffectElementBaseInstance::Destroy

; 271  : }

  00038	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	83 c0 5c	 add	 eax, 92			; 0000005cH
  0003e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\Ref.h

; 37   : 		{

  00041	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 53   : 			if (m_pObject)

  00045	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00048	83 38 00	 cmp	 DWORD PTR [eax], 0
  0004b	74 10		 je	 SHORT $LN3@CEffectMes

; 54   : 			{
; 55   : 				m_pObject->Release();

  0004d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 56   : 				m_pObject = NULL;

  00057	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@CEffectMes:

; 39   : 		}

  0005d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 271  : }

  00061	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	83 c1 50	 add	 ecx, 80			; 00000050H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00067	e8 00 00 00 00	 call	 ?_Tidy@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@AAEXXZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 271  : }

  0006c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00072	e8 00 00 00 00	 call	 ??1CFrameController@@UAE@XZ ; CFrameController::~CFrameController
  00077	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	e8 00 00 00 00	 call	 ??1CEffectElementBaseInstance@@UAE@XZ ; CEffectElementBaseInstance::~CEffectElementBaseInstance
  0007f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00082	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00089	59		 pop	 ecx
  0008a	c9		 leave
  0008b	c3		 ret	 0
  0008c	cc		 int	 3
  0008d	cc		 int	 3
  0008e	cc		 int	 3
  0008f	cc		 int	 3
  00090	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CEffectMeshInstance@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CEffectMeshInstance@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CEffectMeshInstance@@UAE@XZ ENDP			; CEffectMeshInstance::~CEffectMeshInstance
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp
;	COMDAT ??0CEffectMeshInstance@@QAE@XZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CEffectMeshInstance@@QAE@XZ PROC			; CEffectMeshInstance::CEffectMeshInstance, COMDAT
; _this$ = ecx

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CEffectMeshInstance@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0CEffectElementBaseInstance@@QAE@XZ ; CEffectElementBaseInstance::CEffectElementBaseInstance
  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CEffectMeshInstance@@6B@
  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00043	e8 00 00 00 00	 call	 ??0CFrameController@@QAE@XZ ; CFrameController::CFrameController
  00048	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0004c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 c0 50	 add	 eax, 80			; 00000050H
  00052	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00055	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0005b	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	89 45 ec	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00061	8b 45 ec	 mov	 eax, DWORD PTR _this$2[ebp]
  00064	83 20 00	 and	 DWORD PTR [eax], 0
  00067	8b 45 ec	 mov	 eax, DWORD PTR _this$2[ebp]
  0006a	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0006e	8b 45 ec	 mov	 eax, DWORD PTR _this$2[ebp]
  00071	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 264  : {

  00075	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00079	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	83 c0 5c	 add	 eax, 92			; 0000005cH
  0007f	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\Ref.h

; 20   : 		CRef() : m_pObject(NULL)

  00082	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00085	83 20 00	 and	 DWORD PTR [eax], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EffectLib\EffectMeshInstance.cpp

; 264  : {

  00088	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 265  : 	Initialize();

  0008c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	e8 00 00 00 00	 call	 ?Initialize@CEffectElementBaseInstance@@QAEXXZ ; CEffectElementBaseInstance::Initialize

; 266  : }

  00094	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00098	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a5	59		 pop	 ecx
  000a6	c9		 leave
  000a7	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CEffectMeshInstance@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CEffectElementBaseInstance@@UAE@XZ ; CEffectElementBaseInstance::~CEffectElementBaseInstance
__unwindfunclet$??0CEffectMeshInstance@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0000e	e9 00 00 00 00	 jmp	 ??1CFrameController@@UAE@XZ ; CFrameController::~CFrameController
__unwindfunclet$??0CEffectMeshInstance@@QAE@XZ$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 50	 add	 ecx, 80			; 00000050H
  00019	e9 00 00 00 00	 jmp	 ??1?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::~vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >
__unwindfunclet$??0CEffectMeshInstance@@QAE@XZ$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00024	e9 00 00 00 00	 jmp	 ??1?$CRef@VCEffectMesh@@@@QAE@XZ ; CRef<CEffectMesh>::~CRef<CEffectMesh>
  00029	cc		 int	 3
  0002a	cc		 int	 3
  0002b	cc		 int	 3
  0002c	cc		 int	 3
  0002d	cc		 int	 3
__ehhandler$??0CEffectMeshInstance@@QAE@XZ:
  0002e	90		 npad	 1
  0002f	90		 npad	 1
  00030	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00034	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00037	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0003a	33 c8		 xor	 ecx, eax
  0003c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00041	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CEffectMeshInstance@@QAE@XZ
  00046	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CEffectMeshInstance@@QAE@XZ ENDP			; CEffectMeshInstance::CEffectMeshInstance
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??_GSTextureInstance@CEffectMeshInstance@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSTextureInstance@CEffectMeshInstance@@QAEPAXI@Z PROC ; CEffectMeshInstance::STextureInstance::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 24	 add	 ecx, 36			; 00000024H

; 673  :         _Tidy();

  0000d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Tidy
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??1CFrameController@@UAE@XZ ; CFrameController::~CFrameController
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001d	83 e0 01	 and	 eax, 1
  00020	74 0c		 je	 SHORT $LN2@scalar
  00022	6a 30		 push	 48			; 00000030H
  00024	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002c	59		 pop	 ecx
  0002d	59		 pop	 ecx
$LN2@scalar:
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c9		 leave
  00032	c2 04 00	 ret	 4
??_GSTextureInstance@CEffectMeshInstance@@QAEPAXI@Z ENDP ; CEffectMeshInstance::STextureInstance::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0STextureInstance@CEffectMeshInstance@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$1 = -4						; size = 4
??0STextureInstance@CEffectMeshInstance@@QAE@XZ PROC	; CEffectMeshInstance::STextureInstance::STextureInstance, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CFrameController@@QAE@XZ ; CFrameController::CFrameController
  00011	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00014	83 c0 24	 add	 eax, 36			; 00000024H
  00017	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00020	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00023	89 45 fc	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$1[ebp]
  00029	83 20 00	 and	 DWORD PTR [eax], 0
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$1[ebp]
  0002f	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$1[ebp]
  00036	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	c9		 leave
  0003e	c3		 ret	 0
??0STextureInstance@CEffectMeshInstance@@QAE@XZ ENDP	; CEffectMeshInstance::STextureInstance::STextureInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Getal@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEAAV?$allocator@PAVCGraphicImageInstance@@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Getal@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEAAV?$allocator@PAVCGraphicImageInstance@@@2@XZ PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Getal, COMDAT
; _this$ = ecx

; 1732 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000b	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000e	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 1734 :     }

  00011	c9		 leave
  00012	c3		 ret	 0
?_Getal@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEAAV?$allocator@PAVCGraphicImageInstance@@@2@XZ ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXXZ PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@YAXPAPAVCGraphicImageInstance@@QAPAV1@AAV?$allocator@PAVCGraphicImageInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicImageInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXXZ ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXQAPAVCGraphicImageInstance@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXQAPAVCGraphicImageInstance@@II@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@YAXPAPAVCGraphicImageInstance@@QAPAV1@AAV?$allocator@PAVCGraphicImageInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicImageInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXQAPAVCGraphicImageInstance@@II@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@ABEII@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@ABEII@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXPAPAVCGraphicImageInstance@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXPAPAVCGraphicImageInstance@@0@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@YAXPAPAVCGraphicImageInstance@@QAPAV1@AAV?$allocator@PAVCGraphicImageInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicImageInstance *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXPAPAVCGraphicImageInstance@@0@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@YAXPAPAVCGraphicImageInstance@@QAPAV1@AAV?$allocator@PAVCGraphicImageInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicImageInstance *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?reserve@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
$T6 = -28						; size = 4
$T7 = -24						; size = 4
tv81 = -20						; size = 4
$T8 = -16						; size = 4
$T9 = -12						; size = 4
__My_data$10 = -8					; size = 4
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?reserve@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXI@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::reserve, COMDAT
; _this$ = ecx

; 1304 :     void reserve(_CRT_GUARDOVERFLOW const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$10[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$10[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 e8	 mov	 DWORD PTR $T7[ebp], eax

; 1305 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1306 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00020	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00023	3b 45 e8	 cmp	 eax, DWORD PTR $T7[ebp]
  00026	76 62		 jbe	 SHORT $LN4@reserve

; 1737 :         return _Mypair._Get_first();

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002b	89 45 e4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  0002e	8b 45 e4	 mov	 eax, DWORD PTR $T6[ebp]
  00031	89 45 d0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00034	c7 45 f4 ff ff
	ff 3f		 mov	 DWORD PTR $T9[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0003b	c7 45 e0 ff ff
	ff 7f		 mov	 DWORD PTR $T5[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00042	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  00045	89 45 f0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00048	8b 45 f4	 mov	 eax, DWORD PTR $T9[ebp]
  0004b	3b 45 f0	 cmp	 eax, DWORD PTR $T8[ebp]
  0004e	73 08		 jae	 SHORT $LN25@reserve
  00050	8d 45 f4	 lea	 eax, DWORD PTR $T9[ebp]
  00053	89 45 ec	 mov	 DWORD PTR tv81[ebp], eax
  00056	eb 06		 jmp	 SHORT $LN26@reserve
$LN25@reserve:
  00058	8d 45 f0	 lea	 eax, DWORD PTR $T8[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR tv81[ebp], eax
$LN26@reserve:
  0005e	8b 45 ec	 mov	 eax, DWORD PTR tv81[ebp]
  00061	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
  00064	8b 45 dc	 mov	 eax, DWORD PTR $T4[ebp]
  00067	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0006a	8b 45 d8	 mov	 eax, DWORD PTR $T3[ebp]
  0006d	8b 00		 mov	 eax, DWORD PTR [eax]
  0006f	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax

; 1307 :             if (_Newcapacity > max_size()) {

  00072	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00075	3b 45 d4	 cmp	 eax, DWORD PTR $T2[ebp]
  00078	76 05		 jbe	 SHORT $LN3@reserve

; 1308 :                 _Xlength();

  0007a	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@CAXXZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Xlength
$LN3@reserve:

; 1309 :             }
; 1310 : 
; 1311 :             _Reallocate_exactly(_Newcapacity);

  0007f	ff 75 08	 push	 DWORD PTR __Newcapacity$[ebp]
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?_Reallocate_exactly@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXI@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Reallocate_exactly
$LN4@reserve:

; 1312 :         }
; 1313 :     }

  0008a	c9		 leave
  0008b	c2 04 00	 ret	 4
?reserve@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::reserve
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Max_possible$2 = -80					; size = 4
$T3 = -76						; size = 4
__Size$ = -72						; size = 4
__First$ = -68						; size = 4
__Last$ = -64						; size = 4
$T4 = -60						; size = 4
$T5 = -56						; size = 4
$T6 = -52						; size = 4
$T7 = -48						; size = 4
__Myfirst$ = -44					; size = 4
__Mylast$ = -40						; size = 4
__My_data$ = -36					; size = 4
__Newvec$ = -32						; size = 4
_this$ = -28						; size = 4
___formal$ = -24					; size = 1
__Overflow_is_possible$8 = -18				; size = 1
$T9 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newcapacity$ = 8					; size = 4
?_Reallocate_exactly@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXI@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1251 :     void _Reallocate_exactly(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate_exactly@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 40	 sub	 esp, 64			; 00000040H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 1252 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1253 :         auto& _My_data    = _Mypair._Myval2;

  0002f	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00032	89 45 dc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1254 :         pointer& _Myfirst = _My_data._Myfirst;

  00035	8b 45 dc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00038	89 45 d4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1255 :         pointer& _Mylast  = _My_data._Mylast;

  0003b	8b 45 dc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003e	83 c0 04	 add	 eax, 4
  00041	89 45 d8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1256 : 
; 1257 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

  00044	8b 45 d8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00047	8b 4d d4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0004a	8b 00		 mov	 eax, DWORD PTR [eax]
  0004c	2b 01		 sub	 eax, DWORD PTR [ecx]
  0004e	c1 f8 02	 sar	 eax, 2
  00051	89 45 b8	 mov	 DWORD PTR __Size$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  00054	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00057	89 45 d0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0005a	8b 45 d0	 mov	 eax, DWORD PTR $T7[ebp]
  0005d	89 45 b4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00060	c6 45 ee 01	 mov	 BYTE PTR __Overflow_is_possible$8[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00064	c7 45 b0 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  0006b	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  00072	76 05		 jbe	 SHORT $LN17@Reallocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00074	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN17@Reallocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00079	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0007c	c1 e0 02	 shl	 eax, 2
  0007f	89 45 cc	 mov	 DWORD PTR $T6[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00082	ff 75 cc	 push	 DWORD PTR $T6[ebp]
  00085	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0008a	59		 pop	 ecx
  0008b	89 45 e0	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1261 :         _TRY_BEGIN

  0008e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0

; 1262 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00092	8b 45 d8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00095	8b 00		 mov	 eax, DWORD PTR [eax]
  00097	89 45 c0	 mov	 DWORD PTR __Last$[ebp], eax
  0009a	8b 45 d4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0009d	8b 00		 mov	 eax, DWORD PTR [eax]
  0009f	89 45 bc	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  000a2	33 c0		 xor	 eax, eax
  000a4	88 45 ef	 mov	 BYTE PTR $T9[ebp], al
  000a7	8a 45 ef	 mov	 al, BYTE PTR $T9[ebp]
  000aa	88 45 e8	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  000ad	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000b0	89 45 c8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000b3	8b 45 c8	 mov	 eax, DWORD PTR $T5[ebp]
  000b6	89 45 c4	 mov	 DWORD PTR $T4[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  000b9	ff 75 c4	 push	 DWORD PTR $T4[ebp]
  000bc	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  000bf	ff 75 c0	 push	 DWORD PTR __Last$[ebp]
  000c2	ff 75 bc	 push	 DWORD PTR __First$[ebp]
  000c5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@YAPAPAVCGraphicImageInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicImageInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicImageInstance * *,std::allocator<CGraphicImageInstance *> >
  000ca	83 c4 10	 add	 esp, 16			; 00000010H

; 1262 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  000cd	eb 24		 jmp	 SHORT $LN4@Reallocate
__catch$?_Reallocate_exactly@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXI@Z$0:

; 1263 :         _CATCH_ALL
; 1264 :         _Getal().deallocate(_Newvec, _Newcapacity);

  000cf	ff 75 08	 push	 DWORD PTR __Newcapacity$[ebp]
  000d2	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  000d5	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEAAV?$allocator@PAVCGraphicImageInstance@@@2@XZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Getal
  000dd	8b c8		 mov	 ecx, eax
  000df	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXQAPAVCGraphicImageInstance@@I@Z ; std::allocator<CGraphicImageInstance *>::deallocate

; 1265 :         _RERAISE;

  000e4	6a 00		 push	 0
  000e6	6a 00		 push	 0
  000e8	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1266 :         _CATCH_END

  000ed	b8 00 00 00 00	 mov	 eax, $LN7@Reallocate
  000f2	c3		 ret	 0
$LN4@Reallocate:
  000f3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  000f7	eb 04		 jmp	 SHORT __tryend$?_Reallocate_exactly@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXI@Z$1
$LN7@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  000f9	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate_exactly@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXI@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1267 : 
; 1268 :         _Change_array(_Newvec, _Size, _Newcapacity);

  000fd	ff 75 08	 push	 DWORD PTR __Newcapacity$[ebp]
  00100	ff 75 b8	 push	 DWORD PTR __Size$[ebp]
  00103	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  00106	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXQAPAVCGraphicImageInstance@@II@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Change_array
$LN20@Reallocate:

; 1269 :     }

  0010e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00111	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00118	59		 pop	 ecx
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx
  0011c	c9		 leave
  0011d	c2 04 00	 ret	 4
  00120	cc		 int	 3
  00121	cc		 int	 3
  00122	cc		 int	 3
  00123	cc		 int	 3
  00124	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate_exactly@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate_exactly@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate_exactly@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@AAEXI@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Reallocate_exactly
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 4
_this$ = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__Right$ = -12						; size = 4
___formal$ = -8						; size = 1
$T4 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >, COMDAT
; _this$ = ecx

; 581  :     vector(vector&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00015	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00018	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 581  :     vector(vector&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  0001b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 582  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 583  :         _Move_construct(_Right, true_type{});

  0003b	33 c0		 xor	 eax, eax
  0003d	88 45 ff	 mov	 BYTE PTR $T4[ebp], al
  00040	8a 45 ff	 mov	 al, BYTE PTR $T4[ebp]
  00043	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al

; 557  :         _Mypair._Myval2._Take_contents(_Right._Mypair._Myval2);

  00046	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00049	89 45 f4	 mov	 DWORD PTR __Right$[ebp], eax
  0004c	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 386  :         _Myfirst = _Right._Myfirst;

  00052	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __Right$[ebp]
  00058	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0005a	89 08		 mov	 DWORD PTR [eax], ecx

; 387  :         _Mylast  = _Right._Mylast;

  0005c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __Right$[ebp]
  00062	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00065	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 388  :         _Myend   = _Right._Myend;

  00068	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __Right$[ebp]
  0006e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00071	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 389  : 
; 390  :         _Right._Myfirst = pointer();

  00074	8b 45 f4	 mov	 eax, DWORD PTR __Right$[ebp]
  00077	83 20 00	 and	 DWORD PTR [eax], 0

; 391  :         _Right._Mylast  = pointer();

  0007a	8b 45 f4	 mov	 eax, DWORD PTR __Right$[ebp]
  0007d	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 392  :         _Right._Myend   = pointer();

  00081	8b 45 f4	 mov	 eax, DWORD PTR __Right$[ebp]
  00084	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 584  :     }

  00088	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0008b	c9		 leave
  0008c	c2 04 00	 ret	 4
??0?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXQAPAVCGraphicImageInstance@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXQAPAVCGraphicImageInstance@@I@Z PROC ; std::allocator<CGraphicImageInstance *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXQAPAVCGraphicImageInstance@@I@Z ENDP ; std::allocator<CGraphicImageInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?begin@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
___param0$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::begin, COMDAT
; _this$ = ecx

; 1409 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	89 45 f4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00020	8b 4d f4	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00025	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1412 :     }

  00028	c9		 leave
  00029	c2 04 00	 ret	 4
?begin@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCFrameController@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCFrameController@@UAEPAXI@Z PROC			; CFrameController::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CFrameController@@UAE@XZ ; CFrameController::~CFrameController
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_GCFrameController@@UAEPAXI@Z ENDP			; CFrameController::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0CFrameController@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0CFrameController@@QAE@ABV0@@Z PROC			; CFrameController::CFrameController, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CFrameController@@6B@
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00016	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00019	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00022	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00025	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0002e	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00031	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0003a	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0003d	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00046	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00049	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0004c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00052	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00055	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0005e	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00061	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0006a	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0006d	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00070	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00073	c9		 leave
  00074	c2 04 00	 ret	 4
??0CFrameController@@QAE@ABV0@@Z ENDP			; CFrameController::CFrameController
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000d	48		 dec	 eax
  0000e	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00015	76 11		 jbe	 SHORT $LN1@vector
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001a	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00020	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00023	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00026	eb dc		 jmp	 SHORT $LN2@vector
$LN1@vector:
  00028	c9		 leave
  00029	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
