; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?ms_dwFourCC@CLZObject@@2KA			; CLZObject::ms_dwFourCC
_DATA	SEGMENT
?ms_dwFourCC@CLZObject@@2KA DD 05a4f434dH		; CLZObject::ms_dwFourCC
_DATA	ENDS
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??0CLZObject@@QAE@XZ				; CLZObject::CLZObject
PUBLIC	??1CLZObject@@QAE@XZ				; CLZObject::~CLZObject
PUBLIC	?Clear@CLZObject@@QAEXXZ			; CLZObject::Clear
PUBLIC	?BeginCompress@CLZObject@@QAEXPBXI@Z		; CLZObject::BeginCompress
PUBLIC	?BeginCompressInBuffer@CLZObject@@QAEXPBXIPAX@Z	; CLZObject::BeginCompressInBuffer
PUBLIC	?Compress@CLZObject@@QAE_NXZ			; CLZObject::Compress
PUBLIC	?BeginDecompress@CLZObject@@QAE_NPBX@Z		; CLZObject::BeginDecompress
PUBLIC	?Decompress@CLZObject@@QAE_NPAK@Z		; CLZObject::Decompress
PUBLIC	?Encrypt@CLZObject@@QAE_NPAK@Z			; CLZObject::Encrypt
PUBLIC	?__Decrypt@CLZObject@@QAE_NPAKPAE@Z		; CLZObject::__Decrypt
PUBLIC	?GetSize@CLZObject@@QAEKXZ			; CLZObject::GetSize
PUBLIC	?AllocBuffer@CLZObject@@QAEXK@Z			; CLZObject::AllocBuffer
PUBLIC	?Initialize@CLZObject@@AAEXXZ			; CLZObject::Initialize
PUBLIC	??1?$CSingleton@VCLZO@@@@UAE@XZ			; CSingleton<CLZO>::~CSingleton<CLZO>
PUBLIC	??_G?$CSingleton@VCLZO@@@@UAEPAXI@Z		; CSingleton<CLZO>::`scalar deleting destructor'
PUBLIC	??0CLZO@@QAE@XZ					; CLZO::CLZO
PUBLIC	??1CLZO@@UAE@XZ					; CLZO::~CLZO
PUBLIC	?CompressMemory@CLZO@@QAE_NAAVCLZObject@@PBXI@Z	; CLZO::CompressMemory
PUBLIC	?CompressEncryptedMemory@CLZO@@QAE_NAAVCLZObject@@PBXIPAK@Z ; CLZO::CompressEncryptedMemory
PUBLIC	?Decompress@CLZO@@QAE_NAAVCLZObject@@PBEPAK@Z	; CLZO::Decompress
PUBLIC	?GetWorkMemory@CLZO@@QAEPAEXZ			; CLZO::GetWorkMemory
PUBLIC	??_GCLZO@@UAEPAXI@Z				; CLZO::`scalar deleting destructor'
PUBLIC	??1LZOFreeMemoryMgr@@QAE@XZ			; LZOFreeMemoryMgr::~LZOFreeMemoryMgr
PUBLIC	?Alloc@LZOFreeMemoryMgr@@QAEPAEI@Z		; LZOFreeMemoryMgr::Alloc
PUBLIC	?deallocate@?$allocator@PAE@std@@QAEXQAPAEI@Z	; std::allocator<unsigned char *>::deallocate
PUBLIC	??0?$vector@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::vector<unsigned char *,std::allocator<unsigned char *> >::vector<unsigned char *,std::allocator<unsigned char *> >
PUBLIC	?clear@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEXXZ ; std::vector<unsigned char *,std::allocator<unsigned char *> >::clear
PUBLIC	?_Destroy@?$vector@PAEV?$allocator@PAE@std@@@std@@AAEXPAPAE0@Z ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAEV?$allocator@PAE@std@@@std@@ABEII@Z ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAEV?$allocator@PAE@std@@@std@@AAEXQAPAEII@Z ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAEV?$allocator@PAE@std@@@std@@AAEXXZ ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAEV?$allocator@PAE@std@@@std@@CAXXZ ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Xlength
PUBLIC	??0DecryptBuffer@@QAE@I@Z			; DecryptBuffer::DecryptBuffer
PUBLIC	??1DecryptBuffer@@QAE@XZ			; DecryptBuffer::~DecryptBuffer
PUBLIC	??$emplace_back@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEXABQAE@Z ; std::vector<unsigned char *,std::allocator<unsigned char *> >::emplace_back<unsigned char * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@AAEXABQAE@Z ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Emplace_back_with_unused_capacity<unsigned char * const &>
PUBLIC	??$_Emplace_reallocate@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEPAPAEQAPAEABQAE@Z ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Emplace_reallocate<unsigned char * const &>
PUBLIC	??$_Destroy_range@V?$allocator@PAE@std@@@std@@YAXPAPAEQAPAEAAV?$allocator@PAE@0@@Z ; std::_Destroy_range<std::allocator<unsigned char *> >
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Uninitialized_move@PAPAEV?$allocator@PAE@std@@@std@@YAPAPAEQAPAE0PAPAEAAV?$allocator@PAE@0@@Z ; std::_Uninitialized_move<unsigned char * *,std::allocator<unsigned char *> >
PUBLIC	??$_Copy_memmove@PAPAEPAPAE@std@@YAPAPAEPAPAE00@Z ; std::_Copy_memmove<unsigned char * *,unsigned char * *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A	; CSingleton<CLZO>::ms_singleton
PUBLIC	??_7?$CSingleton@VCLZO@@@@6B@			; CSingleton<CLZO>::`vftable'
PUBLIC	??_7CLZO@@6B@					; CLZO::`vftable'
PUBLIC	??_C@_0BP@LNIOABIE@LZO?3?5lzo1x_999_compress?5failed@ ; `string'
PUBLIC	??_C@_0BL@BHMEHIOE@LZObject?3?5not?5a?5valid?5data@ ; `string'
PUBLIC	?count@?1???0DecryptBuffer@@QAE@I@Z@4IA		; `DecryptBuffer::DecryptBuffer'::`2'::count
PUBLIC	?sum@?1???0DecryptBuffer@@QAE@I@Z@4IA		; `DecryptBuffer::DecryptBuffer'::`2'::sum
PUBLIC	?maxSize@?1???0DecryptBuffer@@QAE@I@Z@4IA	; `DecryptBuffer::DecryptBuffer'::`2'::maxSize
PUBLIC	??_C@_0BI@LOICJMKN@LZObject?3?5key?5incorrect@	; `string'
PUBLIC	??_C@_0CN@JNKNGBBC@LZObject?3?5Decompress?5failed?$CIdec@ ; `string'
PUBLIC	??_C@_0DJ@JONLEDGH@LZObject?3?5Decompress?5failed?5?3?5r@ ; `string'
PUBLIC	??_C@_0BH@MGOIPKD@LZObject?3?5Size?5differs@	; `string'
PUBLIC	??_C@_0BH@CNLKBJA@LZO?3?5cannot?5initialize@	; `string'
PUBLIC	??_C@_0BJ@HNOINGEF@LZO?3?5cannot?5alloc?5memory@ ; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CLZO@@6B@					; CLZO::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCLZO@@@8				; CLZO `RTTI Type Descriptor'
PUBLIC	??_R3CLZO@@8					; CLZO::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CLZO@@8					; CLZO::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CLZO@@8				; CLZO::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$CSingleton@VCLZO@@@@8		; CSingleton<CLZO>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$CSingleton@VCLZO@@@@@8		; CSingleton<CLZO> `RTTI Type Descriptor'
PUBLIC	??_R3?$CSingleton@VCLZO@@@@8			; CSingleton<CLZO>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CSingleton@VCLZO@@@@8			; CSingleton<CLZO>::`RTTI Base Class Array'
PUBLIC	??_R4?$CSingleton@VCLZO@@@@6B@			; CSingleton<CLZO>::`RTTI Complete Object Locator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	___lzo_init_v2:PROC
EXTRN	_lzo1x_decompress:PROC
EXTRN	_lzo1x_999_compress:PROC
EXTRN	??_E?$CSingleton@VCLZO@@@@UAEPAXI@Z:PROC	; CSingleton<CLZO>::`vector deleting destructor'
EXTRN	??_ECLZO@@UAEPAXI@Z:PROC			; CLZO::`vector deleting destructor'
EXTRN	_tea_encrypt:PROC
EXTRN	_tea_decrypt:PROC
EXTRN	?TraceError@@YAXPBDZZ:PROC			; TraceError
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A DD 01H DUP (?) ; CSingleton<CLZO>::ms_singleton
_BSS	ENDS
_BSS	SEGMENT
?gs_freeMemMgr@@3VLZOFreeMemoryMgr@@A DB 0cH DUP (?)	; gs_freeMemMgr
_BSS	ENDS
;	COMDAT ?count@?1???0DecryptBuffer@@QAE@I@Z@4IA
_BSS	SEGMENT
?count@?1???0DecryptBuffer@@QAE@I@Z@4IA DD 01H DUP (?)	; `DecryptBuffer::DecryptBuffer'::`2'::count
_BSS	ENDS
;	COMDAT ?sum@?1???0DecryptBuffer@@QAE@I@Z@4IA
_BSS	SEGMENT
?sum@?1???0DecryptBuffer@@QAE@I@Z@4IA DD 01H DUP (?)	; `DecryptBuffer::DecryptBuffer'::`2'::sum
_BSS	ENDS
;	COMDAT ?maxSize@?1???0DecryptBuffer@@QAE@I@Z@4IA
_BSS	SEGMENT
?maxSize@?1???0DecryptBuffer@@QAE@I@Z@4IA DD 01H DUP (?) ; `DecryptBuffer::DecryptBuffer'::`2'::maxSize
_BSS	ENDS
CRT$XCU	SEGMENT
?gs_freeMemMgr$initializer$@@3P6AXXZA DD FLAT:??__Egs_freeMemMgr@@YAXXZ ; gs_freeMemMgr$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R4?$CSingleton@VCLZO@@@@6B@
rdata$r	SEGMENT
??_R4?$CSingleton@VCLZO@@@@6B@ DD 00H			; CSingleton<CLZO>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CSingleton@VCLZO@@@@@8
	DD	FLAT:??_R3?$CSingleton@VCLZO@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CSingleton@VCLZO@@@@8
rdata$r	SEGMENT
??_R2?$CSingleton@VCLZO@@@@8 DD FLAT:??_R1A@?0A@EA@?$CSingleton@VCLZO@@@@8 ; CSingleton<CLZO>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CSingleton@VCLZO@@@@8
rdata$r	SEGMENT
??_R3?$CSingleton@VCLZO@@@@8 DD 00H			; CSingleton<CLZO>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CSingleton@VCLZO@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CSingleton@VCLZO@@@@@8
data$rs	SEGMENT
??_R0?AV?$CSingleton@VCLZO@@@@@8 DD FLAT:??_7type_info@@6B@ ; CSingleton<CLZO> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CSingleton@VCLZO@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CSingleton@VCLZO@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CSingleton@VCLZO@@@@8 DD FLAT:??_R0?AV?$CSingleton@VCLZO@@@@@8 ; CSingleton<CLZO>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CSingleton@VCLZO@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CLZO@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CLZO@@8 DD FLAT:??_R0?AVCLZO@@@8		; CLZO::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CLZO@@8
rdata$r	ENDS
;	COMDAT ??_R2CLZO@@8
rdata$r	SEGMENT
??_R2CLZO@@8 DD	FLAT:??_R1A@?0A@EA@CLZO@@8		; CLZO::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$CSingleton@VCLZO@@@@8
rdata$r	ENDS
;	COMDAT ??_R3CLZO@@8
rdata$r	SEGMENT
??_R3CLZO@@8 DD	00H					; CLZO::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CLZO@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCLZO@@@8
data$rs	SEGMENT
??_R0?AVCLZO@@@8 DD FLAT:??_7type_info@@6B@		; CLZO `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCLZO@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CLZO@@6B@
rdata$r	SEGMENT
??_R4CLZO@@6B@ DD 00H					; CLZO::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCLZO@@@8
	DD	FLAT:??_R3CLZO@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HNOINGEF@LZO?3?5cannot?5alloc?5memory@
CONST	SEGMENT
??_C@_0BJ@HNOINGEF@LZO?3?5cannot?5alloc?5memory@ DB 'LZO: cannot alloc me'
	DB	'mory', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CNLKBJA@LZO?3?5cannot?5initialize@
CONST	SEGMENT
??_C@_0BH@CNLKBJA@LZO?3?5cannot?5initialize@ DB 'LZO: cannot initialize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MGOIPKD@LZObject?3?5Size?5differs@
CONST	SEGMENT
??_C@_0BH@MGOIPKD@LZObject?3?5Size?5differs@ DB 'LZObject: Size differs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@JONLEDGH@LZObject?3?5Decompress?5failed?5?3?5r@
CONST	SEGMENT
??_C@_0DJ@JONLEDGH@LZObject?3?5Decompress?5failed?5?3?5r@ DB 'LZObject: D'
	DB	'ecompress failed : ret %d, CompressedSize %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JNKNGBBC@LZObject?3?5Decompress?5failed?$CIdec@
CONST	SEGMENT
??_C@_0CN@JNKNGBBC@LZObject?3?5Decompress?5failed?$CIdec@ DB 'LZObject: D'
	DB	'ecompress failed(decrypt) ret %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LOICJMKN@LZObject?3?5key?5incorrect@
CONST	SEGMENT
??_C@_0BI@LOICJMKN@LZObject?3?5key?5incorrect@ DB 'LZObject: key incorrec'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BHMEHIOE@LZObject?3?5not?5a?5valid?5data@
CONST	SEGMENT
??_C@_0BL@BHMEHIOE@LZObject?3?5not?5a?5valid?5data@ DB 'LZObject: not a v'
	DB	'alid data', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LNIOABIE@LZO?3?5lzo1x_999_compress?5failed@
CONST	SEGMENT
??_C@_0BP@LNIOABIE@LZO?3?5lzo1x_999_compress?5failed@ DB 'LZO: lzo1x_999_'
	DB	'compress failed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CLZO@@6B@
CONST	SEGMENT
??_7CLZO@@6B@ DD FLAT:??_R4CLZO@@6B@			; CLZO::`vftable'
	DD	FLAT:??_ECLZO@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CSingleton@VCLZO@@@@6B@
CONST	SEGMENT
??_7?$CSingleton@VCLZO@@@@6B@ DD FLAT:??_R4?$CSingleton@VCLZO@@@@6B@ ; CSingleton<CLZO>::`vftable'
	DD	FLAT:??_E?$CSingleton@VCLZO@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEPAPAEQAPAEABQAE@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEPAPAEQAPAEABQAE@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEPAPAEQAPAEABQAE@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEPAPAEQAPAEABQAE@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEPAPAEQAPAEABQAE@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEPAPAEQAPAEABQAE@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEPAPAEQAPAEABQAE@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEPAPAEQAPAEABQAE@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CLZO@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CLZO@@QAE@XZ$0
__ehfuncinfo$??0CLZO@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CLZO@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Decompress@CLZObject@@QAE_NPAK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Decompress@CLZObject@@QAE_NPAK@Z$0
__ehfuncinfo$?Decompress@CLZObject@@QAE_NPAK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Decompress@CLZObject@@QAE_NPAK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CLZObject@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAEPAPAE@std@@YAPAPAEPAPAE00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAEPAPAE@std@@YAPAPAEPAPAE00@Z PROC	; std::_Copy_memmove<unsigned char * *,unsigned char * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAEPAPAE@std@@YAPAPAEPAPAE00@Z ENDP	; std::_Copy_memmove<unsigned char * *,unsigned char * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAEV?$allocator@PAE@std@@@std@@YAPAPAEQAPAE0PAPAEAAV?$allocator@PAE@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAEV?$allocator@PAE@std@@@std@@YAPAPAEQAPAE0PAPAEAAV?$allocator@PAE@0@@Z PROC ; std::_Uninitialized_move<unsigned char * *,std::allocator<unsigned char *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAEPAPAE@std@@YAPAPAEPAPAE00@Z ; std::_Copy_memmove<unsigned char * *,unsigned char * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAEV?$allocator@PAE@std@@@std@@YAPAPAEQAPAE0PAPAEAAV?$allocator@PAE@0@@Z ENDP ; std::_Uninitialized_move<unsigned char * *,std::allocator<unsigned char *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAE@std@@@std@@YAXPAPAEQAPAEAAV?$allocator@PAE@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAE@std@@@std@@YAXPAPAEQAPAEAAV?$allocator@PAE@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAE@std@@@std@@YAXPAPAEQAPAEAAV?$allocator@PAE@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEPAPAEQAPAEABQAE@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEPAPAEQAPAEABQAE@Z PROC ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Emplace_reallocate<unsigned char * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEPAPAEQAPAEABQAE@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAEV?$allocator@PAE@std@@@std@@CAXXZ ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAEV?$allocator@PAE@std@@@std@@ABEII@Z ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAEV?$allocator@PAE@std@@@std@@YAPAPAEQAPAE0PAPAEAAV?$allocator@PAE@0@@Z ; std::_Uninitialized_move<unsigned char * *,std::allocator<unsigned char *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAEV?$allocator@PAE@std@@@std@@YAPAPAEQAPAE0PAPAEAAV?$allocator@PAE@0@@Z ; std::_Uninitialized_move<unsigned char * *,std::allocator<unsigned char *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAEV?$allocator@PAE@std@@@std@@YAPAPAEQAPAE0PAPAEAAV?$allocator@PAE@0@@Z ; std::_Uninitialized_move<unsigned char * *,std::allocator<unsigned char *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEPAPAEQAPAEABQAE@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAEV?$allocator@PAE@std@@@std@@AAEXPAPAE0@Z ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAE@std@@QAEXQAPAEI@Z ; std::allocator<unsigned char *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEPAPAEQAPAEABQAE@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEPAPAEQAPAEABQAE@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAEV?$allocator@PAE@std@@@std@@AAEXQAPAEII@Z ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEPAPAEQAPAEABQAE@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEPAPAEQAPAEABQAE@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEPAPAEQAPAEABQAE@Z ENDP ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Emplace_reallocate<unsigned char * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@AAEXABQAE@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@AAEXABQAE@Z PROC ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Emplace_back_with_unused_capacity<unsigned char * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@AAEXABQAE@Z ENDP ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Emplace_back_with_unused_capacity<unsigned char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEXABQAE@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEXABQAE@Z PROC ; std::vector<unsigned char *,std::allocator<unsigned char *> >::emplace_back<unsigned char * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@AAEXABQAE@Z ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Emplace_back_with_unused_capacity<unsigned char * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEPAPAEQAPAEABQAE@Z ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Emplace_reallocate<unsigned char * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEXABQAE@Z ENDP ; std::vector<unsigned char *,std::allocator<unsigned char *> >::emplace_back<unsigned char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ??1DecryptBuffer@@QAE@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
??1DecryptBuffer@@QAE@XZ PROC				; DecryptBuffer::~DecryptBuffer, COMDAT
; _this$ = ecx

; 240  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 241  : 		if (m_local_buf != m_buf)

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 c0 04	 add	 eax, 4
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00013	74 11		 je	 SHORT $LN4@DecryptBuf

; 242  : 		{
; 243  : 			dbg_printf("DecruptBuffer - FreeHeap\n");
; 244  : 			delete [] m_buf;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  0001d	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  00020	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00025	59		 pop	 ecx
$LN4@DecryptBuf:

; 245  : 		}
; 246  : 		else
; 247  : 		{
; 248  : 			dbg_printf("DecruptBuffer - FreeStack\n");
; 249  : 		}
; 250  : 	}

  00026	c9		 leave
  00027	c3		 ret	 0
??1DecryptBuffer@@QAE@XZ ENDP				; DecryptBuffer::~DecryptBuffer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ??0DecryptBuffer@@QAE@I@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
tv67 = -8						; size = 4
_this$ = -4						; size = 4
_size$ = 8						; size = 4
??0DecryptBuffer@@QAE@I@Z PROC				; DecryptBuffer::DecryptBuffer, COMDAT
; _this$ = ecx

; 218  : 	DecryptBuffer(unsigned size)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 219  : 	{
; 220  : 		static unsigned count = 0;
; 221  : 		static unsigned sum = 0;
; 222  : 		static unsigned maxSize = 0;
; 223  : 
; 224  : 		sum += size;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sum@?1???0DecryptBuffer@@QAE@I@Z@4IA ; `DecryptBuffer::DecryptBuffer'::`2'::sum
  0000e	03 45 08	 add	 eax, DWORD PTR _size$[ebp]
  00011	a3 00 00 00 00	 mov	 DWORD PTR ?sum@?1???0DecryptBuffer@@QAE@I@Z@4IA, eax ; `DecryptBuffer::DecryptBuffer'::`2'::sum

; 225  : 		count++;

  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ?count@?1???0DecryptBuffer@@QAE@I@Z@4IA ; `DecryptBuffer::DecryptBuffer'::`2'::count
  0001b	40		 inc	 eax
  0001c	a3 00 00 00 00	 mov	 DWORD PTR ?count@?1???0DecryptBuffer@@QAE@I@Z@4IA, eax ; `DecryptBuffer::DecryptBuffer'::`2'::count

; 226  : 
; 227  : 		maxSize = max(size, maxSize);

  00021	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00024	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?maxSize@?1???0DecryptBuffer@@QAE@I@Z@4IA ; `DecryptBuffer::DecryptBuffer'::`2'::maxSize
  0002a	76 08		 jbe	 SHORT $LN5@DecryptBuf
  0002c	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  0002f	89 45 f8	 mov	 DWORD PTR tv67[ebp], eax
  00032	eb 08		 jmp	 SHORT $LN6@DecryptBuf
$LN5@DecryptBuf:
  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ?maxSize@?1???0DecryptBuffer@@QAE@I@Z@4IA ; `DecryptBuffer::DecryptBuffer'::`2'::maxSize
  00039	89 45 f8	 mov	 DWORD PTR tv67[ebp], eax
$LN6@DecryptBuf:
  0003c	8b 45 f8	 mov	 eax, DWORD PTR tv67[ebp]
  0003f	a3 00 00 00 00	 mov	 DWORD PTR ?maxSize@?1???0DecryptBuffer@@QAE@I@Z@4IA, eax ; `DecryptBuffer::DecryptBuffer'::`2'::maxSize

; 228  : 		if (size >= LOCAL_BUF_SIZE)

  00044	81 7d 08 00 20
	00 00		 cmp	 DWORD PTR _size$[ebp], 8192 ; 00002000H
  0004b	72 16		 jb	 SHORT $LN2@DecryptBuf

; 229  : 		{
; 230  : 			m_buf = new char[size];

  0004d	ff 75 08	 push	 DWORD PTR _size$[ebp]
  00050	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00055	59		 pop	 ecx
  00056	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0005f	89 08		 mov	 DWORD PTR [eax], ecx

; 231  : 			dbg_printf("DecryptBuffer - AllocHeap %d max(%d) ave(%d)\n", size, maxSize/1024, sum/count);
; 232  : 		}

  00061	eb 0b		 jmp	 SHORT $LN1@DecryptBuf
$LN2@DecryptBuf:

; 233  : 		else
; 234  : 		{
; 235  : 			dbg_printf("DecryptBuffer - AllocStack %d max(%d) ave(%d)\n", size, maxSize/1024, sum/count);
; 236  : 			m_buf = m_local_buf;

  00063	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00066	83 c0 04	 add	 eax, 4
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@DecryptBuf:

; 237  : 		}
; 238  : 	}

  0006e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00071	c9		 leave
  00072	c2 04 00	 ret	 4
??0DecryptBuffer@@QAE@I@Z ENDP				; DecryptBuffer::DecryptBuffer
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__Fgs_freeMemMgr@@YAXXZ
text$yd	SEGMENT
??__Fgs_freeMemMgr@@YAXXZ PROC				; `dynamic atexit destructor for 'gs_freeMemMgr'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_freeMemMgr@@3VLZOFreeMemoryMgr@@A
  00008	e8 00 00 00 00	 call	 ??1LZOFreeMemoryMgr@@QAE@XZ ; LZOFreeMemoryMgr::~LZOFreeMemoryMgr
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fgs_freeMemMgr@@YAXXZ ENDP				; `dynamic atexit destructor for 'gs_freeMemMgr''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ??__Egs_freeMemMgr@@YAXXZ
text$di	SEGMENT
??__Egs_freeMemMgr@@YAXXZ PROC				; `dynamic initializer for 'gs_freeMemMgr'', COMDAT

; 64   : } gs_freeMemMgr;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_freeMemMgr@@3VLZOFreeMemoryMgr@@A
  00008	e8 00 00 00 00	 call	 ??0?$vector@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::vector<unsigned char *,std::allocator<unsigned char *> >::vector<unsigned char *,std::allocator<unsigned char *> >
  0000d	68 00 00 00 00	 push	 OFFSET ??__Fgs_freeMemMgr@@YAXXZ ; `dynamic atexit destructor for 'gs_freeMemMgr''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Egs_freeMemMgr@@YAXXZ ENDP				; `dynamic initializer for 'gs_freeMemMgr''
text$di	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAEV?$allocator@PAE@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAEV?$allocator@PAE@std@@@std@@CAXXZ PROC ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAEV?$allocator@PAE@std@@@std@@CAXXZ ENDP ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAEV?$allocator@PAE@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAEV?$allocator@PAE@std@@@std@@AAEXXZ PROC ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAE@std@@@std@@YAXPAPAEQAPAEAAV?$allocator@PAE@0@@Z ; std::_Destroy_range<std::allocator<unsigned char *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAEV?$allocator@PAE@std@@@std@@AAEXXZ ENDP ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAEV?$allocator@PAE@std@@@std@@AAEXQAPAEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAEV?$allocator@PAE@std@@@std@@AAEXQAPAEII@Z PROC ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAE@std@@@std@@YAXPAPAEQAPAEAAV?$allocator@PAE@0@@Z ; std::_Destroy_range<std::allocator<unsigned char *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAEV?$allocator@PAE@std@@@std@@AAEXQAPAEII@Z ENDP ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAEV?$allocator@PAE@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAEV?$allocator@PAE@std@@@std@@ABEII@Z PROC ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAEV?$allocator@PAE@std@@@std@@ABEII@Z ENDP ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAEV?$allocator@PAE@std@@@std@@AAEXPAPAE0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAEV?$allocator@PAE@std@@@std@@AAEXPAPAE0@Z PROC ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAE@std@@@std@@YAXPAPAEQAPAEAAV?$allocator@PAE@0@@Z ; std::_Destroy_range<std::allocator<unsigned char *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAEV?$allocator@PAE@std@@@std@@AAEXPAPAE0@Z ENDP ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEXXZ PROC ; std::vector<unsigned char *,std::allocator<unsigned char *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAE@std@@@std@@YAXPAPAEQAPAEAAV?$allocator@PAE@0@@Z ; std::_Destroy_range<std::allocator<unsigned char *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEXXZ ENDP ; std::vector<unsigned char *,std::allocator<unsigned char *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$vector@PAEV?$allocator@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$vector@PAEV?$allocator@PAE@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char *,std::allocator<unsigned char *> >::vector<unsigned char *,std::allocator<unsigned char *> >, COMDAT
; _this$ = ecx

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 20 00	 and	 DWORD PTR [eax], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 446  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 447  :     }

  00029	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	c9		 leave
  0002d	c3		 ret	 0
??0?$vector@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char *,std::allocator<unsigned char *> >::vector<unsigned char *,std::allocator<unsigned char *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAE@std@@QAEXQAPAEI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAE@std@@QAEXQAPAEI@Z PROC	; std::allocator<unsigned char *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAE@std@@QAEXQAPAEI@Z ENDP	; std::allocator<unsigned char *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ?Alloc@LZOFreeMemoryMgr@@QAEPAEI@Z
_TEXT	SEGMENT
$T1 = -72						; size = 4
$T2 = -68						; size = 4
_newMem$ = -64						; size = 4
$T3 = -60						; size = 4
_newMem$4 = -56						; size = 4
$T5 = -52						; size = 4
_freeMem$6 = -48					; size = 4
$T7 = -44						; size = 4
__Ptr$ = -40						; size = 4
__My_data$8 = -36					; size = 4
$T9 = -32						; size = 4
__My_data$10 = -28					; size = 4
_this$ = -24						; size = 4
tv90 = -20						; size = 4
__My_data$11 = -16					; size = 4
__Mylast$12 = -12					; size = 4
_this$ = -8						; size = 4
$T13 = -1						; size = 1
_capacity$ = 8						; size = 4
?Alloc@LZOFreeMemoryMgr@@QAEPAEI@Z PROC			; LZOFreeMemoryMgr::Alloc, COMDAT
; _this$ = ecx

; 28   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 		assert(capacity > 0);
; 30   : 		if (capacity < REUSING_CAPACITY)

  00009	81 7d 08 00 00
	01 00		 cmp	 DWORD PTR _capacity$[ebp], 65536 ; 00010000H
  00010	0f 83 a8 00 00
	00		 jae	 $LN2@Alloc
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00016	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00019	89 45 f0	 mov	 DWORD PTR __My_data$11[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  0001c	8b 45 f0	 mov	 eax, DWORD PTR __My_data$11[ebp]
  0001f	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$11[ebp]
  00022	8b 00		 mov	 eax, DWORD PTR [eax]
  00024	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00027	75 09		 jne	 SHORT $LN7@Alloc
  00029	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv90[ebp], 1
  00030	eb 04		 jmp	 SHORT $LN8@Alloc
$LN7@Alloc:
  00032	83 65 ec 00	 and	 DWORD PTR tv90[ebp], 0
$LN8@Alloc:
  00036	8a 45 ec	 mov	 al, BYTE PTR tv90[ebp]
  00039	88 45 ff	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp

; 32   : 			if (!m_freeVector.empty())

  0003c	0f b6 45 ff	 movzx	 eax, BYTE PTR $T13[ebp]
  00040	85 c0		 test	 eax, eax
  00042	75 61		 jne	 SHORT $LN3@Alloc
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  00044	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR __My_data$10[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  0004a	6a 04		 push	 4
  0004c	58		 pop	 eax
  0004d	6b c0 ff	 imul	 eax, eax, -1
  00050	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$10[ebp]
  00053	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  00056	89 45 e0	 mov	 DWORD PTR $T9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp

; 34   : 				BYTE* freeMem = m_freeVector.back();

  00059	8b 45 e0	 mov	 eax, DWORD PTR $T9[ebp]
  0005c	8b 00		 mov	 eax, DWORD PTR [eax]
  0005e	89 45 d0	 mov	 DWORD PTR _freeMem$6[ebp], eax

; 35   : 				m_freeVector.pop_back();

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1329 :         auto& _My_data   = _Mypair._Myval2;

  00067	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	89 45 dc	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1330 :         pointer& _Mylast = _My_data._Mylast;

  0006d	8b 45 dc	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00070	83 c0 04	 add	 eax, 4
  00073	89 45 f4	 mov	 DWORD PTR __Mylast$12[ebp], eax

; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1333 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1334 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1336 : 
; 1337 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  00076	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  00079	8b 00		 mov	 eax, DWORD PTR [eax]
  0007b	83 e8 04	 sub	 eax, 4
  0007e	89 45 d8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00081	8b 45 d8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00084	89 45 bc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00087	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0008a	89 45 d4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0008d	8b 45 d4	 mov	 eax, DWORD PTR $T7[ebp]
  00090	89 45 b8	 mov	 DWORD PTR $T1[ebp], eax

; 1338 :         --_Mylast;

  00093	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  00096	8b 00		 mov	 eax, DWORD PTR [eax]
  00098	83 e8 04	 sub	 eax, 4
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR __Mylast$12[ebp]
  0009e	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp

; 38   : 				return freeMem;

  000a0	8b 45 d0	 mov	 eax, DWORD PTR _freeMem$6[ebp]
  000a3	eb 2e		 jmp	 SHORT $LN1@Alloc
$LN3@Alloc:

; 39   : 			}
; 40   : 			BYTE* newMem = new BYTE[REUSING_CAPACITY];

  000a5	68 00 00 01 00	 push	 65536			; 00010000H
  000aa	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000af	59		 pop	 ecx
  000b0	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
  000b3	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  000b6	89 45 c8	 mov	 DWORD PTR _newMem$4[ebp], eax

; 41   : 			dbg_printf("lzo.reuse_alloc\t%p(%d) real\n", newMem, capacity);
; 42   : 			return newMem;

  000b9	8b 45 c8	 mov	 eax, DWORD PTR _newMem$4[ebp]
  000bc	eb 15		 jmp	 SHORT $LN1@Alloc
$LN2@Alloc:

; 43   : 		}
; 44   : 		BYTE* newMem = new BYTE[capacity];

  000be	ff 75 08	 push	 DWORD PTR _capacity$[ebp]
  000c1	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000c6	59		 pop	 ecx
  000c7	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
  000ca	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  000cd	89 45 c0	 mov	 DWORD PTR _newMem$[ebp], eax

; 45   : 		dbg_printf("lzo.real_alloc\t%p(%d)\n", newMem, capacity);
; 46   : 		return newMem;

  000d0	8b 45 c0	 mov	 eax, DWORD PTR _newMem$[ebp]
$LN1@Alloc:

; 47   : 	}

  000d3	c9		 leave
  000d4	c2 04 00	 ret	 4
?Alloc@LZOFreeMemoryMgr@@QAEPAEI@Z ENDP			; LZOFreeMemoryMgr::Alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ??1LZOFreeMemoryMgr@@QAE@XZ
_TEXT	SEGMENT
$T1 = -72						; size = 4
$T2 = -68						; size = 4
$T3 = -64						; size = 4
$T4 = -60						; size = 4
$T5 = -56						; size = 4
$T6 = -52						; size = 4
$T7 = -48						; size = 4
___param0$ = -44					; size = 4
$T8 = -40						; size = 4
$T9 = -36						; size = 4
___param0$ = -32					; size = 4
tv178 = -28						; size = 4
tv192 = -24						; size = 4
__My_data$10 = -20					; size = 4
__My_data$11 = -16					; size = 4
_this$ = -12						; size = 4
_i$ = -8						; size = 4
$T12 = -2						; size = 1
$T13 = -1						; size = 1
??1LZOFreeMemoryMgr@@QAE@XZ PROC			; LZOFreeMemoryMgr::~LZOFreeMemoryMgr, COMDAT
; _this$ = ecx

; 20   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  00009	83 65 f8 00	 and	 DWORD PTR _i$[ebp], 0

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0000d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00010	89 45 f0	 mov	 DWORD PTR __My_data$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00013	8b 45 f0	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00016	89 45 bc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00019	8b 45 f0	 mov	 eax, DWORD PTR __My_data$11[ebp]
  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 dc	 mov	 DWORD PTR $T9[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00027	8d 45 dc	 lea	 eax, DWORD PTR $T9[ebp]
  0002a	89 45 d8	 mov	 DWORD PTR $T8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp

; 22   : 		for (i = m_freeVector.begin(); i != m_freeVector.end(); ++i)

  0002d	8b 45 d8	 mov	 eax, DWORD PTR $T8[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00035	eb 09		 jmp	 SHORT $LN4@LZOFreeMem
$LN2@LZOFreeMem:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00037	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0003a	83 c0 04	 add	 eax, 4
  0003d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@LZOFreeMem:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00040	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 ec	 mov	 DWORD PTR __My_data$10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00046	8b 45 ec	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00049	89 45 b8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0004c	8b 45 ec	 mov	 eax, DWORD PTR __My_data$10[ebp]
  0004f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00052	89 45 d4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00055	8b 45 d4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00058	89 45 d0	 mov	 DWORD PTR $T7[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0005b	8d 45 d0	 lea	 eax, DWORD PTR $T7[ebp]
  0005e	89 45 cc	 mov	 DWORD PTR $T6[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00061	8b 45 cc	 mov	 eax, DWORD PTR $T6[ebp]
  00064	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00067	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00069	75 09		 jne	 SHORT $LN55@LZOFreeMem
  0006b	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv192[ebp], 1
  00072	eb 04		 jmp	 SHORT $LN56@LZOFreeMem
$LN55@LZOFreeMem:
  00074	83 65 e8 00	 and	 DWORD PTR tv192[ebp], 0
$LN56@LZOFreeMem:
  00078	8a 45 e8	 mov	 al, BYTE PTR tv192[ebp]
  0007b	88 45 ff	 mov	 BYTE PTR $T13[ebp], al

; 153  :         return !(*this == _Right);

  0007e	0f b6 45 ff	 movzx	 eax, BYTE PTR $T13[ebp]
  00082	85 c0		 test	 eax, eax
  00084	75 09		 jne	 SHORT $LN50@LZOFreeMem
  00086	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv178[ebp], 1
  0008d	eb 04		 jmp	 SHORT $LN51@LZOFreeMem
$LN50@LZOFreeMem:
  0008f	83 65 e4 00	 and	 DWORD PTR tv178[ebp], 0
$LN51@LZOFreeMem:
  00093	8a 45 e4	 mov	 al, BYTE PTR tv178[ebp]
  00096	88 45 fe	 mov	 BYTE PTR $T12[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp

; 22   : 		for (i = m_freeVector.begin(); i != m_freeVector.end(); ++i)

  00099	0f b6 45 fe	 movzx	 eax, BYTE PTR $T12[ebp]
  0009d	85 c0		 test	 eax, eax
  0009f	74 25		 je	 SHORT $LN3@LZOFreeMem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000a1	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000a4	89 45 c8	 mov	 DWORD PTR $T5[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  000a7	8b 45 c8	 mov	 eax, DWORD PTR $T5[ebp]
  000aa	89 45 c4	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp

; 23   : 			delete *i;

  000ad	8b 45 c4	 mov	 eax, DWORD PTR $T4[ebp]
  000b0	8b 00		 mov	 eax, DWORD PTR [eax]
  000b2	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
  000b5	6a 01		 push	 1
  000b7	ff 75 c0	 push	 DWORD PTR $T3[ebp]
  000ba	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000bf	59		 pop	 ecx
  000c0	59		 pop	 ecx
  000c1	e9 71 ff ff ff	 jmp	 $LN2@LZOFreeMem
$LN3@LZOFreeMem:

; 24   : 
; 25   : 		m_freeVector.clear();

  000c6	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?clear@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEXXZ ; std::vector<unsigned char *,std::allocator<unsigned char *> >::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  000ce	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d1	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAEV?$allocator@PAE@std@@@std@@AAEXXZ ; std::vector<unsigned char *,std::allocator<unsigned char *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp

; 26   : 	}

  000d6	c9		 leave
  000d7	c3		 ret	 0
??1LZOFreeMemoryMgr@@QAE@XZ ENDP			; LZOFreeMemoryMgr::~LZOFreeMemoryMgr
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCLZO@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCLZO@@UAEPAXI@Z PROC				; CLZO::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CLZO@@UAE@XZ		; CLZO::~CLZO
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 08		 push	 8
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_GCLZO@@UAEPAXI@Z ENDP				; CLZO::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ?GetWorkMemory@CLZO@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWorkMemory@CLZO@@QAEPAEXZ PROC			; CLZO::GetWorkMemory, COMDAT
; _this$ = ecx

; 408  : {   

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 409  :     return m_pWorkMem;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 410  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetWorkMemory@CLZO@@QAEPAEXZ ENDP			; CLZO::GetWorkMemory
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ?Decompress@CLZO@@QAE_NAAVCLZObject@@PBEPAK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rObj$ = 8						; size = 4
_pbBuf$ = 12						; size = 4
_pdwKey$ = 16						; size = 4
?Decompress@CLZO@@QAE_NAAVCLZObject@@PBEPAK@Z PROC	; CLZO::Decompress, COMDAT
; _this$ = ecx

; 396  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 397  :     if (!rObj.BeginDecompress(pbBuf))

  00007	ff 75 0c	 push	 DWORD PTR _pbBuf$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _rObj$[ebp]
  0000d	e8 00 00 00 00	 call	 ?BeginDecompress@CLZObject@@QAE_NPBX@Z ; CLZObject::BeginDecompress
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	75 04		 jne	 SHORT $LN2@Decompress

; 398  : 		return false;

  00019	32 c0		 xor	 al, al
  0001b	eb 18		 jmp	 SHORT $LN1@Decompress
$LN2@Decompress:

; 399  : 	
; 400  :     if (!rObj.Decompress(pdwKey))

  0001d	ff 75 10	 push	 DWORD PTR _pdwKey$[ebp]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _rObj$[ebp]
  00023	e8 00 00 00 00	 call	 ?Decompress@CLZObject@@QAE_NPAK@Z ; CLZObject::Decompress
  00028	0f b6 c0	 movzx	 eax, al
  0002b	85 c0		 test	 eax, eax
  0002d	75 04		 jne	 SHORT $LN3@Decompress

; 401  : 		return false;

  0002f	32 c0		 xor	 al, al
  00031	eb 02		 jmp	 SHORT $LN1@Decompress
$LN3@Decompress:

; 402  : 	
; 403  :     return true;

  00033	b0 01		 mov	 al, 1
$LN1@Decompress:

; 404  : }

  00035	c9		 leave
  00036	c2 0c 00	 ret	 12			; 0000000cH
?Decompress@CLZO@@QAE_NAAVCLZObject@@PBEPAK@Z ENDP	; CLZO::Decompress
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ?CompressEncryptedMemory@CLZO@@QAE_NAAVCLZObject@@PBXIPAK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rObj$ = 8						; size = 4
_pIn$ = 12						; size = 4
_uiInLen$ = 16						; size = 4
_pdwKey$ = 20						; size = 4
?CompressEncryptedMemory@CLZO@@QAE_NAAVCLZObject@@PBXIPAK@Z PROC ; CLZO::CompressEncryptedMemory, COMDAT
; _this$ = ecx

; 381  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 382  :     rObj.BeginCompress(pIn, uiInLen);

  00007	ff 75 10	 push	 DWORD PTR _uiInLen$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR _pIn$[ebp]
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _rObj$[ebp]
  00010	e8 00 00 00 00	 call	 ?BeginCompress@CLZObject@@QAEXPBXI@Z ; CLZObject::BeginCompress

; 383  : 	
; 384  :     if (rObj.Compress())

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _rObj$[ebp]
  00018	e8 00 00 00 00	 call	 ?Compress@CLZObject@@QAE_NXZ ; CLZObject::Compress
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	74 1a		 je	 SHORT $LN2@CompressEn

; 385  :     {
; 386  : 		if (rObj.Encrypt(pdwKey))

  00024	ff 75 14	 push	 DWORD PTR _pdwKey$[ebp]
  00027	8b 4d 08	 mov	 ecx, DWORD PTR _rObj$[ebp]
  0002a	e8 00 00 00 00	 call	 ?Encrypt@CLZObject@@QAE_NPAK@Z ; CLZObject::Encrypt
  0002f	0f b6 c0	 movzx	 eax, al
  00032	85 c0		 test	 eax, eax
  00034	74 04		 je	 SHORT $LN3@CompressEn

; 387  : 			return true;

  00036	b0 01		 mov	 al, 1
  00038	eb 06		 jmp	 SHORT $LN1@CompressEn
$LN3@CompressEn:

; 388  : 		
; 389  : 		return false;

  0003a	32 c0		 xor	 al, al
  0003c	eb 02		 jmp	 SHORT $LN1@CompressEn
$LN2@CompressEn:

; 390  :     }   
; 391  : 	
; 392  :     return false;

  0003e	32 c0		 xor	 al, al
$LN1@CompressEn:

; 393  : }   

  00040	c9		 leave
  00041	c2 10 00	 ret	 16			; 00000010H
?CompressEncryptedMemory@CLZO@@QAE_NAAVCLZObject@@PBXIPAK@Z ENDP ; CLZO::CompressEncryptedMemory
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ?CompressMemory@CLZO@@QAE_NAAVCLZObject@@PBXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rObj$ = 8						; size = 4
_pIn$ = 12						; size = 4
_uiInLen$ = 16						; size = 4
?CompressMemory@CLZO@@QAE_NAAVCLZObject@@PBXI@Z PROC	; CLZO::CompressMemory, COMDAT
; _this$ = ecx

; 375  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 376  :     rObj.BeginCompress(pIn, uiInLen);

  00007	ff 75 10	 push	 DWORD PTR _uiInLen$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR _pIn$[ebp]
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _rObj$[ebp]
  00010	e8 00 00 00 00	 call	 ?BeginCompress@CLZObject@@QAEXPBXI@Z ; CLZObject::BeginCompress

; 377  :     return rObj.Compress();

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _rObj$[ebp]
  00018	e8 00 00 00 00	 call	 ?Compress@CLZObject@@QAE_NXZ ; CLZObject::Compress

; 378  : }

  0001d	c9		 leave
  0001e	c2 0c 00	 ret	 12			; 0000000cH
?CompressMemory@CLZO@@QAE_NAAVCLZObject@@PBXI@Z ENDP	; CLZO::CompressMemory
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ??1CLZO@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CLZO@@UAE@XZ PROC					; CLZO::~CLZO, COMDAT
; _this$ = ecx

; 366  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CLZO@@6B@

; 367  :     if (m_pWorkMem)

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00017	74 13		 je	 SHORT $LN1@CLZO

; 368  :     {
; 369  : 		free(m_pWorkMem);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	ff 70 04	 push	 DWORD PTR [eax+4]
  0001f	e8 00 00 00 00	 call	 _free
  00024	59		 pop	 ecx

; 370  : 		m_pWorkMem = NULL;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	83 60 04 00	 and	 DWORD PTR [eax+4], 0
$LN1@CLZO:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h

; 19   : 	{ 

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CSingleton@VCLZO@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00035	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A, 0 ; CSingleton<CLZO>::ms_singleton
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp

; 372  : }

  0003c	c9		 leave
  0003d	c3		 ret	 0
??1CLZO@@UAE@XZ ENDP					; CLZO::~CLZO
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ??0CLZO@@QAE@XZ
_TEXT	SEGMENT
_offset$2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CLZO@@QAE@XZ PROC					; CLZO::CLZO, COMDAT
; _this$ = ecx

; 345  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CLZO@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h

; 12   : 	{ 

  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CSingleton@VCLZO@@@@6B@

; 13   : 		assert(!ms_singleton);
; 14   : 		int offset = (int) (T*) 1 - (int) (CSingleton <T>*) (T*) 1; 

  00030	33 c0		 xor	 eax, eax
  00032	89 45 ec	 mov	 DWORD PTR _offset$2[ebp], eax

; 15   : 		ms_singleton = (T*) ((int) this + offset);

  00035	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00038	03 45 ec	 add	 eax, DWORD PTR _offset$2[ebp]
  0003b	a3 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A, eax ; CSingleton<CLZO>::ms_singleton
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp

; 345  : {

  00040	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00044	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00047	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CLZO@@6B@

; 344  : CLZO::CLZO() : m_pWorkMem(NULL)

  0004d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00050	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 346  :     if (lzo_init() != LZO_E_OK)

  00054	6a 18		 push	 24			; 00000018H
  00056	6a 04		 push	 4
  00058	6a 04		 push	 4
  0005a	6a 04		 push	 4
  0005c	6a 04		 push	 4
  0005e	6a 04		 push	 4
  00060	6a 04		 push	 4
  00062	6a 04		 push	 4
  00064	6a 02		 push	 2
  00066	68 30 20 00 00	 push	 8240			; 00002030H
  0006b	e8 00 00 00 00	 call	 ___lzo_init_v2
  00070	83 c4 28	 add	 esp, 40			; 00000028H
  00073	85 c0		 test	 eax, eax
  00075	74 0d		 je	 SHORT $LN2@CLZO

; 347  :     {
; 348  : 		TraceError("LZO: cannot initialize");

  00077	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@CNLKBJA@LZO?3?5cannot?5initialize@
  0007c	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00081	59		 pop	 ecx

; 349  : 		return;

  00082	eb 25		 jmp	 SHORT $LN1@CLZO
$LN2@CLZO:

; 350  :     }
; 351  : 
; 352  : #if defined( LZO1X_999_MEM_COMPRESS )
; 353  :     m_pWorkMem = (BYTE *) malloc(LZO1X_999_MEM_COMPRESS);

  00084	68 00 00 07 00	 push	 458752			; 00070000H
  00089	e8 00 00 00 00	 call	 _malloc
  0008e	59		 pop	 ecx
  0008f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 354  : #else
; 355  :     m_pWorkMem = (BYTE *) malloc(LZO1X_1_MEM_COMPRESS);
; 356  : #endif
; 357  : 
; 358  :     if (NULL == m_pWorkMem)

  00095	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00098	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0009c	75 0b		 jne	 SHORT $LN1@CLZO

; 359  :     {
; 360  : 		TraceError("LZO: cannot alloc memory");

  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@HNOINGEF@LZO?3?5cannot?5alloc?5memory@
  000a3	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000a8	59		 pop	 ecx
$LN1@CLZO:

; 361  : 		return;
; 362  :     }
; 363  : }

  000a9	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000ad	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ba	59		 pop	 ecx
  000bb	c9		 leave
  000bc	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CLZO@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CSingleton@VCLZO@@@@UAE@XZ ; CSingleton<CLZO>::~CSingleton<CLZO>
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0CLZO@@QAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CLZO@@QAE@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CLZO@@QAE@XZ ENDP					; CLZO::CLZO
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h
;	COMDAT ??_G?$CSingleton@VCLZO@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CSingleton@VCLZO@@@@UAEPAXI@Z PROC		; CSingleton<CLZO>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 19   : 	{ 

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CSingleton@VCLZO@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00010	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A, 0 ; CSingleton<CLZO>::ms_singleton
  00017	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001a	83 e0 01	 and	 eax, 1
  0001d	74 0c		 je	 SHORT $LN2@scalar
  0001f	6a 04		 push	 4
  00021	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	59		 pop	 ecx
  0002a	59		 pop	 ecx
$LN2@scalar:
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c9		 leave
  0002f	c2 04 00	 ret	 4
??_G?$CSingleton@VCLZO@@@@UAEPAXI@Z ENDP		; CSingleton<CLZO>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h
;	COMDAT ??1?$CSingleton@VCLZO@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CSingleton@VCLZO@@@@UAE@XZ PROC			; CSingleton<CLZO>::~CSingleton<CLZO>, COMDAT
; _this$ = ecx

; 19   : 	{ 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CSingleton@VCLZO@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00010	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A, 0 ; CSingleton<CLZO>::ms_singleton

; 22   : 	}

  00017	c9		 leave
  00018	c3		 ret	 0
??1?$CSingleton@VCLZO@@@@UAE@XZ ENDP			; CSingleton<CLZO>::~CSingleton<CLZO>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ?Initialize@CLZObject@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Initialize@CLZObject@@AAEXXZ PROC			; CLZObject::Initialize, COMDAT
; _this$ = ecx

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 77   : 	m_bInBuffer = false;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 40 11 00	 mov	 BYTE PTR [eax+17], 0

; 78   :     m_pbBuffer = NULL;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 20 00	 and	 DWORD PTR [eax], 0

; 79   :     m_dwBufferSize = 0;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 80   : 
; 81   :     m_pHeader = NULL;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 82   :     m_pbIn = NULL;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 60 0c 00	 and	 DWORD PTR [eax+12], 0

; 83   :     m_bCompressed = false;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	c6 40 10 00	 mov	 BYTE PTR [eax+16], 0

; 84   : }

  00030	c9		 leave
  00031	c3		 ret	 0
?Initialize@CLZObject@@AAEXXZ ENDP			; CLZObject::Initialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ?AllocBuffer@CLZObject@@QAEXK@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
_capacity$ = -12					; size = 4
_ptr$ = -8						; size = 4
_this$ = -4						; size = 4
_dwSrcSize$ = 8						; size = 4
?AllocBuffer@CLZObject@@QAEXK@Z PROC			; CLZObject::AllocBuffer, COMDAT
; _this$ = ecx

; 329  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 330  :     if (m_pbBuffer && !m_bInBuffer)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 44		 je	 SHORT $LN2@AllocBuffe
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	0f b6 40 11	 movzx	 eax, BYTE PTR [eax+17]
  00018	85 c0		 test	 eax, eax
  0001a	75 39		 jne	 SHORT $LN2@AllocBuffe

; 331  : 		gs_freeMemMgr.Free(m_pbBuffer, m_dwBufferSize);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00022	89 45 f4	 mov	 DWORD PTR _capacity$[ebp], eax
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	89 45 f8	 mov	 DWORD PTR _ptr$[ebp], eax

; 52   : 		if (capacity < REUSING_CAPACITY)

  0002d	81 7d f4 00 00
	01 00		 cmp	 DWORD PTR _capacity$[ebp], 65536 ; 00010000H
  00034	73 10		 jae	 SHORT $LN5@AllocBuffe
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00036	8d 45 f8	 lea	 eax, DWORD PTR _ptr$[ebp]
  00039	50		 push	 eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_freeMemMgr@@3VLZOFreeMemoryMgr@@A
  0003f	e8 00 00 00 00	 call	 ??$emplace_back@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEXABQAE@Z ; std::vector<unsigned char *,std::allocator<unsigned char *> >::emplace_back<unsigned char * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp

; 56   : 			return;

  00044	eb 0f		 jmp	 SHORT $LN2@AllocBuffe
$LN5@AllocBuffe:

; 57   : 		}
; 58   : 
; 59   : 		dbg_printf("lzo.real_free\t%p(%d)\n", ptr, capacity);
; 60   : 		delete [] ptr;

  00046	8b 45 f8	 mov	 eax, DWORD PTR _ptr$[ebp]
  00049	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0004c	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  0004f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00054	59		 pop	 ecx
$LN2@AllocBuffe:

; 332  :     
; 333  :     m_pbBuffer = gs_freeMemMgr.Alloc(dwSrcSize);

  00055	ff 75 08	 push	 DWORD PTR _dwSrcSize$[ebp]
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_freeMemMgr@@3VLZOFreeMemoryMgr@@A
  0005d	e8 00 00 00 00	 call	 ?Alloc@LZOFreeMemoryMgr@@QAEPAEI@Z ; LZOFreeMemoryMgr::Alloc
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	89 01		 mov	 DWORD PTR [ecx], eax

; 334  : 	m_dwBufferSize = dwSrcSize;

  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _dwSrcSize$[ebp]
  0006d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 335  : }

  00070	c9		 leave
  00071	c2 04 00	 ret	 4
?AllocBuffer@CLZObject@@QAEXK@Z ENDP			; CLZObject::AllocBuffer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ?GetSize@CLZObject@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSize@CLZObject@@QAEKXZ PROC				; CLZObject::GetSize, COMDAT
; _this$ = ecx

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 106  : 	assert(m_pHeader);
; 107  : 
; 108  : 	if (m_bCompressed)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  0000e	85 c0		 test	 eax, eax
  00010	74 2c		 je	 SHORT $LN2@GetSize

; 109  : 	{
; 110  : 		if (m_pHeader->dwEncryptSize)

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0001c	74 10		 je	 SHORT $LN4@GetSize

; 111  : 			return sizeof(THeader) + sizeof(DWORD) + m_pHeader->dwEncryptSize;

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00024	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00027	83 c0 14	 add	 eax, 20			; 00000014H
  0002a	eb 1b		 jmp	 SHORT $LN1@GetSize
  0002c	eb 0e		 jmp	 SHORT $LN5@GetSize
$LN4@GetSize:

; 112  : 		else
; 113  : 			return sizeof(THeader) + sizeof(DWORD) + m_pHeader->dwCompressedSize;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00034	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00037	83 c0 14	 add	 eax, 20			; 00000014H
  0003a	eb 0b		 jmp	 SHORT $LN1@GetSize
$LN5@GetSize:

; 114  : 	}

  0003c	eb 09		 jmp	 SHORT $LN1@GetSize
$LN2@GetSize:

; 115  : 	else
; 116  : 		return m_pHeader->dwRealSize;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00044	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
$LN1@GetSize:

; 117  : }

  00047	c9		 leave
  00048	c3		 ret	 0
?GetSize@CLZObject@@QAEKXZ ENDP				; CLZObject::GetSize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ?__Decrypt@CLZObject@@QAE_NPAKPAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_key$ = 8						; size = 4
_data$ = 12						; size = 4
?__Decrypt@CLZObject@@QAE_NPAKPAE@Z PROC		; CLZObject::__Decrypt, COMDAT
; _this$ = ecx

; 321  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 322  :     assert(m_pbBuffer);
; 323  : 		
; 324  :     tea_decrypt((DWORD *) data, (const DWORD *) (m_pbIn - sizeof(DWORD)), key, m_pHeader->dwEncryptSize);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	ff 70 04	 push	 DWORD PTR [eax+4]
  00010	ff 75 08	 push	 DWORD PTR _key$[ebp]
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00019	83 e8 04	 sub	 eax, 4
  0001c	50		 push	 eax
  0001d	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  00020	e8 00 00 00 00	 call	 _tea_decrypt
  00025	83 c4 10	 add	 esp, 16			; 00000010H

; 325  :     return true;

  00028	b0 01		 mov	 al, 1

; 326  : }

  0002a	c9		 leave
  0002b	c2 08 00	 ret	 8
?__Decrypt@CLZObject@@QAE_NPAKPAE@Z ENDP		; CLZObject::__Decrypt
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ?Encrypt@CLZObject@@QAE_NPAK@Z
_TEXT	SEGMENT
_pbBuffer$ = -8						; size = 4
_this$ = -4						; size = 4
_pdwKey$ = 8						; size = 4
?Encrypt@CLZObject@@QAE_NPAK@Z PROC			; CLZObject::Encrypt, COMDAT
; _this$ = ecx

; 308  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 309  :     if (!m_bCompressed)

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  0000f	85 c0		 test	 eax, eax
  00011	75 04		 jne	 SHORT $LN2@Encrypt

; 310  :     {
; 311  : 		assert(!"not compressed yet");
; 312  : 		return false;

  00013	32 c0		 xor	 al, al
  00015	eb 34		 jmp	 SHORT $LN1@Encrypt
$LN2@Encrypt:

; 313  :     }
; 314  : 	
; 315  :     BYTE * pbBuffer = m_pbBuffer + sizeof(THeader);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	83 c0 10	 add	 eax, 16			; 00000010H
  0001f	89 45 f8	 mov	 DWORD PTR _pbBuffer$[ebp], eax

; 316  :     m_pHeader->dwEncryptSize = tea_encrypt((DWORD *) pbBuffer, (const DWORD *) pbBuffer, pdwKey, m_pHeader->dwCompressedSize + 19);

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00028	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002b	83 c0 13	 add	 eax, 19			; 00000013H
  0002e	50		 push	 eax
  0002f	ff 75 08	 push	 DWORD PTR _pdwKey$[ebp]
  00032	ff 75 f8	 push	 DWORD PTR _pbBuffer$[ebp]
  00035	ff 75 f8	 push	 DWORD PTR _pbBuffer$[ebp]
  00038	e8 00 00 00 00	 call	 _tea_encrypt
  0003d	83 c4 10	 add	 esp, 16			; 00000010H
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00046	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 317  :     return true;

  00049	b0 01		 mov	 al, 1
$LN1@Encrypt:

; 318  : }

  0004b	c9		 leave
  0004c	c2 04 00	 ret	 4
?Encrypt@CLZObject@@QAE_NPAK@Z ENDP			; CLZObject::Encrypt
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ?Decompress@CLZObject@@QAE_NPAK@Z
_TEXT	SEGMENT
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
_uiSize$ = -32						; size = 4
_pbDecryptedBuffer$5 = -28				; size = 4
_r$ = -24						; size = 4
$T6 = -18						; size = 1
$T7 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_buf$8 = 0						; size = 8196
__$ArrayPad$ = 8196					; size = 4
_pdwKey$ = 8208						; size = 4
?Decompress@CLZObject@@QAE_NPAK@Z PROC			; CLZObject::Decompress, COMDAT
; _this$ = ecx

; 262  : {

  00000	55		 push	 ebp
  00001	8d ac 24 f8 df
	ff ff		 lea	 ebp, DWORD PTR [esp-8200]
  00008	b8 08 20 00 00	 mov	 eax, 8200		; 00002008H
  0000d	e8 00 00 00 00	 call	 __chkstk
  00012	6a ff		 push	 -1
  00014	68 00 00 00 00	 push	 __ehhandler$?Decompress@CLZObject@@QAE_NPAK@Z
  00019	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001f	50		 push	 eax
  00020	83 ec 20	 sub	 esp, 32			; 00000020H
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00028	33 c5		 xor	 eax, ebp
  0002a	89 85 04 20 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 263  :     UINT uiSize;
; 264  :     int r;
; 265  : 	
; 266  :     if (m_pHeader->dwEncryptSize)

  0003d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00043	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00047	0f 84 ea 00 00
	00		 je	 $LN2@Decompress

; 267  :     {
; 268  : 		DecryptBuffer buf(m_pHeader->dwEncryptSize);

  0004d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00053	ff 70 04	 push	 DWORD PTR [eax+4]
  00056	8d 4d 00	 lea	 ecx, DWORD PTR _buf$8[ebp]
  00059	e8 00 00 00 00	 call	 ??0DecryptBuffer@@QAE@I@Z ; DecryptBuffer::DecryptBuffer
  0005e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 253  : 		return m_buf;

  00062	8b 45 00	 mov	 eax, DWORD PTR _buf$8[ebp]
  00065	89 45 e4	 mov	 DWORD PTR _pbDecryptedBuffer$5[ebp], eax

; 269  : 
; 270  : 		BYTE* pbDecryptedBuffer = (BYTE*)buf.GetBufferPtr();
; 271  : 			
; 272  : 		__Decrypt(pdwKey, pbDecryptedBuffer);

  00068	ff 75 e4	 push	 DWORD PTR _pbDecryptedBuffer$5[ebp]
  0006b	ff b5 10 20 00
	00		 push	 DWORD PTR _pdwKey$[ebp]
  00071	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	e8 00 00 00 00	 call	 ?__Decrypt@CLZObject@@QAE_NPAKPAE@Z ; CLZObject::__Decrypt

; 273  : 		
; 274  : 		if (*(DWORD *) pbDecryptedBuffer != ms_dwFourCC)

  00079	8b 45 e4	 mov	 eax, DWORD PTR _pbDecryptedBuffer$5[ebp]
  0007c	8b 00		 mov	 eax, DWORD PTR [eax]
  0007e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?ms_dwFourCC@CLZObject@@2KA ; CLZObject::ms_dwFourCC
  00084	74 32		 je	 SHORT $LN4@Decompress

; 275  : 		{
; 276  : 			TraceError("LZObject: key incorrect");

  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@LOICJMKN@LZObject?3?5key?5incorrect@
  0008b	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00090	59		 pop	 ecx

; 277  : 			return false;

  00091	c6 45 ef 00	 mov	 BYTE PTR $T7[ebp], 0
  00095	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 241  : 		if (m_local_buf != m_buf)

  00099	8d 45 04	 lea	 eax, DWORD PTR _buf$8[ebp+4]
  0009c	3b 45 00	 cmp	 eax, DWORD PTR _buf$8[ebp]
  0009f	74 0f		 je	 SHORT $LN21@Decompress

; 242  : 		{
; 243  : 			dbg_printf("DecruptBuffer - FreeHeap\n");
; 244  : 			delete [] m_buf;

  000a1	8b 45 00	 mov	 eax, DWORD PTR _buf$8[ebp]
  000a4	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
  000a7	ff 75 dc	 push	 DWORD PTR $T4[ebp]
  000aa	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000af	59		 pop	 ecx
$LN21@Decompress:

; 277  : 			return false;

  000b0	8a 45 ef	 mov	 al, BYTE PTR $T7[ebp]
  000b3	e9 f2 00 00 00	 jmp	 $LN1@Decompress
$LN4@Decompress:

; 278  : 		}
; 279  : 		
; 280  : 		if (LZO_E_OK != (r = lzo1x_decompress(pbDecryptedBuffer + sizeof(DWORD), m_pHeader->dwCompressedSize, m_pbBuffer, (lzo_uint*) &uiSize, NULL)))

  000b8	6a 00		 push	 0
  000ba	8d 45 e0	 lea	 eax, DWORD PTR _uiSize$[ebp]
  000bd	50		 push	 eax
  000be	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c1	ff 30		 push	 DWORD PTR [eax]
  000c3	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c9	ff 70 08	 push	 DWORD PTR [eax+8]
  000cc	8b 45 e4	 mov	 eax, DWORD PTR _pbDecryptedBuffer$5[ebp]
  000cf	83 c0 04	 add	 eax, 4
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 _lzo1x_decompress
  000d8	83 c4 14	 add	 esp, 20			; 00000014H
  000db	89 45 e8	 mov	 DWORD PTR _r$[ebp], eax
  000de	83 7d e8 00	 cmp	 DWORD PTR _r$[ebp], 0
  000e2	74 36		 je	 SHORT $LN5@Decompress

; 281  : 		{
; 282  : 			TraceError("LZObject: Decompress failed(decrypt) ret %d\n", r);

  000e4	ff 75 e8	 push	 DWORD PTR _r$[ebp]
  000e7	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@JNKNGBBC@LZObject?3?5Decompress?5failed?$CIdec@
  000ec	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000f1	59		 pop	 ecx
  000f2	59		 pop	 ecx

; 283  : 			return false;

  000f3	c6 45 ee 00	 mov	 BYTE PTR $T6[ebp], 0
  000f7	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 241  : 		if (m_local_buf != m_buf)

  000fb	8d 45 04	 lea	 eax, DWORD PTR _buf$8[ebp+4]
  000fe	3b 45 00	 cmp	 eax, DWORD PTR _buf$8[ebp]
  00101	74 0f		 je	 SHORT $LN26@Decompress

; 242  : 		{
; 243  : 			dbg_printf("DecruptBuffer - FreeHeap\n");
; 244  : 			delete [] m_buf;

  00103	8b 45 00	 mov	 eax, DWORD PTR _buf$8[ebp]
  00106	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
  00109	ff 75 d8	 push	 DWORD PTR $T3[ebp]
  0010c	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00111	59		 pop	 ecx
$LN26@Decompress:

; 283  : 			return false;

  00112	8a 45 ee	 mov	 al, BYTE PTR $T6[ebp]
  00115	e9 90 00 00 00	 jmp	 $LN1@Decompress
$LN5@Decompress:

; 284  : 		}
; 285  :     }

  0011a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 241  : 		if (m_local_buf != m_buf)

  0011e	8d 45 04	 lea	 eax, DWORD PTR _buf$8[ebp+4]
  00121	3b 45 00	 cmp	 eax, DWORD PTR _buf$8[ebp]
  00124	74 0f		 je	 SHORT $LN31@Decompress

; 242  : 		{
; 243  : 			dbg_printf("DecruptBuffer - FreeHeap\n");
; 244  : 			delete [] m_buf;

  00126	8b 45 00	 mov	 eax, DWORD PTR _buf$8[ebp]
  00129	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
  0012c	ff 75 d4	 push	 DWORD PTR $T2[ebp]
  0012f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00134	59		 pop	 ecx
$LN31@Decompress:

; 284  : 		}
; 285  :     }

  00135	eb 54		 jmp	 SHORT $LN3@Decompress
$LN2@Decompress:

; 286  :     else
; 287  :     {
; 288  : 		uiSize = m_pHeader->dwRealSize;

  00137	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0013a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0013d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00140	89 45 e0	 mov	 DWORD PTR _uiSize$[ebp], eax

; 289  : 		
; 290  : 		//if (LZO_E_OK != (r = lzo1x_decompress_safe(m_pbIn, m_pHeader->dwCompressedSize, m_pbBuffer, (lzo_uint*) &uiSize, NULL)))
; 291  : 		if (LZO_E_OK != (r = lzo1x_decompress(m_pbIn, m_pHeader->dwCompressedSize, m_pbBuffer, (lzo_uint*) &uiSize, NULL)))

  00143	6a 00		 push	 0
  00145	8d 45 e0	 lea	 eax, DWORD PTR _uiSize$[ebp]
  00148	50		 push	 eax
  00149	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0014c	ff 30		 push	 DWORD PTR [eax]
  0014e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00151	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00154	ff 70 08	 push	 DWORD PTR [eax+8]
  00157	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0015a	ff 70 0c	 push	 DWORD PTR [eax+12]
  0015d	e8 00 00 00 00	 call	 _lzo1x_decompress
  00162	83 c4 14	 add	 esp, 20			; 00000014H
  00165	89 45 e8	 mov	 DWORD PTR _r$[ebp], eax
  00168	83 7d e8 00	 cmp	 DWORD PTR _r$[ebp], 0
  0016c	74 1d		 je	 SHORT $LN3@Decompress

; 292  : 		{
; 293  : 			TraceError("LZObject: Decompress failed : ret %d, CompressedSize %d\n", r, m_pHeader->dwCompressedSize);

  0016e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00171	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00174	ff 70 08	 push	 DWORD PTR [eax+8]
  00177	ff 75 e8	 push	 DWORD PTR _r$[ebp]
  0017a	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@JONLEDGH@LZObject?3?5Decompress?5failed?5?3?5r@
  0017f	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00184	83 c4 0c	 add	 esp, 12			; 0000000cH

; 294  : 			return false;

  00187	32 c0		 xor	 al, al
  00189	eb 1f		 jmp	 SHORT $LN1@Decompress
$LN3@Decompress:

; 295  : 		}
; 296  :     }
; 297  : 	
; 298  :     if (uiSize != m_pHeader->dwRealSize)

  0018b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0018e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00191	8b 4d e0	 mov	 ecx, DWORD PTR _uiSize$[ebp]
  00194	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00197	74 0f		 je	 SHORT $LN7@Decompress

; 299  :     {
; 300  : 		TraceError("LZObject: Size differs");

  00199	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@MGOIPKD@LZObject?3?5Size?5differs@
  0019e	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  001a3	59		 pop	 ecx

; 301  : 		return false;

  001a4	32 c0		 xor	 al, al
  001a6	eb 02		 jmp	 SHORT $LN1@Decompress
$LN7@Decompress:

; 302  :     }
; 303  : 	
; 304  :     return true;

  001a8	b0 01		 mov	 al, 1
$LN1@Decompress:

; 305  : }

  001aa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001b4	59		 pop	 ecx
  001b5	8b 8d 04 20 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bb	33 cd		 xor	 ecx, ebp
  001bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c2	81 c5 08 20 00
	00		 add	 ebp, 8200		; 00002008H
  001c8	c9		 leave
  001c9	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Decompress@CLZObject@@QAE_NPAK@Z$0:
  00000	8d 4d 00	 lea	 ecx, DWORD PTR _buf$8[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1DecryptBuffer@@QAE@XZ ; DecryptBuffer::~DecryptBuffer
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?Decompress@CLZObject@@QAE_NPAK@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 8a 10 20 00
	00		 mov	 ecx, DWORD PTR [edx+8208]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Decompress@CLZObject@@QAE_NPAK@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Decompress@CLZObject@@QAE_NPAK@Z ENDP			; CLZObject::Decompress
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ?BeginDecompress@CLZObject@@QAE_NPBX@Z
_TEXT	SEGMENT
_pHeader$ = -8						; size = 4
_this$ = -4						; size = 4
_pvIn$ = 8						; size = 4
?BeginDecompress@CLZObject@@QAE_NPBX@Z PROC		; CLZObject::BeginDecompress, COMDAT
; _this$ = ecx

; 185  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 186  :     THeader * pHeader = (THeader *) pvIn;

  00008	8b 45 08	 mov	 eax, DWORD PTR _pvIn$[ebp]
  0000b	89 45 f8	 mov	 DWORD PTR _pHeader$[ebp], eax

; 187  : 
; 188  :     if (pHeader->dwFourCC != ms_dwFourCC)

  0000e	8b 45 f8	 mov	 eax, DWORD PTR _pHeader$[ebp]
  00011	8b 00		 mov	 eax, DWORD PTR [eax]
  00013	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?ms_dwFourCC@CLZObject@@2KA ; CLZObject::ms_dwFourCC
  00019	74 0f		 je	 SHORT $LN2@BeginDecom

; 189  :     {
; 190  : 		TraceError("LZObject: not a valid data");

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@BHMEHIOE@LZObject?3?5not?5a?5valid?5data@
  00020	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00025	59		 pop	 ecx

; 191  : 		return false;

  00026	32 c0		 xor	 al, al
  00028	eb 4d		 jmp	 SHORT $LN1@BeginDecom
$LN2@BeginDecom:

; 192  :     }
; 193  : 	
; 194  :     m_pHeader	= pHeader;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _pHeader$[ebp]
  00030	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 195  :     m_pbIn	= (const BYTE *) pvIn + (sizeof(THeader) + sizeof(DWORD));

  00033	8b 45 08	 mov	 eax, DWORD PTR _pvIn$[ebp]
  00036	83 c0 14	 add	 eax, 20			; 00000014H
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 196  : 
; 197  : 	/*
; 198  : 	static unsigned sum = 0;
; 199  : 	static unsigned count = 0;
; 200  : 	sum += pHeader->dwRealSize;
; 201  : 	count++;
; 202  : 	printf("decompress cur: %d, ave: %d\n", pHeader->dwRealSize, sum/count);
; 203  : 	*/
; 204  : 	m_dwBufferSize = pHeader->dwRealSize;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d f8	 mov	 ecx, DWORD PTR _pHeader$[ebp]
  00045	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00048	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 205  : 	m_pbBuffer = gs_freeMemMgr.Alloc(m_dwBufferSize);

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	ff 70 04	 push	 DWORD PTR [eax+4]
  00051	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_freeMemMgr@@3VLZOFreeMemoryMgr@@A
  00056	e8 00 00 00 00	 call	 ?Alloc@LZOFreeMemoryMgr@@QAEPAEI@Z ; LZOFreeMemoryMgr::Alloc
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	89 01		 mov	 DWORD PTR [ecx], eax

; 206  :     memset(m_pbBuffer, 0, pHeader->dwRealSize);

  00060	8b 45 f8	 mov	 eax, DWORD PTR _pHeader$[ebp]
  00063	ff 70 0c	 push	 DWORD PTR [eax+12]
  00066	6a 00		 push	 0
  00068	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	ff 30		 push	 DWORD PTR [eax]
  0006d	e8 00 00 00 00	 call	 _memset
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH

; 207  :     return true;

  00075	b0 01		 mov	 al, 1
$LN1@BeginDecom:

; 208  : }

  00077	c9		 leave
  00078	c2 04 00	 ret	 4
?BeginDecompress@CLZObject@@QAE_NPBX@Z ENDP		; CLZObject::BeginDecompress
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ?Compress@CLZObject@@QAE_NXZ
_TEXT	SEGMENT
_iOutLen$ = -20						; size = 4
_r$ = -16						; size = 4
$T1 = -12						; size = 4
_pbBuffer$ = -8						; size = 4
_this$ = -4						; size = 4
?Compress@CLZObject@@QAE_NXZ PROC			; CLZObject::Compress, COMDAT
; _this$ = ecx

; 159  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 160  :     UINT	iOutLen;
; 161  :     BYTE *	pbBuffer;
; 162  : 	
; 163  :     pbBuffer = m_pbBuffer + sizeof(THeader);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	83 c0 10	 add	 eax, 16			; 00000010H
  00011	89 45 f8	 mov	 DWORD PTR _pbBuffer$[ebp], eax

; 164  :     *(DWORD *) pbBuffer = ms_dwFourCC;

  00014	8b 45 f8	 mov	 eax, DWORD PTR _pbBuffer$[ebp]
  00017	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_dwFourCC@CLZObject@@2KA ; CLZObject::ms_dwFourCC
  0001d	89 08		 mov	 DWORD PTR [eax], ecx

; 165  :     pbBuffer += sizeof(DWORD);

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _pbBuffer$[ebp]
  00022	83 c0 04	 add	 eax, 4
  00025	89 45 f8	 mov	 DWORD PTR _pbBuffer$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A ; CSingleton<CLZO>::ms_singleton
  0002d	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp

; 168  :     int r = lzo1x_999_compress((BYTE *) m_pbIn, m_pHeader->dwRealSize, pbBuffer, (lzo_uint*) &iOutLen, CLZO::Instance().GetWorkMemory());

  00030	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00033	e8 00 00 00 00	 call	 ?GetWorkMemory@CLZO@@QAEPAEXZ ; CLZO::GetWorkMemory
  00038	50		 push	 eax
  00039	8d 45 ec	 lea	 eax, DWORD PTR _iOutLen$[ebp]
  0003c	50		 push	 eax
  0003d	ff 75 f8	 push	 DWORD PTR _pbBuffer$[ebp]
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00046	ff 70 0c	 push	 DWORD PTR [eax+12]
  00049	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	ff 70 0c	 push	 DWORD PTR [eax+12]
  0004f	e8 00 00 00 00	 call	 _lzo1x_999_compress
  00054	83 c4 14	 add	 esp, 20			; 00000014H
  00057	89 45 f0	 mov	 DWORD PTR _r$[ebp], eax

; 169  : #else
; 170  :     int r = lzo1x_1_compress((BYTE *) m_pbIn, m_pHeader->dwRealSize, pbBuffer, (lzo_uint*) &iOutLen, CLZO::Instance().GetWorkMemory());
; 171  : #endif
; 172  : 	
; 173  :     if (LZO_E_OK != r)

  0005a	83 7d f0 00	 cmp	 DWORD PTR _r$[ebp], 0
  0005e	74 0f		 je	 SHORT $LN2@Compress

; 174  :     {
; 175  : 		TraceError("LZO: lzo1x_999_compress failed");

  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@LNIOABIE@LZO?3?5lzo1x_999_compress?5failed@
  00065	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0006a	59		 pop	 ecx

; 176  : 		return false;

  0006b	32 c0		 xor	 al, al
  0006d	eb 15		 jmp	 SHORT $LN1@Compress
$LN2@Compress:

; 177  :     }
; 178  : 	
; 179  :     m_pHeader->dwCompressedSize = iOutLen;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00075	8b 4d ec	 mov	 ecx, DWORD PTR _iOutLen$[ebp]
  00078	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 180  :     m_bCompressed = true;

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	c6 40 10 01	 mov	 BYTE PTR [eax+16], 1

; 181  :     return true;

  00082	b0 01		 mov	 al, 1
$LN1@Compress:

; 182  : }

  00084	c9		 leave
  00085	c3		 ret	 0
?Compress@CLZObject@@QAE_NXZ ENDP			; CLZObject::Compress
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ?BeginCompressInBuffer@CLZObject@@QAEXPBXIPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pvIn$ = 8						; size = 4
_uiInLen$ = 12						; size = 4
___formal$ = 16						; size = 4
?BeginCompressInBuffer@CLZObject@@QAEXPBXIPAX@Z PROC	; CLZObject::BeginCompressInBuffer, COMDAT
; _this$ = ecx

; 139  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 140  :     m_pbIn = (const BYTE *) pvIn;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pvIn$[ebp]
  0000d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 141  : 	
; 142  :     // sizeof(SHeader) +
; 143  :     //   fourCC 4
; 144  :     //        +
; 145  :     //   8 
; 146  :     m_dwBufferSize = sizeof(THeader) + sizeof(DWORD) + (uiInLen + uiInLen / 64 + 16 + 3) + 8;

  00010	8b 45 0c	 mov	 eax, DWORD PTR _uiInLen$[ebp]
  00013	c1 e8 06	 shr	 eax, 6
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _uiInLen$[ebp]
  00019	8d 44 01 2f	 lea	 eax, DWORD PTR [ecx+eax+47]
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 147  : 	
; 148  :     m_pbBuffer = gs_freeMemMgr.Alloc(m_dwBufferSize);

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	ff 70 04	 push	 DWORD PTR [eax+4]
  00029	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_freeMemMgr@@3VLZOFreeMemoryMgr@@A
  0002e	e8 00 00 00 00	 call	 ?Alloc@LZOFreeMemoryMgr@@QAEPAEI@Z ; LZOFreeMemoryMgr::Alloc
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	89 01		 mov	 DWORD PTR [ecx], eax

; 149  :     memset(m_pbBuffer, 0, m_dwBufferSize);

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	ff 70 04	 push	 DWORD PTR [eax+4]
  0003e	6a 00		 push	 0
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	ff 30		 push	 DWORD PTR [eax]
  00045	e8 00 00 00 00	 call	 _memset
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 150  : 	
; 151  :     m_pHeader = (THeader *) m_pbBuffer;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00055	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 152  :     m_pHeader->dwFourCC = ms_dwFourCC;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_dwFourCC@CLZObject@@2KA ; CLZObject::ms_dwFourCC
  00064	89 08		 mov	 DWORD PTR [eax], ecx

; 153  :     m_pHeader->dwEncryptSize = m_pHeader->dwCompressedSize = m_pHeader->dwRealSize = 0;

  00066	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0006c	83 60 0c 00	 and	 DWORD PTR [eax+12], 0
  00070	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00076	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00080	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 154  :     m_pHeader->dwRealSize = uiInLen;

  00084	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00087	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0008a	8b 4d 0c	 mov	 ecx, DWORD PTR _uiInLen$[ebp]
  0008d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 155  : 	m_bInBuffer = true;

  00090	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00093	c6 40 11 01	 mov	 BYTE PTR [eax+17], 1

; 156  : }

  00097	c9		 leave
  00098	c2 0c 00	 ret	 12			; 0000000cH
?BeginCompressInBuffer@CLZObject@@QAEXPBXIPAX@Z ENDP	; CLZObject::BeginCompressInBuffer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ?BeginCompress@CLZObject@@QAEXPBXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pvIn$ = 8						; size = 4
_uiInLen$ = 12						; size = 4
?BeginCompress@CLZObject@@QAEXPBXI@Z PROC		; CLZObject::BeginCompress, COMDAT
; _this$ = ecx

; 120  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 121  :     m_pbIn = (const BYTE *) pvIn;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pvIn$[ebp]
  0000d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 122  : 	
; 123  :     // sizeof(SHeader) +
; 124  :     //   fourCC 4
; 125  :     //        +
; 126  :     //   8 
; 127  :     m_dwBufferSize = sizeof(THeader) + sizeof(DWORD) + (uiInLen + uiInLen / 64 + 16 + 3) + 8;

  00010	8b 45 0c	 mov	 eax, DWORD PTR _uiInLen$[ebp]
  00013	c1 e8 06	 shr	 eax, 6
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _uiInLen$[ebp]
  00019	8d 44 01 2f	 lea	 eax, DWORD PTR [ecx+eax+47]
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 128  : 	
; 129  :     m_pbBuffer = gs_freeMemMgr.Alloc(m_dwBufferSize);

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	ff 70 04	 push	 DWORD PTR [eax+4]
  00029	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_freeMemMgr@@3VLZOFreeMemoryMgr@@A
  0002e	e8 00 00 00 00	 call	 ?Alloc@LZOFreeMemoryMgr@@QAEPAEI@Z ; LZOFreeMemoryMgr::Alloc
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	89 01		 mov	 DWORD PTR [ecx], eax

; 130  :     memset(m_pbBuffer, 0, m_dwBufferSize);

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	ff 70 04	 push	 DWORD PTR [eax+4]
  0003e	6a 00		 push	 0
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	ff 30		 push	 DWORD PTR [eax]
  00045	e8 00 00 00 00	 call	 _memset
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 131  : 	
; 132  :     m_pHeader = (THeader *) m_pbBuffer;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00055	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 133  :     m_pHeader->dwFourCC = ms_dwFourCC;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_dwFourCC@CLZObject@@2KA ; CLZObject::ms_dwFourCC
  00064	89 08		 mov	 DWORD PTR [eax], ecx

; 134  :     m_pHeader->dwEncryptSize = m_pHeader->dwCompressedSize = m_pHeader->dwRealSize = 0;

  00066	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0006c	83 60 0c 00	 and	 DWORD PTR [eax+12], 0
  00070	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00076	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00080	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 135  :     m_pHeader->dwRealSize = uiInLen;

  00084	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00087	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0008a	8b 4d 0c	 mov	 ecx, DWORD PTR _uiInLen$[ebp]
  0008d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 136  : }

  00090	c9		 leave
  00091	c2 08 00	 ret	 8
?BeginCompress@CLZObject@@QAEXPBXI@Z ENDP		; CLZObject::BeginCompress
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ?Clear@CLZObject@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
_capacity$ = -12					; size = 4
_ptr$ = -8						; size = 4
_this$ = -4						; size = 4
?Clear@CLZObject@@QAEXXZ PROC				; CLZObject::Clear, COMDAT
; _this$ = ecx

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 88   :     if (m_pbBuffer && !m_bInBuffer)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 44		 je	 SHORT $LN3@Clear
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	0f b6 40 11	 movzx	 eax, BYTE PTR [eax+17]
  00018	85 c0		 test	 eax, eax
  0001a	75 39		 jne	 SHORT $LN3@Clear

; 89   : 		gs_freeMemMgr.Free(m_pbBuffer, m_dwBufferSize);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00022	89 45 f4	 mov	 DWORD PTR _capacity$[ebp], eax
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	89 45 f8	 mov	 DWORD PTR _ptr$[ebp], eax

; 52   : 		if (capacity < REUSING_CAPACITY)

  0002d	81 7d f4 00 00
	01 00		 cmp	 DWORD PTR _capacity$[ebp], 65536 ; 00010000H
  00034	73 10		 jae	 SHORT $LN6@Clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00036	8d 45 f8	 lea	 eax, DWORD PTR _ptr$[ebp]
  00039	50		 push	 eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_freeMemMgr@@3VLZOFreeMemoryMgr@@A
  0003f	e8 00 00 00 00	 call	 ??$emplace_back@ABQAE@?$vector@PAEV?$allocator@PAE@std@@@std@@QAEXABQAE@Z ; std::vector<unsigned char *,std::allocator<unsigned char *> >::emplace_back<unsigned char * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp

; 56   : 			return;

  00044	eb 0f		 jmp	 SHORT $LN3@Clear
$LN6@Clear:

; 57   : 		}
; 58   : 
; 59   : 		dbg_printf("lzo.real_free\t%p(%d)\n", ptr, capacity);
; 60   : 		delete [] ptr;

  00046	8b 45 f8	 mov	 eax, DWORD PTR _ptr$[ebp]
  00049	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0004c	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  0004f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00054	59		 pop	 ecx
$LN3@Clear:

; 90   : 	
; 91   : 	if (m_dwBufferSize > 0)
; 92   : 	{
; 93   : 		dbg_printf("lzo.free %d\n", m_dwBufferSize);
; 94   : 	}
; 95   : 
; 96   :     Initialize();

  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?Initialize@CLZObject@@AAEXXZ ; CLZObject::Initialize

; 97   : }

  0005d	c9		 leave
  0005e	c3		 ret	 0
?Clear@CLZObject@@QAEXXZ ENDP				; CLZObject::Clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ??1CLZObject@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CLZObject@@QAE@XZ PROC				; CLZObject::~CLZObject, COMDAT
; _this$ = ecx

; 100  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CLZObject@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 101  :     Clear();

  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?Clear@CLZObject@@QAEXXZ ; CLZObject::Clear

; 102  : }

  0002e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00031	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00038	59		 pop	 ecx
  00039	c9		 leave
  0003a	c3		 ret	 0
  0003b	cc		 int	 3
  0003c	cc		 int	 3
  0003d	cc		 int	 3
  0003e	cc		 int	 3
  0003f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CLZObject@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CLZObject@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CLZObject@@QAE@XZ ENDP				; CLZObject::~CLZObject
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.cpp
;	COMDAT ??0CLZObject@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CLZObject@@QAE@XZ PROC				; CLZObject::CLZObject, COMDAT
; _this$ = ecx

; 71   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 72   :     Initialize();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Initialize@CLZObject@@AAEXXZ ; CLZObject::Initialize

; 73   : }

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c9		 leave
  00013	c3		 ret	 0
??0CLZObject@@QAE@XZ ENDP				; CLZObject::CLZObject
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
