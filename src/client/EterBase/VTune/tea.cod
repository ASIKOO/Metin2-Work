; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\tea.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_tea_encrypt
PUBLIC	_tea_decrypt
PUBLIC	?tea_code@@YAXKKPBKPAK@Z			; tea_code
PUBLIC	?tea_decode@@YAXKKPBKPAK@Z			; tea_decode
EXTRN	_memset:PROC
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\tea.cpp
;	COMDAT ?tea_decode@@YAXKKPBKPAK@Z
_TEXT	SEGMENT
tv66 = -20						; size = 4
_n$ = -16						; size = 4
_z$ = -12						; size = 4
_y$ = -8						; size = 4
_sum$ = -4						; size = 4
_sz$ = 8						; size = 4
_sy$ = 12						; size = 4
_key$ = 16						; size = 4
_dest$ = 20						; size = 4
?tea_decode@@YAXKKPBKPAK@Z PROC				; tea_decode, COMDAT

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi

; 50   : #pragma warning(disable:4307)
; 51   : 	register unsigned long y = sy, z = sz, sum = DELTA * TEA_ROUND;

  00007	8b 45 0c	 mov	 eax, DWORD PTR _sy$[ebp]
  0000a	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax
  0000d	8b 45 08	 mov	 eax, DWORD PTR _sz$[ebp]
  00010	89 45 f4	 mov	 DWORD PTR _z$[ebp], eax
  00013	c7 45 fc 20 37
	ef c6		 mov	 DWORD PTR _sum$[ebp], -957401312 ; c6ef3720H

; 52   : #pragma warning(default:4307)
; 53   : 
; 54   : 	unsigned long		n = TEA_ROUND;

  0001a	c7 45 f0 20 00
	00 00		 mov	 DWORD PTR _n$[ebp], 32	; 00000020H
$LN2@tea_decode:

; 55   : 	
; 56   : 	while (n-- > 0)

  00021	8b 45 f0	 mov	 eax, DWORD PTR _n$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR tv66[ebp], eax
  00027	8b 45 f0	 mov	 eax, DWORD PTR _n$[ebp]
  0002a	48		 dec	 eax
  0002b	89 45 f0	 mov	 DWORD PTR _n$[ebp], eax
  0002e	83 7d ec 00	 cmp	 DWORD PTR tv66[ebp], 0
  00032	76 64		 jbe	 SHORT $LN3@tea_decode

; 57   : 	{
; 58   : 		z -= ((y << 4 ^ y >> 5) + y) ^ (sum + key[sum >> 11 & 3]);

  00034	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00037	c1 e0 04	 shl	 eax, 4
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _y$[ebp]
  0003d	c1 e9 05	 shr	 ecx, 5
  00040	33 c1		 xor	 eax, ecx
  00042	03 45 f8	 add	 eax, DWORD PTR _y$[ebp]
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _sum$[ebp]
  00048	c1 e9 0b	 shr	 ecx, 11			; 0000000bH
  0004b	83 e1 03	 and	 ecx, 3
  0004e	8b 55 10	 mov	 edx, DWORD PTR _key$[ebp]
  00051	8b 75 fc	 mov	 esi, DWORD PTR _sum$[ebp]
  00054	03 34 8a	 add	 esi, DWORD PTR [edx+ecx*4]
  00057	33 c6		 xor	 eax, esi
  00059	8b 4d f4	 mov	 ecx, DWORD PTR _z$[ebp]
  0005c	2b c8		 sub	 ecx, eax
  0005e	89 4d f4	 mov	 DWORD PTR _z$[ebp], ecx

; 59   : 		sum -= DELTA;

  00061	8b 45 fc	 mov	 eax, DWORD PTR _sum$[ebp]
  00064	05 47 86 c8 61	 add	 eax, 1640531527		; 61c88647H
  00069	89 45 fc	 mov	 DWORD PTR _sum$[ebp], eax

; 60   : 		y -= ((z << 4 ^ z >> 5) + z) ^ (sum + key[sum & 3]);

  0006c	8b 45 f4	 mov	 eax, DWORD PTR _z$[ebp]
  0006f	c1 e0 04	 shl	 eax, 4
  00072	8b 4d f4	 mov	 ecx, DWORD PTR _z$[ebp]
  00075	c1 e9 05	 shr	 ecx, 5
  00078	33 c1		 xor	 eax, ecx
  0007a	03 45 f4	 add	 eax, DWORD PTR _z$[ebp]
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _sum$[ebp]
  00080	83 e1 03	 and	 ecx, 3
  00083	8b 55 10	 mov	 edx, DWORD PTR _key$[ebp]
  00086	8b 75 fc	 mov	 esi, DWORD PTR _sum$[ebp]
  00089	03 34 8a	 add	 esi, DWORD PTR [edx+ecx*4]
  0008c	33 c6		 xor	 eax, esi
  0008e	8b 4d f8	 mov	 ecx, DWORD PTR _y$[ebp]
  00091	2b c8		 sub	 ecx, eax
  00093	89 4d f8	 mov	 DWORD PTR _y$[ebp], ecx

; 61   : 	}

  00096	eb 89		 jmp	 SHORT $LN2@tea_decode
$LN3@tea_decode:

; 62   : 	
; 63   : 	*(dest++)	= y;

  00098	8b 45 14	 mov	 eax, DWORD PTR _dest$[ebp]
  0009b	8b 4d f8	 mov	 ecx, DWORD PTR _y$[ebp]
  0009e	89 08		 mov	 DWORD PTR [eax], ecx
  000a0	8b 45 14	 mov	 eax, DWORD PTR _dest$[ebp]
  000a3	83 c0 04	 add	 eax, 4
  000a6	89 45 14	 mov	 DWORD PTR _dest$[ebp], eax

; 64   : 	*dest	= z;

  000a9	8b 45 14	 mov	 eax, DWORD PTR _dest$[ebp]
  000ac	8b 4d f4	 mov	 ecx, DWORD PTR _z$[ebp]
  000af	89 08		 mov	 DWORD PTR [eax], ecx

; 65   : }

  000b1	5e		 pop	 esi
  000b2	c9		 leave
  000b3	c3		 ret	 0
?tea_decode@@YAXKKPBKPAK@Z ENDP				; tea_decode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\tea.cpp
;	COMDAT ?tea_code@@YAXKKPBKPAK@Z
_TEXT	SEGMENT
tv66 = -20						; size = 4
_n$ = -16						; size = 4
_z$ = -12						; size = 4
_y$ = -8						; size = 4
_sum$ = -4						; size = 4
_sz$ = 8						; size = 4
_sy$ = 12						; size = 4
_key$ = 16						; size = 4
_dest$ = 20						; size = 4
?tea_code@@YAXKKPBKPAK@Z PROC				; tea_code, COMDAT

; 33   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi

; 34   : 	register unsigned long y = sy, z = sz, sum = 0;

  00007	8b 45 0c	 mov	 eax, DWORD PTR _sy$[ebp]
  0000a	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax
  0000d	8b 45 08	 mov	 eax, DWORD PTR _sz$[ebp]
  00010	89 45 f4	 mov	 DWORD PTR _z$[ebp], eax
  00013	83 65 fc 00	 and	 DWORD PTR _sum$[ebp], 0

; 35   : 	unsigned long		n = TEA_ROUND;

  00017	c7 45 f0 20 00
	00 00		 mov	 DWORD PTR _n$[ebp], 32	; 00000020H
$LN2@tea_code:

; 36   : 	
; 37   : 	while (n-- > 0)

  0001e	8b 45 f0	 mov	 eax, DWORD PTR _n$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR tv66[ebp], eax
  00024	8b 45 f0	 mov	 eax, DWORD PTR _n$[ebp]
  00027	48		 dec	 eax
  00028	89 45 f0	 mov	 DWORD PTR _n$[ebp], eax
  0002b	83 7d ec 00	 cmp	 DWORD PTR tv66[ebp], 0
  0002f	76 60		 jbe	 SHORT $LN3@tea_code

; 38   : 	{
; 39   : 		y	+= ((z << 4 ^ z >> 5) + z) ^ (sum + key[sum & 3]);

  00031	8b 45 f4	 mov	 eax, DWORD PTR _z$[ebp]
  00034	c1 e0 04	 shl	 eax, 4
  00037	8b 4d f4	 mov	 ecx, DWORD PTR _z$[ebp]
  0003a	c1 e9 05	 shr	 ecx, 5
  0003d	33 c1		 xor	 eax, ecx
  0003f	03 45 f4	 add	 eax, DWORD PTR _z$[ebp]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _sum$[ebp]
  00045	83 e1 03	 and	 ecx, 3
  00048	8b 55 10	 mov	 edx, DWORD PTR _key$[ebp]
  0004b	8b 75 fc	 mov	 esi, DWORD PTR _sum$[ebp]
  0004e	03 34 8a	 add	 esi, DWORD PTR [edx+ecx*4]
  00051	33 c6		 xor	 eax, esi
  00053	03 45 f8	 add	 eax, DWORD PTR _y$[ebp]
  00056	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax

; 40   : 		sum	+= DELTA;

  00059	8b 45 fc	 mov	 eax, DWORD PTR _sum$[ebp]
  0005c	2d 47 86 c8 61	 sub	 eax, 1640531527		; 61c88647H
  00061	89 45 fc	 mov	 DWORD PTR _sum$[ebp], eax

; 41   : 		z	+= ((y << 4 ^ y >> 5) + y) ^ (sum + key[sum >> 11 & 3]);

  00064	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00067	c1 e0 04	 shl	 eax, 4
  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _y$[ebp]
  0006d	c1 e9 05	 shr	 ecx, 5
  00070	33 c1		 xor	 eax, ecx
  00072	03 45 f8	 add	 eax, DWORD PTR _y$[ebp]
  00075	8b 4d fc	 mov	 ecx, DWORD PTR _sum$[ebp]
  00078	c1 e9 0b	 shr	 ecx, 11			; 0000000bH
  0007b	83 e1 03	 and	 ecx, 3
  0007e	8b 55 10	 mov	 edx, DWORD PTR _key$[ebp]
  00081	8b 75 fc	 mov	 esi, DWORD PTR _sum$[ebp]
  00084	03 34 8a	 add	 esi, DWORD PTR [edx+ecx*4]
  00087	33 c6		 xor	 eax, esi
  00089	03 45 f4	 add	 eax, DWORD PTR _z$[ebp]
  0008c	89 45 f4	 mov	 DWORD PTR _z$[ebp], eax

; 42   : 	}

  0008f	eb 8d		 jmp	 SHORT $LN2@tea_code
$LN3@tea_code:

; 43   : 	
; 44   : 	*(dest++)	= y;

  00091	8b 45 14	 mov	 eax, DWORD PTR _dest$[ebp]
  00094	8b 4d f8	 mov	 ecx, DWORD PTR _y$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx
  00099	8b 45 14	 mov	 eax, DWORD PTR _dest$[ebp]
  0009c	83 c0 04	 add	 eax, 4
  0009f	89 45 14	 mov	 DWORD PTR _dest$[ebp], eax

; 45   : 	*dest	= z;

  000a2	8b 45 14	 mov	 eax, DWORD PTR _dest$[ebp]
  000a5	8b 4d f4	 mov	 ecx, DWORD PTR _z$[ebp]
  000a8	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : }

  000aa	5e		 pop	 esi
  000ab	c9		 leave
  000ac	c3		 ret	 0
?tea_code@@YAXKKPBKPAK@Z ENDP				; tea_code
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\tea.cpp
;	COMDAT _tea_decrypt
_TEXT	SEGMENT
_resize$ = -8						; size = 4
_i$ = -4						; size = 4
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_key$ = 16						; size = 4
_size$ = 20						; size = 4
_tea_decrypt PROC					; COMDAT

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 88   : 	int		i;
; 89   : 	int		resize;
; 90   : 	
; 91   : 	if (size % 8 != 0)

  00005	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  00008	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0000d	79 05		 jns	 SHORT $LN8@tea_decryp
  0000f	48		 dec	 eax
  00010	83 c8 f8	 or	 eax, -8			; fffffff8H
  00013	40		 inc	 eax
$LN8@tea_decryp:
  00014	85 c0		 test	 eax, eax
  00016	74 1d		 je	 SHORT $LN5@tea_decryp

; 92   : 		resize = size + 8 - (size % 8);

  00018	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  0001b	83 c0 08	 add	 eax, 8
  0001e	8b 4d 14	 mov	 ecx, DWORD PTR _size$[ebp]
  00021	81 e1 07 00 00
	80		 and	 ecx, -2147483641	; 80000007H
  00027	79 05		 jns	 SHORT $LN9@tea_decryp
  00029	49		 dec	 ecx
  0002a	83 c9 f8	 or	 ecx, -8			; fffffff8H
  0002d	41		 inc	 ecx
$LN9@tea_decryp:
  0002e	2b c1		 sub	 eax, ecx
  00030	89 45 f8	 mov	 DWORD PTR _resize$[ebp], eax
  00033	eb 06		 jmp	 SHORT $LN6@tea_decryp
$LN5@tea_decryp:

; 93   : 	else
; 94   : 		resize = size;

  00035	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  00038	89 45 f8	 mov	 DWORD PTR _resize$[ebp], eax
$LN6@tea_decryp:

; 95   : 	
; 96   : 	for (i = 0; i < resize >> 3; i++, dest += 2, src += 2)

  0003b	83 65 fc 00	 and	 DWORD PTR _i$[ebp], 0
  0003f	eb 19		 jmp	 SHORT $LN4@tea_decryp
$LN2@tea_decryp:
  00041	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00044	40		 inc	 eax
  00045	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00048	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0004b	83 c0 08	 add	 eax, 8
  0004e	89 45 08	 mov	 DWORD PTR _dest$[ebp], eax
  00051	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00054	83 c0 08	 add	 eax, 8
  00057	89 45 0c	 mov	 DWORD PTR _src$[ebp], eax
$LN4@tea_decryp:
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _resize$[ebp]
  0005d	c1 f8 03	 sar	 eax, 3
  00060	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  00063	7d 1b		 jge	 SHORT $LN3@tea_decryp

; 97   : 		tea_decode(*(src + 1), *src, key, dest);

  00065	ff 75 08	 push	 DWORD PTR _dest$[ebp]
  00068	ff 75 10	 push	 DWORD PTR _key$[ebp]
  0006b	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0006e	ff 30		 push	 DWORD PTR [eax]
  00070	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00073	ff 70 04	 push	 DWORD PTR [eax+4]
  00076	e8 00 00 00 00	 call	 ?tea_decode@@YAXKKPBKPAK@Z ; tea_decode
  0007b	83 c4 10	 add	 esp, 16			; 00000010H
  0007e	eb c1		 jmp	 SHORT $LN2@tea_decryp
$LN3@tea_decryp:

; 98   : 	
; 99   : 	return (resize);

  00080	8b 45 f8	 mov	 eax, DWORD PTR _resize$[ebp]

; 100  : }

  00083	c9		 leave
  00084	c3		 ret	 0
_tea_decrypt ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\tea.cpp
;	COMDAT _tea_encrypt
_TEXT	SEGMENT
_i$ = -8						; size = 4
_resize$ = -4						; size = 4
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_key$ = 16						; size = 4
_size$ = 20						; size = 4
_tea_encrypt PROC					; COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 69   : 	int		i;
; 70   : 	int		resize;
; 71   : 	
; 72   : 	if (size % 8 != 0)

  00005	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  00008	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0000d	79 05		 jns	 SHORT $LN8@tea_encryp
  0000f	48		 dec	 eax
  00010	83 c8 f8	 or	 eax, -8			; fffffff8H
  00013	40		 inc	 eax
$LN8@tea_encryp:
  00014	85 c0		 test	 eax, eax
  00016	74 35		 je	 SHORT $LN5@tea_encryp

; 73   : 	{
; 74   : 		resize = size + 8 - (size % 8);

  00018	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  0001b	83 c0 08	 add	 eax, 8
  0001e	8b 4d 14	 mov	 ecx, DWORD PTR _size$[ebp]
  00021	81 e1 07 00 00
	80		 and	 ecx, -2147483641	; 80000007H
  00027	79 05		 jns	 SHORT $LN9@tea_encryp
  00029	49		 dec	 ecx
  0002a	83 c9 f8	 or	 ecx, -8			; fffffff8H
  0002d	41		 inc	 ecx
$LN9@tea_encryp:
  0002e	2b c1		 sub	 eax, ecx
  00030	89 45 fc	 mov	 DWORD PTR _resize$[ebp], eax

; 75   : 		memset((char *) src + size, 0, resize - size);

  00033	8b 45 fc	 mov	 eax, DWORD PTR _resize$[ebp]
  00036	2b 45 14	 sub	 eax, DWORD PTR _size$[ebp]
  00039	50		 push	 eax
  0003a	6a 00		 push	 0
  0003c	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0003f	03 45 14	 add	 eax, DWORD PTR _size$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _memset
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 76   : 	}

  0004b	eb 06		 jmp	 SHORT $LN6@tea_encryp
$LN5@tea_encryp:

; 77   : 	else
; 78   : 		resize = size;

  0004d	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  00050	89 45 fc	 mov	 DWORD PTR _resize$[ebp], eax
$LN6@tea_encryp:

; 79   : 	
; 80   : 	for (i = 0; i < resize >> 3; i++, dest += 2, src += 2)

  00053	83 65 f8 00	 and	 DWORD PTR _i$[ebp], 0
  00057	eb 19		 jmp	 SHORT $LN4@tea_encryp
$LN2@tea_encryp:
  00059	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0005c	40		 inc	 eax
  0005d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00060	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00063	83 c0 08	 add	 eax, 8
  00066	89 45 08	 mov	 DWORD PTR _dest$[ebp], eax
  00069	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0006c	83 c0 08	 add	 eax, 8
  0006f	89 45 0c	 mov	 DWORD PTR _src$[ebp], eax
$LN4@tea_encryp:
  00072	8b 45 fc	 mov	 eax, DWORD PTR _resize$[ebp]
  00075	c1 f8 03	 sar	 eax, 3
  00078	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  0007b	7d 1b		 jge	 SHORT $LN3@tea_encryp

; 81   : 		tea_code(*(src + 1), *src, key, dest);

  0007d	ff 75 08	 push	 DWORD PTR _dest$[ebp]
  00080	ff 75 10	 push	 DWORD PTR _key$[ebp]
  00083	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00086	ff 30		 push	 DWORD PTR [eax]
  00088	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0008b	ff 70 04	 push	 DWORD PTR [eax+4]
  0008e	e8 00 00 00 00	 call	 ?tea_code@@YAXKKPBKPAK@Z ; tea_code
  00093	83 c4 10	 add	 esp, 16			; 00000010H
  00096	eb c1		 jmp	 SHORT $LN2@tea_encryp
$LN3@tea_encryp:

; 82   : 	
; 83   : 	return (resize);

  00098	8b 45 fc	 mov	 eax, DWORD PTR _resize$[ebp]

; 84   : }

  0009b	c9		 leave
  0009c	c3		 ret	 0
_tea_encrypt ENDP
_TEXT	ENDS
END
