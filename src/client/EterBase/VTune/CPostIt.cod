; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__snprintf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??0CPostIt@@QAE@PBD@Z				; CPostIt::CPostIt
PUBLIC	??1CPostIt@@QAE@XZ				; CPostIt::~CPostIt
PUBLIC	?Flush@CPostIt@@QAEHXZ				; CPostIt::Flush
PUBLIC	?Empty@CPostIt@@QAEXXZ				; CPostIt::Empty
PUBLIC	?Get@CPostIt@@QAEHPBDPADK@Z			; CPostIt::Get
PUBLIC	?Set@CPostIt@@QAEHPBD@Z				; CPostIt::Set
PUBLIC	?Set@CPostIt@@QAEHPBD0@Z			; CPostIt::Set
PUBLIC	?Set@CPostIt@@QAEHPBDK@Z			; CPostIt::Set
PUBLIC	?CopyTo@CPostIt@@QAEHPAV1@PBD@Z			; CPostIt::CopyTo
PUBLIC	?Init@CPostIt@@IAEHPBD@Z			; CPostIt::Init
PUBLIC	?Destroy@CPostIt@@IAEXXZ			; CPostIt::Destroy
PUBLIC	??0_CPostItMemoryBlock@@QAE@XZ			; _CPostItMemoryBlock::_CPostItMemoryBlock
PUBLIC	??1_CPostItMemoryBlock@@QAE@XZ			; _CPostItMemoryBlock::~_CPostItMemoryBlock
PUBLIC	?Assign@_CPostItMemoryBlock@@QAEHPAX@Z		; _CPostItMemoryBlock::Assign
PUBLIC	?CreateHandle@_CPostItMemoryBlock@@QAEPAXXZ	; _CPostItMemoryBlock::CreateHandle
PUBLIC	?DestroyHandle@_CPostItMemoryBlock@@QAEHXZ	; _CPostItMemoryBlock::DestroyHandle
PUBLIC	?Find@_CPostItMemoryBlock@@QAEPADPBD@Z		; _CPostItMemoryBlock::Find
PUBLIC	?Put@_CPostItMemoryBlock@@QAEHPBD@Z		; _CPostItMemoryBlock::Put
PUBLIC	?Put@_CPostItMemoryBlock@@QAEHPBD0@Z		; _CPostItMemoryBlock::Put
PUBLIC	?Get@_CPostItMemoryBlock@@QAEHPBDPADK@Z		; _CPostItMemoryBlock::Get
PUBLIC	??0?$list@PADV?$allocator@PAD@std@@@std@@QAE@XZ	; std::list<char *,std::allocator<char *> >::list<char *,std::allocator<char *> >
PUBLIC	?begin@?$list@PADV?$allocator@PAD@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAD@std@@@std@@@2@XZ ; std::list<char *,std::allocator<char *> >::begin
PUBLIC	?erase@?$list@PADV?$allocator@PAD@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAD@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@PAD@std@@@std@@@2@@Z ; std::list<char *,std::allocator<char *> >::erase
PUBLIC	?_Tidy@?$list@PADV?$allocator@PAD@std@@@std@@AAEXXZ ; std::list<char *,std::allocator<char *> >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@PADV?$allocator@PAD@std@@@std@@AAEXXZ ; std::list<char *,std::allocator<char *> >::_Alloc_sentinel_and_proxy
PUBLIC	??$_Emplace@ABQAD@?$list@PADV?$allocator@PAD@std@@@std@@QAEPAU?$_List_node@PADPAX@1@QAU21@ABQAD@Z ; std::list<char *,std::allocator<char *> >::_Emplace<char * const &>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@PADPAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@PADPAX@0@0@Z ; std::_Construct_in_place<std::_List_node<char *,void *> *,std::_List_node<char *,void *> * &>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@?$_List_node@PADPAX@std@@SAXAAV?$allocator@U?$_List_node@PADPAX@std@@@1@PAU01@@Z ; std::_List_node<char *,void *>::_Free_non_head<std::allocator<std::_List_node<char *,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@?$_List_node@PADPAX@std@@SAXAAV?$allocator@U?$_List_node@PADPAX@std@@@1@PAU01@@Z ; std::_List_node<char *,void *>::_Freenode0<std::allocator<std::_List_node<char *,void *> > >
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<char *,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<char *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<char *,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<char *,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<char *,void *> > >
PUBLIC	?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAEPAU?$_List_node@PADPAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<char *,void *> > >::_Transfer_before
PUBLIC	??$?0ABQAD@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PADPAX@std@@@1@ABQAD@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<char *,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<char *,void *> > ><char * const &>
PUBLIC	??$_Destroy_in_place@PAU?$_List_node@PADPAX@std@@@std@@YAXAAPAU?$_List_node@PADPAX@0@@Z ; std::_Destroy_in_place<std::_List_node<char *,void *> *>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@PADPAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@PADPAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<char *,void *> *,std::_List_node<char *,void *> * const &>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_04LBFPPOKC@YMCF@				; `string'
PUBLIC	??_C@_05FEKNMKB@YMCF_@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_0O@NKNMEGII@list?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__strnicmp:PROC
EXTRN	_strncpy:PROC
EXTRN	__imp__GlobalAlloc@8:PROC
EXTRN	__imp__GlobalUnlock@4:PROC
EXTRN	__imp__GlobalLock@4:PROC
EXTRN	__imp__GlobalFree@4:PROC
EXTRN	__imp__OpenClipboard@4:PROC
EXTRN	__imp__CloseClipboard@0:PROC
EXTRN	__imp__SetClipboardData@8:PROC
EXTRN	__imp__GetClipboardData@4:PROC
EXTRN	__imp__RegisterClipboardFormatA@4:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0O@NKNMEGII@list?5too?5long@
CONST	SEGMENT
??_C@_0O@NKNMEGII@list?5too?5long@ DB 'list too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FEKNMKB@YMCF_@
CONST	SEGMENT
??_C@_05FEKNMKB@YMCF_@ DB 'YMCF_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBFPPOKC@YMCF@
CONST	SEGMENT
??_C@_04LBFPPOKC@YMCF@ DB 'YMCF', 00H			; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABQAD@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PADPAX@std@@@1@ABQAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABQAD@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PADPAX@std@@@1@ABQAD@Z$0
__ehfuncinfo$??$?0ABQAD@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PADPAX@std@@@1@ABQAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABQAD@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PADPAX@std@@@1@ABQAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Set@CPostIt@@QAEHPBD0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Set@CPostIt@@QAEHPBD0@Z$0
__ehfuncinfo$?Set@CPostIt@@QAEHPBD0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Set@CPostIt@@QAEHPBD0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Set@CPostIt@@QAEHPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Set@CPostIt@@QAEHPBD@Z$0
__ehfuncinfo$?Set@CPostIt@@QAEHPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Set@CPostIt@@QAEHPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Get@CPostIt@@QAEHPBDPADK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Get@CPostIt@@QAEHPBDPADK@Z$0
__ehfuncinfo$?Get@CPostIt@@QAEHPBDPADK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Get@CPostIt@@QAEHPBDPADK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CPostIt@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@PADPAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@PADPAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@PADPAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@PADPAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<char *,void *> *,std::_List_node<char *,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@PADPAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@PADPAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<char *,void *> *,std::_List_node<char *,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_List_node@PADPAX@std@@@std@@YAXAAPAU?$_List_node@PADPAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_List_node@PADPAX@std@@@std@@YAXAAPAU?$_List_node@PADPAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<char *,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_List_node@PADPAX@std@@@std@@YAXAAPAU?$_List_node@PADPAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<char *,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$?0ABQAD@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PADPAX@std@@@1@ABQAD@Z
_TEXT	SEGMENT
___formal$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
__Val$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
_<_Vals_0>$ = 12					; size = 4
??$?0ABQAD@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PADPAX@std@@@1@ABQAD@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<char *,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<char *,void *> > ><char * const &>, COMDAT
; _this$ = ecx

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABQAD@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PADPAX@std@@@1@ABQAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx
  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00037	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 586  :         this->_Allocate();

  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<char *,void *> > >::_Allocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00043	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00046	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  00049	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004f	83 c0 08	 add	 eax, 8
  00052	89 45 ec	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00055	8b 45 ec	 mov	 eax, DWORD PTR __Val$[ebp]
  00058	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0005b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 00		 mov	 eax, DWORD PTR [eax]
  00060	89 45 d8	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00063	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00066	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00069	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  0006c	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0006f	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00072	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  00075	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00077	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 588  :     }

  00079	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0007d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	c9		 leave
  0008c	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABQAD@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PADPAX@std@@@1@ABQAD@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<char *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<char *,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0ABQAD@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PADPAX@std@@@1@ABQAD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABQAD@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PADPAX@std@@@1@ABQAD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABQAD@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PADPAX@std@@@1@ABQAD@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<char *,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<char *,void *> > ><char * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAEPAU?$_List_node@PADPAX@2@QAU32@@Z
_TEXT	SEGMENT
__Insert_after$ = -12					; size = 4
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
__Insert_before$ = 8					; size = 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAEPAU?$_List_node@PADPAX@2@QAU32@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<char *,void *> > >::_Transfer_before, COMDAT
; _this$ = ecx

; 599  :     pointer _Transfer_before(const pointer _Insert_before) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 600  :         const pointer _Insert_after = _Insert_before->_Prev;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 45 f4	 mov	 DWORD PTR __Insert_after$[ebp], eax

; 601  :         _Construct_in_place(this->_Ptr->_Next, _Insert_before);

  00012	8d 45 08	 lea	 eax, DWORD PTR __Insert_before$[ebp]
  00015	50		 push	 eax
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@PADPAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@PADPAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<char *,void *> *,std::_List_node<char *,void *> * const &>
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx

; 602  :         _Construct_in_place(this->_Ptr->_Prev, _Insert_after);

  00023	8d 45 f4	 lea	 eax, DWORD PTR __Insert_after$[ebp]
  00026	50		 push	 eax
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	83 c0 04	 add	 eax, 4
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@PADPAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@PADPAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<char *,void *> *,std::_List_node<char *,void *> * const &>
  00036	59		 pop	 ecx
  00037	59		 pop	 ecx

; 603  :         const auto _Result    = this->_Ptr;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003e	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 604  :         this->_Ptr            = pointer{};

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 605  :         _Insert_before->_Prev = _Result;

  00048	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  0004e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 606  :         _Insert_after->_Next  = _Result;

  00051	8b 45 f4	 mov	 eax, DWORD PTR __Insert_after$[ebp]
  00054	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  00057	89 08		 mov	 DWORD PTR [eax], ecx

; 607  :         return _Result;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 608  :     }

  0005c	c9		 leave
  0005d	c2 04 00	 ret	 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAEPAU?$_List_node@PADPAX@2@QAU32@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<char *,void *> > >::_Transfer_before
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<char *,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<char *,void *> > >, COMDAT
; _this$ = ecx

; 590  :     ~_List_node_emplace_op2() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 591  :         if (this->_Ptr != pointer{}) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 12		 je	 SHORT $LN1@List_node_

; 592  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	83 c0 08	 add	 eax, 8
  0001b	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00021	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
$LN1@List_node_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 594  :     }

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<char *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<char *,void *> > >
  0002c	c9		 leave
  0002d	c3		 ret	 0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<char *,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<char *,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<char *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<char *,void *> > >, COMDAT
; _this$ = ecx

; 1056 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 22		 je	 SHORT $LN3@Alloc_cons

; 1058 :             _Al.deallocate(_Ptr, 1);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	6b c0 0c	 imul	 eax, eax, 12
  00029	50		 push	 eax
  0002a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN3@Alloc_cons:

; 1059 :         }
; 1060 :     }

  00034	c9		 leave
  00035	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<char *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<char *,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<char *,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1051 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1053 :         _Ptr = _Al.allocate(1);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00018	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001c	c7 45 e8 55 55
	55 15		 mov	 DWORD PTR __Max_possible$1[ebp], 357913941 ; 15555555H

; 60   :         if (_Count > _Max_possible) {

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  0002b	76 05		 jbe	 SHORT $LN6@Allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Allocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 0c	 imul	 eax, eax, 12
  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00043	59		 pop	 ecx
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1053 :         _Ptr = _Al.allocate(1);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Allocate:

; 1054 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<char *,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@?$_List_node@PADPAX@std@@SAXAAV?$allocator@U?$_List_node@PADPAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@?$_List_node@PADPAX@std@@SAXAAV?$allocator@U?$_List_node@PADPAX@std@@@1@PAU01@@Z PROC ; std::_List_node<char *,void *>::_Freenode0<std::allocator<std::_List_node<char *,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@PADPAX@std@@@std@@YAXAAPAU?$_List_node@PADPAX@0@@Z ; std::_Destroy_in_place<std::_List_node<char *,void *> *>
  0000b	59		 pop	 ecx

; 311  :         _Destroy_in_place(_Ptr->_Prev);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@PADPAX@std@@@std@@YAXAAPAU?$_List_node@PADPAX@0@@Z ; std::_Destroy_in_place<std::_List_node<char *,void *> *>
  00018	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00019	33 c0		 xor	 eax, eax
  0001b	40		 inc	 eax
  0001c	6b c0 0c	 imul	 eax, eax, 12
  0001f	50		 push	 eax
  00020	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 313  :     }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@?$_List_node@PADPAX@std@@SAXAAV?$allocator@U?$_List_node@PADPAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<char *,void *>::_Freenode0<std::allocator<std::_List_node<char *,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@?$_List_node@PADPAX@std@@SAXAAV?$allocator@U?$_List_node@PADPAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Pnext$2 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Al$ = 8						; size = 4
__Head$ = 12						; size = 4
??$_Free_non_head@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@?$_List_node@PADPAX@std@@SAXAAV?$allocator@U?$_List_node@PADPAX@std@@@1@PAU01@@Z PROC ; std::_List_node<char *,void *>::_Free_non_head<std::allocator<std::_List_node<char *,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 324  :         _Head->_Prev->_Next = nullptr;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	83 20 00	 and	 DWORD PTR [eax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  00017	eb 06		 jmp	 SHORT $LN4@Free_non_h
$LN2@Free_non_h:
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$2[ebp]
  0001c	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN4@Free_non_h:
  0001f	83 7d fc 00	 cmp	 DWORD PTR __Pnode$[ebp], 0
  00023	74 20		 je	 SHORT $LN5@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

  00025	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	89 45 f8	 mov	 DWORD PTR __Pnext$2[ebp], eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0002d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00030	83 c0 08	 add	 eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00033	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 318  :         _Freenode0(_Al, _Ptr);

  00036	ff 75 fc	 push	 DWORD PTR __Pnode$[ebp]
  00039	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@?$_List_node@PADPAX@std@@SAXAAV?$allocator@U?$_List_node@PADPAX@std@@@1@PAU01@@Z ; std::_List_node<char *,void *>::_Freenode0<std::allocator<std::_List_node<char *,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 329  :             _Freenode(_Al, _Pnode);
; 330  :         }

  00043	eb d4		 jmp	 SHORT $LN2@Free_non_h
$LN5@Free_non_h:

; 331  :     }

  00045	c9		 leave
  00046	c3		 ret	 0
??$_Free_non_head@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@?$_List_node@PADPAX@std@@SAXAAV?$allocator@U?$_List_node@PADPAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<char *,void *>::_Free_non_head<std::allocator<std::_List_node<char *,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@PADPAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@PADPAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@PADPAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@PADPAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<char *,void *> *,std::_List_node<char *,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@PADPAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@PADPAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<char *,void *> *,std::_List_node<char *,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Emplace@ABQAD@?$list@PADV?$allocator@PAD@std@@@std@@QAEPAU?$_List_node@PADPAX@1@QAU21@ABQAD@Z
_TEXT	SEGMENT
__Op$ = -76						; size = 8
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
$T8 = -40						; size = 4
$T9 = -36						; size = 4
$T10 = -32						; size = 4
tv80 = -28						; size = 4
tv82 = -24						; size = 4
tv94 = -20						; size = 4
$T11 = -16						; size = 4
$T12 = -12						; size = 4
__Mysize$ = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace@ABQAD@?$list@PADV?$allocator@PAD@std@@@std@@QAEPAU?$_List_node@PADPAX@1@QAU21@ABQAD@Z PROC ; std::list<char *,std::allocator<char *> >::_Emplace<char * const &>, COMDAT
; _this$ = ecx

; 1012 :     _Nodeptr _Emplace(const _Nodeptr _Where, _Valty&&... _Val) { // insert element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1013 :         size_type& _Mysize = _Mypair._Myval2._Mysize;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __Mysize$[ebp], eax

; 1791 :         return _Mypair._Get_first();

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00015	89 45 e0	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1791 :         return _Mypair._Get_first();

  00018	8b 45 e0	 mov	 eax, DWORD PTR $T10[ebp]
  0001b	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0001e	c7 45 f4 55 55
	55 15		 mov	 DWORD PTR $T12[ebp], 357913941 ; 15555555H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00025	c7 45 dc ff ff
	ff 7f		 mov	 DWORD PTR $T9[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1195 :         return (_STD min)(

  0002c	8b 45 dc	 mov	 eax, DWORD PTR $T9[ebp]
  0002f	89 45 f0	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00032	8b 45 f4	 mov	 eax, DWORD PTR $T12[ebp]
  00035	3b 45 f0	 cmp	 eax, DWORD PTR $T11[ebp]
  00038	73 08		 jae	 SHORT $LN22@Emplace
  0003a	8d 45 f4	 lea	 eax, DWORD PTR $T12[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
  00040	eb 06		 jmp	 SHORT $LN23@Emplace
$LN22@Emplace:
  00042	8d 45 f0	 lea	 eax, DWORD PTR $T11[ebp]
  00045	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
$LN23@Emplace:
  00048	8b 45 ec	 mov	 eax, DWORD PTR tv94[ebp]
  0004b	89 45 d8	 mov	 DWORD PTR $T8[ebp], eax
  0004e	8b 45 d8	 mov	 eax, DWORD PTR $T8[ebp]
  00051	89 45 d4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1195 :         return (_STD min)(

  00054	8b 45 d4	 mov	 eax, DWORD PTR $T7[ebp]
  00057	8b 00		 mov	 eax, DWORD PTR [eax]
  00059	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax

; 1014 :         if (_Mysize == max_size()) {

  0005c	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	3b 45 d0	 cmp	 eax, DWORD PTR $T6[ebp]
  00064	75 0a		 jne	 SHORT $LN2@Emplace

; 1015 :             _Xlength_error("list too long");

  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NKNMEGII@list?5too?5long@
  0006b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Emplace:

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00070	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]
  00073	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax

; 1787 :         return _Mypair._Get_first();

  00076	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00079	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0007c	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  0007f	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00082	8b 45 bc	 mov	 eax, DWORD PTR $T1[ebp]
  00085	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00088	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0008b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  0008e	ff 75 e8	 push	 DWORD PTR tv82[ebp]
  00091	ff 75 e4	 push	 DWORD PTR tv80[ebp]
  00094	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  00097	e8 00 00 00 00	 call	 ??$?0ABQAD@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PADPAX@std@@@1@ABQAD@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<char *,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<char *,void *> > ><char * const &>

; 1019 :         ++_Mysize;

  0009c	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0009f	8b 00		 mov	 eax, DWORD PTR [eax]
  000a1	40		 inc	 eax
  000a2	8b 4d f8	 mov	 ecx, DWORD PTR __Mysize$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1020 :         return _Op._Transfer_before(_Where);

  000a7	ff 75 08	 push	 DWORD PTR __Where$[ebp]
  000aa	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  000ad	e8 00 00 00 00	 call	 ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAEPAU?$_List_node@PADPAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<char *,void *> > >::_Transfer_before
  000b2	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
  000b5	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  000b8	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<char *,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<char *,void *> > >
  000bd	8b 45 c8	 mov	 eax, DWORD PTR $T4[ebp]
$LN3@Emplace:

; 1021 :     }

  000c0	c9		 leave
  000c1	c2 08 00	 ret	 8
??$_Emplace@ABQAD@?$list@PADV?$allocator@PAD@std@@@std@@QAEPAU?$_List_node@PADPAX@1@QAU21@ABQAD@Z ENDP ; std::list<char *,std::allocator<char *> >::_Emplace<char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@PADV?$allocator@PAD@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -36					; size = 4
__Al$ = -32						; size = 4
__Alproxy$ = -28					; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
__Newhead$ = -8						; size = 4
__Overflow_is_possible$5 = -2				; size = 1
_$S10$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$list@PADV?$allocator@PAD@std@@@std@@AAEXXZ PROC ; std::list<char *,std::allocator<char *> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1771 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1772 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00009	8d 45 ff	 lea	 eax, DWORD PTR _$S10$[ebp]
  0000c	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00012	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 e0	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 fe 01	 mov	 BYTE PTR __Overflow_is_possible$5[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001f	c7 45 dc 55 55
	55 15		 mov	 DWORD PTR __Max_possible$1[ebp], 357913941 ; 15555555H

; 60   :         if (_Count > _Max_possible) {

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  0002e	76 05		 jbe	 SHORT $LN15@Alloc_sent

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00030	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN15@Alloc_sent:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00035	33 c0		 xor	 eax, eax
  00037	40		 inc	 eax
  00038	6b c0 0c	 imul	 eax, eax, 12
  0003b	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003e	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00041	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00046	59		 pop	 ecx
  00047	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1775 :         auto _Newhead = _Al.allocate(1);

  0004a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0004d	89 45 f8	 mov	 DWORD PTR __Newhead$[ebp], eax

; 1776 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  00050	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00053	50		 push	 eax
  00054	ff 75 f8	 push	 DWORD PTR __Newhead$[ebp]
  00057	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@PADPAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@PADPAX@0@0@Z ; std::_Construct_in_place<std::_List_node<char *,void *> *,std::_List_node<char *,void *> * &>
  0005c	59		 pop	 ecx
  0005d	59		 pop	 ecx

; 1777 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  0005e	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00061	50		 push	 eax
  00062	8b 45 f8	 mov	 eax, DWORD PTR __Newhead$[ebp]
  00065	83 c0 04	 add	 eax, 4
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@PADPAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@PADPAX@0@0@Z ; std::_Construct_in_place<std::_List_node<char *,void *> *,std::_List_node<char *,void *> * &>
  0006e	59		 pop	 ecx
  0006f	59		 pop	 ecx

; 1778 :         _Mypair._Myval2._Myhead = _Newhead;

  00070	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 4d f8	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00076	89 08		 mov	 DWORD PTR [eax], ecx
$LN18@Alloc_sent:

; 1779 :         _Proxy._Release();
; 1780 :     }

  00078	c9		 leave
  00079	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$list@PADV?$allocator@PAD@std@@@std@@AAEXXZ ENDP ; std::list<char *,std::allocator<char *> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Tidy@?$list@PADV?$allocator@PAD@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Al$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$list@PADV?$allocator@PAD@std@@@std@@AAEXXZ PROC ; std::list<char *,std::allocator<char *> >::_Tidy, COMDAT
; _this$ = ecx

; 1436 :     void _Tidy() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1787 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Al$[ebp], eax

; 1437 :         auto& _Al      = _Getal();
; 1438 :         auto& _My_data = _Mypair._Myval2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1439 :         _My_data._Orphan_all();
; 1440 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@?$_List_node@PADPAX@std@@SAXAAV?$allocator@U?$_List_node@PADPAX@std@@@1@PAU01@@Z ; std::_List_node<char *,void *>::_Free_non_head<std::allocator<std::_List_node<char *,void *> > >
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 1441 :         _Node::_Freenode0(_Al, _My_data._Myhead);

  0002a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	ff 30		 push	 DWORD PTR [eax]
  0002f	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@?$_List_node@PADPAX@std@@SAXAAV?$allocator@U?$_List_node@PADPAX@std@@@1@PAU01@@Z ; std::_List_node<char *,void *>::_Freenode0<std::allocator<std::_List_node<char *,void *> > >
  00037	59		 pop	 ecx
  00038	59		 pop	 ecx

; 1442 :     }

  00039	c9		 leave
  0003a	c3		 ret	 0
?_Tidy@?$list@PADV?$allocator@PAD@std@@@std@@AAEXXZ ENDP ; std::list<char *,std::allocator<char *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?erase@?$list@PADV?$allocator@PAD@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAD@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@PAD@std@@@std@@@2@@Z
_TEXT	SEGMENT
$T1 = -32						; size = 4
$T2 = -28						; size = 4
__Result$ = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$list@PADV?$allocator@PAD@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAD@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@PAD@std@@@std@@@2@@Z PROC ; std::list<char *,std::allocator<char *> >::erase, COMDAT
; _this$ = ecx

; 1349 :     iterator erase(const const_iterator _Where) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1350 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1351 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "list erase iterator outside range");
; 1352 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1353 :         const auto _Result = _Where._Ptr->_Next;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax

; 1354 :         _Node::_Freenode(_Getal(), _Mypair._Myval2._Unlinknode(_Where._Ptr));

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 396  :         _Pnode->_Prev->_Next = _Pnode->_Next;

  00017	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0001a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00022	89 08		 mov	 DWORD PTR [eax], ecx

; 397  :         _Pnode->_Next->_Prev = _Pnode->_Prev;

  00024	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  0002c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0002f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 398  :         --_Mysize;

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00038	48		 dec	 eax
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 399  :         return _Pnode;

  0003f	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00042	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax

; 1787 :         return _Mypair._Get_first();

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0004b	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0004e	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00051	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00054	83 c0 08	 add	 eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00057	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 318  :         _Freenode0(_Al, _Ptr);

  0005a	ff 75 f4	 push	 DWORD PTR $T5[ebp]
  0005d	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00060	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@PADPAX@std@@@std@@@?$_List_node@PADPAX@std@@SAXAAV?$allocator@U?$_List_node@PADPAX@std@@@1@PAU01@@Z ; std::_List_node<char *,void *>::_Freenode0<std::allocator<std::_List_node<char *,void *> > >
  00065	59		 pop	 ecx
  00066	59		 pop	 ecx

; 1124 :         return iterator(_Where, _STD addressof(_Mypair._Myval2));

  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0006a	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00070	8b 4d e8	 mov	 ecx, DWORD PTR __Result$[ebp]
  00073	89 08		 mov	 DWORD PTR [eax], ecx

; 1355 :         return _Make_iter(_Result);

  00075	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1356 :     }

  00078	c9		 leave
  00079	c2 08 00	 ret	 8
?erase@?$list@PADV?$allocator@PAD@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAD@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@PAD@std@@@std@@@2@@Z ENDP ; std::list<char *,std::allocator<char *> >::erase
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?begin@?$list@PADV?$allocator@PAD@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAD@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
___param0$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@PADV?$allocator@PAD@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAD@std@@@std@@@2@XZ PROC ; std::list<char *,std::allocator<char *> >::begin, COMDAT
; _this$ = ecx

; 1091 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	89 45 f8	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00019	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8b 4d f8	 mov	 ecx, DWORD PTR ___param0$[ebp]
  0001f	89 08		 mov	 DWORD PTR [eax], ecx

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1093 :     }

  00024	c9		 leave
  00025	c2 04 00	 ret	 4
?begin@?$list@PADV?$allocator@PAD@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAD@std@@@std@@@2@XZ ENDP ; std::list<char *,std::allocator<char *> >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??0?$list@PADV?$allocator@PAD@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$list@PADV?$allocator@PAD@std@@@std@@QAE@XZ PROC	; std::list<char *,std::allocator<char *> >::list<char *,std::allocator<char *> >, COMDAT
; _this$ = ecx

; 804  :     list() : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 20 00	 and	 DWORD PTR [eax], 0
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 805  :         _Alloc_sentinel_and_proxy();

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$list@PADV?$allocator@PAD@std@@@std@@AAEXXZ ; std::list<char *,std::allocator<char *> >::_Alloc_sentinel_and_proxy

; 806  :     }

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c9		 leave
  0002e	c3		 ret	 0
??0?$list@PADV?$allocator@PAD@std@@@std@@QAE@XZ ENDP	; std::list<char *,std::allocator<char *> >::list<char *,std::allocator<char *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
;	COMDAT ?Get@_CPostItMemoryBlock@@QAEHPBDPADK@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv81 = -8						; size = 4
_lpszText$ = -4						; size = 4
_lpszKeyName$ = 8					; size = 4
_lpBuffer$ = 12						; size = 4
_nSize$ = 16						; size = 4
?Get@_CPostItMemoryBlock@@QAEHPBDPADK@Z PROC		; _CPostItMemoryBlock::Get, COMDAT
; _this$ = ecx

; 291  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 292  : 	LPSTR lpszText = Find( lpszKeyName );

  00009	ff 75 08	 push	 DWORD PTR _lpszKeyName$[ebp]
  0000c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?Find@_CPostItMemoryBlock@@QAEPADPBD@Z ; _CPostItMemoryBlock::Find
  00014	89 45 fc	 mov	 DWORD PTR _lpszText$[ebp], eax

; 293  : 	if( lpszText == NULL )

  00017	83 7d fc 00	 cmp	 DWORD PTR _lpszText$[ebp], 0
  0001b	75 04		 jne	 SHORT $LN2@Get

; 294  : 		return FALSE;

  0001d	33 c0		 xor	 eax, eax
  0001f	eb 59		 jmp	 SHORT $LN1@Get
$LN2@Get:

; 295  : 	lpszText += (strlen( lpszKeyName ) + 1);

  00021	ff 75 08	 push	 DWORD PTR _lpszKeyName$[ebp]
  00024	e8 00 00 00 00	 call	 _strlen
  00029	59		 pop	 ecx
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _lpszText$[ebp]
  0002d	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  00031	89 45 fc	 mov	 DWORD PTR _lpszText$[ebp], eax

; 296  : 	::ZeroMemory( lpBuffer, nSize );

  00034	ff 75 10	 push	 DWORD PTR _nSize$[ebp]
  00037	6a 00		 push	 0
  00039	ff 75 0c	 push	 DWORD PTR _lpBuffer$[ebp]
  0003c	e8 00 00 00 00	 call	 _memset
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 297  : 	strncpy( lpBuffer, lpszText, (nSize < strlen( lpszText )) ? nSize : strlen( lpszText ) );

  00044	ff 75 fc	 push	 DWORD PTR _lpszText$[ebp]
  00047	e8 00 00 00 00	 call	 _strlen
  0004c	59		 pop	 ecx
  0004d	39 45 10	 cmp	 DWORD PTR _nSize$[ebp], eax
  00050	73 08		 jae	 SHORT $LN4@Get
  00052	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  00055	89 45 f8	 mov	 DWORD PTR tv81[ebp], eax
  00058	eb 0c		 jmp	 SHORT $LN5@Get
$LN4@Get:
  0005a	ff 75 fc	 push	 DWORD PTR _lpszText$[ebp]
  0005d	e8 00 00 00 00	 call	 _strlen
  00062	59		 pop	 ecx
  00063	89 45 f8	 mov	 DWORD PTR tv81[ebp], eax
$LN5@Get:
  00066	ff 75 f8	 push	 DWORD PTR tv81[ebp]
  00069	ff 75 fc	 push	 DWORD PTR _lpszText$[ebp]
  0006c	ff 75 0c	 push	 DWORD PTR _lpBuffer$[ebp]
  0006f	e8 00 00 00 00	 call	 _strncpy
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 298  : 	return TRUE;

  00077	33 c0		 xor	 eax, eax
  00079	40		 inc	 eax
$LN1@Get:

; 299  : }

  0007a	c9		 leave
  0007b	c2 0c 00	 ret	 12			; 0000000cH
?Get@_CPostItMemoryBlock@@QAEHPBDPADK@Z ENDP		; _CPostItMemoryBlock::Get
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
;	COMDAT ?Put@_CPostItMemoryBlock@@QAEHPBD0@Z
_TEXT	SEGMENT
$T1 = -76						; size = 4
$T2 = -72						; size = 4
$T3 = -68						; size = 4
$T4 = -64						; size = 4
$T5 = -60						; size = 4
$T6 = -56						; size = 4
$T7 = -52						; size = 4
$T8 = -48						; size = 4
$T9 = -44						; size = 4
___param0$ = -40					; size = 4
_this$ = -36						; size = 4
_nStrLen$ = -32						; size = 4
tv216 = -28						; size = 4
tv240 = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_itr$10 = -12						; size = 4
_lpszText$ = -8						; size = 4
$T11 = -2						; size = 1
$T12 = -1						; size = 1
_lpszKeyName$ = 8					; size = 4
_lpBuffer$ = 12						; size = 4
?Put@_CPostItMemoryBlock@@QAEHPBD0@Z PROC		; _CPostItMemoryBlock::Put, COMDAT
; _this$ = ecx

; 250  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	56		 push	 esi
  00007	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 251  : 	LPSTR	lpszText;
; 252  : 
; 253  : 	if( (lpszText = Find( lpszKeyName )) != NULL ) {

  0000a	ff 75 08	 push	 DWORD PTR _lpszKeyName$[ebp]
  0000d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?Find@_CPostItMemoryBlock@@QAEPADPBD@Z ; _CPostItMemoryBlock::Find
  00015	89 45 f8	 mov	 DWORD PTR _lpszText$[ebp], eax
  00018	83 7d f8 00	 cmp	 DWORD PTR _lpszText$[ebp], 0
  0001c	0f 84 cd 00 00
	00		 je	 $LN5@Put

; 254  : 		for( StrListItr itr = m_StrList.begin(); itr != m_StrList.end(); ++itr ) {

  00022	8d 45 f4	 lea	 eax, DWORD PTR _itr$10[ebp]
  00025	50		 push	 eax
  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	83 c1 04	 add	 ecx, 4
  0002c	e8 00 00 00 00	 call	 ?begin@?$list@PADV?$allocator@PAD@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAD@std@@@std@@@2@XZ ; std::list<char *,std::allocator<char *> >::begin
  00031	eb 08		 jmp	 SHORT $LN4@Put
$LN2@Put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  00033	8b 45 f4	 mov	 eax, DWORD PTR _itr$10[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 f4	 mov	 DWORD PTR _itr$10[ebp], eax
$LN4@Put:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 254  : 		for( StrListItr itr = m_StrList.begin(); itr != m_StrList.end(); ++itr ) {

  0003b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 04	 add	 eax, 4
  00041	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00044	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00047	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0004a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 00		 mov	 eax, DWORD PTR [eax]
  0004f	89 45 d8	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00052	8b 45 d8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00055	89 45 d4	 mov	 DWORD PTR $T9[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00058	8d 45 d4	 lea	 eax, DWORD PTR $T9[ebp]
  0005b	89 45 d0	 mov	 DWORD PTR $T8[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  0005e	8b 45 d0	 mov	 eax, DWORD PTR $T8[ebp]
  00061	8b 4d f4	 mov	 ecx, DWORD PTR _itr$10[ebp]
  00064	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00066	75 09		 jne	 SHORT $LN60@Put
  00068	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv240[ebp], 1
  0006f	eb 04		 jmp	 SHORT $LN61@Put
$LN60@Put:
  00071	83 65 e8 00	 and	 DWORD PTR tv240[ebp], 0
$LN61@Put:
  00075	8a 45 e8	 mov	 al, BYTE PTR tv240[ebp]
  00078	88 45 ff	 mov	 BYTE PTR $T12[ebp], al

; 203  :         return !(*this == _Right);

  0007b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T12[ebp]
  0007f	85 c0		 test	 eax, eax
  00081	75 09		 jne	 SHORT $LN55@Put
  00083	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv216[ebp], 1
  0008a	eb 04		 jmp	 SHORT $LN56@Put
$LN55@Put:
  0008c	83 65 e4 00	 and	 DWORD PTR tv216[ebp], 0
$LN56@Put:
  00090	8a 45 e4	 mov	 al, BYTE PTR tv216[ebp]
  00093	88 45 fe	 mov	 BYTE PTR $T11[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 254  : 		for( StrListItr itr = m_StrList.begin(); itr != m_StrList.end(); ++itr ) {

  00096	0f b6 45 fe	 movzx	 eax, BYTE PTR $T11[ebp]
  0009a	85 c0		 test	 eax, eax
  0009c	74 51		 je	 SHORT $LN5@Put
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  0009e	8b 45 f4	 mov	 eax, DWORD PTR _itr$10[ebp]
  000a1	83 c0 08	 add	 eax, 8
  000a4	89 45 cc	 mov	 DWORD PTR $T7[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  000a7	8b 45 cc	 mov	 eax, DWORD PTR $T7[ebp]
  000aa	89 45 c8	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 255  : 			if( lpszText == *itr ) {

  000ad	8b 45 c8	 mov	 eax, DWORD PTR $T6[ebp]
  000b0	8b 4d f8	 mov	 ecx, DWORD PTR _lpszText$[ebp]
  000b3	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000b5	75 33		 jne	 SHORT $LN6@Put

; 256  : 				SAFE_DELETE_ARRAY( lpszText );

  000b7	83 7d f8 00	 cmp	 DWORD PTR _lpszText$[ebp], 0
  000bb	74 13		 je	 SHORT $LN7@Put
  000bd	8b 45 f8	 mov	 eax, DWORD PTR _lpszText$[ebp]
  000c0	89 45 c4	 mov	 DWORD PTR $T5[ebp], eax
  000c3	ff 75 c4	 push	 DWORD PTR $T5[ebp]
  000c6	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000cb	59		 pop	 ecx
  000cc	83 65 f8 00	 and	 DWORD PTR _lpszText$[ebp], 0
$LN7@Put:

; 257  : 				m_StrList.erase( itr );

  000d0	8b 45 f4	 mov	 eax, DWORD PTR _itr$10[ebp]
  000d3	89 45 c0	 mov	 DWORD PTR $T4[ebp], eax
  000d6	ff 75 c0	 push	 DWORD PTR $T4[ebp]
  000d9	8d 45 b4	 lea	 eax, DWORD PTR $T1[ebp]
  000dc	50		 push	 eax
  000dd	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e0	83 c1 04	 add	 ecx, 4
  000e3	e8 00 00 00 00	 call	 ?erase@?$list@PADV?$allocator@PAD@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAD@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@PAD@std@@@std@@@2@@Z ; std::list<char *,std::allocator<char *> >::erase

; 258  : 				break;

  000e8	eb 05		 jmp	 SHORT $LN5@Put
$LN6@Put:

; 259  : 			}
; 260  : 		}

  000ea	e9 44 ff ff ff	 jmp	 $LN2@Put
$LN5@Put:

; 261  : 	}
; 262  : 	if( lpBuffer == NULL || !*lpBuffer )

  000ef	83 7d 0c 00	 cmp	 DWORD PTR _lpBuffer$[ebp], 0
  000f3	74 0a		 je	 SHORT $LN9@Put
  000f5	8b 45 0c	 mov	 eax, DWORD PTR _lpBuffer$[ebp]
  000f8	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000fb	85 c0		 test	 eax, eax
  000fd	75 08		 jne	 SHORT $LN8@Put
$LN9@Put:

; 263  : 		return TRUE;

  000ff	33 c0		 xor	 eax, eax
  00101	40		 inc	 eax
  00102	e9 a3 00 00 00	 jmp	 $LN1@Put
$LN8@Put:

; 264  : 	size_t nStrLen	= strlen( lpszKeyName ) + 1 /* '=' */ + strlen( lpBuffer );

  00107	ff 75 08	 push	 DWORD PTR _lpszKeyName$[ebp]
  0010a	e8 00 00 00 00	 call	 _strlen
  0010f	59		 pop	 ecx
  00110	8b f0		 mov	 esi, eax
  00112	ff 75 0c	 push	 DWORD PTR _lpBuffer$[ebp]
  00115	e8 00 00 00 00	 call	 _strlen
  0011a	59		 pop	 ecx
  0011b	8d 44 06 01	 lea	 eax, DWORD PTR [esi+eax+1]
  0011f	89 45 e0	 mov	 DWORD PTR _nStrLen$[ebp], eax

; 265  : 	lpszText = new CHAR[ nStrLen + 1 ];

  00122	8b 45 e0	 mov	 eax, DWORD PTR _nStrLen$[ebp]
  00125	40		 inc	 eax
  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0012c	59		 pop	 ecx
  0012d	89 45 bc	 mov	 DWORD PTR $T3[ebp], eax
  00130	8b 45 bc	 mov	 eax, DWORD PTR $T3[ebp]
  00133	89 45 f8	 mov	 DWORD PTR _lpszText$[ebp], eax

; 266  : 	::CopyMemory( lpszText, lpszKeyName, strlen( lpszKeyName ) );

  00136	ff 75 08	 push	 DWORD PTR _lpszKeyName$[ebp]
  00139	e8 00 00 00 00	 call	 _strlen
  0013e	59		 pop	 ecx
  0013f	50		 push	 eax
  00140	ff 75 08	 push	 DWORD PTR _lpszKeyName$[ebp]
  00143	ff 75 f8	 push	 DWORD PTR _lpszText$[ebp]
  00146	e8 00 00 00 00	 call	 _memcpy
  0014b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 267  : 	*(lpszText + strlen( lpszKeyName )) = '=';

  0014e	ff 75 08	 push	 DWORD PTR _lpszKeyName$[ebp]
  00151	e8 00 00 00 00	 call	 _strlen
  00156	59		 pop	 ecx
  00157	8b 4d f8	 mov	 ecx, DWORD PTR _lpszText$[ebp]
  0015a	c6 04 01 3d	 mov	 BYTE PTR [ecx+eax], 61	; 0000003dH

; 268  : 	::CopyMemory( lpszText + strlen( lpszKeyName ) + 1, lpBuffer, strlen( lpBuffer ) );

  0015e	ff 75 0c	 push	 DWORD PTR _lpBuffer$[ebp]
  00161	e8 00 00 00 00	 call	 _strlen
  00166	59		 pop	 ecx
  00167	50		 push	 eax
  00168	ff 75 0c	 push	 DWORD PTR _lpBuffer$[ebp]
  0016b	ff 75 08	 push	 DWORD PTR _lpszKeyName$[ebp]
  0016e	e8 00 00 00 00	 call	 _strlen
  00173	59		 pop	 ecx
  00174	8b 4d f8	 mov	 ecx, DWORD PTR _lpszText$[ebp]
  00177	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  0017b	50		 push	 eax
  0017c	e8 00 00 00 00	 call	 _memcpy
  00181	83 c4 0c	 add	 esp, 12			; 0000000cH

; 269  : 	*(lpszText + nStrLen) = '\0';

  00184	8b 45 f8	 mov	 eax, DWORD PTR _lpszText$[ebp]
  00187	03 45 e0	 add	 eax, DWORD PTR _nStrLen$[ebp]
  0018a	c6 00 00	 mov	 BYTE PTR [eax], 0

; 270  : 
; 271  : 	m_StrList.push_back( lpszText );

  0018d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00190	83 c0 04	 add	 eax, 4
  00193	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1252 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  00196	8d 45 f8	 lea	 eax, DWORD PTR _lpszText$[ebp]
  00199	50		 push	 eax
  0019a	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0019d	ff 30		 push	 DWORD PTR [eax]
  0019f	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a2	e8 00 00 00 00	 call	 ??$_Emplace@ABQAD@?$list@PADV?$allocator@PAD@std@@@std@@QAEPAU?$_List_node@PADPAX@1@QAU21@ABQAD@Z ; std::list<char *,std::allocator<char *> >::_Emplace<char * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 272  : 	return TRUE;

  001a7	33 c0		 xor	 eax, eax
  001a9	40		 inc	 eax
$LN1@Put:

; 273  : }

  001aa	5e		 pop	 esi
  001ab	c9		 leave
  001ac	c2 08 00	 ret	 8
?Put@_CPostItMemoryBlock@@QAEHPBD0@Z ENDP		; _CPostItMemoryBlock::Put
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
;	COMDAT ?Put@_CPostItMemoryBlock@@QAEHPBD@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T1 = -16						; size = 4
_this$ = -12						; size = 4
_lpszText$ = -8						; size = 4
_nStrLen$ = -4						; size = 4
_lpBuffer$ = 8						; size = 4
?Put@_CPostItMemoryBlock@@QAEHPBD@Z PROC		; _CPostItMemoryBlock::Put, COMDAT
; _this$ = ecx

; 276  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 277  : 	LPSTR	lpszText;
; 278  : 
; 279  : 	if( lpBuffer == NULL || !*lpBuffer )

  00009	83 7d 08 00	 cmp	 DWORD PTR _lpBuffer$[ebp], 0
  0000d	74 0a		 je	 SHORT $LN3@Put
  0000f	8b 45 08	 mov	 eax, DWORD PTR _lpBuffer$[ebp]
  00012	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00015	85 c0		 test	 eax, eax
  00017	75 05		 jne	 SHORT $LN2@Put
$LN3@Put:

; 280  : 		return TRUE;

  00019	33 c0		 xor	 eax, eax
  0001b	40		 inc	 eax
  0001c	eb 57		 jmp	 SHORT $LN1@Put
$LN2@Put:

; 281  : 	size_t nStrLen	= strlen( lpBuffer );

  0001e	ff 75 08	 push	 DWORD PTR _lpBuffer$[ebp]
  00021	e8 00 00 00 00	 call	 _strlen
  00026	59		 pop	 ecx
  00027	89 45 fc	 mov	 DWORD PTR _nStrLen$[ebp], eax

; 282  : 	lpszText = new CHAR[ nStrLen + 1 ];

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _nStrLen$[ebp]
  0002d	40		 inc	 eax
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00034	59		 pop	 ecx
  00035	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00038	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 f8	 mov	 DWORD PTR _lpszText$[ebp], eax

; 283  : 	::CopyMemory( lpszText, lpBuffer, nStrLen );

  0003e	ff 75 fc	 push	 DWORD PTR _nStrLen$[ebp]
  00041	ff 75 08	 push	 DWORD PTR _lpBuffer$[ebp]
  00044	ff 75 f8	 push	 DWORD PTR _lpszText$[ebp]
  00047	e8 00 00 00 00	 call	 _memcpy
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 284  : 	*(lpszText + nStrLen) = '\0';

  0004f	8b 45 f8	 mov	 eax, DWORD PTR _lpszText$[ebp]
  00052	03 45 fc	 add	 eax, DWORD PTR _nStrLen$[ebp]
  00055	c6 00 00	 mov	 BYTE PTR [eax], 0

; 285  : 
; 286  : 	m_StrList.push_back( lpszText );

  00058	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	83 c0 04	 add	 eax, 4
  0005e	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1252 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  00061	8d 45 f8	 lea	 eax, DWORD PTR _lpszText$[ebp]
  00064	50		 push	 eax
  00065	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00068	ff 30		 push	 DWORD PTR [eax]
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ??$_Emplace@ABQAD@?$list@PADV?$allocator@PAD@std@@@std@@QAEPAU?$_List_node@PADPAX@1@QAU21@ABQAD@Z ; std::list<char *,std::allocator<char *> >::_Emplace<char * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 287  : 	return TRUE;

  00072	33 c0		 xor	 eax, eax
  00074	40		 inc	 eax
$LN1@Put:

; 288  : }

  00075	c9		 leave
  00076	c2 04 00	 ret	 4
?Put@_CPostItMemoryBlock@@QAEHPBD@Z ENDP		; _CPostItMemoryBlock::Put
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
;	COMDAT ?Find@_CPostItMemoryBlock@@QAEPADPBD@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
___param0$ = -32					; size = 4
tv177 = -28						; size = 4
tv201 = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_lpszText$6 = -12					; size = 4
_itr$7 = -8						; size = 4
$T8 = -2						; size = 1
$T9 = -1						; size = 1
_lpszKeyName$ = 8					; size = 4
?Find@_CPostItMemoryBlock@@QAEPADPBD@Z PROC		; _CPostItMemoryBlock::Find, COMDAT
; _this$ = ecx

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 237  : 	for( StrListItr itr = m_StrList.begin(); itr != m_StrList.end(); ++itr ) {

  00009	8d 45 f8	 lea	 eax, DWORD PTR _itr$7[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	83 c1 04	 add	 ecx, 4
  00013	e8 00 00 00 00	 call	 ?begin@?$list@PADV?$allocator@PAD@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAD@std@@@std@@@2@XZ ; std::list<char *,std::allocator<char *> >::begin
  00018	eb 08		 jmp	 SHORT $LN4@Find
$LN2@Find:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  0001a	8b 45 f8	 mov	 eax, DWORD PTR _itr$7[ebp]
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	89 45 f8	 mov	 DWORD PTR _itr$7[ebp], eax
$LN4@Find:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 237  : 	for( StrListItr itr = m_StrList.begin(); itr != m_StrList.end(); ++itr ) {

  00022	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 c0 04	 add	 eax, 4
  00028	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0002b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0002e	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00031	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00039	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  0003c	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0003f	8d 45 dc	 lea	 eax, DWORD PTR $T5[ebp]
  00042	89 45 d8	 mov	 DWORD PTR $T4[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  00045	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	8b 4d f8	 mov	 ecx, DWORD PTR _itr$7[ebp]
  0004b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0004d	75 09		 jne	 SHORT $LN57@Find
  0004f	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv201[ebp], 1
  00056	eb 04		 jmp	 SHORT $LN58@Find
$LN57@Find:
  00058	83 65 e8 00	 and	 DWORD PTR tv201[ebp], 0
$LN58@Find:
  0005c	8a 45 e8	 mov	 al, BYTE PTR tv201[ebp]
  0005f	88 45 ff	 mov	 BYTE PTR $T9[ebp], al

; 203  :         return !(*this == _Right);

  00062	0f b6 45 ff	 movzx	 eax, BYTE PTR $T9[ebp]
  00066	85 c0		 test	 eax, eax
  00068	75 09		 jne	 SHORT $LN52@Find
  0006a	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv177[ebp], 1
  00071	eb 04		 jmp	 SHORT $LN53@Find
$LN52@Find:
  00073	83 65 e4 00	 and	 DWORD PTR tv177[ebp], 0
$LN53@Find:
  00077	8a 45 e4	 mov	 al, BYTE PTR tv177[ebp]
  0007a	88 45 fe	 mov	 BYTE PTR $T8[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 237  : 	for( StrListItr itr = m_StrList.begin(); itr != m_StrList.end(); ++itr ) {

  0007d	0f b6 45 fe	 movzx	 eax, BYTE PTR $T8[ebp]
  00081	85 c0		 test	 eax, eax
  00083	74 5c		 je	 SHORT $LN3@Find
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  00085	8b 45 f8	 mov	 eax, DWORD PTR _itr$7[ebp]
  00088	83 c0 08	 add	 eax, 8
  0008b	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  0008e	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00091	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 238  : 		LPSTR	lpszText = *itr;

  00094	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	89 45 f4	 mov	 DWORD PTR _lpszText$6[ebp], eax

; 239  : 
; 240  : 		if( _strnicmp( lpszText, lpszKeyName, strlen( lpszKeyName ) ) != 0 )

  0009c	ff 75 08	 push	 DWORD PTR _lpszKeyName$[ebp]
  0009f	e8 00 00 00 00	 call	 _strlen
  000a4	59		 pop	 ecx
  000a5	50		 push	 eax
  000a6	ff 75 08	 push	 DWORD PTR _lpszKeyName$[ebp]
  000a9	ff 75 f4	 push	 DWORD PTR _lpszText$6[ebp]
  000ac	e8 00 00 00 00	 call	 __strnicmp
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b4	85 c0		 test	 eax, eax
  000b6	74 05		 je	 SHORT $LN5@Find

; 241  : 			continue;

  000b8	e9 5d ff ff ff	 jmp	 $LN2@Find
$LN5@Find:

; 242  : 		if( *(lpszText + strlen( lpszKeyName )) != '=' )

  000bd	ff 75 08	 push	 DWORD PTR _lpszKeyName$[ebp]
  000c0	e8 00 00 00 00	 call	 _strlen
  000c5	59		 pop	 ecx
  000c6	8b 4d f4	 mov	 ecx, DWORD PTR _lpszText$6[ebp]
  000c9	0f be 04 01	 movsx	 eax, BYTE PTR [ecx+eax]
  000cd	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  000d0	74 05		 je	 SHORT $LN6@Find

; 243  : 			continue;

  000d2	e9 43 ff ff ff	 jmp	 $LN2@Find
$LN6@Find:

; 244  : 		return lpszText;

  000d7	8b 45 f4	 mov	 eax, DWORD PTR _lpszText$6[ebp]
  000da	eb 07		 jmp	 SHORT $LN1@Find

; 245  : 	}

  000dc	e9 39 ff ff ff	 jmp	 $LN2@Find
$LN3@Find:

; 246  : 	return NULL;

  000e1	33 c0		 xor	 eax, eax
$LN1@Find:

; 247  : }

  000e3	c9		 leave
  000e4	c2 04 00	 ret	 4
?Find@_CPostItMemoryBlock@@QAEPADPBD@Z ENDP		; _CPostItMemoryBlock::Find
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
;	COMDAT ?DestroyHandle@_CPostItMemoryBlock@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DestroyHandle@_CPostItMemoryBlock@@QAEHXZ PROC		; _CPostItMemoryBlock::DestroyHandle, COMDAT
; _this$ = ecx

; 229  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 230  : 	::GlobalFree( m_hHandle );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	ff 30		 push	 DWORD PTR [eax]
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 231  : 	m_hHandle = NULL;

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 20 00	 and	 DWORD PTR [eax], 0

; 232  : 	return TRUE;

  00018	33 c0		 xor	 eax, eax
  0001a	40		 inc	 eax

; 233  : }

  0001b	c9		 leave
  0001c	c3		 ret	 0
?DestroyHandle@_CPostItMemoryBlock@@QAEHXZ ENDP		; _CPostItMemoryBlock::DestroyHandle
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
;	COMDAT ?CreateHandle@_CPostItMemoryBlock@@QAEPAXXZ
_TEXT	SEGMENT
$T1 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
$T6 = -28						; size = 4
$T7 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
$T10 = -12						; size = 4
$T11 = -8						; size = 4
$T12 = -4						; size = 4
$T13 = 0						; size = 4
$T14 = 4						; size = 4
___param0$ = 8						; size = 4
$T15 = 12						; size = 4
$T16 = 16						; size = 4
___param0$ = 20						; size = 4
$T17 = 24						; size = 4
$T18 = 28						; size = 4
$T19 = 32						; size = 4
$T20 = 36						; size = 4
$T21 = 40						; size = 4
___param0$ = 44						; size = 4
$T22 = 48						; size = 4
$T23 = 52						; size = 4
___param0$ = 56						; size = 4
$T24 = 60						; size = 4
tv372 = 64						; size = 4
tv396 = 68						; size = 4
_this$ = 72						; size = 4
_this$ = 76						; size = 4
tv255 = 80						; size = 4
tv279 = 84						; size = 4
_this$ = 88						; size = 4
_this$ = 92						; size = 4
_dwBlockSize$ = 96					; size = 4
_hBlock$ = 100						; size = 4
_this$ = 104						; size = 4
$T25 = 108						; size = 1
$T26 = 109						; size = 1
$T27 = 110						; size = 1
$T28 = 111						; size = 1
_lpBuffer$ = 112					; size = 4
_itr$ = 116						; size = 4
?CreateHandle@_CPostItMemoryBlock@@QAEPAXXZ PROC	; _CPostItMemoryBlock::CreateHandle, COMDAT
; _this$ = ecx

; 197  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 88	 lea	 ebp, DWORD PTR [esp-120]
  00005	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  0000b	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1191 :         return _Mypair._Myval2._Mysize;

  0000e	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00014	89 45 3c	 mov	 DWORD PTR $T24[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 198  : 	if( m_StrList.size() == 0 )

  00017	83 7d 3c 00	 cmp	 DWORD PTR $T24[ebp], 0
  0001b	75 08		 jne	 SHORT $LN8@CreateHand

; 199  : 		return INVALID_HANDLE_VALUE;

  0001d	83 c8 ff	 or	 eax, -1
  00020	e9 64 02 00 00	 jmp	 $LN1@CreateHand
$LN8@CreateHand:

; 200  : 	DWORD dwBlockSize = sizeof( DWORD );

  00025	c7 45 60 04 00
	00 00		 mov	 DWORD PTR _dwBlockSize$[ebp], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 37   :     _List_unchecked_const_iterator() noexcept : _Ptr() {}

  0002c	83 65 74 00	 and	 DWORD PTR _itr$[ebp], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 204  : 	for( itr = m_StrList.begin(); itr != m_StrList.end(); ++itr ) {

  00030	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 c0 04	 add	 eax, 4
  00036	89 45 5c	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00039	8b 45 5c	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0003c	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0003f	8b 45 5c	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 00		 mov	 eax, DWORD PTR [eax]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	89 45 38	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00049	8b 45 38	 mov	 eax, DWORD PTR ___param0$[ebp]
  0004c	89 45 34	 mov	 DWORD PTR $T23[ebp], eax

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0004f	8d 45 34	 lea	 eax, DWORD PTR $T23[ebp]
  00052	89 45 30	 mov	 DWORD PTR $T22[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 204  : 	for( itr = m_StrList.begin(); itr != m_StrList.end(); ++itr ) {

  00055	8b 45 30	 mov	 eax, DWORD PTR $T22[ebp]
  00058	8b 00		 mov	 eax, DWORD PTR [eax]
  0005a	89 45 74	 mov	 DWORD PTR _itr$[ebp], eax
  0005d	eb 08		 jmp	 SHORT $LN4@CreateHand
$LN2@CreateHand:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  0005f	8b 45 74	 mov	 eax, DWORD PTR _itr$[ebp]
  00062	8b 00		 mov	 eax, DWORD PTR [eax]
  00064	89 45 74	 mov	 DWORD PTR _itr$[ebp], eax
$LN4@CreateHand:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 204  : 	for( itr = m_StrList.begin(); itr != m_StrList.end(); ++itr ) {

  00067	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	83 c0 04	 add	 eax, 4
  0006d	89 45 58	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00070	8b 45 58	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00073	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00076	8b 45 58	 mov	 eax, DWORD PTR _this$[ebp]
  00079	8b 00		 mov	 eax, DWORD PTR [eax]
  0007b	89 45 2c	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0007e	8b 45 2c	 mov	 eax, DWORD PTR ___param0$[ebp]
  00081	89 45 28	 mov	 DWORD PTR $T21[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00084	8d 45 28	 lea	 eax, DWORD PTR $T21[ebp]
  00087	89 45 24	 mov	 DWORD PTR $T20[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  0008a	8b 45 24	 mov	 eax, DWORD PTR $T20[ebp]
  0008d	8b 4d 74	 mov	 ecx, DWORD PTR _itr$[ebp]
  00090	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00092	75 09		 jne	 SHORT $LN73@CreateHand
  00094	c7 45 54 01 00
	00 00		 mov	 DWORD PTR tv279[ebp], 1
  0009b	eb 04		 jmp	 SHORT $LN74@CreateHand
$LN73@CreateHand:
  0009d	83 65 54 00	 and	 DWORD PTR tv279[ebp], 0
$LN74@CreateHand:
  000a1	8a 45 54	 mov	 al, BYTE PTR tv279[ebp]
  000a4	88 45 6c	 mov	 BYTE PTR $T25[ebp], al

; 203  :         return !(*this == _Right);

  000a7	0f b6 45 6c	 movzx	 eax, BYTE PTR $T25[ebp]
  000ab	85 c0		 test	 eax, eax
  000ad	75 09		 jne	 SHORT $LN68@CreateHand
  000af	c7 45 50 01 00
	00 00		 mov	 DWORD PTR tv255[ebp], 1
  000b6	eb 04		 jmp	 SHORT $LN69@CreateHand
$LN68@CreateHand:
  000b8	83 65 50 00	 and	 DWORD PTR tv255[ebp], 0
$LN69@CreateHand:
  000bc	8a 45 50	 mov	 al, BYTE PTR tv255[ebp]
  000bf	88 45 6f	 mov	 BYTE PTR $T28[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 204  : 	for( itr = m_StrList.begin(); itr != m_StrList.end(); ++itr ) {

  000c2	0f b6 45 6f	 movzx	 eax, BYTE PTR $T28[ebp]
  000c6	85 c0		 test	 eax, eax
  000c8	74 2d		 je	 SHORT $LN3@CreateHand

; 205  : 		dwBlockSize += sizeof( WORD );

  000ca	8b 45 60	 mov	 eax, DWORD PTR _dwBlockSize$[ebp]
  000cd	40		 inc	 eax
  000ce	40		 inc	 eax
  000cf	89 45 60	 mov	 DWORD PTR _dwBlockSize$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  000d2	8b 45 74	 mov	 eax, DWORD PTR _itr$[ebp]
  000d5	83 c0 08	 add	 eax, 8
  000d8	89 45 20	 mov	 DWORD PTR $T19[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  000db	8b 45 20	 mov	 eax, DWORD PTR $T19[ebp]
  000de	89 45 1c	 mov	 DWORD PTR $T18[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 206  : 		dwBlockSize += (DWORD) strlen( *itr );

  000e1	8b 45 1c	 mov	 eax, DWORD PTR $T18[ebp]
  000e4	ff 30		 push	 DWORD PTR [eax]
  000e6	e8 00 00 00 00	 call	 _strlen
  000eb	59		 pop	 ecx
  000ec	03 45 60	 add	 eax, DWORD PTR _dwBlockSize$[ebp]
  000ef	89 45 60	 mov	 DWORD PTR _dwBlockSize$[ebp], eax

; 207  : 	}

  000f2	e9 68 ff ff ff	 jmp	 $LN2@CreateHand
$LN3@CreateHand:

; 208  : 
; 209  : 	HANDLE hBlock = ::GlobalAlloc( GMEM_ZEROINIT | GMEM_MOVEABLE, dwBlockSize );

  000f7	ff 75 60	 push	 DWORD PTR _dwBlockSize$[ebp]
  000fa	6a 42		 push	 66			; 00000042H
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  00102	89 45 64	 mov	 DWORD PTR _hBlock$[ebp], eax

; 210  : 	if( hBlock == NULL )

  00105	83 7d 64 00	 cmp	 DWORD PTR _hBlock$[ebp], 0
  00109	75 08		 jne	 SHORT $LN9@CreateHand

; 211  : 		return INVALID_HANDLE_VALUE;

  0010b	83 c8 ff	 or	 eax, -1
  0010e	e9 76 01 00 00	 jmp	 $LN1@CreateHand
$LN9@CreateHand:

; 212  : 	LPBYTE lpBuffer = (LPBYTE) ::GlobalLock( hBlock );

  00113	ff 75 64	 push	 DWORD PTR _hBlock$[ebp]
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4
  0011c	89 45 70	 mov	 DWORD PTR _lpBuffer$[ebp], eax

; 213  : 	if( lpBuffer == NULL ) {

  0011f	83 7d 70 00	 cmp	 DWORD PTR _lpBuffer$[ebp], 0
  00123	75 11		 jne	 SHORT $LN10@CreateHand

; 214  : 		::GlobalFree( hBlock );

  00125	ff 75 64	 push	 DWORD PTR _hBlock$[ebp]
  00128	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 215  : 		return INVALID_HANDLE_VALUE;

  0012e	83 c8 ff	 or	 eax, -1
  00131	e9 53 01 00 00	 jmp	 $LN1@CreateHand
$LN10@CreateHand:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1191 :         return _Mypair._Myval2._Mysize;

  00136	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00139	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0013c	89 45 18	 mov	 DWORD PTR $T17[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 217  : 	*((LPDWORD) lpBuffer) = (DWORD) m_StrList.size();	lpBuffer += sizeof( DWORD );

  0013f	8b 45 70	 mov	 eax, DWORD PTR _lpBuffer$[ebp]
  00142	8b 4d 18	 mov	 ecx, DWORD PTR $T17[ebp]
  00145	89 08		 mov	 DWORD PTR [eax], ecx
  00147	8b 45 70	 mov	 eax, DWORD PTR _lpBuffer$[ebp]
  0014a	83 c0 04	 add	 eax, 4
  0014d	89 45 70	 mov	 DWORD PTR _lpBuffer$[ebp], eax

; 218  : 	for( itr = m_StrList.begin(); itr != m_StrList.end(); ++itr ) {

  00150	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00153	83 c0 04	 add	 eax, 4
  00156	89 45 4c	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00159	8b 45 4c	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0015c	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0015f	8b 45 4c	 mov	 eax, DWORD PTR _this$[ebp]
  00162	8b 00		 mov	 eax, DWORD PTR [eax]
  00164	8b 00		 mov	 eax, DWORD PTR [eax]
  00166	89 45 14	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00169	8b 45 14	 mov	 eax, DWORD PTR ___param0$[ebp]
  0016c	89 45 10	 mov	 DWORD PTR $T16[ebp], eax

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0016f	8d 45 10	 lea	 eax, DWORD PTR $T16[ebp]
  00172	89 45 0c	 mov	 DWORD PTR $T15[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 218  : 	for( itr = m_StrList.begin(); itr != m_StrList.end(); ++itr ) {

  00175	8b 45 0c	 mov	 eax, DWORD PTR $T15[ebp]
  00178	8b 00		 mov	 eax, DWORD PTR [eax]
  0017a	89 45 74	 mov	 DWORD PTR _itr$[ebp], eax
  0017d	eb 08		 jmp	 SHORT $LN7@CreateHand
$LN5@CreateHand:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  0017f	8b 45 74	 mov	 eax, DWORD PTR _itr$[ebp]
  00182	8b 00		 mov	 eax, DWORD PTR [eax]
  00184	89 45 74	 mov	 DWORD PTR _itr$[ebp], eax
$LN7@CreateHand:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 218  : 	for( itr = m_StrList.begin(); itr != m_StrList.end(); ++itr ) {

  00187	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  0018a	83 c0 04	 add	 eax, 4
  0018d	89 45 48	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00190	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00193	89 45 d0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00196	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00199	8b 00		 mov	 eax, DWORD PTR [eax]
  0019b	89 45 08	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0019e	8b 45 08	 mov	 eax, DWORD PTR ___param0$[ebp]
  001a1	89 45 04	 mov	 DWORD PTR $T14[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  001a4	8d 45 04	 lea	 eax, DWORD PTR $T14[ebp]
  001a7	89 45 00	 mov	 DWORD PTR $T13[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  001aa	8b 45 00	 mov	 eax, DWORD PTR $T13[ebp]
  001ad	8b 4d 74	 mov	 ecx, DWORD PTR _itr$[ebp]
  001b0	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001b2	75 09		 jne	 SHORT $LN134@CreateHand
  001b4	c7 45 44 01 00
	00 00		 mov	 DWORD PTR tv396[ebp], 1
  001bb	eb 04		 jmp	 SHORT $LN135@CreateHand
$LN134@CreateHand:
  001bd	83 65 44 00	 and	 DWORD PTR tv396[ebp], 0
$LN135@CreateHand:
  001c1	8a 45 44	 mov	 al, BYTE PTR tv396[ebp]
  001c4	88 45 6e	 mov	 BYTE PTR $T27[ebp], al

; 203  :         return !(*this == _Right);

  001c7	0f b6 45 6e	 movzx	 eax, BYTE PTR $T27[ebp]
  001cb	85 c0		 test	 eax, eax
  001cd	75 09		 jne	 SHORT $LN129@CreateHand
  001cf	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv372[ebp], 1
  001d6	eb 04		 jmp	 SHORT $LN130@CreateHand
$LN129@CreateHand:
  001d8	83 65 40 00	 and	 DWORD PTR tv372[ebp], 0
$LN130@CreateHand:
  001dc	8a 45 40	 mov	 al, BYTE PTR tv372[ebp]
  001df	88 45 6d	 mov	 BYTE PTR $T26[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 218  : 	for( itr = m_StrList.begin(); itr != m_StrList.end(); ++itr ) {

  001e2	0f b6 45 6d	 movzx	 eax, BYTE PTR $T26[ebp]
  001e6	85 c0		 test	 eax, eax
  001e8	0f 84 87 00 00
	00		 je	 $LN6@CreateHand
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  001ee	8b 45 74	 mov	 eax, DWORD PTR _itr$[ebp]
  001f1	83 c0 08	 add	 eax, 8
  001f4	89 45 fc	 mov	 DWORD PTR $T12[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  001f7	8b 45 fc	 mov	 eax, DWORD PTR $T12[ebp]
  001fa	89 45 f8	 mov	 DWORD PTR $T11[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 219  : 		*((LPWORD) lpBuffer) = (WORD) strlen( *itr );	lpBuffer += sizeof( WORD );

  001fd	8b 45 f8	 mov	 eax, DWORD PTR $T11[ebp]
  00200	ff 30		 push	 DWORD PTR [eax]
  00202	e8 00 00 00 00	 call	 _strlen
  00207	59		 pop	 ecx
  00208	8b 4d 70	 mov	 ecx, DWORD PTR _lpBuffer$[ebp]
  0020b	66 89 01	 mov	 WORD PTR [ecx], ax
  0020e	8b 45 70	 mov	 eax, DWORD PTR _lpBuffer$[ebp]
  00211	40		 inc	 eax
  00212	40		 inc	 eax
  00213	89 45 70	 mov	 DWORD PTR _lpBuffer$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  00216	8b 45 74	 mov	 eax, DWORD PTR _itr$[ebp]
  00219	83 c0 08	 add	 eax, 8
  0021c	89 45 f4	 mov	 DWORD PTR $T10[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  0021f	8b 45 f4	 mov	 eax, DWORD PTR $T10[ebp]
  00222	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax

; 152  :         return this->_Ptr->_Myval;

  00225	8b 45 74	 mov	 eax, DWORD PTR _itr$[ebp]
  00228	83 c0 08	 add	 eax, 8
  0022b	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  0022e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00231	89 45 e8	 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 220  : 		::CopyMemory( lpBuffer, *itr, strlen( *itr ) );	lpBuffer += strlen( *itr );

  00234	8b 45 ec	 mov	 eax, DWORD PTR $T8[ebp]
  00237	ff 30		 push	 DWORD PTR [eax]
  00239	e8 00 00 00 00	 call	 _strlen
  0023e	59		 pop	 ecx
  0023f	50		 push	 eax
  00240	8b 45 e8	 mov	 eax, DWORD PTR $T7[ebp]
  00243	ff 30		 push	 DWORD PTR [eax]
  00245	ff 75 70	 push	 DWORD PTR _lpBuffer$[ebp]
  00248	e8 00 00 00 00	 call	 _memcpy
  0024d	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  00250	8b 45 74	 mov	 eax, DWORD PTR _itr$[ebp]
  00253	83 c0 08	 add	 eax, 8
  00256	89 45 e4	 mov	 DWORD PTR $T6[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  00259	8b 45 e4	 mov	 eax, DWORD PTR $T6[ebp]
  0025c	89 45 e0	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 220  : 		::CopyMemory( lpBuffer, *itr, strlen( *itr ) );	lpBuffer += strlen( *itr );

  0025f	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  00262	ff 30		 push	 DWORD PTR [eax]
  00264	e8 00 00 00 00	 call	 _strlen
  00269	59		 pop	 ecx
  0026a	03 45 70	 add	 eax, DWORD PTR _lpBuffer$[ebp]
  0026d	89 45 70	 mov	 DWORD PTR _lpBuffer$[ebp], eax

; 221  : 	}

  00270	e9 0a ff ff ff	 jmp	 $LN5@CreateHand
$LN6@CreateHand:

; 222  : 	::GlobalUnlock( hBlock );

  00275	ff 75 64	 push	 DWORD PTR _hBlock$[ebp]
  00278	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4

; 223  : 
; 224  : 	m_hHandle = hBlock;

  0027e	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00281	8b 4d 64	 mov	 ecx, DWORD PTR _hBlock$[ebp]
  00284	89 08		 mov	 DWORD PTR [eax], ecx

; 225  : 	return hBlock;

  00286	8b 45 64	 mov	 eax, DWORD PTR _hBlock$[ebp]
$LN1@CreateHand:

; 226  : }

  00289	83 c5 78	 add	 ebp, 120		; 00000078H
  0028c	c9		 leave
  0028d	c3		 ret	 0
?CreateHandle@_CPostItMemoryBlock@@QAEPAXXZ ENDP	; _CPostItMemoryBlock::CreateHandle
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
;	COMDAT ?Assign@_CPostItMemoryBlock@@QAEHPAX@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T1 = -24						; size = 4
_dwCount$ = -20						; size = 4
_lpszText$2 = -16					; size = 4
_dwI$3 = -12						; size = 4
_lpBuffer$ = -8						; size = 4
_wLen$4 = -4						; size = 2
_hBlock$ = 8						; size = 4
?Assign@_CPostItMemoryBlock@@QAEHPAX@Z PROC		; _CPostItMemoryBlock::Assign, COMDAT
; _this$ = ecx

; 173  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 174  : 	if( hBlock == NULL || hBlock == INVALID_HANDLE_VALUE )

  00009	83 7d 08 00	 cmp	 DWORD PTR _hBlock$[ebp], 0
  0000d	74 06		 je	 SHORT $LN6@Assign
  0000f	83 7d 08 ff	 cmp	 DWORD PTR _hBlock$[ebp], -1
  00013	75 07		 jne	 SHORT $LN5@Assign
$LN6@Assign:

; 175  : 		return FALSE;

  00015	33 c0		 xor	 eax, eax
  00017	e9 a7 00 00 00	 jmp	 $LN1@Assign
$LN5@Assign:

; 176  : 	LPBYTE lpBuffer = (LPBYTE) ::GlobalLock( hBlock );

  0001c	ff 75 08	 push	 DWORD PTR _hBlock$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4
  00025	89 45 f8	 mov	 DWORD PTR _lpBuffer$[ebp], eax

; 177  : 
; 178  : 	if( lpBuffer == NULL )

  00028	83 7d f8 00	 cmp	 DWORD PTR _lpBuffer$[ebp], 0
  0002c	75 07		 jne	 SHORT $LN7@Assign

; 179  : 		return FALSE;

  0002e	33 c0		 xor	 eax, eax
  00030	e9 8e 00 00 00	 jmp	 $LN1@Assign
$LN7@Assign:

; 180  : 	DWORD dwCount = *((LPDWORD) lpBuffer);				lpBuffer += sizeof( DWORD );

  00035	8b 45 f8	 mov	 eax, DWORD PTR _lpBuffer$[ebp]
  00038	8b 00		 mov	 eax, DWORD PTR [eax]
  0003a	89 45 ec	 mov	 DWORD PTR _dwCount$[ebp], eax
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _lpBuffer$[ebp]
  00040	83 c0 04	 add	 eax, 4
  00043	89 45 f8	 mov	 DWORD PTR _lpBuffer$[ebp], eax

; 181  : 	for( DWORD dwI=0; dwI < dwCount; dwI++ ) {

  00046	83 65 f4 00	 and	 DWORD PTR _dwI$3[ebp], 0
  0004a	eb 07		 jmp	 SHORT $LN4@Assign
$LN2@Assign:
  0004c	8b 45 f4	 mov	 eax, DWORD PTR _dwI$3[ebp]
  0004f	40		 inc	 eax
  00050	89 45 f4	 mov	 DWORD PTR _dwI$3[ebp], eax
$LN4@Assign:
  00053	8b 45 f4	 mov	 eax, DWORD PTR _dwI$3[ebp]
  00056	3b 45 ec	 cmp	 eax, DWORD PTR _dwCount$[ebp]
  00059	73 5c		 jae	 SHORT $LN3@Assign

; 182  : 		WORD	wLen = *((LPWORD) lpBuffer);			lpBuffer += sizeof( WORD );

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _lpBuffer$[ebp]
  0005e	66 8b 00	 mov	 ax, WORD PTR [eax]
  00061	66 89 45 fc	 mov	 WORD PTR _wLen$4[ebp], ax
  00065	8b 45 f8	 mov	 eax, DWORD PTR _lpBuffer$[ebp]
  00068	40		 inc	 eax
  00069	40		 inc	 eax
  0006a	89 45 f8	 mov	 DWORD PTR _lpBuffer$[ebp], eax

; 183  : 
; 184  : 		LPSTR	lpszText = new CHAR[ wLen + 1 ];

  0006d	0f b7 45 fc	 movzx	 eax, WORD PTR _wLen$4[ebp]
  00071	40		 inc	 eax
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00078	59		 pop	 ecx
  00079	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
  0007c	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  0007f	89 45 f0	 mov	 DWORD PTR _lpszText$2[ebp], eax

; 185  : 		::CopyMemory( lpszText, lpBuffer, wLen );

  00082	0f b7 45 fc	 movzx	 eax, WORD PTR _wLen$4[ebp]
  00086	50		 push	 eax
  00087	ff 75 f8	 push	 DWORD PTR _lpBuffer$[ebp]
  0008a	ff 75 f0	 push	 DWORD PTR _lpszText$2[ebp]
  0008d	e8 00 00 00 00	 call	 _memcpy
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH

; 186  : 		lpszText[ wLen ] = '\0';

  00095	0f b7 45 fc	 movzx	 eax, WORD PTR _wLen$4[ebp]
  00099	8b 4d f0	 mov	 ecx, DWORD PTR _lpszText$2[ebp]
  0009c	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 187  : 
; 188  : 		lpBuffer += wLen;

  000a0	0f b7 45 fc	 movzx	 eax, WORD PTR _wLen$4[ebp]
  000a4	03 45 f8	 add	 eax, DWORD PTR _lpBuffer$[ebp]
  000a7	89 45 f8	 mov	 DWORD PTR _lpBuffer$[ebp], eax

; 189  : 
; 190  : 		Put( lpszText );

  000aa	ff 75 f0	 push	 DWORD PTR _lpszText$2[ebp]
  000ad	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	e8 00 00 00 00	 call	 ?Put@_CPostItMemoryBlock@@QAEHPBD@Z ; _CPostItMemoryBlock::Put

; 191  : 	}

  000b5	eb 95		 jmp	 SHORT $LN2@Assign
$LN3@Assign:

; 192  : 	::GlobalUnlock( hBlock ); 

  000b7	ff 75 08	 push	 DWORD PTR _hBlock$[ebp]
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4

; 193  : 	return TRUE;

  000c0	33 c0		 xor	 eax, eax
  000c2	40		 inc	 eax
$LN1@Assign:

; 194  : }

  000c3	c9		 leave
  000c4	c2 04 00	 ret	 4
?Assign@_CPostItMemoryBlock@@QAEHPAX@Z ENDP		; _CPostItMemoryBlock::Assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
;	COMDAT ??1_CPostItMemoryBlock@@QAE@XZ
_TEXT	SEGMENT
$T1 = -76						; size = 4
$T2 = -72						; size = 4
$T3 = -68						; size = 4
$T4 = -64						; size = 4
$T5 = -60						; size = 4
$T6 = -56						; size = 4
$T7 = -52						; size = 4
$T8 = -48						; size = 4
$T9 = -44						; size = 4
___param0$ = -40					; size = 4
___param0$ = -36					; size = 4
tv169 = -32						; size = 4
tv193 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_lpszText$10 = -16					; size = 4
_this$ = -12						; size = 4
_itr$11 = -8						; size = 4
$T12 = -2						; size = 1
$T13 = -1						; size = 1
??1_CPostItMemoryBlock@@QAE@XZ PROC			; _CPostItMemoryBlock::~_CPostItMemoryBlock, COMDAT
; _this$ = ecx

; 164  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 165  : 	for( StrListItr itr = m_StrList.begin(); itr != m_StrList.end(); ) {

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00012	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00015	89 45 bc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00018	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	89 45 dc	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00022	8b 45 dc	 mov	 eax, DWORD PTR ___param0$[ebp]
  00025	89 45 f8	 mov	 DWORD PTR _itr$11[ebp], eax
$LN4@CPostItMem:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 165  : 	for( StrListItr itr = m_StrList.begin(); itr != m_StrList.end(); ) {

  00028	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 04	 add	 eax, 4
  0002e	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00031	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00034	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00037	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 d8	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0003f	8b 45 d8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00042	89 45 d4	 mov	 DWORD PTR $T9[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00045	8d 45 d4	 lea	 eax, DWORD PTR $T9[ebp]
  00048	89 45 d0	 mov	 DWORD PTR $T8[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  0004b	8b 45 d0	 mov	 eax, DWORD PTR $T8[ebp]
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _itr$11[ebp]
  00051	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00053	75 09		 jne	 SHORT $LN50@CPostItMem
  00055	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv193[ebp], 1
  0005c	eb 04		 jmp	 SHORT $LN51@CPostItMem
$LN50@CPostItMem:
  0005e	83 65 e4 00	 and	 DWORD PTR tv193[ebp], 0
$LN51@CPostItMem:
  00062	8a 45 e4	 mov	 al, BYTE PTR tv193[ebp]
  00065	88 45 ff	 mov	 BYTE PTR $T13[ebp], al

; 203  :         return !(*this == _Right);

  00068	0f b6 45 ff	 movzx	 eax, BYTE PTR $T13[ebp]
  0006c	85 c0		 test	 eax, eax
  0006e	75 09		 jne	 SHORT $LN45@CPostItMem
  00070	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv169[ebp], 1
  00077	eb 04		 jmp	 SHORT $LN46@CPostItMem
$LN45@CPostItMem:
  00079	83 65 e0 00	 and	 DWORD PTR tv169[ebp], 0
$LN46@CPostItMem:
  0007d	8a 45 e0	 mov	 al, BYTE PTR tv169[ebp]
  00080	88 45 fe	 mov	 BYTE PTR $T12[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 165  : 	for( StrListItr itr = m_StrList.begin(); itr != m_StrList.end(); ) {

  00083	0f b6 45 fe	 movzx	 eax, BYTE PTR $T12[ebp]
  00087	85 c0		 test	 eax, eax
  00089	74 52		 je	 SHORT $LN1@CPostItMem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  0008b	8b 45 f8	 mov	 eax, DWORD PTR _itr$11[ebp]
  0008e	83 c0 08	 add	 eax, 8
  00091	89 45 cc	 mov	 DWORD PTR $T7[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  00094	8b 45 cc	 mov	 eax, DWORD PTR $T7[ebp]
  00097	89 45 c8	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 166  : 		LPSTR	lpszText = *itr;

  0009a	8b 45 c8	 mov	 eax, DWORD PTR $T6[ebp]
  0009d	8b 00		 mov	 eax, DWORD PTR [eax]
  0009f	89 45 f0	 mov	 DWORD PTR _lpszText$10[ebp], eax

; 167  : 		SAFE_DELETE_ARRAY( lpszText );

  000a2	83 7d f0 00	 cmp	 DWORD PTR _lpszText$10[ebp], 0
  000a6	74 13		 je	 SHORT $LN5@CPostItMem
  000a8	8b 45 f0	 mov	 eax, DWORD PTR _lpszText$10[ebp]
  000ab	89 45 c4	 mov	 DWORD PTR $T5[ebp], eax
  000ae	ff 75 c4	 push	 DWORD PTR $T5[ebp]
  000b1	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000b6	59		 pop	 ecx
  000b7	83 65 f0 00	 and	 DWORD PTR _lpszText$10[ebp], 0
$LN5@CPostItMem:

; 168  : 		itr = m_StrList.erase( itr );

  000bb	8b 45 f8	 mov	 eax, DWORD PTR _itr$11[ebp]
  000be	89 45 c0	 mov	 DWORD PTR $T4[ebp], eax
  000c1	ff 75 c0	 push	 DWORD PTR $T4[ebp]
  000c4	8d 45 b4	 lea	 eax, DWORD PTR $T1[ebp]
  000c7	50		 push	 eax
  000c8	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	83 c1 04	 add	 ecx, 4
  000ce	e8 00 00 00 00	 call	 ?erase@?$list@PADV?$allocator@PAD@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAD@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@PAD@std@@@std@@@2@@Z ; std::list<char *,std::allocator<char *> >::erase
  000d3	8b 00		 mov	 eax, DWORD PTR [eax]
  000d5	89 45 f8	 mov	 DWORD PTR _itr$11[ebp], eax

; 169  : 	}

  000d8	e9 4b ff ff ff	 jmp	 $LN4@CPostItMem
$LN1@CPostItMem:

; 170  : }

  000dd	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e0	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  000e3	e8 00 00 00 00	 call	 ?_Tidy@?$list@PADV?$allocator@PAD@std@@@std@@AAEXXZ ; std::list<char *,std::allocator<char *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp

; 170  : }

  000e8	c9		 leave
  000e9	c3		 ret	 0
??1_CPostItMemoryBlock@@QAE@XZ ENDP			; _CPostItMemoryBlock::~_CPostItMemoryBlock
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
;	COMDAT ??0_CPostItMemoryBlock@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_CPostItMemoryBlock@@QAE@XZ PROC			; _CPostItMemoryBlock::_CPostItMemoryBlock, COMDAT
; _this$ = ecx

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 159  : _CPostItMemoryBlock::_CPostItMemoryBlock( void ) : m_hHandle( NULL )

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 20 00	 and	 DWORD PTR [eax], 0

; 160  : {

  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	83 c1 04	 add	 ecx, 4
  00013	e8 00 00 00 00	 call	 ??0?$list@PADV?$allocator@PAD@std@@@std@@QAE@XZ ; std::list<char *,std::allocator<char *> >::list<char *,std::allocator<char *> >

; 161  : }

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c9		 leave
  0001c	c3		 ret	 0
??0_CPostItMemoryBlock@@QAE@XZ ENDP			; _CPostItMemoryBlock::_CPostItMemoryBlock
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
;	COMDAT ?Destroy@CPostIt@@IAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
tv72 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -4						; size = 4
?Destroy@CPostIt@@IAEXXZ PROC				; CPostIt::Destroy, COMDAT
; _this$ = ecx

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 103  : 	Flush();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?Flush@CPostIt@@QAEHXZ	; CPostIt::Flush

; 104  : 	SAFE_DELETE( m_pMemoryBlock );

  00011	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00014	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [eax+264], 0
  0001b	74 4a		 je	 SHORT $LN1@Destroy
  0001d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 80 08 01 00
	00		 mov	 eax, DWORD PTR [eax+264]
  00026	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  00029	83 7d fc 00	 cmp	 DWORD PTR $T2[ebp], 0
  0002d	74 2a		 je	 SHORT $LN4@Destroy
  0002f	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00032	89 45 f4	 mov	 DWORD PTR tv72[ebp], eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  00038	e8 00 00 00 00	 call	 ??1_CPostItMemoryBlock@@QAE@XZ ; _CPostItMemoryBlock::~_CPostItMemoryBlock
  0003d	33 c0		 xor	 eax, eax
  0003f	40		 inc	 eax
  00040	83 e0 01	 and	 eax, 1
  00043	74 0c		 je	 SHORT $LN7@Destroy
  00045	6a 0c		 push	 12			; 0000000cH
  00047	ff 75 fc	 push	 DWORD PTR $T2[ebp]
  0004a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004f	59		 pop	 ecx
  00050	59		 pop	 ecx
$LN7@Destroy:
  00051	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp]
  00054	89 45 f4	 mov	 DWORD PTR tv72[ebp], eax
  00057	eb 04		 jmp	 SHORT $LN5@Destroy
$LN4@Destroy:
  00059	83 65 f4 00	 and	 DWORD PTR tv72[ebp], 0
$LN5@Destroy:
  0005d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00060	83 a0 08 01 00
	00 00		 and	 DWORD PTR [eax+264], 0
$LN1@Destroy:

; 105  : }

  00067	c9		 leave
  00068	c3		 ret	 0
?Destroy@CPostIt@@IAEXXZ ENDP				; CPostIt::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
;	COMDAT ?Init@CPostIt@@IAEHPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_szAppName$ = 8						; size = 4
?Init@CPostIt@@IAEHPBD@Z PROC				; CPostIt::Init, COMDAT
; _this$ = ecx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 40   : 	if( szAppName == NULL || !*szAppName ) {

  00007	83 7d 08 00	 cmp	 DWORD PTR _szAppName$[ebp], 0
  0000b	74 0a		 je	 SHORT $LN4@Init
  0000d	8b 45 08	 mov	 eax, DWORD PTR _szAppName$[ebp]
  00010	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00013	85 c0		 test	 eax, eax
  00015	75 15		 jne	 SHORT $LN2@Init
$LN4@Init:

; 41   : 		strcpy( m_szClipFormatName, "YMCF" );

  00017	68 00 00 00 00	 push	 OFFSET ??_C@_04LBFPPOKC@YMCF@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 c0 04	 add	 eax, 4
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _strcpy
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 42   : 	} else {

  0002a	eb 24		 jmp	 SHORT $LN3@Init
$LN2@Init:

; 43   : 		strcpy( m_szClipFormatName, "YMCF_" );

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_05FEKNMKB@YMCF_@
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	83 c0 04	 add	 eax, 4
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _strcpy
  0003d	59		 pop	 ecx
  0003e	59		 pop	 ecx

; 44   : 		strcat( m_szClipFormatName, szAppName );

  0003f	ff 75 08	 push	 DWORD PTR _szAppName$[ebp]
  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	83 c0 04	 add	 eax, 4
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _strcat
  0004e	59		 pop	 ecx
  0004f	59		 pop	 ecx
$LN3@Init:

; 45   : 	}
; 46   : 	return TRUE;

  00050	33 c0		 xor	 eax, eax
  00052	40		 inc	 eax

; 47   : }

  00053	c9		 leave
  00054	c2 04 00	 ret	 4
?Init@CPostIt@@IAEHPBD@Z ENDP				; CPostIt::Init
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
;	COMDAT ?CopyTo@CPostIt@@QAEHPAV1@PBD@Z
_TEXT	SEGMENT
_szText$ = -8						; size = 4
_this$ = -4						; size = 4
_pPostIt$ = 8						; size = 4
_lpszKeyName$ = 12					; size = 4
?CopyTo@CPostIt@@QAEHPAV1@PBD@Z PROC			; CPostIt::CopyTo, COMDAT
; _this$ = ecx

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 51   : 	if( m_pMemoryBlock == NULL )

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [eax+264], 0
  00012	75 04		 jne	 SHORT $LN2@CopyTo

; 52   : 		return FALSE;

  00014	33 c0		 xor	 eax, eax
  00016	eb 29		 jmp	 SHORT $LN1@CopyTo
$LN2@CopyTo:

; 53   : 	LPSTR szText = m_pMemoryBlock->Find( lpszKeyName );

  00018	ff 75 0c	 push	 DWORD PTR _lpszKeyName$[ebp]
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 88 08 01 00
	00		 mov	 ecx, DWORD PTR [eax+264]
  00024	e8 00 00 00 00	 call	 ?Find@_CPostItMemoryBlock@@QAEPADPBD@Z ; _CPostItMemoryBlock::Find
  00029	89 45 f8	 mov	 DWORD PTR _szText$[ebp], eax

; 54   : 	if( szText == NULL )

  0002c	83 7d f8 00	 cmp	 DWORD PTR _szText$[ebp], 0
  00030	75 04		 jne	 SHORT $LN3@CopyTo

; 55   : 		return FALSE;

  00032	33 c0		 xor	 eax, eax
  00034	eb 0b		 jmp	 SHORT $LN1@CopyTo
$LN3@CopyTo:

; 56   : 	return pPostIt->Set( szText );

  00036	ff 75 f8	 push	 DWORD PTR _szText$[ebp]
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _pPostIt$[ebp]
  0003c	e8 00 00 00 00	 call	 ?Set@CPostIt@@QAEHPBD@Z	; CPostIt::Set
$LN1@CopyTo:

; 57   : }

  00041	c9		 leave
  00042	c2 08 00	 ret	 8
?CopyTo@CPostIt@@QAEHPAV1@PBD@Z ENDP			; CPostIt::CopyTo
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
;	COMDAT ?Set@CPostIt@@QAEHPBDK@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_szValue$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_lpszKeyName$ = 8					; size = 4
_dwValue$ = 12						; size = 4
?Set@CPostIt@@QAEHPBDK@Z PROC				; CPostIt::Set, COMDAT
; _this$ = ecx

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 	CHAR szValue[12];
; 119  : 
; 120  : 	_snprintf( szValue, 12, "%d", dwValue );

  00013	ff 75 0c	 push	 DWORD PTR _dwValue$[ebp]
  00016	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0001b	6a 0c		 push	 12			; 0000000cH
  0001d	8d 45 f0	 lea	 eax, DWORD PTR _szValue$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 __snprintf
  00026	83 c4 10	 add	 esp, 16			; 00000010H

; 121  : 	return Set( lpszKeyName, szValue );

  00029	8d 45 f0	 lea	 eax, DWORD PTR _szValue$[ebp]
  0002c	50		 push	 eax
  0002d	ff 75 08	 push	 DWORD PTR _lpszKeyName$[ebp]
  00030	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?Set@CPostIt@@QAEHPBD0@Z ; CPostIt::Set

; 122  : }

  00038	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003b	33 cd		 xor	 ecx, ebp
  0003d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00042	c9		 leave
  00043	c2 08 00	 ret	 8
?Set@CPostIt@@QAEHPBDK@Z ENDP				; CPostIt::Set
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
;	COMDAT ?Set@CPostIt@@QAEHPBD0@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
tv78 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_lpszKeyName$ = 8					; size = 4
_lpBuffer$ = 12						; size = 4
?Set@CPostIt@@QAEHPBD0@Z PROC				; CPostIt::Set, COMDAT
; _this$ = ecx

; 108  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Set@CPostIt@@QAEHPBD0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 	if( m_pMemoryBlock == NULL )

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [eax+264], 0
  00032	75 3c		 jne	 SHORT $LN2@Set

; 110  : 		m_pMemoryBlock = new _CPostItMemoryBlock;

  00034	6a 0c		 push	 12			; 0000000cH
  00036	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003b	59		 pop	 ecx
  0003c	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  0003f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ec 00	 cmp	 DWORD PTR $T3[ebp], 0
  00047	74 0d		 je	 SHORT $LN4@Set
  00049	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  0004c	e8 00 00 00 00	 call	 ??0_CPostItMemoryBlock@@QAE@XZ ; _CPostItMemoryBlock::_CPostItMemoryBlock
  00051	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
  00054	eb 04		 jmp	 SHORT $LN5@Set
$LN4@Set:
  00056	83 65 e8 00	 and	 DWORD PTR tv78[ebp], 0
$LN5@Set:
  0005a	8b 45 e8	 mov	 eax, DWORD PTR tv78[ebp]
  0005d	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  00060	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00064	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  0006a	89 88 08 01 00
	00		 mov	 DWORD PTR [eax+264], ecx
$LN2@Set:

; 111  : 	m_pMemoryBlock->Put( lpszKeyName, lpBuffer );

  00070	ff 75 0c	 push	 DWORD PTR _lpBuffer$[ebp]
  00073	ff 75 08	 push	 DWORD PTR _lpszKeyName$[ebp]
  00076	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00079	8b 88 08 01 00
	00		 mov	 ecx, DWORD PTR [eax+264]
  0007f	e8 00 00 00 00	 call	 ?Put@_CPostItMemoryBlock@@QAEHPBD0@Z ; _CPostItMemoryBlock::Put

; 112  : 	m_bModified = TRUE;

  00084	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00087	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 113  : 	return TRUE;

  0008d	33 c0		 xor	 eax, eax
  0008f	40		 inc	 eax

; 114  : }

  00090	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00093	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009a	59		 pop	 ecx
  0009b	c9		 leave
  0009c	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Set@CPostIt@@QAEHPBD0@Z$0:
  00000	6a 0c		 push	 12			; 0000000cH
  00002	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
__ehhandler$?Set@CPostIt@@QAEHPBD0@Z:
  00012	90		 npad	 1
  00013	90		 npad	 1
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Set@CPostIt@@QAEHPBD0@Z
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Set@CPostIt@@QAEHPBD0@Z ENDP				; CPostIt::Set
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
;	COMDAT ?Set@CPostIt@@QAEHPBD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
tv79 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_lpBuffer$ = 8						; size = 4
?Set@CPostIt@@QAEHPBD@Z PROC				; CPostIt::Set, COMDAT
; _this$ = ecx

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Set@CPostIt@@QAEHPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 126  : 	if( lpBuffer == NULL )

  00028	83 7d 08 00	 cmp	 DWORD PTR _lpBuffer$[ebp], 0
  0002c	75 04		 jne	 SHORT $LN2@Set

; 127  : 		return FALSE;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 65		 jmp	 SHORT $LN1@Set
$LN2@Set:

; 128  : 	if( m_pMemoryBlock == NULL )

  00032	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00035	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [eax+264], 0
  0003c	75 3c		 jne	 SHORT $LN3@Set

; 129  : 		m_pMemoryBlock = new _CPostItMemoryBlock;

  0003e	6a 0c		 push	 12			; 0000000cH
  00040	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00045	59		 pop	 ecx
  00046	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  00049	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0004d	83 7d ec 00	 cmp	 DWORD PTR $T3[ebp], 0
  00051	74 0d		 je	 SHORT $LN5@Set
  00053	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  00056	e8 00 00 00 00	 call	 ??0_CPostItMemoryBlock@@QAE@XZ ; _CPostItMemoryBlock::_CPostItMemoryBlock
  0005b	89 45 e8	 mov	 DWORD PTR tv79[ebp], eax
  0005e	eb 04		 jmp	 SHORT $LN6@Set
$LN5@Set:
  00060	83 65 e8 00	 and	 DWORD PTR tv79[ebp], 0
$LN6@Set:
  00064	8b 45 e8	 mov	 eax, DWORD PTR tv79[ebp]
  00067	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  0006a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0006e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00071	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  00074	89 88 08 01 00
	00		 mov	 DWORD PTR [eax+264], ecx
$LN3@Set:

; 130  : 	m_pMemoryBlock->Put( lpBuffer );

  0007a	ff 75 08	 push	 DWORD PTR _lpBuffer$[ebp]
  0007d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 88 08 01 00
	00		 mov	 ecx, DWORD PTR [eax+264]
  00086	e8 00 00 00 00	 call	 ?Put@_CPostItMemoryBlock@@QAEHPBD@Z ; _CPostItMemoryBlock::Put

; 131  : 	m_bModified = TRUE;

  0008b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 132  : 	return TRUE;

  00094	33 c0		 xor	 eax, eax
  00096	40		 inc	 eax
$LN1@Set:

; 133  : }

  00097	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a1	59		 pop	 ecx
  000a2	c9		 leave
  000a3	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Set@CPostIt@@QAEHPBD@Z$0:
  00000	6a 0c		 push	 12			; 0000000cH
  00002	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
__ehhandler$?Set@CPostIt@@QAEHPBD@Z:
  00012	90		 npad	 1
  00013	90		 npad	 1
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Set@CPostIt@@QAEHPBD@Z
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Set@CPostIt@@QAEHPBD@Z ENDP				; CPostIt::Set
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
;	COMDAT ?Get@CPostIt@@QAEHPBDPADK@Z
_TEXT	SEGMENT
$T2 = -36						; size = 4
_uDGPFormat$3 = -32					; size = 4
_hClipboardMemory$4 = -28				; size = 4
tv87 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_lpszKeyName$ = 8					; size = 4
_lpBuffer$ = 12						; size = 4
_nSize$ = 16						; size = 4
?Get@CPostIt@@QAEHPBDPADK@Z PROC			; CPostIt::Get, COMDAT
; _this$ = ecx

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Get@CPostIt@@QAEHPBDPADK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 	if( m_pMemoryBlock == NULL ) {

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [eax+264], 0
  00032	0f 85 92 00 00
	00		 jne	 $LN2@Get

; 138  : 		UINT	uDGPFormat;
; 139  : 
; 140  : 		uDGPFormat = ::RegisterClipboardFormatA( m_szClipFormatName );

  00038	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	50		 push	 eax
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClipboardFormatA@4
  00045	89 45 e0	 mov	 DWORD PTR _uDGPFormat$3[ebp], eax

; 141  : 		if( ::OpenClipboard( NULL ) == FALSE )

  00048	6a 00		 push	 0
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenClipboard@4
  00050	85 c0		 test	 eax, eax
  00052	75 07		 jne	 SHORT $LN3@Get

; 142  : 			return FALSE;

  00054	33 c0		 xor	 eax, eax
  00056	e9 86 00 00 00	 jmp	 $LN1@Get
$LN3@Get:

; 143  : 
; 144  : 		HANDLE hClipboardMemory = ::GetClipboardData( uDGPFormat );

  0005b	ff 75 e0	 push	 DWORD PTR _uDGPFormat$3[ebp]
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClipboardData@4
  00064	89 45 e4	 mov	 DWORD PTR _hClipboardMemory$4[ebp], eax

; 145  : 
; 146  : 		if( hClipboardMemory == NULL ) {

  00067	83 7d e4 00	 cmp	 DWORD PTR _hClipboardMemory$4[ebp], 0
  0006b	75 0a		 jne	 SHORT $LN4@Get

; 147  : 			::CloseClipboard();

  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseClipboard@0

; 148  : 			return FALSE;

  00073	33 c0		 xor	 eax, eax
  00075	eb 6a		 jmp	 SHORT $LN1@Get
$LN4@Get:

; 149  : 		}
; 150  : 		m_pMemoryBlock = new _CPostItMemoryBlock;

  00077	6a 0c		 push	 12			; 0000000cH
  00079	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007e	59		 pop	 ecx
  0007f	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
  00082	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00086	83 7d ec 00	 cmp	 DWORD PTR $T5[ebp], 0
  0008a	74 0d		 je	 SHORT $LN6@Get
  0008c	8b 4d ec	 mov	 ecx, DWORD PTR $T5[ebp]
  0008f	e8 00 00 00 00	 call	 ??0_CPostItMemoryBlock@@QAE@XZ ; _CPostItMemoryBlock::_CPostItMemoryBlock
  00094	89 45 e8	 mov	 DWORD PTR tv87[ebp], eax
  00097	eb 04		 jmp	 SHORT $LN7@Get
$LN6@Get:
  00099	83 65 e8 00	 and	 DWORD PTR tv87[ebp], 0
$LN7@Get:
  0009d	8b 45 e8	 mov	 eax, DWORD PTR tv87[ebp]
  000a0	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
  000a3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000a7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  000ad	89 88 08 01 00
	00		 mov	 DWORD PTR [eax+264], ecx

; 151  : 		m_pMemoryBlock->Assign( hClipboardMemory );

  000b3	ff 75 e4	 push	 DWORD PTR _hClipboardMemory$4[ebp]
  000b6	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	8b 88 08 01 00
	00		 mov	 ecx, DWORD PTR [eax+264]
  000bf	e8 00 00 00 00	 call	 ?Assign@_CPostItMemoryBlock@@QAEHPAX@Z ; _CPostItMemoryBlock::Assign

; 152  : 
; 153  : 		::CloseClipboard();

  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseClipboard@0
$LN2@Get:

; 154  : 	}
; 155  : 
; 156  : 	return m_pMemoryBlock->Get( lpszKeyName, lpBuffer, nSize );

  000ca	ff 75 10	 push	 DWORD PTR _nSize$[ebp]
  000cd	ff 75 0c	 push	 DWORD PTR _lpBuffer$[ebp]
  000d0	ff 75 08	 push	 DWORD PTR _lpszKeyName$[ebp]
  000d3	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	8b 88 08 01 00
	00		 mov	 ecx, DWORD PTR [eax+264]
  000dc	e8 00 00 00 00	 call	 ?Get@_CPostItMemoryBlock@@QAEHPBDPADK@Z ; _CPostItMemoryBlock::Get
$LN1@Get:

; 157  : }

  000e1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000eb	59		 pop	 ecx
  000ec	c9		 leave
  000ed	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Get@CPostIt@@QAEHPBDPADK@Z$0:
  00000	6a 0c		 push	 12			; 0000000cH
  00002	ff 75 ec	 push	 DWORD PTR $T5[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
__ehhandler$?Get@CPostIt@@QAEHPBDPADK@Z:
  00012	90		 npad	 1
  00013	90		 npad	 1
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Get@CPostIt@@QAEHPBDPADK@Z
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Get@CPostIt@@QAEHPBDPADK@Z ENDP			; CPostIt::Get
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
;	COMDAT ?Empty@CPostIt@@QAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
_hClipboardMemory$ = -20				; size = 4
_uDGPFormat$ = -16					; size = 4
tv71 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?Empty@CPostIt@@QAEXXZ PROC				; CPostIt::Empty, COMDAT
; _this$ = ecx

; 83   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 84   : 	SAFE_DELETE( m_pMemoryBlock );

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [eax+264], 0
  00013	74 4a		 je	 SHORT $LN2@Empty
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 80 08 01 00
	00		 mov	 eax, DWORD PTR [eax+264]
  0001e	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  00021	83 7d f8 00	 cmp	 DWORD PTR $T2[ebp], 0
  00025	74 2a		 je	 SHORT $LN6@Empty
  00027	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  0002a	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00030	e8 00 00 00 00	 call	 ??1_CPostItMemoryBlock@@QAE@XZ ; _CPostItMemoryBlock::~_CPostItMemoryBlock
  00035	33 c0		 xor	 eax, eax
  00037	40		 inc	 eax
  00038	83 e0 01	 and	 eax, 1
  0003b	74 0c		 je	 SHORT $LN9@Empty
  0003d	6a 0c		 push	 12			; 0000000cH
  0003f	ff 75 f8	 push	 DWORD PTR $T2[ebp]
  00042	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00047	59		 pop	 ecx
  00048	59		 pop	 ecx
$LN9@Empty:
  00049	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0004c	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  0004f	eb 04		 jmp	 SHORT $LN7@Empty
$LN6@Empty:
  00051	83 65 f4 00	 and	 DWORD PTR tv71[ebp], 0
$LN7@Empty:
  00055	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00058	83 a0 08 01 00
	00 00		 and	 DWORD PTR [eax+264], 0
$LN2@Empty:

; 85   : 
; 86   : 	UINT	uDGPFormat;
; 87   : 
; 88   : 	uDGPFormat = ::RegisterClipboardFormatA( m_szClipFormatName );

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	83 c0 04	 add	 eax, 4
  00065	50		 push	 eax
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClipboardFormatA@4
  0006c	89 45 f0	 mov	 DWORD PTR _uDGPFormat$[ebp], eax

; 89   : 	if( ::OpenClipboard( NULL ) == FALSE )

  0006f	6a 00		 push	 0
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenClipboard@4
  00077	85 c0		 test	 eax, eax
  00079	75 02		 jne	 SHORT $LN3@Empty

; 90   : 		return;

  0007b	eb 29		 jmp	 SHORT $LN1@Empty
$LN3@Empty:

; 91   : 	HANDLE hClipboardMemory = ::GetClipboardData( uDGPFormat );

  0007d	ff 75 f0	 push	 DWORD PTR _uDGPFormat$[ebp]
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClipboardData@4
  00086	89 45 ec	 mov	 DWORD PTR _hClipboardMemory$[ebp], eax

; 92   : 	if( hClipboardMemory ) {

  00089	83 7d ec 00	 cmp	 DWORD PTR _hClipboardMemory$[ebp], 0
  0008d	74 0b		 je	 SHORT $LN4@Empty

; 93   : //		::GlobalFree( hClipboardMemory );
; 94   : 		::SetClipboardData( uDGPFormat, NULL );

  0008f	6a 00		 push	 0
  00091	ff 75 f0	 push	 DWORD PTR _uDGPFormat$[ebp]
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetClipboardData@8
$LN4@Empty:

; 95   : 	}
; 96   : 	::CloseClipboard();

  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseClipboard@0

; 97   : 
; 98   : 	m_bModified = FALSE;

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	83 20 00	 and	 DWORD PTR [eax], 0
$LN1@Empty:

; 99   : }

  000a6	c9		 leave
  000a7	c3		 ret	 0
?Empty@CPostIt@@QAEXXZ ENDP				; CPostIt::Empty
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
;	COMDAT ?Flush@CPostIt@@QAEHXZ
_TEXT	SEGMENT
_uDGPFormat$ = -8					; size = 4
_this$ = -4						; size = 4
?Flush@CPostIt@@QAEHXZ PROC				; CPostIt::Flush, COMDAT
; _this$ = ecx

; 60   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 61   : 	if( m_bModified == FALSE )

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000e	75 04		 jne	 SHORT $LN2@Flush

; 62   : 		return FALSE;

  00010	33 c0		 xor	 eax, eax
  00012	eb 79		 jmp	 SHORT $LN1@Flush
$LN2@Flush:

; 63   : 	if( m_pMemoryBlock == NULL )

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [eax+264], 0
  0001e	75 04		 jne	 SHORT $LN3@Flush

; 64   : 		return FALSE;

  00020	33 c0		 xor	 eax, eax
  00022	eb 69		 jmp	 SHORT $LN1@Flush
$LN3@Flush:

; 65   : 	UINT	uDGPFormat;
; 66   : 
; 67   : 	uDGPFormat = ::RegisterClipboardFormatA( m_szClipFormatName );

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClipboardFormatA@4
  00031	89 45 f8	 mov	 DWORD PTR _uDGPFormat$[ebp], eax

; 68   : 	if( ::OpenClipboard( NULL ) == FALSE )

  00034	6a 00		 push	 0
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenClipboard@4
  0003c	85 c0		 test	 eax, eax
  0003e	75 04		 jne	 SHORT $LN4@Flush

; 69   : 		return FALSE;

  00040	33 c0		 xor	 eax, eax
  00042	eb 49		 jmp	 SHORT $LN1@Flush
$LN4@Flush:

; 70   : 	if( ::SetClipboardData( uDGPFormat, m_pMemoryBlock->CreateHandle() ) == NULL ) {

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 88 08 01 00
	00		 mov	 ecx, DWORD PTR [eax+264]
  0004d	e8 00 00 00 00	 call	 ?CreateHandle@_CPostItMemoryBlock@@QAEPAXXZ ; _CPostItMemoryBlock::CreateHandle
  00052	50		 push	 eax
  00053	ff 75 f8	 push	 DWORD PTR _uDGPFormat$[ebp]
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetClipboardData@8
  0005c	85 c0		 test	 eax, eax
  0005e	75 1e		 jne	 SHORT $LN5@Flush

; 71   : //		DWORD dwLastError = ::GetLastError();
; 72   : 		m_pMemoryBlock->DestroyHandle();

  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	8b 88 08 01 00
	00		 mov	 ecx, DWORD PTR [eax+264]
  00069	e8 00 00 00 00	 call	 ?DestroyHandle@_CPostItMemoryBlock@@QAEHXZ ; _CPostItMemoryBlock::DestroyHandle

; 73   : 		::CloseClipboard();

  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseClipboard@0

; 74   : 		m_bModified = FALSE;

  00074	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00077	83 20 00	 and	 DWORD PTR [eax], 0

; 75   : 		return FALSE;

  0007a	33 c0		 xor	 eax, eax
  0007c	eb 0f		 jmp	 SHORT $LN1@Flush
$LN5@Flush:

; 76   : 	}
; 77   : 	::CloseClipboard();

  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseClipboard@0

; 78   : 	m_bModified = FALSE;

  00084	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00087	83 20 00	 and	 DWORD PTR [eax], 0

; 79   : 	return TRUE;

  0008a	33 c0		 xor	 eax, eax
  0008c	40		 inc	 eax
$LN1@Flush:

; 80   : }

  0008d	c9		 leave
  0008e	c3		 ret	 0
?Flush@CPostIt@@QAEHXZ ENDP				; CPostIt::Flush
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
;	COMDAT ??1CPostIt@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CPostIt@@QAE@XZ PROC					; CPostIt::~CPostIt, COMDAT
; _this$ = ecx

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CPostIt@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 35   : 	Destroy();

  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?Destroy@CPostIt@@IAEXXZ ; CPostIt::Destroy

; 36   : }

  0002e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00031	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00038	59		 pop	 ecx
  00039	c9		 leave
  0003a	c3		 ret	 0
  0003b	cc		 int	 3
  0003c	cc		 int	 3
  0003d	cc		 int	 3
  0003e	cc		 int	 3
  0003f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CPostIt@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CPostIt@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CPostIt@@QAE@XZ ENDP					; CPostIt::~CPostIt
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\CPostIt.cpp
;	COMDAT ??0CPostIt@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_szAppName$ = 8						; size = 4
??0CPostIt@@QAE@PBD@Z PROC				; CPostIt::CPostIt, COMDAT
; _this$ = ecx

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 28   : CPostIt::CPostIt( LPCSTR szAppName ) : m_pMemoryBlock(NULL), m_bModified(FALSE)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 20 00	 and	 DWORD PTR [eax], 0
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 a0 08 01 00
	00 00		 and	 DWORD PTR [eax+264], 0

; 30   : 	Init( szAppName );

  00017	ff 75 08	 push	 DWORD PTR _szAppName$[ebp]
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?Init@CPostIt@@IAEHPBD@Z ; CPostIt::Init

; 31   : }

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	c9		 leave
  00026	c2 04 00	 ret	 4
??0CPostIt@@QAE@PBD@Z ENDP				; CPostIt::CPostIt
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __snprintf
_TEXT	SEGMENT
__Result$ = -20						; size = 4
__Format$ = -16						; size = 4
__ArgList$ = -12					; size = 4
tv86 = -8						; size = 4
__Result$1 = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snprintf PROC						; COMDAT

; 1969 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1970 :         int _Result;
; 1971 :         va_list _ArgList;
; 1972 :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 f4	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1973 :     #pragma warning(suppress:28719)    // 28719
; 1974 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0000c	8b 45 10	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Format$[ebp], eax

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00012	ff 75 f4	 push	 DWORD PTR __ArgList$[ebp]
  00015	6a 00		 push	 0
  00017	ff 75 f0	 push	 DWORD PTR __Format$[ebp]
  0001a	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0001d	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00020	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	83 c9 01	 or	 ecx, 1
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	50		 push	 eax
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00034	83 c4 1c	 add	 esp, 28			; 0000001cH
  00037	89 45 fc	 mov	 DWORD PTR __Result$1[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  0003a	83 7d fc 00	 cmp	 DWORD PTR __Result$1[ebp], 0
  0003e	7d 06		 jge	 SHORT $LN7@snprintf
  00040	83 4d f8 ff	 or	 DWORD PTR tv86[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN3@snprintf
$LN7@snprintf:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$1[ebp]
  00049	89 45 f8	 mov	 DWORD PTR tv86[ebp], eax
$LN3@snprintf:

; 1973 :     #pragma warning(suppress:28719)    // 28719
; 1974 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0004c	8b 45 f8	 mov	 eax, DWORD PTR tv86[ebp]
  0004f	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 1975 :         __crt_va_end(_ArgList);

  00052	83 65 f4 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 1976 :         return _Result;

  00056	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 1977 :     }

  00059	c9		 leave
  0005a	c3		 ret	 0
__snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
